{"type":"system","subtype":"init","cwd":"/__w/perfect-snake-platform/perfect-snake-platform/game","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","ToolSearch"],"mcp_servers":[],"model":"claude-opus-4-5-20251101","permissionMode":"default","slash_commands":["debug","compact","context","cost","init","pr-comments","release-notes","review","security-review","insights"],"apiKeySource":"ANTHROPIC_API_KEY","claude_code_version":"2.1.41","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan"],"skills":["debug"],"plugins":[],"uuid":"ee32ae91-299d-46a6-b70e-119d48abd1e5","fast_mode_state":"off"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0126gE2qYnpT13AsKVor2hNj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","name":"Task","input":{"description":"Explore game codebase structure","prompt":"Explore the codebase structure of this snake game. I need to understand:\n1. The main game files and their locations\n2. How the Phaser game is structured\n3. What visual effects/rendering code exists\n4. Where food, snake, and background rendering happens\n\nFocus on the src/ directory and identify the key files I'll need to modify for a Christmas-themed visual enhancement.","subagent_type":"Explore"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":4966,"cache_read_input_tokens":15284,"cache_creation":{"ephemeral_5m_input_tokens":4966,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"1c75bba1-2996-405b-90e1-a7651e1b1a21"}
{"type":"user","message":{"role":"user","content":[{"type":"text","text":"Explore the codebase structure of this snake game. I need to understand:\n1. The main game files and their locations\n2. How the Phaser game is structured\n3. What visual effects/rendering code exists\n4. Where food, snake, and background rendering happens\n\nFocus on the src/ directory and identify the key files I'll need to modify for a Christmas-themed visual enhancement."}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"40cd64d3-a4eb-4a4c-9703-4b099293b51a"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013G1kiu1seFaSuVQGcgK4wg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Tmfk8NucuYZ7JUGNt775tY","name":"Bash","input":{"command":"find /__w/perfect-snake-platform/perfect-snake-platform/game -type f -name \"*.ts\" -o -name \"*.tsx\" -o -name \"*.js\" | head -30"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":11602,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":11602,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"fd7aecea-8388-4b69-a60f-a8f561563330"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Tmfk8NucuYZ7JUGNt775tY","type":"tool_result","content":"/__w/perfect-snake-platform/perfect-snake-platform/game/e2e/perf.spec.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/.baseline/SnakeScene.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/.baseline/GameBoard.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/scripts/upload-version.js\n/__w/perfect-snake-platform/perfect-snake-platform/game/playwright.config.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/vitest.config.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/vite.config.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/useDirectionQueue.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/logic.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/usePostMessage.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/index.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/useSnakeGame.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/useKeyboard.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/useTouch.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/types.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/constants.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.test.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/vite-env.d.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/main.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/__tests__/postMessage.test.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/__tests__/visual-safety.test.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/__tests__/setup.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/App.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/safe-regex-test/index.d.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/safe-regex-test/test/index.js\n/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/safe-regex-test/index.js\n/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/deep-eql/deep-eql.js","is_error":false}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"fca2f784-e890-43d2-b791-6b78a9f826cf"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FCkbZAF46GfRhjaAMZTNL8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016qfgTcU8eAvryG4oQtz77f","name":"Bash","input":{"command":"ls -la /__w/perfect-snake-platform/perfect-snake-platform/game/src/"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":981,"cache_read_input_tokens":11602,"cache_creation":{"ephemeral_5m_input_tokens":981,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"fab4c359-5f96-4726-9289-0f5d2dabc7ed"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016qfgTcU8eAvryG4oQtz77f","type":"tool_result","content":"total 36\ndrwxr-xr-x  5 root root 4096 Feb 24 21:56 .\ndrwxr-xr-x 11 root root 4096 Feb 24 21:57 ..\n-rw-r--r--  1 root root 3484 Feb 24 21:56 App.css\n-rw-r--r--  1 root root 2591 Feb 24 21:56 App.tsx\ndrwxr-xr-x  2 root root 4096 Feb 24 21:56 __tests__\ndrwxr-xr-x  2 root root 4096 Feb 24 21:56 components\ndrwxr-xr-x  2 root root 4096 Feb 24 21:56 game\n-rw-r--r--  1 root root  215 Feb 24 21:56 main.tsx\n-rw-r--r--  1 root root  164 Feb 24 21:56 vite-env.d.ts","is_error":false}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"873f9ed3-3d46-444e-b962-3f5241494001"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019g9qcMV2wnitHXYzUMjdCS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012V5ucfpkP2CHsMU5Enr2xd","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/App.tsx"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":402,"cache_read_input_tokens":12583,"cache_creation":{"ephemeral_5m_input_tokens":402,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"24f34f73-a06b-473c-923d-a88efe173110"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012V5ucfpkP2CHsMU5Enr2xd","type":"tool_result","content":"     1→import { useSnakeGame } from './game';\n     2→import { GameBoard } from './components/GameBoard';\n     3→import './App.css';\n     4→\n     5→function App() {\n     6→  const { gameState, resetGame, changeDirection, gridSize, isEmbedded } = useSnakeGame();\n     7→\n     8→  // When embedded, render only the game board (platform handles UI)\n     9→  if (isEmbedded) {\n    10→    return (\n    11→      <div className=\"app embedded\">\n    12→        <div className=\"game-container\">\n    13→          <GameBoard gameState={gameState} gridSize={gridSize} />\n    14→        </div>\n    15→      </div>\n    16→    );\n    17→  }\n    18→\n    19→  // Standalone mode: full UI\n    20→  return (\n    21→    <div className=\"app\">\n    22→      <div className=\"game-container\">\n    23→        <h1>Snake Game</h1>\n    24→        <div className=\"score\">Score: {gameState.score}</div>\n    25→\n    26→        {!gameState.gameStarted && (\n    27→          <div className=\"message\">\n    28→            <button className=\"start-button\" onClick={resetGame}>\n    29→              Start Game\n    30→            </button>\n    31→          </div>\n    32→        )}\n    33→\n    34→        {gameState.gameOver && (\n    35→          <div className=\"message game-over\">\n    36→            <div>Game Over!</div>\n    37→            <button className=\"start-button\" onClick={resetGame}>\n    38→              Play Again\n    39→            </button>\n    40→          </div>\n    41→        )}\n    42→\n    43→        <GameBoard gameState={gameState} gridSize={gridSize} />\n    44→\n    45→        <MobileControls\n    46→          onDirection={changeDirection}\n    47→          disabled={!gameState.gameStarted || gameState.gameOver}\n    48→        />\n    49→\n    50→        <div className=\"instructions\">\n    51→          <p>Desktop: Use arrow keys • Mobile: Swipe or use buttons</p>\n    52→        </div>\n    53→      </div>\n    54→    </div>\n    55→  );\n    56→}\n    57→\n    58→interface MobileControlsProps {\n    59→  onDirection: (dir: 'UP' | 'DOWN' | 'LEFT' | 'RIGHT') => void;\n    60→  disabled: boolean;\n    61→}\n    62→\n    63→function MobileControls({ onDirection, disabled }: MobileControlsProps) {\n    64→  return (\n    65→    <div className=\"mobile-controls\">\n    66→      <div className=\"control-row\">\n    67→        <button\n    68→          className=\"control-btn\"\n    69→          onClick={() => onDirection('UP')}\n    70→          disabled={disabled}\n    71→        >\n    72→          ▲\n    73→        </button>\n    74→      </div>\n    75→      <div className=\"control-row\">\n    76→        <button\n    77→          className=\"control-btn\"\n    78→          onClick={() => onDirection('LEFT')}\n    79→          disabled={disabled}\n    80→        >\n    81→          ◀\n    82→        </button>\n    83→        <button\n    84→          className=\"control-btn\"\n    85→          onClick={() => onDirection('DOWN')}\n    86→          disabled={disabled}\n    87→        >\n    88→          ▼\n    89→        </button>\n    90→        <button\n    91→          className=\"control-btn\"\n    92→          onClick={() => onDirection('RIGHT')}\n    93→          disabled={disabled}\n    94→        >\n    95→          ▶\n    96→        </button>\n    97→      </div>\n    98→    </div>\n    99→  );\n   100→}\n   101→\n   102→export default App;\n   103→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"fbcac2c9-5ad2-4cba-9222-3e6a02088241"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019g9qcMV2wnitHXYzUMjdCS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012CLpdHwbp3Q2MXRCWkMBPc","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":402,"cache_read_input_tokens":12583,"cache_creation":{"ephemeral_5m_input_tokens":402,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"17802942-7e0d-4d9d-ba67-9c2b19fc281e"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (53598 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_012CLpdHwbp3Q2MXRCWkMBPc"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"671f0348-a3a2-4f63-aad7-12e3cb513919","tool_use_result":"Error: File content (53598 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019g9qcMV2wnitHXYzUMjdCS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EYHPh5E4MBFqRZQPvtPzR3","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.tsx"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":402,"cache_read_input_tokens":12583,"cache_creation":{"ephemeral_5m_input_tokens":402,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"e22612fb-e71f-48a7-a610-97fc324c66c0"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>Sibling tool call errored</tool_use_error>","is_error":true,"tool_use_id":"toolu_01EYHPh5E4MBFqRZQPvtPzR3"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"e61b8491-a65d-4e07-82a2-c1148896c025","tool_use_result":"Sibling tool call errored"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019g9qcMV2wnitHXYzUMjdCS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Hqxk4nqz6gbuQUveyt3rsy","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/types.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":402,"cache_read_input_tokens":12583,"cache_creation":{"ephemeral_5m_input_tokens":402,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"647d4ea7-6221-4a5d-89a6-83e6e5639733"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>Sibling tool call errored</tool_use_error>","is_error":true,"tool_use_id":"toolu_01Hqxk4nqz6gbuQUveyt3rsy"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"c38b0f99-ae89-4971-8fe8-1849e8b07edf","tool_use_result":"Sibling tool call errored"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FQf8TT5YX3e3Dwx4pbqfnh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ru9KKqFTD6UHEA7vU9XXvf","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","limit":100},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1610,"cache_read_input_tokens":12985,"cache_creation":{"ephemeral_5m_input_tokens":1610,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"6da5671c-e5aa-413f-9858-4756102f7811"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ru9KKqFTD6UHEA7vU9XXvf","type":"tool_result","content":"     1→import Phaser from 'phaser';\n     2→import {\n     3→  createCleanEffectsState,\n     4→  initMotes,\n     5→  updateMotes,\n     6→  updateRipples,\n     7→  updateGlowTrail,\n     8→  spawnRipple,\n     9→  spawnTears,\n    10→  spawnBlood,\n    11→  updateTears,\n    12→  updateBlood,\n    13→  drawCleanBackground,\n    14→  drawCleanGrid,\n    15→  drawMotes,\n    16→  drawRipples,\n    17→  drawGlowTrail,\n    18→  drawCleanFood,\n    19→  drawCleanSnake,\n    20→  drawCleanVignette,\n    21→  drawCleanHUD,\n    22→  drawTears,\n    23→  drawBlood,\n    24→  CLEAN_COLORS,\n    25→  CleanEffectsState,\n    26→} from './cleanEffects';\n    27→\n    28→interface Position {\n    29→  x: number;\n    30→  y: number;\n    31→}\n    32→\n    33→interface GameState {\n    34→  snake: Position[];\n    35→  food: Position;\n    36→  gameOver: boolean;\n    37→  gameStarted?: boolean;\n    38→  score?: number;\n    39→}\n    40→\n    41→interface Star {\n    42→  x: number;\n    43→  y: number;\n    44→  size: number;\n    45→  speed: number;\n    46→  brightness: number;\n    47→}\n    48→\n    49→interface PlasmaWave {\n    50→  phase: number;\n    51→  speed: number;\n    52→  amplitude: number;\n    53→  wavelength: number;\n    54→  hue: number;\n    55→}\n    56→\n    57→interface AuroraWave {\n    58→  y: number;\n    59→  phase: number;\n    60→  speed: number;\n    61→  hue: number;\n    62→  thickness: number;\n    63→  amplitude: number;\n    64→}\n    65→\n    66→interface NebulaCloud {\n    67→  x: number;\n    68→  y: number;\n    69→  radius: number;\n    70→  hue: number;\n    71→  alpha: number;\n    72→  driftX: number;\n    73→  driftY: number;\n    74→  pulsePhase: number;\n    75→  pulseSpeed: number;\n    76→}\n    77→\n    78→interface VortexRing {\n    79→  radius: number;\n    80→  baseRadius: number;\n    81→  rotationOffset: number;\n    82→  rotationSpeed: number;\n    83→  thickness: number;\n    84→  hue: number;\n    85→  pulsePhase: number;\n    86→}\n    87→\n    88→interface VortexParticle {\n    89→  angle: number;\n    90→  radius: number;\n    91→  baseRadius: number;\n    92→  speed: number;\n    93→  size: number;\n    94→  hue: number;\n    95→  alpha: number;\n    96→}\n    97→\n    98→interface SnakeAfterimage {\n    99→  segments: Position[];\n   100→  life: number;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"64cc13ae-b389-4fcf-b3a7-9ca596817a53"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FQf8TT5YX3e3Dwx4pbqfnh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TgDxpzmVAAYFBW8BUdsuVQ","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/types.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1610,"cache_read_input_tokens":12985,"cache_creation":{"ephemeral_5m_input_tokens":1610,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"11267123-b764-4c81-8f2c-fad81b131cdb"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TgDxpzmVAAYFBW8BUdsuVQ","type":"tool_result","content":"     1→/**\n     2→ * Core game types - shared across all game modules\n     3→ */\n     4→\n     5→export interface Position {\n     6→  x: number;\n     7→  y: number;\n     8→}\n     9→\n    10→export type PowerUpType = 'SPEED_BOOST' | 'INVINCIBILITY' | 'SCORE_MULTIPLIER' | 'MAGNET';\n    11→\n    12→export interface PowerUp {\n    13→  position: Position;\n    14→  type: PowerUpType;\n    15→  spawnTime: number;\n    16→  duration: number;\n    17→}\n    18→\n    19→export interface ActivePowerUp {\n    20→  type: PowerUpType;\n    21→  endTime: number;\n    22→}\n    23→\n    24→export interface GameState {\n    25→  snake: Position[];\n    26→  food: Position;\n    27→  direction: Direction;\n    28→  gameOver: boolean;\n    29→  gameStarted: boolean;\n    30→  score: number;\n    31→  powerUp: PowerUp | null;\n    32→  activePowerUps: ActivePowerUp[];\n    33→  tickCount: number;\n    34→}\n    35→\n    36→export type Direction = 'UP' | 'DOWN' | 'LEFT' | 'RIGHT';\n    37→\n    38→export const OPPOSITE_DIRECTIONS: Record<Direction, Direction> = {\n    39→  UP: 'DOWN',\n    40→  DOWN: 'UP',\n    41→  LEFT: 'RIGHT',\n    42→  RIGHT: 'LEFT'\n    43→};\n    44→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"0c9912d1-bf89-4d60-bb20-c4cda6505d37"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FQf8TT5YX3e3Dwx4pbqfnh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01REQs9GbRcHAtEC7HQLdDDx","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/constants.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1610,"cache_read_input_tokens":12985,"cache_creation":{"ephemeral_5m_input_tokens":1610,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"5aab682c-6aed-446b-8e4a-f20003900b73"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01REQs9GbRcHAtEC7HQLdDDx","type":"tool_result","content":"     1→/**\n     2→ * Game constants - single source of truth for game configuration\n     3→ */\n     4→\n     5→import { Position, GameState, PowerUpType } from './types';\n     6→\n     7→export const GRID_SIZE = 20;\n     8→export const CELL_SIZE = 20;\n     9→export const GAME_SPEED_MS = 150;\n    10→export const MAX_DIRECTION_QUEUE = 3;\n    11→export const POINTS_PER_FOOD = 10;\n    12→\n    13→export const INITIAL_SNAKE: Position[] = [{ x: 10, y: 10 }];\n    14→export const INITIAL_FOOD: Position = { x: 15, y: 15 };\n    15→export const INITIAL_DIRECTION = 'RIGHT' as const;\n    16→\n    17→// Power-up configuration\n    18→export const POWERUP_SPAWN_CHANCE = 0.03;\n    19→export const POWERUP_DESPAWN_TICKS = 100;\n    20→export const POWERUP_DURATIONS: Record<PowerUpType, number> = {\n    21→  SPEED_BOOST: 50,\n    22→  INVINCIBILITY: 40,\n    23→  SCORE_MULTIPLIER: 60,\n    24→  MAGNET: 45,\n    25→};\n    26→export const POWERUP_TYPES: PowerUpType[] = ['SPEED_BOOST', 'INVINCIBILITY', 'SCORE_MULTIPLIER', 'MAGNET'];\n    27→export const SCORE_MULTIPLIER_VALUE = 3;\n    28→export const SPEED_BOOST_MS = 80;\n    29→\n    30→export const createInitialState = (): GameState => ({\n    31→  snake: [...INITIAL_SNAKE],\n    32→  food: { ...INITIAL_FOOD },\n    33→  direction: INITIAL_DIRECTION,\n    34→  gameOver: false,\n    35→  gameStarted: false,\n    36→  score: 0,\n    37→  powerUp: null,\n    38→  activePowerUps: [],\n    39→  tickCount: 0,\n    40→});\n    41→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"ac82de1a-883b-4fcb-921c-17edc83694d1"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RL3GSQo2U4RfMoh38Wpwn5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019Ds3b3kWidnQWMUbCwQtyr","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","limit":200,"offset":100},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":2580,"cache_read_input_tokens":14595,"cache_creation":{"ephemeral_5m_input_tokens":2580,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"42b12d27-306c-436c-8632-542a82ed04b5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019Ds3b3kWidnQWMUbCwQtyr","type":"tool_result","content":"   100→  life: number;\n   101→  maxLife: number;\n   102→  hueOffset: number;\n   103→}\n   104→\n   105→interface FoodParticle {\n   106→  x: number;\n   107→  y: number;\n   108→  vx: number;\n   109→  vy: number;\n   110→  life: number;\n   111→  maxLife: number;\n   112→  size: number;\n   113→}\n   114→\n   115→interface SnakeTrailParticle {\n   116→  x: number;\n   117→  y: number;\n   118→  vx: number;\n   119→  vy: number;\n   120→  life: number;\n   121→  maxLife: number;\n   122→  size: number;\n   123→  hue: number;\n   124→}\n   125→\n   126→interface ShockWave {\n   127→  x: number;\n   128→  y: number;\n   129→  radius: number;\n   130→  maxRadius: number;\n   131→  life: number;\n   132→}\n   133→\n   134→interface LightningBolt {\n   135→  points: { x: number; y: number }[];\n   136→  life: number;\n   137→  maxLife: number;\n   138→  hue: number;\n   139→}\n   140→\n   141→const CELL_SIZE = 20;\n   142→const GRID_SIZE = 20;\n   143→const NUM_STARS = 30;\n   144→const MAX_FOOD_PARTICLES = 8;\n   145→const MAX_TRAIL_PARTICLES = 40;\n   146→const MAX_SHOCKWAVES = 3;\n   147→const MAX_LIGHTNING_BOLTS = 5;\n   148→const MAX_BURST_PARTICLES = 12;\n   149→const NUM_PLASMA_WAVES = 3;\n   150→const MAX_AFTERIMAGES = 4;\n   151→const NUM_AURORA_WAVES = 5;\n   152→const NUM_NEBULA_CLOUDS = 6;\n   153→const NUM_VORTEX_RINGS = 5;\n   154→const NUM_VORTEX_PARTICLES = 20;\n   155→const NUM_METEORS = 8;\n   156→const MAX_DEATH_DEBRIS = 24;\n   157→const NUM_SPIRITS_PER_EDGE = 2;\n   158→const MAX_FLAME_PARTICLES = 60;\n   159→const MAX_COMET_TRAIL_LENGTH = 30;\n   160→const MAX_ETHEREAL_PARTICLES = 50;\n   161→const NUM_BEES = 8;\n   162→const BEE_SPAWN_CHANCE = 0.02;\n   163→\n   164→// Comet trail segment - stores historical snake positions for smooth trail rendering\n   165→interface CometTrailSegment {\n   166→  x: number;\n   167→  y: number;\n   168→  alpha: number;\n   169→  size: number;\n   170→  hue: number;\n   171→}\n   172→\n   173→// Ethereal trail particle - luminous particles that drift away from trail\n   174→interface EtherealParticle {\n   175→  x: number;\n   176→  y: number;\n   177→  vx: number;\n   178→  vy: number;\n   179→  size: number;\n   180→  life: number;\n   181→  maxLife: number;\n   182→  hue: number;\n   183→  brightness: number;\n   184→  pulsePhase: number;\n   185→}\n   186→\n   187→// Thrown food animation - food launched onto screen with arc trajectory\n   188→interface ThrownFood {\n   189→  startX: number;\n   190→  startY: number;\n   191→  targetX: number;\n   192→  targetY: number;\n   193→  x: number;\n   194→  y: number;\n   195→  progress: number; // 0 to 1\n   196→  rotation: number;\n   197→  rotationSpeed: number;\n   198→  trail: { x: number; y: number; alpha: number; rotation: number }[];\n   199→  landed: boolean;\n   200→  landingParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number }[];\n   201→  impactRings: { radius: number; alpha: number }[];\n   202→}\n   203→\n   204→// Meteor shower types\n   205→interface Meteor {\n   206→  x: number;\n   207→  y: number;\n   208→  vx: number;\n   209→  vy: number;\n   210→  size: number;\n   211→  hue: number;\n   212→  alpha: number;\n   213→  trail: { x: number; y: number; alpha: number }[];\n   214→  life: number;\n   215→}\n   216→\n   217→// Death debris particle\n   218→interface DeathDebris {\n   219→  x: number;\n   220→  y: number;\n   221→  vx: number;\n   222→  vy: number;\n   223→  size: number;\n   224→  hue: number;\n   225→  rotation: number;\n   226→  rotationSpeed: number;\n   227→  life: number;\n   228→  type: 'shard' | 'spark' | 'ember';\n   229→}\n   230→\n   231→// Guardian spirit - ethereal protectors at edges\n   232→interface GuardianSpirit {\n   233→  x: number;\n   234→  y: number;\n   235→  baseX: number;\n   236→  baseY: number;\n   237→  size: number;\n   238→  phase: number;\n   239→  speed: number;\n   240→  haloPhase: number;\n   241→  orbPhase: number;\n   242→  edge: 'top' | 'bottom' | 'left' | 'right';\n   243→  targetAlpha: number;\n   244→  currentAlpha: number;\n   245→  hue: number;\n   246→  orbs: { angle: number; distance: number; size: number; speed: number }[];\n   247→}\n   248→\n   249→// Flame particle for burning effect\n   250→interface FlameParticle {\n   251→  x: number;\n   252→  y: number;\n   253→  vx: number;\n   254→  vy: number;\n   255→  size: number;\n   256→  life: number;\n   257→  maxLife: number;\n   258→  hue: number;\n   259→  brightness: number;\n   260→}\n   261→\n   262→// Mystical bee - glowing magical creatures that swarm around food\n   263→interface MysticalBee {\n   264→  x: number;\n   265→  y: number;\n   266→  vx: number;\n   267→  vy: number;\n   268→  targetX: number;\n   269→  targetY: number;\n   270→  wingPhase: number;\n   271→  wingSpeed: number;\n   272→  size: number;\n   273→  hue: number;\n   274→  glowIntensity: number;\n   275→  bobPhase: number;\n   276→  bobSpeed: number;\n   277→  trail: { x: number; y: number; alpha: number }[];\n   278→  state: 'flying' | 'hovering' | 'attracted';\n   279→  sparkleTimer: number;\n   280→}\n   281→\n   282→// Rival snake - spectral AI nemesis that competes for food\n   283→interface RivalSnake {\n   284→  segments: { x: number; y: number }[];\n   285→  direction: { dx: number; dy: number };\n   286→  targetX: number;\n   287→  targetY: number;\n   288→  moveTimer: number;\n   289→  moveInterval: number;\n   290→  pulsePhase: number;\n   291→  glowIntensity: number;\n   292→  hue: number;\n   293→  trail: { x: number; y: number; alpha: number }[];\n   294→  energyTrail: { x: number; y: number; alpha: number; size: number }[];\n   295→  state: 'hunting' | 'fleeing' | 'circling';\n   296→  aggression: number;\n   297→  nearMissTimer: number;\n   298→  electricArcs: { x1: number; y1: number; x2: number; y2: number; life: number }[];\n   299→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"6cbe6a35-0292-4775-8ab9-362345835a77"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RL3GSQo2U4RfMoh38Wpwn5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YVDcsgvukpfPmHtwwKJM2L","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","limit":100},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":2580,"cache_read_input_tokens":14595,"cache_creation":{"ephemeral_5m_input_tokens":2580,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"7e5bcce4-d1cd-40dc-823d-23a36b7197b0"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YVDcsgvukpfPmHtwwKJM2L","type":"tool_result","content":"     1→export interface CleanRipple {\n     2→  x: number;\n     3→  y: number;\n     4→  radius: number;\n     5→  maxRadius: number;\n     6→  alpha: number;\n     7→  thickness: number;\n     8→}\n     9→\n    10→export interface FloatingMote {\n    11→  x: number;\n    12→  y: number;\n    13→  vx: number;\n    14→  vy: number;\n    15→  size: number;\n    16→  alpha: number;\n    17→  pulsePhase: number;\n    18→}\n    19→\n    20→export interface SnakeGlowTrail {\n    21→  x: number;\n    22→  y: number;\n    23→  alpha: number;\n    24→  size: number;\n    25→}\n    26→\n    27→export interface TearDrop {\n    28→  x: number;\n    29→  y: number;\n    30→  vy: number;\n    31→  size: number;\n    32→  alpha: number;\n    33→  wobblePhase: number;\n    34→}\n    35→\n    36→export interface BloodSplatter {\n    37→  x: number;\n    38→  y: number;\n    39→  vx: number;\n    40→  vy: number;\n    41→  size: number;\n    42→  alpha: number;\n    43→  life: number;\n    44→  splashed: boolean;\n    45→  splashRadius: number;\n    46→}\n    47→\n    48→export const CLEAN_COLORS = {\n    49→  bgDark: 0x0a1628,\n    50→  bgMid: 0x0f1d32,\n    51→  bgLight: 0x14253e,\n    52→\n    53→  gridLine: 0x1a3050,\n    54→  gridAccent: 0x254060,\n    55→\n    56→  snakeHead: 0x4fd1c5,\n    57→  snakeBody: 0x38b2ac,\n    58→  snakeTail: 0x2c9a94,\n    59→  snakeGlow: 0x81e6d9,\n    60→\n    61→  food: 0xe2e8f0,\n    62→  foodCore: 0xffffff,\n    63→  foodGlow: 0xcbd5e1,\n    64→\n    65→  ripple: 0x81e6d9,\n    66→  mote: 0x4fd1c5,\n    67→\n    68→  text: 0xe2e8f0,\n    69→  textDim: 0x94a3b8,\n    70→\n    71→  blood: 0xdc2626,\n    72→  bloodDark: 0x991b1b,\n    73→  tear: 0x60a5fa,\n    74→  tearHighlight: 0x93c5fd,\n    75→};\n    76→\n    77→const MAX_RIPPLES = 5;\n    78→const MAX_MOTES = 20;\n    79→const MAX_TRAIL_LENGTH = 15;\n    80→const MAX_TEARS = 12;\n    81→const MAX_BLOOD = 20;\n    82→\n    83→export function createCleanEffectsState() {\n    84→  return {\n    85→    ripples: [] as CleanRipple[],\n    86→    motes: [] as FloatingMote[],\n    87→    glowTrail: [] as SnakeGlowTrail[],\n    88→    tears: [] as TearDrop[],\n    89→    blood: [] as BloodSplatter[],\n    90→    frameCount: 0,\n    91→  };\n    92→}\n    93→\n    94→export type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n    95→\n    96→export function initMotes(state: CleanEffectsState, width: number, height: number): void {\n    97→  state.motes = [];\n    98→  for (let i = 0; i < MAX_MOTES; i++) {\n    99→    state.motes.push({\n   100→      x: Math.random() * width,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"507e439d-8294-4cbf-b598-a318cbc31b30"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01NEEBjbdtRthebNTYFKzxKL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015dG3ph9bxNsqjjajUn7iT3","name":"Grep","input":{"pattern":"draw.*food|draw.*snake|render|scene\\.add","path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components","output_mode":"content"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":3811,"cache_read_input_tokens":17175,"cache_creation":{"ephemeral_5m_input_tokens":3811,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"62a1be92-c6d0-4e32-abbc-4dfeddf3c84c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015dG3ph9bxNsqjjajUn7iT3","type":"tool_result","content":"src/components/GameBoard.test.tsx:2:// This is a placeholder test file for future rendering logic tests\nsrc/components/GameBoard.test.tsx:5:import { render } from '@testing-library/react';\nsrc/components/GameBoard.test.tsx:9:  it('should render without crashing', () => {\nsrc/components/GameBoard.test.tsx:19:    const { container } = render(<GameBoard gameState={mockGameState} gridSize={20} />);\nsrc/components/SnakeScene.ts:164:// Comet trail segment - stores historical snake positions for smooth trail rendering\nsrc/components/SnakeScene.ts:2432:    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\nsrc/components/SnakeScene.ts:2434:    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\nsrc/components/SnakeScene.ts:2443:    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\nsrc/components/SnakeScene.ts:3362:    this.drawText(g, 'SCORE', padding + 10, padding + 12, 10, COLORS.snakeBody, 0.9);\nsrc/components/SnakeScene.ts:3385:    this.drawText(g, 'LENGTH', lengthX + 10, padding + 12, 10, COLORS.food, 0.9);\nsrc/components/SnakeScene.ts:3386:    this.drawText(g, String(this.currentState.snake.length), lengthX + 10, padding + 32, 18, COLORS.foodCore, 1);\nsrc/components/SnakeScene.ts:3398:    // Use simple block characters for text rendering\nsrc/components/SnakeScene.ts:3408:      // Simple pixel-style character rendering\nsrc/components/SnakeScene.ts:3577:    this.drawText(g, 'HIGH SCORES', centerX - 55, titleY, 10, COLORS.foodCore, alphaMultiplier);\nsrc/components/SnakeScene.ts:3668:    // Don't draw food if it's still being thrown\nsrc/components/SnakeScene.ts:3748:  private drawEnergyTendrils(g: Phaser.GameObjects.Graphics, foodX: number, foodY: number): void {\nsrc/components/SnakeScene.ts:3760:    // Only draw tendrils when snake is somewhat close\nsrc/components/SnakeScene.ts:3848:        this.drawSnakeHead(g, segment, snake[1]);"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"6854cbd1-9b84-4276-a990-3b898672447d"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AT1tD99nTQzVmgLKqtuNDD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012PnE7jiU8c593YQJDaCzVb","name":"Bash","input":{"command":"grep -n \"create\\|render\\|update\\|preload\" /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts | head -40"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":850,"cache_read_input_tokens":20986,"cache_creation":{"ephemeral_5m_input_tokens":850,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"ad336f27-33ab-4b10-9bef-97396ec00c6b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012PnE7jiU8c593YQJDaCzVb","type":"tool_result","content":"3:  createCleanEffectsState,\n5:  updateMotes,\n6:  updateRipples,\n7:  updateGlowTrail,\n11:  updateTears,\n12:  updateBlood,\n164:// Comet trail segment - stores historical snake positions for smooth trail rendering\n476:  private cleanEffects: CleanEffectsState = createCleanEffectsState();\n482:  create(): void {\n552:  private updateArmageddonEffects(): void {\n988:  private updateRivalSnake(): void {\n1340:  private updateBees(): void {\n1558:  private updateGuardianSpirits(): void {\n1817:  private updateMeteors(width: number, height: number): void {\n1876:  private updateDeathDebris(): void {\n1920:  private updateParticles(): void {\n2034:  updateGameState(state: GameState): void {\n2223:  private updateThrownFood(): void {\n2385:  update(): void {\n2392:    updateMotes(this.cleanEffects, width, height);\n2393:    updateRipples(this.cleanEffects);\n2394:    updateTears(this.cleanEffects, height);\n2395:    updateBlood(this.cleanEffects, height);\n2403:        updateGlowTrail(this.cleanEffects, headX, headY);\n2464:  private updateSmokeParticles(): void {\n2566:  private updateFlameParticles(): void {\n2990:  private updateCometTrail(): void {\n3069:  private updateEtherealParticles(): void {\n3398:    // Use simple block characters for text rendering\n3408:      // Simple pixel-style character rendering","is_error":false}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"5807768c-7a59-4101-98e4-dfaebf91b86b"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Fy3qiWL8zUqZMJ7r9r97S3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QkAWB2XT3UR4TXrko4k19o","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":480,"limit":100},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":593,"cache_read_input_tokens":21836,"cache_creation":{"ephemeral_5m_input_tokens":593,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"e415cd6f-dea9-45ce-81d1-1d6c42e73815"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QkAWB2XT3UR4TXrko4k19o","type":"tool_result","content":"   480→  }\n   481→\n   482→  create(): void {\n   483→    this.graphics = this.add.graphics();\n   484→    const width = GRID_SIZE * CELL_SIZE;\n   485→    const height = GRID_SIZE * CELL_SIZE;\n   486→    initMotes(this.cleanEffects, width, height);\n   487→\n   488→    if (this.currentState) {\n   489→      this.needsRedraw = true;\n   490→    }\n   491→  }\n   492→\n   493→  private initArmageddonEffects(): void {\n   494→    const width = GRID_SIZE * CELL_SIZE;\n   495→    const height = GRID_SIZE * CELL_SIZE;\n   496→\n   497→    // Initialize ground fissures - cracks in the earth with lava\n   498→    this.groundFissures = [];\n   499→    for (let i = 0; i < NUM_FISSURES; i++) {\n   500→      const startX = Math.random() * width;\n   501→      const startY = Math.random() * height;\n   502→      const angle = Math.random() * Math.PI;\n   503→      const length = 40 + Math.random() * 80;\n   504→      this.groundFissures.push({\n   505→        x1: startX,\n   506→        y1: startY,\n   507→        x2: startX + Math.cos(angle) * length,\n   508→        y2: startY + Math.sin(angle) * length,\n   509→        width: 2 + Math.random() * 4,\n   510→        glowIntensity: 0.5 + Math.random() * 0.5,\n   511→        pulsePhase: Math.random() * Math.PI * 2,\n   512→      });\n   513→    }\n   514→\n   515→    // Initialize fire rain\n   516→    this.fireRainParticles = [];\n   517→\n   518→    // Initialize chaos explosions\n   519→    this.chaosExplosions = [];\n   520→\n   521→    // Initialize apocalyptic skulls floating in background\n   522→    this.apocalypticSkulls = [];\n   523→    for (let i = 0; i < NUM_SKULLS; i++) {\n   524→      this.apocalypticSkulls.push({\n   525→        x: 30 + Math.random() * (width - 60),\n   526→        y: 30 + Math.random() * (height - 60),\n   527→        size: 15 + Math.random() * 10,\n   528→        alpha: 0.03 + Math.random() * 0.04,\n   529→        rotation: Math.random() * Math.PI * 2,\n   530→        pulsePhase: Math.random() * Math.PI * 2,\n   531→      });\n   532→    }\n   533→  }\n   534→\n   535→  private initSmokeParticles(): void {\n   536→    this.smokeParticles = [];\n   537→    const width = GRID_SIZE * CELL_SIZE;\n   538→    const height = GRID_SIZE * CELL_SIZE;\n   539→    for (let i = 0; i < 12; i++) {\n   540→      this.smokeParticles.push({\n   541→        x: Math.random() * width,\n   542→        y: Math.random() * height,\n   543→        vx: (Math.random() - 0.5) * 0.3,\n   544→        vy: -0.1 - Math.random() * 0.2,\n   545→        size: 30 + Math.random() * 50,\n   546→        alpha: 0.02 + Math.random() * 0.03,\n   547→        life: Math.random(),\n   548→      });\n   549→    }\n   550→  }\n   551→\n   552→  private updateArmageddonEffects(): void {\n   553→    const width = GRID_SIZE * CELL_SIZE;\n   554→    const height = GRID_SIZE * CELL_SIZE;\n   555→\n   556→    this.armageddonPulse += 0.04;\n   557→\n   558→    // Update ground fissures - pulsing lava glow\n   559→    for (const fissure of this.groundFissures) {\n   560→      fissure.pulsePhase += 0.06;\n   561→      fissure.glowIntensity = 0.5 + Math.sin(fissure.pulsePhase) * 0.3;\n   562→    }\n   563→\n   564→    // Spawn fire rain particles\n   565→    if (this.fireRainParticles.length < MAX_FIRE_RAIN && Math.random() < 0.3) {\n   566→      const hueVariation = Math.random();\n   567→      this.fireRainParticles.push({\n   568→        x: Math.random() * width,\n   569→        y: -20,\n   570→        vy: 2 + Math.random() * 3,\n   571→        size: 2 + Math.random() * 4,\n   572→        alpha: 0.6 + Math.random() * 0.4,\n   573→        hue: hueVariation < 0.6 ? 0 : (hueVariation < 0.85 ? 20 : 40), // Red, orange, yellow\n   574→        trail: [],\n   575→      });\n   576→    }\n   577→\n   578→    // Update fire rain\n   579→    for (let i = this.fireRainParticles.length - 1; i >= 0; i--) {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"a9ffc55e-a0c9-472e-becd-c6ebd1381b1c"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0194YoXBvhCEsKoc6eymQUCz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y49H3ZNz5RT8GRc1zhayds","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.tsx","limit":150},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1723,"cache_read_input_tokens":22429,"cache_creation":{"ephemeral_5m_input_tokens":1723,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"2f2cf518-7199-4c01-a320-5b4dadc0f543"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y49H3ZNz5RT8GRc1zhayds","type":"tool_result","content":"     1→import { useEffect, useRef, useCallback } from 'react';\n     2→import './GameBoard.css';\n     3→import type { SnakeScene } from './SnakeScene';\n     4→\n     5→interface Position {\n     6→  x: number;\n     7→  y: number;\n     8→}\n     9→\n    10→type PowerUpType = 'SPEED_BOOST' | 'INVINCIBILITY' | 'SCORE_MULTIPLIER' | 'MAGNET';\n    11→\n    12→interface PowerUp {\n    13→  position: Position;\n    14→  type: PowerUpType;\n    15→  spawnTime: number;\n    16→  duration: number;\n    17→}\n    18→\n    19→interface ActivePowerUp {\n    20→  type: PowerUpType;\n    21→  endTime: number;\n    22→}\n    23→\n    24→interface GameState {\n    25→  snake: Position[];\n    26→  food: Position;\n    27→  gameOver: boolean;\n    28→  gameStarted: boolean;\n    29→  score: number;\n    30→  powerUp?: PowerUp | null;\n    31→  activePowerUps?: ActivePowerUp[];\n    32→  tickCount?: number;\n    33→}\n    34→\n    35→interface GameBoardProps {\n    36→  gameState: GameState;\n    37→  gridSize: number;\n    38→}\n    39→\n    40→const CELL_SIZE = 20;\n    41→const GRID_SIZE = 20;\n    42→\n    43→// Deep Ocean Bioluminescent Theme Colors\n    44→const COLORS = {\n    45→  // Ocean depths background\n    46→  oceanDeep: '#020812',\n    47→  oceanMid: '#041525',\n    48→  oceanLight: '#082040',\n    49→\n    50→  // Bioluminescent snake\n    51→  snakeGlow: '#00ffaa',\n    52→  snakeCore: '#40ffc0',\n    53→  snakeHead: '#80ffdd',\n    54→  snakeEye: '#ffffff',\n    55→\n    56→  // Food - jellyfish orb\n    57→  foodGlow: '#ff6090',\n    58→  foodCore: '#ffaacc',\n    59→  foodPulse: '#ff80b0',\n    60→\n    61→  // Ambient particles\n    62→  planktonBlue: '#4080ff',\n    63→  planktonCyan: '#00e0ff',\n    64→  planktonGreen: '#40ff80',\n    65→\n    66→  // Game over\n    67→  gameOverOverlay: 'rgba(2, 8, 18, 0.92)',\n    68→\n    69→  // Power-up colors\n    70→  powerUpSpeed: '#ffff00',\n    71→  powerUpSpeedGlow: '#ff8800',\n    72→  powerUpInvincibility: '#00ffff',\n    73→  powerUpInvincibilityGlow: '#0088ff',\n    74→  powerUpMultiplier: '#ff00ff',\n    75→  powerUpMultiplierGlow: '#aa00ff',\n    76→  powerUpMagnet: '#00ff88',\n    77→  powerUpMagnetGlow: '#00ff44',\n    78→};\n    79→\n    80→const POWERUP_COLORS: Record<PowerUpType, { main: string; glow: string; symbol: string }> = {\n    81→  SPEED_BOOST: { main: '#ffff00', glow: '#ffa500', symbol: '⚡' },\n    82→  INVINCIBILITY: { main: '#00ffff', glow: '#0088ff', symbol: '🛡' },\n    83→  SCORE_MULTIPLIER: { main: '#ff00ff', glow: '#8800ff', symbol: '×3' },\n    84→  MAGNET: { main: '#00ff88', glow: '#00ff00', symbol: '◎' },\n    85→};\n    86→\n    87→// Animation frame counter\n    88→let frameCount = 0;\n    89→\n    90→// Floating plankton particles\n    91→interface PlanktonParticle {\n    92→  x: number;\n    93→  y: number;\n    94→  vx: number;\n    95→  vy: number;\n    96→  size: number;\n    97→  hue: number;\n    98→  alpha: number;\n    99→  pulsePhase: number;\n   100→  pulseSpeed: number;\n   101→}\n   102→let planktonParticles: PlanktonParticle[] = [];\n   103→const MAX_PLANKTON = 30;\n   104→\n   105→// Water current effect\n   106→let currentPhase = 0;\n   107→\n   108→// Snake trail glow\n   109→interface TrailSegment {\n   110→  x: number;\n   111→  y: number;\n   112→  alpha: number;\n   113→  size: number;\n   114→}\n   115→let snakeTrail: TrailSegment[] = [];\n   116→const MAX_TRAIL = 20;\n   117→\n   118→// Food pulse animation\n   119→let foodPulsePhase = 0;\n   120→\n   121→// Explosion/collection effect\n   122→interface CollectionBurst {\n   123→  x: number;\n   124→  y: number;\n   125→  particles: { angle: number; dist: number; alpha: number; size: number }[];\n   126→  rings: { radius: number; alpha: number }[];\n   127→  life: number;\n   128→}\n   129→let collectionBursts: CollectionBurst[] = [];\n   130→\n   131→// Screen shake\n   132→let screenShakeX = 0;\n   133→let screenShakeY = 0;\n   134→let screenShakeIntensity = 0;\n   135→\n   136→// State tracking\n   137→let lastSnakeLength = 0;\n   138→let wasGameOver = false;\n   139→let effectsInitialized = false;\n   140→\n   141→// HUD state\n   142→let hudPulsePhase = 0;\n   143→let lastHudScore = 0;\n   144→let scoreFlashIntensity = 0;\n   145→\n   146→// Scoreboard state\n   147→interface HighScoreEntry {\n   148→  score: number;\n   149→  date: number;\n   150→  rank: number;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"bf1e778b-4398-479e-b819-59864e7b7615"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QrvDBZdvvrfTxUAPRGNDWQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013JZaZ4GMBMuJBJR7LuXg8R","name":"Bash","input":{"command":"grep -n \"const render\\|function render\\|canvas\\|fillRect\\|ctx\\|graphics\" /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.tsx | head -50"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2032,"cache_read_input_tokens":24152,"cache_creation":{"ephemeral_5m_input_tokens":2032,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"203b88ae-8da0-47ed-97e5-ec6d96abf623"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013JZaZ4GMBMuJBJR7LuXg8R","type":"tool_result","content":"348:function drawHUD(ctx: CanvasRenderingContext2D, gameState: GameState, width: number, height: number): void {\n361:  ctx.save();\n366:  const scoreGradient = ctx.createLinearGradient(padding, padding, padding + scorePanelWidth, padding + scorePanelHeight);\n370:  ctx.fillStyle = scoreGradient;\n371:  ctx.beginPath();\n372:  ctx.roundRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n373:  ctx.fill();\n376:  ctx.strokeStyle = `rgba(0, 255, 170, ${0.6 + scoreFlashIntensity * 0.4})`;\n377:  ctx.lineWidth = 2;\n378:  ctx.shadowColor = '#00ffaa';\n379:  ctx.shadowBlur = 8 + scoreFlashIntensity * 8;\n380:  ctx.stroke();\n381:  ctx.shadowBlur = 0;\n384:  ctx.font = 'bold 10px monospace';\n385:  ctx.fillStyle = '#40ffc0';\n386:  ctx.textAlign = 'left';\n387:  ctx.textBaseline = 'top';\n388:  ctx.fillText('SCORE', padding + 10, padding + 8);\n391:  ctx.font = 'bold 22px monospace';\n392:  ctx.shadowColor = '#00ffaa';\n393:  ctx.shadowBlur = 6 + scoreFlashIntensity * 10;\n394:  ctx.fillStyle = `rgb(${64 + Math.round(scoreFlashIntensity * 191)}, 255, ${192 + Math.round(scoreFlashIntensity * 63)})`;\n395:  ctx.fillText(String(gameState.score).padStart(5, '0'), padding + 10, padding + 22);\n396:  ctx.shadowBlur = 0;\n403:  const lengthGradient = ctx.createLinearGradient(lengthX, padding, lengthX + lengthPanelWidth, padding + lengthPanelHeight);\n407:  ctx.fillStyle = lengthGradient;\n408:  ctx.beginPath();\n409:  ctx.roundRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n410:  ctx.fill();\n412:  ctx.strokeStyle = 'rgba(0, 224, 255, 0.6)';\n413:  ctx.lineWidth = 2;\n414:  ctx.shadowColor = '#00e0ff';\n415:  ctx.shadowBlur = 8;\n416:  ctx.stroke();\n417:  ctx.shadowBlur = 0;\n419:  ctx.font = 'bold 10px monospace';\n420:  ctx.fillStyle = '#ff80b0';\n421:  ctx.fillText('LENGTH', lengthX + 10, padding + 8);\n423:  ctx.font = 'bold 22px monospace';\n424:  ctx.shadowColor = '#00e0ff';\n425:  ctx.shadowBlur = 6;\n426:  ctx.fillStyle = '#00e0ff';\n427:  ctx.fillText(String(gameState.snake.length), lengthX + 10, padding + 22);\n428:  ctx.shadowBlur = 0;\n446:      ctx.fillStyle = colors.glow;\n447:      ctx.globalAlpha = 0.3 * puPulse;\n448:      ctx.beginPath();\n449:      ctx.arc(px, powerUpY, 25, 0, Math.PI * 2);\n450:      ctx.fill();\n451:      ctx.globalAlpha = 1;","is_error":false}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"e775258e-7080-48f5-9118-3a8d87066e4e"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Qo2UvcMG7aphAz21Tz97GU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01H9ykjcyBJQcf93N3AyqMDa","name":"Bash","input":{"command":"grep -n \"useEffect\\|canvasRef\\|renderCanvas\\|clearRect\" /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.tsx | head -30"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1105,"cache_read_input_tokens":26184,"cache_creation":{"ephemeral_5m_input_tokens":1105,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"90d06a5b-f204-42d0-ad14-c89ad8c9f3eb"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01H9ykjcyBJQcf93N3AyqMDa","type":"tool_result","content":"1:import { useEffect, useRef, useCallback } from 'react';\n998:  const canvasRef = useRef<HTMLCanvasElement>(null);\n1008:    } else if (phaserFailedRef.current && canvasRef.current) {\n1009:      drawCanvas2D(canvasRef.current, gameState);\n1014:  useEffect(() => {\n1015:    const canvas = canvasRef.current;\n1103:  useEffect(() => {\n1105:    const canvas = canvasRef.current;\n1126:  useEffect(() => {\n1133:        ref={canvasRef}","is_error":false}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"aedfbabb-8cbd-41e9-9c47-81d30889538a"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FJToEFBWyMkfw1XPpqfyK7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AUVqvipqgyD46f6JKk2EaH","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.tsx","offset":600,"limit":200},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":311,"cache_read_input_tokens":27289,"cache_creation":{"ephemeral_5m_input_tokens":311,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"526cc072-cbeb-4814-b662-b8ebecea49aa"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AUVqvipqgyD46f6JKk2EaH","type":"tool_result","content":"   600→      if (isNewScore) {\n   601→        ctx.font = 'bold 8px monospace';\n   602→        ctx.textAlign = 'center';\n   603→        ctx.fillStyle = `rgba(255, 204, 0, ${0.8 + Math.sin(scoreboardAnimPhase * 4) * 0.2})`;\n   604→        ctx.shadowColor = '#ffcc00';\n   605→        ctx.shadowBlur = 6;\n   606→        ctx.fillText('NEW!', panelX + 65, entryY);\n   607→        ctx.shadowBlur = 0;\n   608→      }\n   609→    }\n   610→  }\n   611→\n   612→  ctx.globalAlpha = alphaMultiplier;\n   613→\n   614→  const currentScoreY = panelY + panelHeight - 20;\n   615→  ctx.font = '10px monospace';\n   616→  ctx.textAlign = 'center';\n   617→  ctx.fillStyle = 'rgba(150, 220, 255, 0.8)';\n   618→  ctx.fillText('YOUR SCORE', centerX, currentScoreY - 12);\n   619→\n   620→  ctx.font = 'bold 16px monospace';\n   621→  ctx.shadowColor = newHighScoreRank > 0 ? '#ffcc00' : '#00ffaa';\n   622→  ctx.shadowBlur = 10;\n   623→  ctx.fillStyle = newHighScoreRank > 0 ? '#ffcc00' : '#00ffaa';\n   624→  ctx.fillText(String(gameState.score).padStart(5, '0'), centerX, currentScoreY + 2);\n   625→  ctx.shadowBlur = 0;\n   626→\n   627→  ctx.restore();\n   628→}\n   629→\n   630→function drawCanvas2D(canvas: HTMLCanvasElement, gameState: GameState): void {\n   631→  const ctx = canvas.getContext('2d');\n   632→  if (!ctx) return;\n   633→\n   634→  initEffects();\n   635→  frameCount++;\n   636→\n   637→  const width = GRID_SIZE * CELL_SIZE;\n   638→  const height = GRID_SIZE * CELL_SIZE;\n   639→\n   640→  // Detect food eaten\n   641→  if (gameState.snake.length > lastSnakeLength && lastSnakeLength > 0) {\n   642→    const head = gameState.snake[0];\n   643→    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n   644→    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n   645→    spawnCollectionBurst(headX, headY);\n   646→  }\n   647→  lastSnakeLength = gameState.snake.length;\n   648→\n   649→  // Detect game over\n   650→  if (gameState.gameOver && !wasGameOver) {\n   651→    screenShakeIntensity = 15;\n   652→    snakeTrail = [];\n   653→  }\n   654→  wasGameOver = gameState.gameOver;\n   655→\n   656→  updateEffects(gameState);\n   657→\n   658→  ctx.save();\n   659→  ctx.scale(canvas.width / width, canvas.height / height);\n   660→\n   661→  // Apply screen shake\n   662→  if (screenShakeIntensity > 0) {\n   663→    ctx.translate(screenShakeX, screenShakeY);\n   664→  }\n   665→\n   666→  // Deep ocean gradient background\n   667→  const bgGradient = ctx.createLinearGradient(0, 0, 0, height);\n   668→  bgGradient.addColorStop(0, COLORS.oceanDeep);\n   669→  bgGradient.addColorStop(0.4, COLORS.oceanMid);\n   670→  bgGradient.addColorStop(1, COLORS.oceanLight);\n   671→  ctx.fillStyle = bgGradient;\n   672→  ctx.fillRect(0, 0, width, height);\n   673→\n   674→  // Subtle water caustic effect\n   675→  ctx.globalAlpha = 0.03;\n   676→  for (let i = 0; i < 5; i++) {\n   677→    const waveX = (frameCount * 0.5 + i * 80) % (width + 100) - 50;\n   678→    const wavePhase = currentPhase + i * 0.8;\n   679→    ctx.fillStyle = '#4080aa';\n   680→    ctx.beginPath();\n   681→    ctx.moveTo(waveX, 0);\n   682→    for (let y = 0; y < height; y += 10) {\n   683→      const x = waveX + Math.sin(wavePhase + y * 0.02) * 20;\n   684→      ctx.lineTo(x, y);\n   685→    }\n   686→    ctx.lineTo(waveX + 30, height);\n   687→    ctx.lineTo(waveX - 30, height);\n   688→    ctx.closePath();\n   689→    ctx.fill();\n   690→  }\n   691→  ctx.globalAlpha = 1;\n   692→\n   693→  // Draw plankton particles\n   694→  for (const p of planktonParticles) {\n   695→    const pulseAlpha = p.alpha * (0.6 + Math.sin(p.pulsePhase) * 0.4);\n   696→\n   697→    // Outer glow\n   698→    ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${pulseAlpha * 0.3})`;\n   699→    ctx.beginPath();\n   700→    ctx.arc(p.x, p.y, p.size * 2.5, 0, Math.PI * 2);\n   701→    ctx.fill();\n   702→\n   703→    // Core\n   704→    ctx.fillStyle = `hsla(${p.hue}, 100%, 70%, ${pulseAlpha * 0.8})`;\n   705→    ctx.beginPath();\n   706→    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\n   707→    ctx.fill();\n   708→  }\n   709→\n   710→  // Draw snake trail glow\n   711→  for (let i = snakeTrail.length - 1; i >= 0; i--) {\n   712→    const t = snakeTrail[i];\n   713→    const progress = i / snakeTrail.length;\n   714→\n   715→    ctx.fillStyle = `rgba(0, 255, 170, ${t.alpha * 0.2})`;\n   716→    ctx.beginPath();\n   717→    ctx.arc(t.x, t.y, t.size * 1.5, 0, Math.PI * 2);\n   718→    ctx.fill();\n   719→\n   720→    ctx.fillStyle = `rgba(64, 255, 192, ${t.alpha * 0.4 * (1 - progress)})`;\n   721→    ctx.beginPath();\n   722→    ctx.arc(t.x, t.y, t.size * 0.8, 0, Math.PI * 2);\n   723→    ctx.fill();\n   724→  }\n   725→\n   726→  // Draw collection bursts\n   727→  for (const burst of collectionBursts) {\n   728→    // Rings\n   729→    for (const ring of burst.rings) {\n   730→      ctx.strokeStyle = `rgba(255, 96, 144, ${ring.alpha * 0.6})`;\n   731→      ctx.lineWidth = 3 * burst.life;\n   732→      ctx.beginPath();\n   733→      ctx.arc(burst.x, burst.y, ring.radius, 0, Math.PI * 2);\n   734→      ctx.stroke();\n   735→\n   736→      ctx.strokeStyle = `rgba(255, 170, 204, ${ring.alpha * 0.8})`;\n   737→      ctx.lineWidth = 1.5 * burst.life;\n   738→      ctx.stroke();\n   739→    }\n   740→\n   741→    // Particles\n   742→    for (const p of burst.particles) {\n   743→      const px = burst.x + Math.cos(p.angle) * p.dist;\n   744→      const py = burst.y + Math.sin(p.angle) * p.dist;\n   745→\n   746→      ctx.fillStyle = `rgba(255, 128, 176, ${p.alpha * burst.life})`;\n   747→      ctx.beginPath();\n   748→      ctx.arc(px, py, p.size * burst.life, 0, Math.PI * 2);\n   749→      ctx.fill();\n   750→    }\n   751→  }\n   752→\n   753→  // Draw food - bioluminescent jellyfish orb\n   754→  const foodX = gameState.food.x * CELL_SIZE + CELL_SIZE / 2;\n   755→  const foodY = gameState.food.y * CELL_SIZE + CELL_SIZE / 2;\n   756→  const foodPulse = 0.8 + Math.sin(foodPulsePhase) * 0.2;\n   757→\n   758→  // Food tendrils (subtle)\n   759→  ctx.strokeStyle = `rgba(255, 96, 144, ${0.3 * foodPulse})`;\n   760→  ctx.lineWidth = 1.5;\n   761→  for (let i = 0; i < 4; i++) {\n   762→    const tendrilAngle = (i / 4) * Math.PI * 2 + foodPulsePhase * 0.3;\n   763→    const tendrilLength = 12 + Math.sin(foodPulsePhase + i) * 4;\n   764→    const endX = foodX + Math.sin(tendrilAngle) * 3;\n   765→    const endY = foodY + tendrilLength;\n   766→\n   767→    ctx.beginPath();\n   768→    ctx.moveTo(foodX, foodY + CELL_SIZE * 0.3);\n   769→    ctx.quadraticCurveTo(endX, foodY + tendrilLength * 0.5, endX, endY);\n   770→    ctx.stroke();\n   771→  }\n   772→\n   773→  // Outer glow\n   774→  ctx.shadowColor = COLORS.foodGlow;\n   775→  ctx.shadowBlur = 20 * foodPulse;\n   776→  const foodGlow = ctx.createRadialGradient(foodX, foodY, 0, foodX, foodY, CELL_SIZE * 1.2);\n   777→  foodGlow.addColorStop(0, `rgba(255, 170, 204, ${0.9 * foodPulse})`);\n   778→  foodGlow.addColorStop(0.4, `rgba(255, 96, 144, ${0.6 * foodPulse})`);\n   779→  foodGlow.addColorStop(1, 'rgba(255, 64, 120, 0)');\n   780→  ctx.fillStyle = foodGlow;\n   781→  ctx.beginPath();\n   782→  ctx.arc(foodX, foodY, CELL_SIZE * foodPulse, 0, Math.PI * 2);\n   783→  ctx.fill();\n   784→\n   785→  // Core\n   786→  ctx.fillStyle = COLORS.foodCore;\n   787→  ctx.beginPath();\n   788→  ctx.arc(foodX, foodY, CELL_SIZE * 0.35 * foodPulse, 0, Math.PI * 2);\n   789→  ctx.fill();\n   790→\n   791→  // Highlight\n   792→  ctx.fillStyle = '#ffffff';\n   793→  ctx.globalAlpha = 0.8;\n   794→  ctx.beginPath();\n   795→  ctx.arc(foodX - 3, foodY - 3, CELL_SIZE * 0.12, 0, Math.PI * 2);\n   796→  ctx.fill();\n   797→  ctx.globalAlpha = 1;\n   798→  ctx.shadowBlur = 0;\n   799→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"96f50c82-e088-446b-abf2-7c3e73da169b"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_014CoytwzFxjqy1f2Fw8oJcp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ldook6yuhxKZMpyv3MKNae","name":"Bash","input":{"command":"grep -n \"render\\|draw\\|graphics\\|fillStyle\\|strokeStyle\" /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts | grep -E \"^\\s*[0-9]+.*render|2[34][0-9]{2}:\" | head -50"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3483,"cache_read_input_tokens":27600,"cache_creation":{"ephemeral_5m_input_tokens":3483,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"27c9a506-d99f-48ac-b639-72bd0fc080b7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ldook6yuhxKZMpyv3MKNae","type":"tool_result","content":"164:// Comet trail segment - stores historical snake positions for smooth trail rendering\n2316:  private drawThrownFood(g: Phaser.GameObjects.Graphics): void {\n2328:      g.fillStyle(COLORS.foodGlow, t.alpha * 0.3);\n2332:      g.fillStyle(COLORS.food, t.alpha * 0.6);\n2346:      g.fillStyle(COLORS.foodGlow, p.life * 0.6);\n2348:      g.fillStyle(COLORS.noirWhite, p.life * 0.9);\n2358:      g.fillStyle(COLORS.foodGlow, 0.3);\n2362:      g.fillStyle(COLORS.noirWhite, 0.4);\n2366:      g.fillStyle(COLORS.food, 0.95);\n2373:      g.fillStyle(0xffffff, 0.9);\n2380:      g.fillStyle(0xffffff, 0.6);\n2416:    const g = this.graphics;\n2420:    drawCleanBackground(g, width, height, this.frameCount);\n2421:    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n2422:    drawMotes(g, this.cleanEffects);\n2426:    drawGlowTrail(g, this.cleanEffects);\n2427:    drawRipples(g, this.cleanEffects);\n2432:    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n2434:    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n2436:    drawTears(g, this.cleanEffects);\n2437:    drawBlood(g, this.cleanEffects);\n2439:    drawCleanVignette(g, width, height);\n2443:    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n2446:      this.drawGameOver(g, width, height);\n2447:      this.drawScoreboard(g, width, height);\n2451:    this.needsRedraw = false;\n2454:  private drawStars(g: Phaser.GameObjects.Graphics): void {\n2459:      g.fillStyle(COLORS.star, alpha);\n2483:  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n2490:    g.fillStyle(0x000000, 0.6);\n2498:      g.fillStyle(COLORS.spotlight, layerAlpha);\n3398:    // Use simple block characters for text rendering\n3408:      // Simple pixel-style character rendering","is_error":false}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"91c607a8-e90e-475b-804a-6a7a6ec759a6"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017YBHDBgKswk8ePsds6RFG6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Py5hPBZKWdjb3tQA6gWNAG","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":2385,"limit":100},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":895,"cache_read_input_tokens":31083,"cache_creation":{"ephemeral_5m_input_tokens":895,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"bfcf28cc-49e4-484e-b9f5-b2a15288626f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Py5hPBZKWdjb3tQA6gWNAG","type":"tool_result","content":"  2385→  update(): void {\n  2386→    this.frameCount++;\n  2387→    this.cleanEffects.frameCount = this.frameCount;\n  2388→\n  2389→    const width = this.scale.width;\n  2390→    const height = this.scale.height;\n  2391→\n  2392→    updateMotes(this.cleanEffects, width, height);\n  2393→    updateRipples(this.cleanEffects);\n  2394→    updateTears(this.cleanEffects, height);\n  2395→    updateBlood(this.cleanEffects, height);\n  2396→\n  2397→    if (this.currentState && this.currentState.snake.length > 0) {\n  2398→      const head = this.currentState.snake[0];\n  2399→      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n  2400→      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n  2401→\n  2402→      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n  2403→        updateGlowTrail(this.cleanEffects, headX, headY);\n  2404→      }\n  2405→      this.lastHeadPos = { x: head.x, y: head.y };\n  2406→\n  2407→      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n  2408→        const food = this.currentState.food;\n  2409→        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n  2410→        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n  2411→        spawnRipple(this.cleanEffects, foodX, foodY);\n  2412→      }\n  2413→      this.lastSnakeLength = this.currentState.snake.length;\n  2414→    }\n  2415→\n  2416→    const g = this.graphics;\n  2417→    g.clear();\n  2418→    g.setPosition(0, 0);\n  2419→\n  2420→    drawCleanBackground(g, width, height, this.frameCount);\n  2421→    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n  2422→    drawMotes(g, this.cleanEffects);\n  2423→\n  2424→    if (!this.currentState) return;\n  2425→\n  2426→    drawGlowTrail(g, this.cleanEffects);\n  2427→    drawRipples(g, this.cleanEffects);\n  2428→\n  2429→    const food = this.currentState.food;\n  2430→    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n  2431→    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n  2432→    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n  2433→\n  2434→    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n  2435→\n  2436→    drawTears(g, this.cleanEffects);\n  2437→    drawBlood(g, this.cleanEffects);\n  2438→\n  2439→    drawCleanVignette(g, width, height);\n  2440→\n  2441→    const score = this.currentState.score || 0;\n  2442→    const snakeLength = this.currentState.snake.length;\n  2443→    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n  2444→\n  2445→    if (this.currentState.gameOver) {\n  2446→      this.drawGameOver(g, width, height);\n  2447→      this.drawScoreboard(g, width, height);\n  2448→    }\n  2449→\n  2450→    this.checkAndSaveHighScore();\n  2451→    this.needsRedraw = false;\n  2452→  }\n  2453→\n  2454→  private drawStars(g: Phaser.GameObjects.Graphics): void {\n  2455→    // In film noir mode, stars are subtle distant lights\n  2456→    for (const star of this.stars) {\n  2457→      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n  2458→      const alpha = star.brightness * twinkle * 0.25;\n  2459→      g.fillStyle(COLORS.star, alpha);\n  2460→      g.fillCircle(star.x, star.y, star.size * 0.7);\n  2461→    }\n  2462→  }\n  2463→\n  2464→  private updateSmokeParticles(): void {\n  2465→    const width = GRID_SIZE * CELL_SIZE;\n  2466→    const height = GRID_SIZE * CELL_SIZE;\n  2467→    for (const smoke of this.smokeParticles) {\n  2468→      smoke.x += smoke.vx;\n  2469→      smoke.y += smoke.vy;\n  2470→      smoke.life -= 0.002;\n  2471→      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n  2472→        smoke.x = Math.random() * width;\n  2473→        smoke.y = height + smoke.size;\n  2474→        smoke.life = 1;\n  2475→        smoke.size = 30 + Math.random() * 50;\n  2476→        smoke.alpha = 0.02 + Math.random() * 0.03;\n  2477→      }\n  2478→      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n  2479→      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n  2480→    }\n  2481→  }\n  2482→\n  2483→  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n  2484→    // Create dramatic spotlight effect centered on snake\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"4217e149-e64a-4015-a309-20ee5dd2aae0"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DLaDW5EVhAXMe9pEKtjQjb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013A9moNArMp5sE9Q8P2RuDz","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","offset":200,"limit":300},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2028,"cache_read_input_tokens":31978,"cache_creation":{"ephemeral_5m_input_tokens":2028,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"8f7db4d7-8c64-4048-93c8-518faa4c4da3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013A9moNArMp5sE9Q8P2RuDz","type":"tool_result","content":"   200→    tear.alpha *= 0.99;\n   201→\n   202→    if (tear.y > height + 10 || tear.alpha < 0.05) {\n   203→      state.tears.splice(i, 1);\n   204→    }\n   205→  }\n   206→}\n   207→\n   208→export function spawnBlood(state: CleanEffectsState, x: number, y: number, count: number): void {\n   209→  for (let i = 0; i < count; i++) {\n   210→    if (state.blood.length >= MAX_BLOOD) {\n   211→      state.blood.shift();\n   212→    }\n   213→    const angle = Math.random() * Math.PI * 2;\n   214→    const speed = 1 + Math.random() * 3;\n   215→    state.blood.push({\n   216→      x,\n   217→      y,\n   218→      vx: Math.cos(angle) * speed,\n   219→      vy: Math.sin(angle) * speed - 1,\n   220→      size: 2 + Math.random() * 4,\n   221→      alpha: 0.8 + Math.random() * 0.2,\n   222→      life: 1.0,\n   223→      splashed: false,\n   224→      splashRadius: 0,\n   225→    });\n   226→  }\n   227→}\n   228→\n   229→export function updateBlood(state: CleanEffectsState, height: number): void {\n   230→  for (let i = state.blood.length - 1; i >= 0; i--) {\n   231→    const drop = state.blood[i];\n   232→\n   233→    if (!drop.splashed) {\n   234→      drop.vy += 0.15;\n   235→      drop.x += drop.vx;\n   236→      drop.y += drop.vy;\n   237→      drop.vx *= 0.98;\n   238→\n   239→      if (drop.y >= height - 5) {\n   240→        drop.splashed = true;\n   241→        drop.y = height - 5;\n   242→        drop.splashRadius = drop.size * 1.5;\n   243→      }\n   244→    } else {\n   245→      drop.splashRadius += 0.3;\n   246→      drop.alpha *= 0.95;\n   247→    }\n   248→\n   249→    drop.life -= 0.015;\n   250→\n   251→    if (drop.life <= 0 || drop.alpha < 0.02) {\n   252→      state.blood.splice(i, 1);\n   253→    }\n   254→  }\n   255→}\n   256→\n   257→export function drawCleanBackground(\n   258→  g: Phaser.GameObjects.Graphics,\n   259→  width: number,\n   260→  height: number,\n   261→  frameCount: number\n   262→): void {\n   263→  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n   264→  g.fillRect(0, 0, width, height);\n   265→\n   266→  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n   267→  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n   268→  g.fillCircle(width / 2, height / 2, width * 0.6);\n   269→  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n   270→  g.fillCircle(width / 2, height / 2, width * 0.3);\n   271→}\n   272→\n   273→export function drawCleanGrid(\n   274→  g: Phaser.GameObjects.Graphics,\n   275→  width: number,\n   276→  height: number,\n   277→  cellSize: number,\n   278→  gridSize: number,\n   279→  frameCount: number\n   280→): void {\n   281→  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n   282→  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n   283→\n   284→  for (let i = 0; i <= gridSize; i++) {\n   285→    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n   286→    g.lineBetween(0, i * cellSize, width, i * cellSize);\n   287→  }\n   288→\n   289→  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n   290→  for (let i = 0; i <= gridSize; i += 5) {\n   291→    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n   292→    g.lineBetween(0, i * cellSize, width, i * cellSize);\n   293→  }\n   294→}\n   295→\n   296→export function drawMotes(\n   297→  g: Phaser.GameObjects.Graphics,\n   298→  state: CleanEffectsState\n   299→): void {\n   300→  for (const mote of state.motes) {\n   301→    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n   302→    const alpha = mote.alpha * pulse;\n   303→\n   304→    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n   305→    g.fillCircle(mote.x, mote.y, mote.size * 2);\n   306→    g.fillStyle(CLEAN_COLORS.mote, alpha);\n   307→    g.fillCircle(mote.x, mote.y, mote.size);\n   308→  }\n   309→}\n   310→\n   311→export function drawRipples(\n   312→  g: Phaser.GameObjects.Graphics,\n   313→  state: CleanEffectsState\n   314→): void {\n   315→  for (const ripple of state.ripples) {\n   316→    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n   317→    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n   318→\n   319→    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n   320→    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n   321→  }\n   322→}\n   323→\n   324→export function drawGlowTrail(\n   325→  g: Phaser.GameObjects.Graphics,\n   326→  state: CleanEffectsState\n   327→): void {\n   328→  for (const trail of state.glowTrail) {\n   329→    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n   330→    g.fillCircle(trail.x, trail.y, trail.size);\n   331→  }\n   332→}\n   333→\n   334→export function drawCleanFood(\n   335→  g: Phaser.GameObjects.Graphics,\n   336→  foodX: number,\n   337→  foodY: number,\n   338→  cellSize: number,\n   339→  frameCount: number\n   340→): void {\n   341→  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n   342→  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n   343→  const foodSize = (cellSize / 2 - 2) * pulseScale;\n   344→\n   345→  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n   346→  g.fillCircle(foodX, foodY, foodSize + 12);\n   347→  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n   348→  g.fillCircle(foodX, foodY, foodSize + 6);\n   349→\n   350→  g.fillStyle(CLEAN_COLORS.food, 0.9);\n   351→  g.fillCircle(foodX, foodY, foodSize);\n   352→  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n   353→  g.fillCircle(foodX, foodY, foodSize * 0.5);\n   354→\n   355→  g.fillStyle(0xffffff, 0.6);\n   356→  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n   357→}\n   358→\n   359→export function drawCleanSnake(\n   360→  g: Phaser.GameObjects.Graphics,\n   361→  snake: { x: number; y: number }[],\n   362→  cellSize: number,\n   363→  frameCount: number\n   364→): void {\n   365→  const snakeLen = snake.length;\n   366→  if (snakeLen === 0) return;\n   367→\n   368→  for (let i = snakeLen - 1; i >= 0; i--) {\n   369→    const segment = snake[i];\n   370→    const centerX = segment.x * cellSize + cellSize / 2;\n   371→    const centerY = segment.y * cellSize + cellSize / 2;\n   372→    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n   373→\n   374→    const glowAlpha = 0.15 * (1 - t * 0.5);\n   375→    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n   376→    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n   377→    g.fillCircle(centerX, centerY, glowSize);\n   378→  }\n   379→\n   380→  for (let i = snakeLen - 1; i >= 0; i--) {\n   381→    const segment = snake[i];\n   382→    const centerX = segment.x * cellSize + cellSize / 2;\n   383→    const centerY = segment.y * cellSize + cellSize / 2;\n   384→    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n   385→    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n   386→\n   387→    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n   388→    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n   389→    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n   390→    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n   391→    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n   392→    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n   393→\n   394→    const r = Math.round(r1 + (r2 - r1) * t);\n   395→    const gVal = Math.round(g1 + (g2 - g1) * t);\n   396→    const b = Math.round(b1 + (b2 - b1) * t);\n   397→    const color = (r << 16) | (gVal << 8) | b;\n   398→\n   399→    g.fillStyle(color, 0.95);\n   400→    g.fillCircle(centerX, centerY, radius);\n   401→\n   402→    if (i === 0) {\n   403→      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n   404→      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n   405→      g.fillCircle(centerX, centerY, radius + 4);\n   406→\n   407→      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n   408→      g.fillCircle(centerX, centerY, radius);\n   409→\n   410→      g.fillStyle(0xffffff, 0.7);\n   411→      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n   412→    }\n   413→  }\n   414→}\n   415→\n   416→export function drawCleanVignette(\n   417→  g: Phaser.GameObjects.Graphics,\n   418→  width: number,\n   419→  height: number\n   420→): void {\n   421→  const layers = 4;\n   422→  for (let i = 0; i < layers; i++) {\n   423→    const inset = i * 25;\n   424→    const alpha = 0.08 * (1 - i / layers);\n   425→    g.lineStyle(50, 0x000000, alpha);\n   426→    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n   427→  }\n   428→}\n   429→\n   430→export function drawTears(\n   431→  g: Phaser.GameObjects.Graphics,\n   432→  state: CleanEffectsState\n   433→): void {\n   434→  for (const tear of state.tears) {\n   435→    g.fillStyle(CLEAN_COLORS.tear, tear.alpha * 0.3);\n   436→    g.fillCircle(tear.x, tear.y, tear.size * 2);\n   437→\n   438→    g.fillStyle(CLEAN_COLORS.tear, tear.alpha);\n   439→    g.fillCircle(tear.x, tear.y - tear.size * 0.3, tear.size);\n   440→    g.fillCircle(tear.x, tear.y + tear.size * 0.5, tear.size * 0.7);\n   441→\n   442→    g.fillStyle(CLEAN_COLORS.tearHighlight, tear.alpha * 0.6);\n   443→    g.fillCircle(tear.x - tear.size * 0.25, tear.y - tear.size * 0.4, tear.size * 0.3);\n   444→  }\n   445→}\n   446→\n   447→export function drawBlood(\n   448→  g: Phaser.GameObjects.Graphics,\n   449→  state: CleanEffectsState\n   450→): void {\n   451→  for (const drop of state.blood) {\n   452→    const effectiveAlpha = drop.alpha * drop.life;\n   453→\n   454→    if (drop.splashed) {\n   455→      g.fillStyle(CLEAN_COLORS.bloodDark, effectiveAlpha * 0.5);\n   456→      g.fillCircle(drop.x, drop.y, drop.splashRadius);\n   457→      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.7);\n   458→      g.fillCircle(drop.x, drop.y, drop.splashRadius * 0.6);\n   459→    } else {\n   460→      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.4);\n   461→      g.fillCircle(drop.x, drop.y, drop.size * 2);\n   462→      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha);\n   463→      g.fillCircle(drop.x, drop.y, drop.size);\n   464→      g.fillStyle(0xffffff, effectiveAlpha * 0.3);\n   465→      g.fillCircle(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.25);\n   466→    }\n   467→  }\n   468→}\n   469→\n   470→export function drawCleanHUD(\n   471→  g: Phaser.GameObjects.Graphics,\n   472→  score: number,\n   473→  snakeLength: number,\n   474→  width: number,\n   475→  frameCount: number,\n   476→  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n   477→): void {\n   478→  const padding = 15;\n   479→  const digitSize = 12;\n   480→  const digitSpacing = digitSize * 0.6;\n   481→\n   482→  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n   483→\n   484→  const scoreStr = String(score).padStart(4, '0');\n   485→  let xPos = padding;\n   486→\n   487→  for (let i = 0; i < scoreStr.length; i++) {\n   488→    const digit = scoreStr[i];\n   489→    g.fillStyle(CLEAN_COLORS.text, pulse);\n   490→    drawDigit(g, digit, xPos, padding, digitSize);\n   491→    xPos += digitSpacing;\n   492→  }\n   493→\n   494→  const lengthStr = String(snakeLength);\n   495→  xPos = width - padding - lengthStr.length * digitSpacing;\n   496→\n   497→  for (let i = 0; i < lengthStr.length; i++) {\n   498→    const digit = lengthStr[i];\n   499→    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"a16a3884-8caa-4a43-89bd-1ba2e31c29e7"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01XmJszpcJ2hDzLutuP1jP5G","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0178WGyEQk1HXALTY3BDAc22","name":"Bash","input":{"command":"find /__w/perfect-snake-platform/perfect-snake-platform/game/src -type f \\( -name \"*.ts\" -o -name \"*.tsx\" -o -name \"*.css\" \\) | sort"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":4970,"cache_read_input_tokens":34006,"cache_creation":{"ephemeral_5m_input_tokens":4970,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"29a02369-0973-49e7-b1b6-f3670c6e32ce"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0178WGyEQk1HXALTY3BDAc22","type":"tool_result","content":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/App.css\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/App.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/__tests__/postMessage.test.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/__tests__/setup.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/__tests__/visual-safety.test.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.css\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.test.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/constants.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/index.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/logic.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/types.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/useDirectionQueue.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/useKeyboard.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/usePostMessage.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/useSnakeGame.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/useTouch.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/main.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/vite-env.d.ts","is_error":false}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"4557172d-0c10-4d2d-8cf6-ae54956a0a36"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01R59zsGNQwfg8VXxgh9MfmV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015TxQrqL35Q27Gz8hKqEhJi","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/package.json"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":722,"cache_read_input_tokens":38976,"cache_creation":{"ephemeral_5m_input_tokens":722,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"ad895e09-1d18-4abe-9709-d0a887ccf53e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015TxQrqL35Q27Gz8hKqEhJi","type":"tool_result","content":"     1→{\n     2→  \"name\": \"the-perfect-snake\",\n     3→  \"private\": true,\n     4→  \"version\": \"0.0.0\",\n     5→  \"type\": \"module\",\n     6→  \"scripts\": {\n     7→    \"dev\": \"vite\",\n     8→    \"start\": \"vite\",\n     9→    \"build\": \"tsc && vite build\",\n    10→    \"preview\": \"vite preview\",\n    11→    \"test\": \"vitest run\",\n    12→    \"test:watch\": \"vitest\",\n    13→    \"test:coverage\": \"vitest run --coverage\",\n    14→    \"test:perf\": \"npx playwright test\",\n    15→    \"reset-to-baseline\": \"cp .baseline/App.css src/App.css && cp .baseline/GameBoard.css src/components/GameBoard.css && cp .baseline/GameBoard.tsx src/components/GameBoard.tsx && cp .baseline/SnakeScene.ts src/components/SnakeScene.ts && echo '✅ Reset to boring baseline (v0)'\",\n    16→    \"upload-version\": \"node scripts/upload-version.js\"\n    17→  },\n    18→  \"dependencies\": {\n    19→    \"@vercel/blob\": \"^2.0.1\",\n    20→    \"phaser\": \"^3.90.0\",\n    21→    \"react\": \"^18.2.0\",\n    22→    \"react-dom\": \"^18.2.0\"\n    23→  },\n    24→  \"devDependencies\": {\n    25→    \"@playwright/test\": \"^1.58.2\",\n    26→    \"@testing-library/react\": \"^14.1.2\",\n    27→    \"@types/react\": \"^18.2.43\",\n    28→    \"@types/react-dom\": \"^18.2.17\",\n    29→    \"@vitejs/plugin-react\": \"^4.2.1\",\n    30→    \"@vitest/ui\": \"^1.1.0\",\n    31→    \"jsdom\": \"^23.0.1\",\n    32→    \"typescript\": \"^5.2.2\",\n    33→    \"vite\": \"^5.0.8\",\n    34→    \"vitest\": \"^1.1.0\"\n    35→  }\n    36→}\n    37→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"76f63a37-16ae-4dfe-b74a-3b0be6eda27e"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0112VPEd57iYaGz8JyFKsmYM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KhFH6RhxV6s682sLWuyJCg","name":"Bash","input":{"command":"find /__w/perfect-snake-platform/perfect-snake-platform/game -maxdepth 2 -name \"README*\" -o -name \"readme*\" | head -5"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":808,"cache_read_input_tokens":39698,"cache_creation":{"ephemeral_5m_input_tokens":808,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"cac82e4b-b8f6-4dc9-b25a-fc31cea38860"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KhFH6RhxV6s682sLWuyJCg","type":"tool_result","content":"/__w/perfect-snake-platform/perfect-snake-platform/game/.baseline/README.md\n/__w/perfect-snake-platform/perfect-snake-platform/game/README.md","is_error":false}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"5e43eae5-ff0a-4fb5-aef9-e5bf16d6754f"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RaZNS2GxgzBTR5wcanQZvN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016Bn7WMCACephJeDeLnBsxd","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/README.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":198,"cache_read_input_tokens":40506,"cache_creation":{"ephemeral_5m_input_tokens":198,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"4d9a8923-dc6f-4eb7-90d8-cc99ac6272af"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016Bn7WMCACephJeDeLnBsxd","type":"tool_result","content":"     1→# The Perfect Snake\n     2→\n     3→A classic Snake game built with React + TypeScript + Vite.\n     4→\n     5→This is the standalone game component that can be embedded via iframe or deployed independently.\n     6→\n     7→## Getting Started\n     8→\n     9→1. Install dependencies:\n    10→```bash\n    11→npm install\n    12→```\n    13→\n    14→2. Start the development server:\n    15→```bash\n    16→npm start\n    17→```\n    18→\n    19→The game will open in your browser at `http://localhost:5173`\n    20→\n    21→3. Build for production:\n    22→```bash\n    23→npm run build\n    24→```\n    25→\n    26→## How to Play\n    27→\n    28→**Desktop:**\n    29→- Press **SPACE** to start the game\n    30→- Use **Arrow Keys** to control the snake\n    31→\n    32→**Mobile:**\n    33→- Tap **Start Game** button\n    34→- Swipe in any direction OR use on-screen arrow buttons to control the snake\n    35→\n    36→**Goal:**\n    37→- Eat the red food to grow and score points\n    38→- Avoid hitting walls or your own tail\n    39→\n    40→## Features\n    41→\n    42→- Fully responsive design (works on desktop and mobile)\n    43→- Touch/swipe controls for mobile devices\n    44→- On-screen control buttons\n    45→- Real-time snake movement\n    46→- Score tracking\n    47→- Collision detection\n    48→- Embeddable via iframe\n    49→\n    50→## Tech Stack\n    51→\n    52→- React 18\n    53→- TypeScript\n    54→- Vite\n    55→- CSS3\n    56→\n    57→## Embedding\n    58→\n    59→This game can be embedded in other applications using an iframe:\n    60→\n    61→```html\n    62→<iframe\n    63→  src=\"https://your-game-url.vercel.app\"\n    64→  width=\"600\"\n    65→  height=\"700\"\n    66→  allow=\"accelerometer; autoplay\"\n    67→  sandbox=\"allow-scripts allow-same-origin\"\n    68→/>\n    69→```\n    70→\n    71→## Architecture\n    72→\n    73→This repository contains only the pure game code. The payment and AI improvement platform is maintained separately in a private repository.\n    74→\n    75→Enjoy the game!\n    76→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"1b07f138-e230-4b31-83c5-93d5e22e7f03"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01K8EJHQPzE6gn35tqgRRod7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01B4FCh6c8cxtdGiwgYQbtr5","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/useSnakeGame.ts","limit":100},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":943,"cache_read_input_tokens":40704,"cache_creation":{"ephemeral_5m_input_tokens":943,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"3fea880a-fd07-4d7a-85cf-7d68df8196dc"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01B4FCh6c8cxtdGiwgYQbtr5","type":"tool_result","content":"     1→/**\n     2→ * Main Snake Game Hook\n     3→ * Composes all game modules into a single, clean interface\n     4→ */\n     5→\n     6→import { useState, useEffect, useCallback, useRef } from 'react';\n     7→import { GameState, Direction } from './types';\n     8→import { createInitialState, INITIAL_SNAKE, GAME_SPEED_MS, GRID_SIZE, SPEED_BOOST_MS } from './constants';\n     9→import { tick, createNewGame, hasPowerUp } from './logic';\n    10→import { usePostMessage } from './usePostMessage';\n    11→import { useKeyboard } from './useKeyboard';\n    12→import { useTouch } from './useTouch';\n    13→import { useDirectionQueue } from './useDirectionQueue';\n    14→\n    15→export type { Direction, GameState, Position } from './types';\n    16→export { GRID_SIZE } from './constants';\n    17→\n    18→export function useSnakeGame() {\n    19→  const [gameState, setGameState] = useState<GameState>(createInitialState);\n    20→  const gameLoopRef = useRef<number>();\n    21→  const directionQueue = useDirectionQueue();\n    22→\n    23→  // Detect embedded mode (in iframe)\n    24→  const isEmbedded = typeof window !== 'undefined' && window.parent !== window;\n    25→\n    26→  // Game actions\n    27→  const resetGame = useCallback(() => {\n    28→    directionQueue.reset();\n    29→    setGameState(createNewGame(INITIAL_SNAKE));\n    30→  }, [directionQueue]);\n    31→\n    32→  const changeDirection = useCallback((direction: Direction) => {\n    33→    if (!gameState.gameStarted || gameState.gameOver) return;\n    34→    directionQueue.enqueue(direction);\n    35→  }, [gameState.gameStarted, gameState.gameOver, directionQueue]);\n    36→\n    37→  // PostMessage communication (origin-agnostic)\n    38→  const { broadcastState, broadcastReady } = usePostMessage({\n    39→    isEmbedded,\n    40→    onDirectionChange: changeDirection,\n    41→    onStartGame: resetGame,\n    42→    onResetGame: resetGame\n    43→  });\n    44→\n    45→  // Keyboard input (standalone mode only)\n    46→  useKeyboard({\n    47→    enabled: !isEmbedded,\n    48→    gameStarted: gameState.gameStarted,\n    49→    gameOver: gameState.gameOver,\n    50→    onDirectionChange: changeDirection,\n    51→    onStartOrReset: resetGame\n    52→  });\n    53→\n    54→  // Touch/swipe input (standalone mode only)\n    55→  useTouch({\n    56→    enabled: !isEmbedded,\n    57→    gameStarted: gameState.gameStarted,\n    58→    gameOver: gameState.gameOver,\n    59→    onDirectionChange: changeDirection\n    60→  });\n    61→\n    62→  // Game loop\n    63→  useEffect(() => {\n    64→    if (!gameState.gameStarted || gameState.gameOver) {\n    65→      return;\n    66→    }\n    67→\n    68→    const runTick = () => {\n    69→      const direction = directionQueue.dequeue();\n    70→      setGameState(prev => tick(prev, direction));\n    71→    };\n    72→\n    73→    const hasSpeedBoost = hasPowerUp(gameState.activePowerUps, 'SPEED_BOOST');\n    74→    const speed = hasSpeedBoost ? SPEED_BOOST_MS : GAME_SPEED_MS;\n    75→\n    76→    gameLoopRef.current = window.setInterval(runTick, speed);\n    77→\n    78→    return () => {\n    79→      if (gameLoopRef.current) {\n    80→        clearInterval(gameLoopRef.current);\n    81→      }\n    82→    };\n    83→  }, [gameState.gameStarted, gameState.gameOver, gameState.activePowerUps, directionQueue]);\n    84→\n    85→  // Broadcast state changes to parent\n    86→  useEffect(() => {\n    87→    broadcastState({\n    88→      gameStarted: gameState.gameStarted,\n    89→      gameOver: gameState.gameOver,\n    90→      score: gameState.score\n    91→    });\n    92→  }, [gameState.gameStarted, gameState.gameOver, gameState.score, broadcastState]);\n    93→\n    94→  // Broadcast ready on mount\n    95→  useEffect(() => {\n    96→    broadcastReady();\n    97→  }, [broadcastReady]);\n    98→\n    99→  return {\n   100→    gameState,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"922350a0-58b5-476c-af09-fc21944d21fc"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01K8EJHQPzE6gn35tqgRRod7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FdNwm1sNcvc7GhVKvCWkhi","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/logic.ts","limit":100},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":943,"cache_read_input_tokens":40704,"cache_creation":{"ephemeral_5m_input_tokens":943,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"236aba74-4742-4466-a833-1e7838fe3359"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FdNwm1sNcvc7GhVKvCWkhi","type":"tool_result","content":"     1→/**\n     2→ * Pure game logic functions - no React, no side effects\n     3→ * Easy to test, easy to reason about\n     4→ */\n     5→\n     6→import { Position, Direction, GameState, OPPOSITE_DIRECTIONS, PowerUp, PowerUpType, ActivePowerUp } from './types';\n     7→import { GRID_SIZE, POINTS_PER_FOOD, POWERUP_SPAWN_CHANCE, POWERUP_DESPAWN_TICKS, POWERUP_DURATIONS, POWERUP_TYPES, SCORE_MULTIPLIER_VALUE } from './constants';\n     8→\n     9→/** Check if two positions are equal */\n    10→export const positionsEqual = (a: Position, b: Position): boolean =>\n    11→  a.x === b.x && a.y === b.y;\n    12→\n    13→/** Check if position is within grid bounds */\n    14→export const isInBounds = (pos: Position): boolean =>\n    15→  pos.x >= 0 && pos.x < GRID_SIZE && pos.y >= 0 && pos.y < GRID_SIZE;\n    16→\n    17→/** Check if position collides with snake body */\n    18→export const collidesWithSnake = (pos: Position, snake: Position[]): boolean =>\n    19→  snake.some(segment => positionsEqual(pos, segment));\n    20→\n    21→/** Check if move would cause collision (wall or self) */\n    22→export const wouldCollide = (head: Position, snake: Position[]): boolean =>\n    23→  !isInBounds(head) || collidesWithSnake(head, snake);\n    24→\n    25→/** Get next head position based on direction */\n    26→export const getNextHead = (head: Position, direction: Direction): Position => {\n    27→  const moves: Record<Direction, Position> = {\n    28→    UP: { x: head.x, y: head.y - 1 },\n    29→    DOWN: { x: head.x, y: head.y + 1 },\n    30→    LEFT: { x: head.x - 1, y: head.y },\n    31→    RIGHT: { x: head.x + 1, y: head.y }\n    32→  };\n    33→  return moves[direction];\n    34→};\n    35→\n    36→/** Check if direction change is valid (not 180-degree turn) */\n    37→export const isValidDirectionChange = (\n    38→  newDirection: Direction,\n    39→  currentDirection: Direction\n    40→): boolean => OPPOSITE_DIRECTIONS[newDirection] !== currentDirection;\n    41→\n    42→/** Generate random food position not on snake */\n    43→export const generateFood = (snake: Position[], excludePos?: Position): Position => {\n    44→  let food: Position;\n    45→  do {\n    46→    food = {\n    47→      x: Math.floor(Math.random() * GRID_SIZE),\n    48→      y: Math.floor(Math.random() * GRID_SIZE)\n    49→    };\n    50→  } while (collidesWithSnake(food, snake) || (excludePos && positionsEqual(food, excludePos)));\n    51→  return food;\n    52→};\n    53→\n    54→/** Generate a power-up at a random position */\n    55→export const generatePowerUp = (snake: Position[], food: Position, tickCount: number): PowerUp => {\n    56→  const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];\n    57→  let pos: Position;\n    58→  do {\n    59→    pos = {\n    60→      x: Math.floor(Math.random() * GRID_SIZE),\n    61→      y: Math.floor(Math.random() * GRID_SIZE)\n    62→    };\n    63→  } while (collidesWithSnake(pos, snake) || positionsEqual(pos, food));\n    64→\n    65→  return {\n    66→    position: pos,\n    67→    type,\n    68→    spawnTime: tickCount,\n    69→    duration: POWERUP_DURATIONS[type],\n    70→  };\n    71→};\n    72→\n    73→/** Check if a power-up type is active */\n    74→export const hasPowerUp = (activePowerUps: ActivePowerUp[], type: PowerUpType): boolean => {\n    75→  return activePowerUps.some(p => p.type === type);\n    76→};\n    77→\n    78→/** Update active power-ups, removing expired ones */\n    79→export const updateActivePowerUps = (activePowerUps: ActivePowerUp[], tickCount: number): ActivePowerUp[] => {\n    80→  return activePowerUps.filter(p => p.endTime > tickCount);\n    81→};\n    82→\n    83→/** Activate a power-up */\n    84→export const activatePowerUp = (activePowerUps: ActivePowerUp[], type: PowerUpType, tickCount: number): ActivePowerUp[] => {\n    85→  const existing = activePowerUps.find(p => p.type === type);\n    86→  const duration = POWERUP_DURATIONS[type];\n    87→\n    88→  if (existing) {\n    89→    return activePowerUps.map(p =>\n    90→      p.type === type ? { ...p, endTime: tickCount + duration } : p\n    91→    );\n    92→  }\n    93→\n    94→  return [...activePowerUps, { type, endTime: tickCount + duration }];\n    95→};\n    96→\n    97→/** Calculate next game state after one tick */\n    98→export const tick = (state: GameState, direction: Direction): GameState => {\n    99→  if (state.gameOver || !state.gameStarted) {\n   100→    return state;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"11948bcd-54ed-444a-9790-3d3e1d93e921"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UaGk7ZmceBk6w5BrH55Ctx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Gu5vCzqcZrW4VZGC8qHA28","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/index.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3208,"cache_read_input_tokens":41647,"cache_creation":{"ephemeral_5m_input_tokens":3208,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"8710889a-ac2b-42d4-b578-765ab2b9c453"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Gu5vCzqcZrW4VZGC8qHA28","type":"tool_result","content":"     1→/**\n     2→ * Game module exports\n     3→ */\n     4→\n     5→export { useSnakeGame } from './useSnakeGame';\n     6→export type { GameState, Direction, Position } from './types';\n     7→export { GRID_SIZE, CELL_SIZE } from './constants';\n     8→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"159464fd-7e11-4d81-954c-5f3d2236c150"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019qLP3fHnGUyUPZMhPuDFtj","type":"tool_result","content":[{"type":"text","text":"Perfect! Now I have all the information needed. Let me create a comprehensive exploration report.\n\n## Codebase Exploration Report: Perfect Snake Game\n\n### 1. Main Game Files and Locations\n\n**Root Structure:**\n- **Game directory:** `/__w/perfect-snake-platform/perfect-snake-platform/game/`\n- **Source directory:** `/__w/perfect-snake-platform/perfect-snake-platform/game/src/`\n\n**Key file locations:**\n\n| File | Path | Purpose |\n|------|------|---------|\n| **Entry Point** | `/src/main.tsx` | React app initialization |\n| **App Component** | `/src/App.tsx` | Main UI component with game board and controls |\n| **Game Logic** | `/src/game/logic.ts` | Pure game logic (tick, collision, food generation) |\n| **Game State** | `/src/game/types.ts` | Type definitions for GameState, Direction, Position, PowerUp |\n| **Game Constants** | `/src/game/constants.ts` | GRID_SIZE=20, CELL_SIZE=20, GAME_SPEED_MS=150, initial state |\n| **Game Hook** | `/src/game/useSnakeGame.ts` | Main React hook orchestrating all game functionality |\n| **PostMessage API** | `/src/game/usePostMessage.ts` | iframe communication (START_GAME, RESET_GAME, DIRECTION_CHANGE) |\n| **Keyboard Input** | `/src/game/useKeyboard.ts` | Arrow keys, space bar handling |\n| **Touch Input** | `/src/game/useTouch.ts` | Swipe and mobile button controls |\n| **Direction Queue** | `/src/game/useDirectionQueue.ts` | Direction input buffering |\n\n---\n\n### 2. Phaser Game Structure\n\n**Phaser Scene: SnakeScene**\n- **File:** `/src/components/SnakeScene.ts`\n- **Size:** ~3,600+ lines (large, comprehensive scene)\n- **Initialization:** Called from GameBoard component\n\n**Phaser Architecture:**\n```\nSnakeScene (Phaser.Scene)\n├── create() - Initializes graphics and clean effects\n├── update() - Main game loop (called 60 FPS)\n│   ├── Updates effects (motes, ripples, trails, tears, blood)\n│   ├── Clears and redraws graphics\n│   └── Renders background, grid, food, snake, HUD\n└── Graphics object (Phaser.GameObjects.Graphics)\n    └── Handles all rendering via fillStyle, strokeStyle, fillCircle, etc.\n```\n\n**Key Properties:**\n- Uses Phaser's `Graphics` object for custom rendering (instead of sprites)\n- `frameCount` tracks animation frame for time-based effects\n- `update()` called every Phaser frame (~60 FPS)\n- Rendering is completely custom (no pre-made sprites)\n\n---\n\n### 3. Visual Effects and Rendering Code\n\n**Clean Effects System** (`/src/components/cleanEffects.ts` - 500+ lines)\n\nCore effect types and their rendering functions:\n\n| Effect | Type | Draw Function | Update Function |\n|--------|------|---------------|-----------------|\n| **Floating Motes** | Ambient particles | `drawMotes()` | `updateMotes()` |\n| **Ripples** | Circular waves | `drawRipples()` | `updateRipples()` |\n| **Glow Trail** | Snake path glow | `drawGlowTrail()` | `updateGlowTrail()` |\n| **Tears** | Blue drops | `drawTears()` | `updateTears()` |\n| **Blood Splatters** | Red drops | `drawBlood()` | `updateBlood()` |\n\n**Drawing Priority (Order in update() method):**\n1. **Background:** `drawCleanBackground()` - Dark gradient pulses\n2. **Grid:** `drawCleanGrid()` - Animated grid lines\n3. **Motes:** `drawMotes()` - Floating particles\n4. **Trail:** `drawGlowTrail()` - Following snake path\n5. **Ripples:** `drawRipples()` - Food pickup effect\n6. **Food:** `drawCleanFood()` - Pulsing orb with glow\n7. **Snake:** `drawCleanSnake()` - Head to tail with gradient\n8. **Effects:** `drawTears()`, `drawBlood()` - Special effects\n9. **Vignette:** `drawCleanVignette()` - Border darkening\n10. **HUD:** `drawCleanHUD()` - Score and length display\n\n**Color Palette (CLEAN_COLORS object):**\n```typescript\nconst CLEAN_COLORS = {\n  bgDark: 0x0a1628,      // Dark blue background\n  bgMid: 0x0f1d32,       // Mid-tone blue\n  bgLight: 0x14253e,     // Light blue\n  gridLine: 0x1a3050,    // Subtle grid\n  snakeHead: 0x4fd1c5,   // Cyan head\n  snakeBody: 0x38b2ac,   // Teal body\n  snakeGlow: 0x81e6d9,   // Bright glow\n  food: 0xe2e8f0,        // Light gray/white\n  foodGlow: 0xcbd5e1,    // Dim glow\n  blood: 0xdc2626,       // Red\n  tear: 0x60a5fa,        // Blue\n  text: 0xe2e8f0         // Light text\n};\n```\n\n---\n\n### 4. Food Rendering Location\n\n**Primary rendering:** `/src/components/cleanEffects.ts` lines 334-357\n\n```typescript\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  // Draws: Glow layers → Core → Highlight\n}\n```\n\n**Called from:** `/src/components/SnakeScene.ts` line 2432\n- Food position: `food.x * CELL_SIZE + CELL_SIZE/2`, `food.y * CELL_SIZE + CELL_SIZE/2`\n- Rendering: Concentric circles with gradient colors\n\n**Visual components:**\n- Outer glow (foodGlow, low alpha)\n- Middle glow (foodGlow, medium alpha)\n- Core circle (food color, high alpha)\n- Highlight dot (white, 60% alpha)\n\n---\n\n### 5. Snake Rendering Location\n\n**Primary rendering:** `/src/components/cleanEffects.ts` lines 359-414\n\n```typescript\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  // Renders from tail to head with:\n  // 1. Glow halo around each segment\n  // 2. Body color gradient (tail → head)\n  // 3. Head special styling (pulse + highlight)\n}\n```\n\n**Called from:** `/src/components/SnakeScene.ts` line 2434\n\n**Rendering approach:**\n- Each segment: `segment.x * CELL_SIZE + CELL_SIZE/2`, `segment.y * CELL_SIZE + CELL_SIZE/2`\n- Two-pass rendering:\n  - **Pass 1:** Glows (semi-transparent halos)\n  - **Pass 2:** Segments with interpolated color (tail→head), head pulse\n- Head (index 0) gets special treatment: pulse effect + bright glow + white highlight\n\n---\n\n### 6. Background Rendering Location\n\n**Primary rendering:** `/src/components/cleanEffects.ts` lines 257-271\n\n```typescript\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  // Draws dark gradient with pulsing mid-tone circles\n}\n```\n\n**Called from:** `/src/components/SnakeScene.ts` line 2420\n\n**Visual components:**\n- Dark blue base fill (bgDark)\n- Pulsing circular gradient (bgMid)\n- Pulsing inner circle (bgLight)\n- Subtle animation using `Math.sin(frameCount * 0.01)`\n\n---\n\n### 7. File Organization Summary\n\n**By responsibility:**\n\n```\n/src/components/\n├── SnakeScene.ts           # Phaser scene + main update loop\n├── GameBoard.tsx           # React wrapper + Canvas2D fallback\n├── cleanEffects.ts         # All visual effects + color palette\n├── GameBoard.css           # Styling\n└── GameBoard.test.tsx      # Tests\n\n/src/game/\n├── useSnakeGame.ts         # Main game hook (orchestrator)\n├── logic.ts                # Pure game logic (100% testable)\n├── types.ts                # Type definitions\n├── constants.ts            # Game constants\n├── usePostMessage.ts       # iframe API\n├── useKeyboard.ts          # Desktop input\n├── useTouch.ts             # Mobile input\n├── useDirectionQueue.ts    # Input buffering\n└── index.ts                # Exports\n\n/\n├── App.tsx                 # Main React component\n├── main.tsx                # Entry point\n└── vite-env.d.ts          # TypeScript declarations\n```\n\n---\n\n### 8. Key Technical Details for Christmas Theme\n\n**For Christmas visual enhancements, you'll need to modify:**\n\n1. **Color definitions:** `/src/components/cleanEffects.ts` (CLEAN_COLORS object)\n   - Change snake colors to red/white\n   - Change food to gold/red\n   - Update background to winter tones\n\n2. **Drawing functions:** `/src/components/cleanEffects.ts`\n   - `drawCleanFood()` - Transform food into ornament/gift shape\n   - `drawCleanSnake()` - Add festive colors\n   - `drawCleanBackground()` - Add snow/winter effects\n   - New function: `drawSnowParticles()`, `drawDecorations()`, etc.\n\n3. **State additions:** `/src/components/SnakeScene.ts`\n   - Add snowflake particles array\n   - Add decoration particles array\n   - Update in the `update()` method loop\n\n4. **Important:** All visual modifications go to **Phaser** code (SnakeScene.ts + cleanEffects.ts), NOT the Canvas2D fallback (GameBoard.tsx is noted as \"never runs\")\n\n---\n\n### 9. Current Theme Context\n\nThe game currently uses a **\"Clean Modern\"** aesthetic with:\n- Dark blue/teal color scheme\n- Cyan/teal glowing snake\n- Subtle grid\n- Minimalist design\n- Film noir influenced styling\n\n**Rendering runs at:** 60 FPS via Phaser's update() loop\n\n**Game tick rate:** 150ms (configurable via GAME_SPEED_MS constant)\n\n---\n\nThis structure gives you complete control over the visual appearance while preserving the game logic and PostMessage API requirements."},{"type":"text","text":"agentId: abe2567 (for resuming to continue this agent's work if needed)\n<usage>total_tokens: 47917\ntool_uses: 28\nduration_ms: 58448</usage>"}]}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"f8615fde-5761-48a8-97cb-ceb36fc55f11","tool_use_result":{"status":"completed","prompt":"Explore the codebase structure of this snake game. I need to understand:\n1. The main game files and their locations\n2. How the Phaser game is structured\n3. What visual effects/rendering code exists\n4. Where food, snake, and background rendering happens\n\nFocus on the src/ directory and identify the key files I'll need to modify for a Christmas-themed visual enhancement.","agentId":"abe2567","content":[{"type":"text","text":"Perfect! Now I have all the information needed. Let me create a comprehensive exploration report.\n\n## Codebase Exploration Report: Perfect Snake Game\n\n### 1. Main Game Files and Locations\n\n**Root Structure:**\n- **Game directory:** `/__w/perfect-snake-platform/perfect-snake-platform/game/`\n- **Source directory:** `/__w/perfect-snake-platform/perfect-snake-platform/game/src/`\n\n**Key file locations:**\n\n| File | Path | Purpose |\n|------|------|---------|\n| **Entry Point** | `/src/main.tsx` | React app initialization |\n| **App Component** | `/src/App.tsx` | Main UI component with game board and controls |\n| **Game Logic** | `/src/game/logic.ts` | Pure game logic (tick, collision, food generation) |\n| **Game State** | `/src/game/types.ts` | Type definitions for GameState, Direction, Position, PowerUp |\n| **Game Constants** | `/src/game/constants.ts` | GRID_SIZE=20, CELL_SIZE=20, GAME_SPEED_MS=150, initial state |\n| **Game Hook** | `/src/game/useSnakeGame.ts` | Main React hook orchestrating all game functionality |\n| **PostMessage API** | `/src/game/usePostMessage.ts` | iframe communication (START_GAME, RESET_GAME, DIRECTION_CHANGE) |\n| **Keyboard Input** | `/src/game/useKeyboard.ts` | Arrow keys, space bar handling |\n| **Touch Input** | `/src/game/useTouch.ts` | Swipe and mobile button controls |\n| **Direction Queue** | `/src/game/useDirectionQueue.ts` | Direction input buffering |\n\n---\n\n### 2. Phaser Game Structure\n\n**Phaser Scene: SnakeScene**\n- **File:** `/src/components/SnakeScene.ts`\n- **Size:** ~3,600+ lines (large, comprehensive scene)\n- **Initialization:** Called from GameBoard component\n\n**Phaser Architecture:**\n```\nSnakeScene (Phaser.Scene)\n├── create() - Initializes graphics and clean effects\n├── update() - Main game loop (called 60 FPS)\n│   ├── Updates effects (motes, ripples, trails, tears, blood)\n│   ├── Clears and redraws graphics\n│   └── Renders background, grid, food, snake, HUD\n└── Graphics object (Phaser.GameObjects.Graphics)\n    └── Handles all rendering via fillStyle, strokeStyle, fillCircle, etc.\n```\n\n**Key Properties:**\n- Uses Phaser's `Graphics` object for custom rendering (instead of sprites)\n- `frameCount` tracks animation frame for time-based effects\n- `update()` called every Phaser frame (~60 FPS)\n- Rendering is completely custom (no pre-made sprites)\n\n---\n\n### 3. Visual Effects and Rendering Code\n\n**Clean Effects System** (`/src/components/cleanEffects.ts` - 500+ lines)\n\nCore effect types and their rendering functions:\n\n| Effect | Type | Draw Function | Update Function |\n|--------|------|---------------|-----------------|\n| **Floating Motes** | Ambient particles | `drawMotes()` | `updateMotes()` |\n| **Ripples** | Circular waves | `drawRipples()` | `updateRipples()` |\n| **Glow Trail** | Snake path glow | `drawGlowTrail()` | `updateGlowTrail()` |\n| **Tears** | Blue drops | `drawTears()` | `updateTears()` |\n| **Blood Splatters** | Red drops | `drawBlood()` | `updateBlood()` |\n\n**Drawing Priority (Order in update() method):**\n1. **Background:** `drawCleanBackground()` - Dark gradient pulses\n2. **Grid:** `drawCleanGrid()` - Animated grid lines\n3. **Motes:** `drawMotes()` - Floating particles\n4. **Trail:** `drawGlowTrail()` - Following snake path\n5. **Ripples:** `drawRipples()` - Food pickup effect\n6. **Food:** `drawCleanFood()` - Pulsing orb with glow\n7. **Snake:** `drawCleanSnake()` - Head to tail with gradient\n8. **Effects:** `drawTears()`, `drawBlood()` - Special effects\n9. **Vignette:** `drawCleanVignette()` - Border darkening\n10. **HUD:** `drawCleanHUD()` - Score and length display\n\n**Color Palette (CLEAN_COLORS object):**\n```typescript\nconst CLEAN_COLORS = {\n  bgDark: 0x0a1628,      // Dark blue background\n  bgMid: 0x0f1d32,       // Mid-tone blue\n  bgLight: 0x14253e,     // Light blue\n  gridLine: 0x1a3050,    // Subtle grid\n  snakeHead: 0x4fd1c5,   // Cyan head\n  snakeBody: 0x38b2ac,   // Teal body\n  snakeGlow: 0x81e6d9,   // Bright glow\n  food: 0xe2e8f0,        // Light gray/white\n  foodGlow: 0xcbd5e1,    // Dim glow\n  blood: 0xdc2626,       // Red\n  tear: 0x60a5fa,        // Blue\n  text: 0xe2e8f0         // Light text\n};\n```\n\n---\n\n### 4. Food Rendering Location\n\n**Primary rendering:** `/src/components/cleanEffects.ts` lines 334-357\n\n```typescript\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  // Draws: Glow layers → Core → Highlight\n}\n```\n\n**Called from:** `/src/components/SnakeScene.ts` line 2432\n- Food position: `food.x * CELL_SIZE + CELL_SIZE/2`, `food.y * CELL_SIZE + CELL_SIZE/2`\n- Rendering: Concentric circles with gradient colors\n\n**Visual components:**\n- Outer glow (foodGlow, low alpha)\n- Middle glow (foodGlow, medium alpha)\n- Core circle (food color, high alpha)\n- Highlight dot (white, 60% alpha)\n\n---\n\n### 5. Snake Rendering Location\n\n**Primary rendering:** `/src/components/cleanEffects.ts` lines 359-414\n\n```typescript\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  // Renders from tail to head with:\n  // 1. Glow halo around each segment\n  // 2. Body color gradient (tail → head)\n  // 3. Head special styling (pulse + highlight)\n}\n```\n\n**Called from:** `/src/components/SnakeScene.ts` line 2434\n\n**Rendering approach:**\n- Each segment: `segment.x * CELL_SIZE + CELL_SIZE/2`, `segment.y * CELL_SIZE + CELL_SIZE/2`\n- Two-pass rendering:\n  - **Pass 1:** Glows (semi-transparent halos)\n  - **Pass 2:** Segments with interpolated color (tail→head), head pulse\n- Head (index 0) gets special treatment: pulse effect + bright glow + white highlight\n\n---\n\n### 6. Background Rendering Location\n\n**Primary rendering:** `/src/components/cleanEffects.ts` lines 257-271\n\n```typescript\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  // Draws dark gradient with pulsing mid-tone circles\n}\n```\n\n**Called from:** `/src/components/SnakeScene.ts` line 2420\n\n**Visual components:**\n- Dark blue base fill (bgDark)\n- Pulsing circular gradient (bgMid)\n- Pulsing inner circle (bgLight)\n- Subtle animation using `Math.sin(frameCount * 0.01)`\n\n---\n\n### 7. File Organization Summary\n\n**By responsibility:**\n\n```\n/src/components/\n├── SnakeScene.ts           # Phaser scene + main update loop\n├── GameBoard.tsx           # React wrapper + Canvas2D fallback\n├── cleanEffects.ts         # All visual effects + color palette\n├── GameBoard.css           # Styling\n└── GameBoard.test.tsx      # Tests\n\n/src/game/\n├── useSnakeGame.ts         # Main game hook (orchestrator)\n├── logic.ts                # Pure game logic (100% testable)\n├── types.ts                # Type definitions\n├── constants.ts            # Game constants\n├── usePostMessage.ts       # iframe API\n├── useKeyboard.ts          # Desktop input\n├── useTouch.ts             # Mobile input\n├── useDirectionQueue.ts    # Input buffering\n└── index.ts                # Exports\n\n/\n├── App.tsx                 # Main React component\n├── main.tsx                # Entry point\n└── vite-env.d.ts          # TypeScript declarations\n```\n\n---\n\n### 8. Key Technical Details for Christmas Theme\n\n**For Christmas visual enhancements, you'll need to modify:**\n\n1. **Color definitions:** `/src/components/cleanEffects.ts` (CLEAN_COLORS object)\n   - Change snake colors to red/white\n   - Change food to gold/red\n   - Update background to winter tones\n\n2. **Drawing functions:** `/src/components/cleanEffects.ts`\n   - `drawCleanFood()` - Transform food into ornament/gift shape\n   - `drawCleanSnake()` - Add festive colors\n   - `drawCleanBackground()` - Add snow/winter effects\n   - New function: `drawSnowParticles()`, `drawDecorations()`, etc.\n\n3. **State additions:** `/src/components/SnakeScene.ts`\n   - Add snowflake particles array\n   - Add decoration particles array\n   - Update in the `update()` method loop\n\n4. **Important:** All visual modifications go to **Phaser** code (SnakeScene.ts + cleanEffects.ts), NOT the Canvas2D fallback (GameBoard.tsx is noted as \"never runs\")\n\n---\n\n### 9. Current Theme Context\n\nThe game currently uses a **\"Clean Modern\"** aesthetic with:\n- Dark blue/teal color scheme\n- Cyan/teal glowing snake\n- Subtle grid\n- Minimalist design\n- Film noir influenced styling\n\n**Rendering runs at:** 60 FPS via Phaser's update() loop\n\n**Game tick rate:** 150ms (configurable via GAME_SPEED_MS constant)\n\n---\n\nThis structure gives you complete control over the visual appearance while preserving the game logic and PostMessage API requirements."}],"totalDurationMs":58448,"totalTokens":47917,"totalToolUseCount":28,"usage":{"input_tokens":0,"cache_creation_input_tokens":313,"cache_read_input_tokens":44855,"output_tokens":2749,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":313},"inference_geo":"","iterations":[],"speed":"standard"}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JiB8AqbgzeXSAvEvqFPnsB","type":"message","role":"assistant","content":[{"type":"text","text":"Now I understand the codebase structure. Let me read the key files I'll need to modify for a Christmas theme."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3025,"cache_read_input_tokens":20250,"cache_creation":{"ephemeral_5m_input_tokens":3025,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"bab87da1-0db9-47c8-b786-77a5f2473b8b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JiB8AqbgzeXSAvEvqFPnsB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K3jq8Zpg6seKZbwS3x8cfJ","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3025,"cache_read_input_tokens":20250,"cache_creation":{"ephemeral_5m_input_tokens":3025,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"c14aed62-b434-4621-9fe6-de578cb11150"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K3jq8Zpg6seKZbwS3x8cfJ","type":"tool_result","content":"     1→export interface CleanRipple {\n     2→  x: number;\n     3→  y: number;\n     4→  radius: number;\n     5→  maxRadius: number;\n     6→  alpha: number;\n     7→  thickness: number;\n     8→}\n     9→\n    10→export interface FloatingMote {\n    11→  x: number;\n    12→  y: number;\n    13→  vx: number;\n    14→  vy: number;\n    15→  size: number;\n    16→  alpha: number;\n    17→  pulsePhase: number;\n    18→}\n    19→\n    20→export interface SnakeGlowTrail {\n    21→  x: number;\n    22→  y: number;\n    23→  alpha: number;\n    24→  size: number;\n    25→}\n    26→\n    27→export interface TearDrop {\n    28→  x: number;\n    29→  y: number;\n    30→  vy: number;\n    31→  size: number;\n    32→  alpha: number;\n    33→  wobblePhase: number;\n    34→}\n    35→\n    36→export interface BloodSplatter {\n    37→  x: number;\n    38→  y: number;\n    39→  vx: number;\n    40→  vy: number;\n    41→  size: number;\n    42→  alpha: number;\n    43→  life: number;\n    44→  splashed: boolean;\n    45→  splashRadius: number;\n    46→}\n    47→\n    48→export const CLEAN_COLORS = {\n    49→  bgDark: 0x0a1628,\n    50→  bgMid: 0x0f1d32,\n    51→  bgLight: 0x14253e,\n    52→\n    53→  gridLine: 0x1a3050,\n    54→  gridAccent: 0x254060,\n    55→\n    56→  snakeHead: 0x4fd1c5,\n    57→  snakeBody: 0x38b2ac,\n    58→  snakeTail: 0x2c9a94,\n    59→  snakeGlow: 0x81e6d9,\n    60→\n    61→  food: 0xe2e8f0,\n    62→  foodCore: 0xffffff,\n    63→  foodGlow: 0xcbd5e1,\n    64→\n    65→  ripple: 0x81e6d9,\n    66→  mote: 0x4fd1c5,\n    67→\n    68→  text: 0xe2e8f0,\n    69→  textDim: 0x94a3b8,\n    70→\n    71→  blood: 0xdc2626,\n    72→  bloodDark: 0x991b1b,\n    73→  tear: 0x60a5fa,\n    74→  tearHighlight: 0x93c5fd,\n    75→};\n    76→\n    77→const MAX_RIPPLES = 5;\n    78→const MAX_MOTES = 20;\n    79→const MAX_TRAIL_LENGTH = 15;\n    80→const MAX_TEARS = 12;\n    81→const MAX_BLOOD = 20;\n    82→\n    83→export function createCleanEffectsState() {\n    84→  return {\n    85→    ripples: [] as CleanRipple[],\n    86→    motes: [] as FloatingMote[],\n    87→    glowTrail: [] as SnakeGlowTrail[],\n    88→    tears: [] as TearDrop[],\n    89→    blood: [] as BloodSplatter[],\n    90→    frameCount: 0,\n    91→  };\n    92→}\n    93→\n    94→export type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n    95→\n    96→export function initMotes(state: CleanEffectsState, width: number, height: number): void {\n    97→  state.motes = [];\n    98→  for (let i = 0; i < MAX_MOTES; i++) {\n    99→    state.motes.push({\n   100→      x: Math.random() * width,\n   101→      y: Math.random() * height,\n   102→      vx: (Math.random() - 0.5) * 0.3,\n   103→      vy: (Math.random() - 0.5) * 0.3,\n   104→      size: 1 + Math.random() * 2,\n   105→      alpha: 0.1 + Math.random() * 0.2,\n   106→      pulsePhase: Math.random() * Math.PI * 2,\n   107→    });\n   108→  }\n   109→}\n   110→\n   111→export function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n   112→  for (const mote of state.motes) {\n   113→    mote.x += mote.vx;\n   114→    mote.y += mote.vy;\n   115→    mote.pulsePhase += 0.02;\n   116→\n   117→    if (mote.x < 0) mote.x = width;\n   118→    if (mote.x > width) mote.x = 0;\n   119→    if (mote.y < 0) mote.y = height;\n   120→    if (mote.y > height) mote.y = 0;\n   121→  }\n   122→}\n   123→\n   124→export function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n   125→  if (state.ripples.length >= MAX_RIPPLES) {\n   126→    state.ripples.shift();\n   127→  }\n   128→\n   129→  state.ripples.push({\n   130→    x,\n   131→    y,\n   132→    radius: 5,\n   133→    maxRadius: 60,\n   134→    alpha: 0.6,\n   135→    thickness: 2,\n   136→  });\n   137→}\n   138→\n   139→export function updateRipples(state: CleanEffectsState): void {\n   140→  for (let i = state.ripples.length - 1; i >= 0; i--) {\n   141→    const ripple = state.ripples[i];\n   142→    ripple.radius += 2;\n   143→    ripple.alpha *= 0.94;\n   144→    ripple.thickness *= 0.98;\n   145→\n   146→    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n   147→      state.ripples.splice(i, 1);\n   148→    }\n   149→  }\n   150→}\n   151→\n   152→export function updateGlowTrail(\n   153→  state: CleanEffectsState,\n   154→  headX: number,\n   155→  headY: number\n   156→): void {\n   157→  state.glowTrail.unshift({\n   158→    x: headX,\n   159→    y: headY,\n   160→    alpha: 0.5,\n   161→    size: 12,\n   162→  });\n   163→\n   164→  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n   165→    state.glowTrail.pop();\n   166→  }\n   167→\n   168→  for (let i = 0; i < state.glowTrail.length; i++) {\n   169→    const t = state.glowTrail[i];\n   170→    t.alpha *= 0.85;\n   171→    t.size *= 0.95;\n   172→  }\n   173→\n   174→  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n   175→}\n   176→\n   177→export function spawnTears(state: CleanEffectsState, x: number, y: number, count: number): void {\n   178→  for (let i = 0; i < count; i++) {\n   179→    if (state.tears.length >= MAX_TEARS) {\n   180→      state.tears.shift();\n   181→    }\n   182→    state.tears.push({\n   183→      x: x + (Math.random() - 0.5) * 20,\n   184→      y: y + (Math.random() - 0.5) * 10,\n   185→      vy: 0.5 + Math.random() * 1.5,\n   186→      size: 3 + Math.random() * 3,\n   187→      alpha: 0.7 + Math.random() * 0.3,\n   188→      wobblePhase: Math.random() * Math.PI * 2,\n   189→    });\n   190→  }\n   191→}\n   192→\n   193→export function updateTears(state: CleanEffectsState, height: number): void {\n   194→  for (let i = state.tears.length - 1; i >= 0; i--) {\n   195→    const tear = state.tears[i];\n   196→    tear.vy += 0.08;\n   197→    tear.y += tear.vy;\n   198→    tear.wobblePhase += 0.1;\n   199→    tear.x += Math.sin(tear.wobblePhase) * 0.3;\n   200→    tear.alpha *= 0.99;\n   201→\n   202→    if (tear.y > height + 10 || tear.alpha < 0.05) {\n   203→      state.tears.splice(i, 1);\n   204→    }\n   205→  }\n   206→}\n   207→\n   208→export function spawnBlood(state: CleanEffectsState, x: number, y: number, count: number): void {\n   209→  for (let i = 0; i < count; i++) {\n   210→    if (state.blood.length >= MAX_BLOOD) {\n   211→      state.blood.shift();\n   212→    }\n   213→    const angle = Math.random() * Math.PI * 2;\n   214→    const speed = 1 + Math.random() * 3;\n   215→    state.blood.push({\n   216→      x,\n   217→      y,\n   218→      vx: Math.cos(angle) * speed,\n   219→      vy: Math.sin(angle) * speed - 1,\n   220→      size: 2 + Math.random() * 4,\n   221→      alpha: 0.8 + Math.random() * 0.2,\n   222→      life: 1.0,\n   223→      splashed: false,\n   224→      splashRadius: 0,\n   225→    });\n   226→  }\n   227→}\n   228→\n   229→export function updateBlood(state: CleanEffectsState, height: number): void {\n   230→  for (let i = state.blood.length - 1; i >= 0; i--) {\n   231→    const drop = state.blood[i];\n   232→\n   233→    if (!drop.splashed) {\n   234→      drop.vy += 0.15;\n   235→      drop.x += drop.vx;\n   236→      drop.y += drop.vy;\n   237→      drop.vx *= 0.98;\n   238→\n   239→      if (drop.y >= height - 5) {\n   240→        drop.splashed = true;\n   241→        drop.y = height - 5;\n   242→        drop.splashRadius = drop.size * 1.5;\n   243→      }\n   244→    } else {\n   245→      drop.splashRadius += 0.3;\n   246→      drop.alpha *= 0.95;\n   247→    }\n   248→\n   249→    drop.life -= 0.015;\n   250→\n   251→    if (drop.life <= 0 || drop.alpha < 0.02) {\n   252→      state.blood.splice(i, 1);\n   253→    }\n   254→  }\n   255→}\n   256→\n   257→export function drawCleanBackground(\n   258→  g: Phaser.GameObjects.Graphics,\n   259→  width: number,\n   260→  height: number,\n   261→  frameCount: number\n   262→): void {\n   263→  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n   264→  g.fillRect(0, 0, width, height);\n   265→\n   266→  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n   267→  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n   268→  g.fillCircle(width / 2, height / 2, width * 0.6);\n   269→  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n   270→  g.fillCircle(width / 2, height / 2, width * 0.3);\n   271→}\n   272→\n   273→export function drawCleanGrid(\n   274→  g: Phaser.GameObjects.Graphics,\n   275→  width: number,\n   276→  height: number,\n   277→  cellSize: number,\n   278→  gridSize: number,\n   279→  frameCount: number\n   280→): void {\n   281→  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n   282→  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n   283→\n   284→  for (let i = 0; i <= gridSize; i++) {\n   285→    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n   286→    g.lineBetween(0, i * cellSize, width, i * cellSize);\n   287→  }\n   288→\n   289→  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n   290→  for (let i = 0; i <= gridSize; i += 5) {\n   291→    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n   292→    g.lineBetween(0, i * cellSize, width, i * cellSize);\n   293→  }\n   294→}\n   295→\n   296→export function drawMotes(\n   297→  g: Phaser.GameObjects.Graphics,\n   298→  state: CleanEffectsState\n   299→): void {\n   300→  for (const mote of state.motes) {\n   301→    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n   302→    const alpha = mote.alpha * pulse;\n   303→\n   304→    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n   305→    g.fillCircle(mote.x, mote.y, mote.size * 2);\n   306→    g.fillStyle(CLEAN_COLORS.mote, alpha);\n   307→    g.fillCircle(mote.x, mote.y, mote.size);\n   308→  }\n   309→}\n   310→\n   311→export function drawRipples(\n   312→  g: Phaser.GameObjects.Graphics,\n   313→  state: CleanEffectsState\n   314→): void {\n   315→  for (const ripple of state.ripples) {\n   316→    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n   317→    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n   318→\n   319→    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n   320→    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n   321→  }\n   322→}\n   323→\n   324→export function drawGlowTrail(\n   325→  g: Phaser.GameObjects.Graphics,\n   326→  state: CleanEffectsState\n   327→): void {\n   328→  for (const trail of state.glowTrail) {\n   329→    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n   330→    g.fillCircle(trail.x, trail.y, trail.size);\n   331→  }\n   332→}\n   333→\n   334→export function drawCleanFood(\n   335→  g: Phaser.GameObjects.Graphics,\n   336→  foodX: number,\n   337→  foodY: number,\n   338→  cellSize: number,\n   339→  frameCount: number\n   340→): void {\n   341→  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n   342→  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n   343→  const foodSize = (cellSize / 2 - 2) * pulseScale;\n   344→\n   345→  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n   346→  g.fillCircle(foodX, foodY, foodSize + 12);\n   347→  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n   348→  g.fillCircle(foodX, foodY, foodSize + 6);\n   349→\n   350→  g.fillStyle(CLEAN_COLORS.food, 0.9);\n   351→  g.fillCircle(foodX, foodY, foodSize);\n   352→  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n   353→  g.fillCircle(foodX, foodY, foodSize * 0.5);\n   354→\n   355→  g.fillStyle(0xffffff, 0.6);\n   356→  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n   357→}\n   358→\n   359→export function drawCleanSnake(\n   360→  g: Phaser.GameObjects.Graphics,\n   361→  snake: { x: number; y: number }[],\n   362→  cellSize: number,\n   363→  frameCount: number\n   364→): void {\n   365→  const snakeLen = snake.length;\n   366→  if (snakeLen === 0) return;\n   367→\n   368→  for (let i = snakeLen - 1; i >= 0; i--) {\n   369→    const segment = snake[i];\n   370→    const centerX = segment.x * cellSize + cellSize / 2;\n   371→    const centerY = segment.y * cellSize + cellSize / 2;\n   372→    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n   373→\n   374→    const glowAlpha = 0.15 * (1 - t * 0.5);\n   375→    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n   376→    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n   377→    g.fillCircle(centerX, centerY, glowSize);\n   378→  }\n   379→\n   380→  for (let i = snakeLen - 1; i >= 0; i--) {\n   381→    const segment = snake[i];\n   382→    const centerX = segment.x * cellSize + cellSize / 2;\n   383→    const centerY = segment.y * cellSize + cellSize / 2;\n   384→    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n   385→    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n   386→\n   387→    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n   388→    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n   389→    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n   390→    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n   391→    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n   392→    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n   393→\n   394→    const r = Math.round(r1 + (r2 - r1) * t);\n   395→    const gVal = Math.round(g1 + (g2 - g1) * t);\n   396→    const b = Math.round(b1 + (b2 - b1) * t);\n   397→    const color = (r << 16) | (gVal << 8) | b;\n   398→\n   399→    g.fillStyle(color, 0.95);\n   400→    g.fillCircle(centerX, centerY, radius);\n   401→\n   402→    if (i === 0) {\n   403→      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n   404→      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n   405→      g.fillCircle(centerX, centerY, radius + 4);\n   406→\n   407→      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n   408→      g.fillCircle(centerX, centerY, radius);\n   409→\n   410→      g.fillStyle(0xffffff, 0.7);\n   411→      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n   412→    }\n   413→  }\n   414→}\n   415→\n   416→export function drawCleanVignette(\n   417→  g: Phaser.GameObjects.Graphics,\n   418→  width: number,\n   419→  height: number\n   420→): void {\n   421→  const layers = 4;\n   422→  for (let i = 0; i < layers; i++) {\n   423→    const inset = i * 25;\n   424→    const alpha = 0.08 * (1 - i / layers);\n   425→    g.lineStyle(50, 0x000000, alpha);\n   426→    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n   427→  }\n   428→}\n   429→\n   430→export function drawTears(\n   431→  g: Phaser.GameObjects.Graphics,\n   432→  state: CleanEffectsState\n   433→): void {\n   434→  for (const tear of state.tears) {\n   435→    g.fillStyle(CLEAN_COLORS.tear, tear.alpha * 0.3);\n   436→    g.fillCircle(tear.x, tear.y, tear.size * 2);\n   437→\n   438→    g.fillStyle(CLEAN_COLORS.tear, tear.alpha);\n   439→    g.fillCircle(tear.x, tear.y - tear.size * 0.3, tear.size);\n   440→    g.fillCircle(tear.x, tear.y + tear.size * 0.5, tear.size * 0.7);\n   441→\n   442→    g.fillStyle(CLEAN_COLORS.tearHighlight, tear.alpha * 0.6);\n   443→    g.fillCircle(tear.x - tear.size * 0.25, tear.y - tear.size * 0.4, tear.size * 0.3);\n   444→  }\n   445→}\n   446→\n   447→export function drawBlood(\n   448→  g: Phaser.GameObjects.Graphics,\n   449→  state: CleanEffectsState\n   450→): void {\n   451→  for (const drop of state.blood) {\n   452→    const effectiveAlpha = drop.alpha * drop.life;\n   453→\n   454→    if (drop.splashed) {\n   455→      g.fillStyle(CLEAN_COLORS.bloodDark, effectiveAlpha * 0.5);\n   456→      g.fillCircle(drop.x, drop.y, drop.splashRadius);\n   457→      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.7);\n   458→      g.fillCircle(drop.x, drop.y, drop.splashRadius * 0.6);\n   459→    } else {\n   460→      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.4);\n   461→      g.fillCircle(drop.x, drop.y, drop.size * 2);\n   462→      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha);\n   463→      g.fillCircle(drop.x, drop.y, drop.size);\n   464→      g.fillStyle(0xffffff, effectiveAlpha * 0.3);\n   465→      g.fillCircle(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.25);\n   466→    }\n   467→  }\n   468→}\n   469→\n   470→export function drawCleanHUD(\n   471→  g: Phaser.GameObjects.Graphics,\n   472→  score: number,\n   473→  snakeLength: number,\n   474→  width: number,\n   475→  frameCount: number,\n   476→  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n   477→): void {\n   478→  const padding = 15;\n   479→  const digitSize = 12;\n   480→  const digitSpacing = digitSize * 0.6;\n   481→\n   482→  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n   483→\n   484→  const scoreStr = String(score).padStart(4, '0');\n   485→  let xPos = padding;\n   486→\n   487→  for (let i = 0; i < scoreStr.length; i++) {\n   488→    const digit = scoreStr[i];\n   489→    g.fillStyle(CLEAN_COLORS.text, pulse);\n   490→    drawDigit(g, digit, xPos, padding, digitSize);\n   491→    xPos += digitSpacing;\n   492→  }\n   493→\n   494→  const lengthStr = String(snakeLength);\n   495→  xPos = width - padding - lengthStr.length * digitSpacing;\n   496→\n   497→  for (let i = 0; i < lengthStr.length; i++) {\n   498→    const digit = lengthStr[i];\n   499→    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n   500→    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n   501→    xPos += digitSpacing * 0.9;\n   502→  }\n   503→}\n   504→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"eff3bb2e-d19b-436d-9989-073b70a59b6a","tool_use_result":{"type":"text","file":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","content":"export interface CleanRipple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport interface FloatingMote {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  pulsePhase: number;\n}\n\nexport interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport interface TearDrop {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n}\n\nexport interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}\n\nexport const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n};\n\nconst MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;\n\nexport function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    frameCount: 0,\n  };\n}\n\nexport type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n\nexport function initMotes(state: CleanEffectsState, width: number, height: number): void {\n  state.motes = [];\n  for (let i = 0; i < MAX_MOTES; i++) {\n    state.motes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: (Math.random() - 0.5) * 0.3,\n      vy: (Math.random() - 0.5) * 0.3,\n      size: 1 + Math.random() * 2,\n      alpha: 0.1 + Math.random() * 0.2,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n  for (const mote of state.motes) {\n    mote.x += mote.vx;\n    mote.y += mote.vy;\n    mote.pulsePhase += 0.02;\n\n    if (mote.x < 0) mote.x = width;\n    if (mote.x > width) mote.x = 0;\n    if (mote.y < 0) mote.y = height;\n    if (mote.y > height) mote.y = 0;\n  }\n}\n\nexport function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n  if (state.ripples.length >= MAX_RIPPLES) {\n    state.ripples.shift();\n  }\n\n  state.ripples.push({\n    x,\n    y,\n    radius: 5,\n    maxRadius: 60,\n    alpha: 0.6,\n    thickness: 2,\n  });\n}\n\nexport function updateRipples(state: CleanEffectsState): void {\n  for (let i = state.ripples.length - 1; i >= 0; i--) {\n    const ripple = state.ripples[i];\n    ripple.radius += 2;\n    ripple.alpha *= 0.94;\n    ripple.thickness *= 0.98;\n\n    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n      state.ripples.splice(i, 1);\n    }\n  }\n}\n\nexport function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function spawnTears(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.tears.length >= MAX_TEARS) {\n      state.tears.shift();\n    }\n    state.tears.push({\n      x: x + (Math.random() - 0.5) * 20,\n      y: y + (Math.random() - 0.5) * 10,\n      vy: 0.5 + Math.random() * 1.5,\n      size: 3 + Math.random() * 3,\n      alpha: 0.7 + Math.random() * 0.3,\n      wobblePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateTears(state: CleanEffectsState, height: number): void {\n  for (let i = state.tears.length - 1; i >= 0; i--) {\n    const tear = state.tears[i];\n    tear.vy += 0.08;\n    tear.y += tear.vy;\n    tear.wobblePhase += 0.1;\n    tear.x += Math.sin(tear.wobblePhase) * 0.3;\n    tear.alpha *= 0.99;\n\n    if (tear.y > height + 10 || tear.alpha < 0.05) {\n      state.tears.splice(i, 1);\n    }\n  }\n}\n\nexport function spawnBlood(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.blood.length >= MAX_BLOOD) {\n      state.blood.shift();\n    }\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 1 + Math.random() * 3;\n    state.blood.push({\n      x,\n      y,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 1,\n      size: 2 + Math.random() * 4,\n      alpha: 0.8 + Math.random() * 0.2,\n      life: 1.0,\n      splashed: false,\n      splashRadius: 0,\n    });\n  }\n}\n\nexport function updateBlood(state: CleanEffectsState, height: number): void {\n  for (let i = state.blood.length - 1; i >= 0; i--) {\n    const drop = state.blood[i];\n\n    if (!drop.splashed) {\n      drop.vy += 0.15;\n      drop.x += drop.vx;\n      drop.y += drop.vy;\n      drop.vx *= 0.98;\n\n      if (drop.y >= height - 5) {\n        drop.splashed = true;\n        drop.y = height - 5;\n        drop.splashRadius = drop.size * 1.5;\n      }\n    } else {\n      drop.splashRadius += 0.3;\n      drop.alpha *= 0.95;\n    }\n\n    drop.life -= 0.015;\n\n    if (drop.life <= 0 || drop.alpha < 0.02) {\n      state.blood.splice(i, 1);\n    }\n  }\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}\n\nexport function drawCleanGrid(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  cellSize: number,\n  gridSize: number,\n  frameCount: number\n): void {\n  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n\n  for (let i = 0; i <= gridSize; i++) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n\n  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n  for (let i = 0; i <= gridSize; i += 5) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n}\n\nexport function drawMotes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const mote of state.motes) {\n    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n    const alpha = mote.alpha * pulse;\n\n    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n    g.fillCircle(mote.x, mote.y, mote.size * 2);\n    g.fillStyle(CLEAN_COLORS.mote, alpha);\n    g.fillCircle(mote.x, mote.y, mote.size);\n  }\n}\n\nexport function drawRipples(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const ripple of state.ripples) {\n    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n\n    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n  }\n}\n\nexport function drawGlowTrail(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const trail of state.glowTrail) {\n    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n    g.fillCircle(trail.x, trail.y, trail.size);\n  }\n}\n\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n  const foodSize = (cellSize / 2 - 2) * pulseScale;\n\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n  g.fillCircle(foodX, foodY, foodSize + 12);\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n  g.fillCircle(foodX, foodY, foodSize + 6);\n\n  g.fillStyle(CLEAN_COLORS.food, 0.9);\n  g.fillCircle(foodX, foodY, foodSize);\n  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n  g.fillCircle(foodX, foodY, foodSize * 0.5);\n\n  g.fillStyle(0xffffff, 0.6);\n  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n}\n\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  const snakeLen = snake.length;\n  if (snakeLen === 0) return;\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n\n    const glowAlpha = 0.15 * (1 - t * 0.5);\n    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n    g.fillCircle(centerX, centerY, glowSize);\n  }\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n\n    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n\n    const r = Math.round(r1 + (r2 - r1) * t);\n    const gVal = Math.round(g1 + (g2 - g1) * t);\n    const b = Math.round(b1 + (b2 - b1) * t);\n    const color = (r << 16) | (gVal << 8) | b;\n\n    g.fillStyle(color, 0.95);\n    g.fillCircle(centerX, centerY, radius);\n\n    if (i === 0) {\n      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n      g.fillCircle(centerX, centerY, radius + 4);\n\n      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n      g.fillCircle(centerX, centerY, radius);\n\n      g.fillStyle(0xffffff, 0.7);\n      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n    }\n  }\n}\n\nexport function drawCleanVignette(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number\n): void {\n  const layers = 4;\n  for (let i = 0; i < layers; i++) {\n    const inset = i * 25;\n    const alpha = 0.08 * (1 - i / layers);\n    g.lineStyle(50, 0x000000, alpha);\n    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n  }\n}\n\nexport function drawTears(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const tear of state.tears) {\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha * 0.3);\n    g.fillCircle(tear.x, tear.y, tear.size * 2);\n\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha);\n    g.fillCircle(tear.x, tear.y - tear.size * 0.3, tear.size);\n    g.fillCircle(tear.x, tear.y + tear.size * 0.5, tear.size * 0.7);\n\n    g.fillStyle(CLEAN_COLORS.tearHighlight, tear.alpha * 0.6);\n    g.fillCircle(tear.x - tear.size * 0.25, tear.y - tear.size * 0.4, tear.size * 0.3);\n  }\n}\n\nexport function drawBlood(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const drop of state.blood) {\n    const effectiveAlpha = drop.alpha * drop.life;\n\n    if (drop.splashed) {\n      g.fillStyle(CLEAN_COLORS.bloodDark, effectiveAlpha * 0.5);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.7);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius * 0.6);\n    } else {\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.4);\n      g.fillCircle(drop.x, drop.y, drop.size * 2);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha);\n      g.fillCircle(drop.x, drop.y, drop.size);\n      g.fillStyle(0xffffff, effectiveAlpha * 0.3);\n      g.fillCircle(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.25);\n    }\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {\n  const padding = 15;\n  const digitSize = 12;\n  const digitSpacing = digitSize * 0.6;\n\n  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n\n  const scoreStr = String(score).padStart(4, '0');\n  let xPos = padding;\n\n  for (let i = 0; i < scoreStr.length; i++) {\n    const digit = scoreStr[i];\n    g.fillStyle(CLEAN_COLORS.text, pulse);\n    drawDigit(g, digit, xPos, padding, digitSize);\n    xPos += digitSpacing;\n  }\n\n  const lengthStr = String(snakeLength);\n  xPos = width - padding - lengthStr.length * digitSpacing;\n\n  for (let i = 0; i < lengthStr.length; i++) {\n    const digit = lengthStr[i];\n    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n    xPos += digitSpacing * 0.9;\n  }\n}\n","numLines":504,"startLine":1,"totalLines":504}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JiB8AqbgzeXSAvEvqFPnsB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XYXD2Zh9iToZYkRWQJzUtJ","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3025,"cache_read_input_tokens":20250,"cache_creation":{"ephemeral_5m_input_tokens":3025,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"da4fb1da-06f3-4c18-b05f-95af9e8aa7d1"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (53598 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01XYXD2Zh9iToZYkRWQJzUtJ"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"3b619038-7ec1-49c7-864f-64fa2e3f6e3c","tool_use_result":"Error: File content (53598 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UPLxWFdjnV28W2xgE36ymZ","type":"message","role":"assistant","content":[{"type":"text","text":"The SnakeScene.ts file is too large. Let me read specific sections of it."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":7654,"cache_read_input_tokens":23275,"cache_creation":{"ephemeral_5m_input_tokens":7654,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"914e3295-946b-4fd8-a548-973cb6a6d529"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UPLxWFdjnV28W2xgE36ymZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WQ4RLgTEoUSf1WhW198va2","name":"Grep","input":{"pattern":"drawMotes|drawRipples|drawGlowTrail|drawCleanFood|drawCleanSnake|drawCleanBackground","path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","output_mode":"content","-n":true},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":7654,"cache_read_input_tokens":23275,"cache_creation":{"ephemeral_5m_input_tokens":7654,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"6e5b6c70-7ad8-4431-8c07-9a378b0373ae"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WQ4RLgTEoUSf1WhW198va2","type":"tool_result","content":"13:  drawCleanBackground,\n15:  drawMotes,\n16:  drawRipples,\n17:  drawGlowTrail,\n18:  drawCleanFood,\n19:  drawCleanSnake,\n2420:    drawCleanBackground(g, width, height, this.frameCount);\n2422:    drawMotes(g, this.cleanEffects);\n2426:    drawGlowTrail(g, this.cleanEffects);\n2427:    drawRipples(g, this.cleanEffects);\n2432:    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n2434:    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"6919c6b3-ddb4-4083-80b8-16d39688729e","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"13:  drawCleanBackground,\n15:  drawMotes,\n16:  drawRipples,\n17:  drawGlowTrail,\n18:  drawCleanFood,\n19:  drawCleanSnake,\n2420:    drawCleanBackground(g, width, height, this.frameCount);\n2422:    drawMotes(g, this.cleanEffects);\n2426:    drawGlowTrail(g, this.cleanEffects);\n2427:    drawRipples(g, this.cleanEffects);\n2432:    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n2434:    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);","numLines":12}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UPLxWFdjnV28W2xgE36ymZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011jEwaCxbjGULqnwQwFNCdr","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":1,"limit":100},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":7654,"cache_read_input_tokens":23275,"cache_creation":{"ephemeral_5m_input_tokens":7654,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"0f59fd9e-f9ea-4591-b4b8-769e394acc17"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011jEwaCxbjGULqnwQwFNCdr","type":"tool_result","content":"     1→import Phaser from 'phaser';\n     2→import {\n     3→  createCleanEffectsState,\n     4→  initMotes,\n     5→  updateMotes,\n     6→  updateRipples,\n     7→  updateGlowTrail,\n     8→  spawnRipple,\n     9→  spawnTears,\n    10→  spawnBlood,\n    11→  updateTears,\n    12→  updateBlood,\n    13→  drawCleanBackground,\n    14→  drawCleanGrid,\n    15→  drawMotes,\n    16→  drawRipples,\n    17→  drawGlowTrail,\n    18→  drawCleanFood,\n    19→  drawCleanSnake,\n    20→  drawCleanVignette,\n    21→  drawCleanHUD,\n    22→  drawTears,\n    23→  drawBlood,\n    24→  CLEAN_COLORS,\n    25→  CleanEffectsState,\n    26→} from './cleanEffects';\n    27→\n    28→interface Position {\n    29→  x: number;\n    30→  y: number;\n    31→}\n    32→\n    33→interface GameState {\n    34→  snake: Position[];\n    35→  food: Position;\n    36→  gameOver: boolean;\n    37→  gameStarted?: boolean;\n    38→  score?: number;\n    39→}\n    40→\n    41→interface Star {\n    42→  x: number;\n    43→  y: number;\n    44→  size: number;\n    45→  speed: number;\n    46→  brightness: number;\n    47→}\n    48→\n    49→interface PlasmaWave {\n    50→  phase: number;\n    51→  speed: number;\n    52→  amplitude: number;\n    53→  wavelength: number;\n    54→  hue: number;\n    55→}\n    56→\n    57→interface AuroraWave {\n    58→  y: number;\n    59→  phase: number;\n    60→  speed: number;\n    61→  hue: number;\n    62→  thickness: number;\n    63→  amplitude: number;\n    64→}\n    65→\n    66→interface NebulaCloud {\n    67→  x: number;\n    68→  y: number;\n    69→  radius: number;\n    70→  hue: number;\n    71→  alpha: number;\n    72→  driftX: number;\n    73→  driftY: number;\n    74→  pulsePhase: number;\n    75→  pulseSpeed: number;\n    76→}\n    77→\n    78→interface VortexRing {\n    79→  radius: number;\n    80→  baseRadius: number;\n    81→  rotationOffset: number;\n    82→  rotationSpeed: number;\n    83→  thickness: number;\n    84→  hue: number;\n    85→  pulsePhase: number;\n    86→}\n    87→\n    88→interface VortexParticle {\n    89→  angle: number;\n    90→  radius: number;\n    91→  baseRadius: number;\n    92→  speed: number;\n    93→  size: number;\n    94→  hue: number;\n    95→  alpha: number;\n    96→}\n    97→\n    98→interface SnakeAfterimage {\n    99→  segments: Position[];\n   100→  life: number;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"4f423418-6515-423c-8bd2-7382019f9ab8","tool_use_result":{"type":"text","file":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","content":"import Phaser from 'phaser';\nimport {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface GameState {\n  snake: Position[];\n  food: Position;\n  gameOver: boolean;\n  gameStarted?: boolean;\n  score?: number;\n}\n\ninterface Star {\n  x: number;\n  y: number;\n  size: number;\n  speed: number;\n  brightness: number;\n}\n\ninterface PlasmaWave {\n  phase: number;\n  speed: number;\n  amplitude: number;\n  wavelength: number;\n  hue: number;\n}\n\ninterface AuroraWave {\n  y: number;\n  phase: number;\n  speed: number;\n  hue: number;\n  thickness: number;\n  amplitude: number;\n}\n\ninterface NebulaCloud {\n  x: number;\n  y: number;\n  radius: number;\n  hue: number;\n  alpha: number;\n  driftX: number;\n  driftY: number;\n  pulsePhase: number;\n  pulseSpeed: number;\n}\n\ninterface VortexRing {\n  radius: number;\n  baseRadius: number;\n  rotationOffset: number;\n  rotationSpeed: number;\n  thickness: number;\n  hue: number;\n  pulsePhase: number;\n}\n\ninterface VortexParticle {\n  angle: number;\n  radius: number;\n  baseRadius: number;\n  speed: number;\n  size: number;\n  hue: number;\n  alpha: number;\n}\n\ninterface SnakeAfterimage {\n  segments: Position[];\n  life: number;","numLines":100,"startLine":1,"totalLines":4143}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NyYZdiLiFdYm8gz4hjKbaU","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read more of SnakeScene.ts to understand the update loop and where effects are drawn."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1534,"cache_read_input_tokens":30929,"cache_creation":{"ephemeral_5m_input_tokens":1534,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"48b87a2f-db03-4037-970c-68ba3f566b4d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NyYZdiLiFdYm8gz4hjKbaU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01APR8gc6NfHpQxzfzpjMKMQ","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":2400,"limit":150},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1534,"cache_read_input_tokens":30929,"cache_creation":{"ephemeral_5m_input_tokens":1534,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"798bc756-f9e3-43fb-983f-66c56370f22b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01APR8gc6NfHpQxzfzpjMKMQ","type":"tool_result","content":"  2400→      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n  2401→\n  2402→      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n  2403→        updateGlowTrail(this.cleanEffects, headX, headY);\n  2404→      }\n  2405→      this.lastHeadPos = { x: head.x, y: head.y };\n  2406→\n  2407→      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n  2408→        const food = this.currentState.food;\n  2409→        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n  2410→        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n  2411→        spawnRipple(this.cleanEffects, foodX, foodY);\n  2412→      }\n  2413→      this.lastSnakeLength = this.currentState.snake.length;\n  2414→    }\n  2415→\n  2416→    const g = this.graphics;\n  2417→    g.clear();\n  2418→    g.setPosition(0, 0);\n  2419→\n  2420→    drawCleanBackground(g, width, height, this.frameCount);\n  2421→    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n  2422→    drawMotes(g, this.cleanEffects);\n  2423→\n  2424→    if (!this.currentState) return;\n  2425→\n  2426→    drawGlowTrail(g, this.cleanEffects);\n  2427→    drawRipples(g, this.cleanEffects);\n  2428→\n  2429→    const food = this.currentState.food;\n  2430→    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n  2431→    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n  2432→    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n  2433→\n  2434→    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n  2435→\n  2436→    drawTears(g, this.cleanEffects);\n  2437→    drawBlood(g, this.cleanEffects);\n  2438→\n  2439→    drawCleanVignette(g, width, height);\n  2440→\n  2441→    const score = this.currentState.score || 0;\n  2442→    const snakeLength = this.currentState.snake.length;\n  2443→    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n  2444→\n  2445→    if (this.currentState.gameOver) {\n  2446→      this.drawGameOver(g, width, height);\n  2447→      this.drawScoreboard(g, width, height);\n  2448→    }\n  2449→\n  2450→    this.checkAndSaveHighScore();\n  2451→    this.needsRedraw = false;\n  2452→  }\n  2453→\n  2454→  private drawStars(g: Phaser.GameObjects.Graphics): void {\n  2455→    // In film noir mode, stars are subtle distant lights\n  2456→    for (const star of this.stars) {\n  2457→      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n  2458→      const alpha = star.brightness * twinkle * 0.25;\n  2459→      g.fillStyle(COLORS.star, alpha);\n  2460→      g.fillCircle(star.x, star.y, star.size * 0.7);\n  2461→    }\n  2462→  }\n  2463→\n  2464→  private updateSmokeParticles(): void {\n  2465→    const width = GRID_SIZE * CELL_SIZE;\n  2466→    const height = GRID_SIZE * CELL_SIZE;\n  2467→    for (const smoke of this.smokeParticles) {\n  2468→      smoke.x += smoke.vx;\n  2469→      smoke.y += smoke.vy;\n  2470→      smoke.life -= 0.002;\n  2471→      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n  2472→        smoke.x = Math.random() * width;\n  2473→        smoke.y = height + smoke.size;\n  2474→        smoke.life = 1;\n  2475→        smoke.size = 30 + Math.random() * 50;\n  2476→        smoke.alpha = 0.02 + Math.random() * 0.03;\n  2477→      }\n  2478→      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n  2479→      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n  2480→    }\n  2481→  }\n  2482→\n  2483→  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n  2484→    // Create dramatic spotlight effect centered on snake\n  2485→    const cx = this.spotlightX || width / 2;\n  2486→    const cy = this.spotlightY || height / 2;\n  2487→    const pulse = 0.9 + Math.sin(this.frameCount * 0.03) * 0.1;\n  2488→\n  2489→    // Outer darkness vignette\n  2490→    g.fillStyle(0x000000, 0.6);\n  2491→    g.fillRect(0, 0, width, height);\n  2492→\n  2493→    // Spotlight cone - multiple layers for smooth falloff\n  2494→    const layers = 4;\n  2495→    for (let i = layers; i > 0; i--) {\n  2496→      const layerRadius = (width * 0.4 + i * 30) * pulse;\n  2497→      const layerAlpha = 0.15 * (1 - i / (layers + 1));\n  2498→      g.fillStyle(COLORS.spotlight, layerAlpha);\n  2499→      g.fillCircle(cx, cy, layerRadius);\n  2500→    }\n  2501→\n  2502→    // Bright center\n  2503→    g.fillStyle(COLORS.noirWhite, 0.08 * pulse);\n  2504→    g.fillCircle(cx, cy, width * 0.25);\n  2505→  }\n  2506→\n  2507→  private drawVenetianBlinds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n  2508→    // Horizontal light streaks simulating light through venetian blinds\n  2509→    const blindSpacing = 25;\n  2510→    const blindWidth = 8;\n  2511→    const waveOffset = Math.sin(this.venetianPhase) * 10;\n  2512→\n  2513→    for (let y = waveOffset; y < height; y += blindSpacing) {\n  2514→      const brightness = 0.03 + Math.sin(y * 0.02 + this.venetianPhase * 2) * 0.015;\n  2515→      g.fillStyle(COLORS.noirWhite, brightness);\n  2516→      g.fillRect(0, y, width, blindWidth);\n  2517→    }\n  2518→\n  2519→    // Diagonal shadow bars from window frame\n  2520→    const diagonalAlpha = 0.04 + Math.sin(this.frameCount * 0.02) * 0.01;\n  2521→    g.fillStyle(0x000000, diagonalAlpha);\n  2522→    for (let i = -2; i < 6; i++) {\n  2523→      const x1 = i * 100 + Math.sin(this.venetianPhase) * 20;\n  2524→      g.beginPath();\n  2525→      g.moveTo(x1, 0);\n  2526→      g.lineTo(x1 + 40, 0);\n  2527→      g.lineTo(x1 + 40 + height * 0.3, height);\n  2528→      g.lineTo(x1 + height * 0.3, height);\n  2529→      g.closePath();\n  2530→      g.fillPath();\n  2531→    }\n  2532→  }\n  2533→\n  2534→  private drawSmoke(g: Phaser.GameObjects.Graphics): void {\n  2535→    for (const smoke of this.smokeParticles) {\n  2536→      const alpha = smoke.alpha * smoke.life;\n  2537→      g.fillStyle(COLORS.noirGray, alpha);\n  2538→      g.fillCircle(smoke.x, smoke.y, smoke.size);\n  2539→      g.fillStyle(COLORS.noirWhite, alpha * 0.3);\n  2540→      g.fillCircle(smoke.x, smoke.y, smoke.size * 0.5);\n  2541→    }\n  2542→  }\n  2543→\n  2544→  private spawnFlameParticle(x: number, y: number, intensity: number): void {\n  2545→    if (this.flameParticles.length >= MAX_FLAME_PARTICLES) {\n  2546→      this.flameParticles.shift();\n  2547→    }\n  2548→\n  2549→    const angle = Math.random() * Math.PI * 2;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"82dcaae9-7c54-4339-82de-b375b1cf4d62","tool_use_result":{"type":"text","file":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","content":"      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n        updateGlowTrail(this.cleanEffects, headX, headY);\n      }\n      this.lastHeadPos = { x: head.x, y: head.y };\n\n      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n        const food = this.currentState.food;\n        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnRipple(this.cleanEffects, foodX, foodY);\n      }\n      this.lastSnakeLength = this.currentState.snake.length;\n    }\n\n    const g = this.graphics;\n    g.clear();\n    g.setPosition(0, 0);\n\n    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n\n    if (!this.currentState) return;\n\n    drawGlowTrail(g, this.cleanEffects);\n    drawRipples(g, this.cleanEffects);\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n\n    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawTears(g, this.cleanEffects);\n    drawBlood(g, this.cleanEffects);\n\n    drawCleanVignette(g, width, height);\n\n    const score = this.currentState.score || 0;\n    const snakeLength = this.currentState.snake.length;\n    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n\n    if (this.currentState.gameOver) {\n      this.drawGameOver(g, width, height);\n      this.drawScoreboard(g, width, height);\n    }\n\n    this.checkAndSaveHighScore();\n    this.needsRedraw = false;\n  }\n\n  private drawStars(g: Phaser.GameObjects.Graphics): void {\n    // In film noir mode, stars are subtle distant lights\n    for (const star of this.stars) {\n      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n      const alpha = star.brightness * twinkle * 0.25;\n      g.fillStyle(COLORS.star, alpha);\n      g.fillCircle(star.x, star.y, star.size * 0.7);\n    }\n  }\n\n  private updateSmokeParticles(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (const smoke of this.smokeParticles) {\n      smoke.x += smoke.vx;\n      smoke.y += smoke.vy;\n      smoke.life -= 0.002;\n      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n        smoke.x = Math.random() * width;\n        smoke.y = height + smoke.size;\n        smoke.life = 1;\n        smoke.size = 30 + Math.random() * 50;\n        smoke.alpha = 0.02 + Math.random() * 0.03;\n      }\n      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n    }\n  }\n\n  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Create dramatic spotlight effect centered on snake\n    const cx = this.spotlightX || width / 2;\n    const cy = this.spotlightY || height / 2;\n    const pulse = 0.9 + Math.sin(this.frameCount * 0.03) * 0.1;\n\n    // Outer darkness vignette\n    g.fillStyle(0x000000, 0.6);\n    g.fillRect(0, 0, width, height);\n\n    // Spotlight cone - multiple layers for smooth falloff\n    const layers = 4;\n    for (let i = layers; i > 0; i--) {\n      const layerRadius = (width * 0.4 + i * 30) * pulse;\n      const layerAlpha = 0.15 * (1 - i / (layers + 1));\n      g.fillStyle(COLORS.spotlight, layerAlpha);\n      g.fillCircle(cx, cy, layerRadius);\n    }\n\n    // Bright center\n    g.fillStyle(COLORS.noirWhite, 0.08 * pulse);\n    g.fillCircle(cx, cy, width * 0.25);\n  }\n\n  private drawVenetianBlinds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Horizontal light streaks simulating light through venetian blinds\n    const blindSpacing = 25;\n    const blindWidth = 8;\n    const waveOffset = Math.sin(this.venetianPhase) * 10;\n\n    for (let y = waveOffset; y < height; y += blindSpacing) {\n      const brightness = 0.03 + Math.sin(y * 0.02 + this.venetianPhase * 2) * 0.015;\n      g.fillStyle(COLORS.noirWhite, brightness);\n      g.fillRect(0, y, width, blindWidth);\n    }\n\n    // Diagonal shadow bars from window frame\n    const diagonalAlpha = 0.04 + Math.sin(this.frameCount * 0.02) * 0.01;\n    g.fillStyle(0x000000, diagonalAlpha);\n    for (let i = -2; i < 6; i++) {\n      const x1 = i * 100 + Math.sin(this.venetianPhase) * 20;\n      g.beginPath();\n      g.moveTo(x1, 0);\n      g.lineTo(x1 + 40, 0);\n      g.lineTo(x1 + 40 + height * 0.3, height);\n      g.lineTo(x1 + height * 0.3, height);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawSmoke(g: Phaser.GameObjects.Graphics): void {\n    for (const smoke of this.smokeParticles) {\n      const alpha = smoke.alpha * smoke.life;\n      g.fillStyle(COLORS.noirGray, alpha);\n      g.fillCircle(smoke.x, smoke.y, smoke.size);\n      g.fillStyle(COLORS.noirWhite, alpha * 0.3);\n      g.fillCircle(smoke.x, smoke.y, smoke.size * 0.5);\n    }\n  }\n\n  private spawnFlameParticle(x: number, y: number, intensity: number): void {\n    if (this.flameParticles.length >= MAX_FLAME_PARTICLES) {\n      this.flameParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;","numLines":150,"startLine":2400,"totalLines":4143}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PjxdqhaarjMyuhvJrquzCz","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a good understanding. I'll create a Christmas-themed enhancement by adding snowflakes falling in the background. This is a contained, visible change that builds on the existing motes system. Let me plan this:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2869,"cache_read_input_tokens":32463,"cache_creation":{"ephemeral_5m_input_tokens":2869,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"38684ea8-68b4-4934-87ac-c883cbe5baa4"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PjxdqhaarjMyuhvJrquzCz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017NUHU8fcihPPRwcobtWUux","name":"TodoWrite","input":{"todos":[{"content":"Add snowflake particle interface and state to cleanEffects.ts","status":"in_progress","activeForm":"Adding snowflake particle interface and state"},{"content":"Create snowflake update and draw functions","status":"pending","activeForm":"Creating snowflake update and draw functions"},{"content":"Update Christmas color palette for food and snake","status":"pending","activeForm":"Updating Christmas color palette"},{"content":"Import and integrate snowflakes in SnakeScene.ts","status":"pending","activeForm":"Importing and integrating snowflakes"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2869,"cache_read_input_tokens":32463,"cache_creation":{"ephemeral_5m_input_tokens":2869,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"a479f6d0-01e3-4503-8806-0a3618b3b938"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017NUHU8fcihPPRwcobtWUux","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"1370dc20-954c-40d5-83f9-d46ea8a361d3","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Add snowflake particle interface and state to cleanEffects.ts","status":"in_progress","activeForm":"Adding snowflake particle interface and state"},{"content":"Create snowflake update and draw functions","status":"pending","activeForm":"Creating snowflake update and draw functions"},{"content":"Update Christmas color palette for food and snake","status":"pending","activeForm":"Updating Christmas color palette"},{"content":"Import and integrate snowflakes in SnakeScene.ts","status":"pending","activeForm":"Importing and integrating snowflakes"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011L33qX4Hk4T9NzQGKzmz1v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YY1gLJJ6ZCjm5tZPj7abhW","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","old_string":"export interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}","new_string":"export interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}\n\nexport interface Snowflake {\n  x: number;\n  y: number;\n  vy: number;\n  vx: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n  wobbleSpeed: number;\n}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":380,"cache_read_input_tokens":35332,"cache_creation":{"ephemeral_5m_input_tokens":380,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"d280efbc-d698-4d5c-ad9a-f7dd65cb9be4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YY1gLJJ6ZCjm5tZPj7abhW","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"c48c4d26-1f73-4199-b288-152bc450186f","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","oldString":"export interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}","newString":"export interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}\n\nexport interface Snowflake {\n  x: number;\n  y: number;\n  vy: number;\n  vx: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n  wobbleSpeed: number;\n}","originalFile":"export interface CleanRipple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport interface FloatingMote {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  pulsePhase: number;\n}\n\nexport interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport interface TearDrop {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n}\n\nexport interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}\n\nexport const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n};\n\nconst MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;\n\nexport function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    frameCount: 0,\n  };\n}\n\nexport type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n\nexport function initMotes(state: CleanEffectsState, width: number, height: number): void {\n  state.motes = [];\n  for (let i = 0; i < MAX_MOTES; i++) {\n    state.motes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: (Math.random() - 0.5) * 0.3,\n      vy: (Math.random() - 0.5) * 0.3,\n      size: 1 + Math.random() * 2,\n      alpha: 0.1 + Math.random() * 0.2,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n  for (const mote of state.motes) {\n    mote.x += mote.vx;\n    mote.y += mote.vy;\n    mote.pulsePhase += 0.02;\n\n    if (mote.x < 0) mote.x = width;\n    if (mote.x > width) mote.x = 0;\n    if (mote.y < 0) mote.y = height;\n    if (mote.y > height) mote.y = 0;\n  }\n}\n\nexport function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n  if (state.ripples.length >= MAX_RIPPLES) {\n    state.ripples.shift();\n  }\n\n  state.ripples.push({\n    x,\n    y,\n    radius: 5,\n    maxRadius: 60,\n    alpha: 0.6,\n    thickness: 2,\n  });\n}\n\nexport function updateRipples(state: CleanEffectsState): void {\n  for (let i = state.ripples.length - 1; i >= 0; i--) {\n    const ripple = state.ripples[i];\n    ripple.radius += 2;\n    ripple.alpha *= 0.94;\n    ripple.thickness *= 0.98;\n\n    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n      state.ripples.splice(i, 1);\n    }\n  }\n}\n\nexport function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function spawnTears(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.tears.length >= MAX_TEARS) {\n      state.tears.shift();\n    }\n    state.tears.push({\n      x: x + (Math.random() - 0.5) * 20,\n      y: y + (Math.random() - 0.5) * 10,\n      vy: 0.5 + Math.random() * 1.5,\n      size: 3 + Math.random() * 3,\n      alpha: 0.7 + Math.random() * 0.3,\n      wobblePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateTears(state: CleanEffectsState, height: number): void {\n  for (let i = state.tears.length - 1; i >= 0; i--) {\n    const tear = state.tears[i];\n    tear.vy += 0.08;\n    tear.y += tear.vy;\n    tear.wobblePhase += 0.1;\n    tear.x += Math.sin(tear.wobblePhase) * 0.3;\n    tear.alpha *= 0.99;\n\n    if (tear.y > height + 10 || tear.alpha < 0.05) {\n      state.tears.splice(i, 1);\n    }\n  }\n}\n\nexport function spawnBlood(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.blood.length >= MAX_BLOOD) {\n      state.blood.shift();\n    }\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 1 + Math.random() * 3;\n    state.blood.push({\n      x,\n      y,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 1,\n      size: 2 + Math.random() * 4,\n      alpha: 0.8 + Math.random() * 0.2,\n      life: 1.0,\n      splashed: false,\n      splashRadius: 0,\n    });\n  }\n}\n\nexport function updateBlood(state: CleanEffectsState, height: number): void {\n  for (let i = state.blood.length - 1; i >= 0; i--) {\n    const drop = state.blood[i];\n\n    if (!drop.splashed) {\n      drop.vy += 0.15;\n      drop.x += drop.vx;\n      drop.y += drop.vy;\n      drop.vx *= 0.98;\n\n      if (drop.y >= height - 5) {\n        drop.splashed = true;\n        drop.y = height - 5;\n        drop.splashRadius = drop.size * 1.5;\n      }\n    } else {\n      drop.splashRadius += 0.3;\n      drop.alpha *= 0.95;\n    }\n\n    drop.life -= 0.015;\n\n    if (drop.life <= 0 || drop.alpha < 0.02) {\n      state.blood.splice(i, 1);\n    }\n  }\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}\n\nexport function drawCleanGrid(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  cellSize: number,\n  gridSize: number,\n  frameCount: number\n): void {\n  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n\n  for (let i = 0; i <= gridSize; i++) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n\n  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n  for (let i = 0; i <= gridSize; i += 5) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n}\n\nexport function drawMotes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const mote of state.motes) {\n    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n    const alpha = mote.alpha * pulse;\n\n    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n    g.fillCircle(mote.x, mote.y, mote.size * 2);\n    g.fillStyle(CLEAN_COLORS.mote, alpha);\n    g.fillCircle(mote.x, mote.y, mote.size);\n  }\n}\n\nexport function drawRipples(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const ripple of state.ripples) {\n    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n\n    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n  }\n}\n\nexport function drawGlowTrail(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const trail of state.glowTrail) {\n    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n    g.fillCircle(trail.x, trail.y, trail.size);\n  }\n}\n\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n  const foodSize = (cellSize / 2 - 2) * pulseScale;\n\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n  g.fillCircle(foodX, foodY, foodSize + 12);\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n  g.fillCircle(foodX, foodY, foodSize + 6);\n\n  g.fillStyle(CLEAN_COLORS.food, 0.9);\n  g.fillCircle(foodX, foodY, foodSize);\n  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n  g.fillCircle(foodX, foodY, foodSize * 0.5);\n\n  g.fillStyle(0xffffff, 0.6);\n  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n}\n\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  const snakeLen = snake.length;\n  if (snakeLen === 0) return;\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n\n    const glowAlpha = 0.15 * (1 - t * 0.5);\n    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n    g.fillCircle(centerX, centerY, glowSize);\n  }\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n\n    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n\n    const r = Math.round(r1 + (r2 - r1) * t);\n    const gVal = Math.round(g1 + (g2 - g1) * t);\n    const b = Math.round(b1 + (b2 - b1) * t);\n    const color = (r << 16) | (gVal << 8) | b;\n\n    g.fillStyle(color, 0.95);\n    g.fillCircle(centerX, centerY, radius);\n\n    if (i === 0) {\n      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n      g.fillCircle(centerX, centerY, radius + 4);\n\n      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n      g.fillCircle(centerX, centerY, radius);\n\n      g.fillStyle(0xffffff, 0.7);\n      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n    }\n  }\n}\n\nexport function drawCleanVignette(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number\n): void {\n  const layers = 4;\n  for (let i = 0; i < layers; i++) {\n    const inset = i * 25;\n    const alpha = 0.08 * (1 - i / layers);\n    g.lineStyle(50, 0x000000, alpha);\n    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n  }\n}\n\nexport function drawTears(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const tear of state.tears) {\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha * 0.3);\n    g.fillCircle(tear.x, tear.y, tear.size * 2);\n\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha);\n    g.fillCircle(tear.x, tear.y - tear.size * 0.3, tear.size);\n    g.fillCircle(tear.x, tear.y + tear.size * 0.5, tear.size * 0.7);\n\n    g.fillStyle(CLEAN_COLORS.tearHighlight, tear.alpha * 0.6);\n    g.fillCircle(tear.x - tear.size * 0.25, tear.y - tear.size * 0.4, tear.size * 0.3);\n  }\n}\n\nexport function drawBlood(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const drop of state.blood) {\n    const effectiveAlpha = drop.alpha * drop.life;\n\n    if (drop.splashed) {\n      g.fillStyle(CLEAN_COLORS.bloodDark, effectiveAlpha * 0.5);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.7);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius * 0.6);\n    } else {\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.4);\n      g.fillCircle(drop.x, drop.y, drop.size * 2);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha);\n      g.fillCircle(drop.x, drop.y, drop.size);\n      g.fillStyle(0xffffff, effectiveAlpha * 0.3);\n      g.fillCircle(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.25);\n    }\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {\n  const padding = 15;\n  const digitSize = 12;\n  const digitSpacing = digitSize * 0.6;\n\n  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n\n  const scoreStr = String(score).padStart(4, '0');\n  let xPos = padding;\n\n  for (let i = 0; i < scoreStr.length; i++) {\n    const digit = scoreStr[i];\n    g.fillStyle(CLEAN_COLORS.text, pulse);\n    drawDigit(g, digit, xPos, padding, digitSize);\n    xPos += digitSpacing;\n  }\n\n  const lengthStr = String(snakeLength);\n  xPos = width - padding - lengthStr.length * digitSpacing;\n\n  for (let i = 0; i < lengthStr.length; i++) {\n    const digit = lengthStr[i];\n    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n    xPos += digitSpacing * 0.9;\n  }\n}\n","structuredPatch":[{"oldStart":45,"oldLines":6,"newStart":45,"newLines":17,"lines":["   splashRadius: number;"," }"," ","+export interface Snowflake {","+  x: number;","+  y: number;","+  vy: number;","+  vx: number;","+  size: number;","+  alpha: number;","+  wobblePhase: number;","+  wobbleSpeed: number;","+}","+"," export const CLEAN_COLORS = {","   bgDark: 0x0a1628,","   bgMid: 0x0f1d32,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01L1szg44DdG5QMnQvQQL6Ns","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014u35p7VeyKZtvfd3CK3qJE","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","old_string":"const MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;","new_string":"const MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;\nconst MAX_SNOWFLAKES = 30;"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":415,"cache_read_input_tokens":35712,"cache_creation":{"ephemeral_5m_input_tokens":415,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"6befed12-ae43-472d-a148-7624cabc2919"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014u35p7VeyKZtvfd3CK3qJE","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"9d6a7896-6074-416a-ac72-24da358d3e90","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","oldString":"const MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;","newString":"const MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;\nconst MAX_SNOWFLAKES = 30;","originalFile":"export interface CleanRipple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport interface FloatingMote {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  pulsePhase: number;\n}\n\nexport interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport interface TearDrop {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n}\n\nexport interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}\n\nexport interface Snowflake {\n  x: number;\n  y: number;\n  vy: number;\n  vx: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n  wobbleSpeed: number;\n}\n\nexport const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n};\n\nconst MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;\n\nexport function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    frameCount: 0,\n  };\n}\n\nexport type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n\nexport function initMotes(state: CleanEffectsState, width: number, height: number): void {\n  state.motes = [];\n  for (let i = 0; i < MAX_MOTES; i++) {\n    state.motes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: (Math.random() - 0.5) * 0.3,\n      vy: (Math.random() - 0.5) * 0.3,\n      size: 1 + Math.random() * 2,\n      alpha: 0.1 + Math.random() * 0.2,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n  for (const mote of state.motes) {\n    mote.x += mote.vx;\n    mote.y += mote.vy;\n    mote.pulsePhase += 0.02;\n\n    if (mote.x < 0) mote.x = width;\n    if (mote.x > width) mote.x = 0;\n    if (mote.y < 0) mote.y = height;\n    if (mote.y > height) mote.y = 0;\n  }\n}\n\nexport function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n  if (state.ripples.length >= MAX_RIPPLES) {\n    state.ripples.shift();\n  }\n\n  state.ripples.push({\n    x,\n    y,\n    radius: 5,\n    maxRadius: 60,\n    alpha: 0.6,\n    thickness: 2,\n  });\n}\n\nexport function updateRipples(state: CleanEffectsState): void {\n  for (let i = state.ripples.length - 1; i >= 0; i--) {\n    const ripple = state.ripples[i];\n    ripple.radius += 2;\n    ripple.alpha *= 0.94;\n    ripple.thickness *= 0.98;\n\n    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n      state.ripples.splice(i, 1);\n    }\n  }\n}\n\nexport function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function spawnTears(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.tears.length >= MAX_TEARS) {\n      state.tears.shift();\n    }\n    state.tears.push({\n      x: x + (Math.random() - 0.5) * 20,\n      y: y + (Math.random() - 0.5) * 10,\n      vy: 0.5 + Math.random() * 1.5,\n      size: 3 + Math.random() * 3,\n      alpha: 0.7 + Math.random() * 0.3,\n      wobblePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateTears(state: CleanEffectsState, height: number): void {\n  for (let i = state.tears.length - 1; i >= 0; i--) {\n    const tear = state.tears[i];\n    tear.vy += 0.08;\n    tear.y += tear.vy;\n    tear.wobblePhase += 0.1;\n    tear.x += Math.sin(tear.wobblePhase) * 0.3;\n    tear.alpha *= 0.99;\n\n    if (tear.y > height + 10 || tear.alpha < 0.05) {\n      state.tears.splice(i, 1);\n    }\n  }\n}\n\nexport function spawnBlood(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.blood.length >= MAX_BLOOD) {\n      state.blood.shift();\n    }\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 1 + Math.random() * 3;\n    state.blood.push({\n      x,\n      y,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 1,\n      size: 2 + Math.random() * 4,\n      alpha: 0.8 + Math.random() * 0.2,\n      life: 1.0,\n      splashed: false,\n      splashRadius: 0,\n    });\n  }\n}\n\nexport function updateBlood(state: CleanEffectsState, height: number): void {\n  for (let i = state.blood.length - 1; i >= 0; i--) {\n    const drop = state.blood[i];\n\n    if (!drop.splashed) {\n      drop.vy += 0.15;\n      drop.x += drop.vx;\n      drop.y += drop.vy;\n      drop.vx *= 0.98;\n\n      if (drop.y >= height - 5) {\n        drop.splashed = true;\n        drop.y = height - 5;\n        drop.splashRadius = drop.size * 1.5;\n      }\n    } else {\n      drop.splashRadius += 0.3;\n      drop.alpha *= 0.95;\n    }\n\n    drop.life -= 0.015;\n\n    if (drop.life <= 0 || drop.alpha < 0.02) {\n      state.blood.splice(i, 1);\n    }\n  }\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}\n\nexport function drawCleanGrid(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  cellSize: number,\n  gridSize: number,\n  frameCount: number\n): void {\n  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n\n  for (let i = 0; i <= gridSize; i++) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n\n  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n  for (let i = 0; i <= gridSize; i += 5) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n}\n\nexport function drawMotes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const mote of state.motes) {\n    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n    const alpha = mote.alpha * pulse;\n\n    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n    g.fillCircle(mote.x, mote.y, mote.size * 2);\n    g.fillStyle(CLEAN_COLORS.mote, alpha);\n    g.fillCircle(mote.x, mote.y, mote.size);\n  }\n}\n\nexport function drawRipples(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const ripple of state.ripples) {\n    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n\n    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n  }\n}\n\nexport function drawGlowTrail(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const trail of state.glowTrail) {\n    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n    g.fillCircle(trail.x, trail.y, trail.size);\n  }\n}\n\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n  const foodSize = (cellSize / 2 - 2) * pulseScale;\n\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n  g.fillCircle(foodX, foodY, foodSize + 12);\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n  g.fillCircle(foodX, foodY, foodSize + 6);\n\n  g.fillStyle(CLEAN_COLORS.food, 0.9);\n  g.fillCircle(foodX, foodY, foodSize);\n  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n  g.fillCircle(foodX, foodY, foodSize * 0.5);\n\n  g.fillStyle(0xffffff, 0.6);\n  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n}\n\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  const snakeLen = snake.length;\n  if (snakeLen === 0) return;\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n\n    const glowAlpha = 0.15 * (1 - t * 0.5);\n    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n    g.fillCircle(centerX, centerY, glowSize);\n  }\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n\n    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n\n    const r = Math.round(r1 + (r2 - r1) * t);\n    const gVal = Math.round(g1 + (g2 - g1) * t);\n    const b = Math.round(b1 + (b2 - b1) * t);\n    const color = (r << 16) | (gVal << 8) | b;\n\n    g.fillStyle(color, 0.95);\n    g.fillCircle(centerX, centerY, radius);\n\n    if (i === 0) {\n      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n      g.fillCircle(centerX, centerY, radius + 4);\n\n      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n      g.fillCircle(centerX, centerY, radius);\n\n      g.fillStyle(0xffffff, 0.7);\n      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n    }\n  }\n}\n\nexport function drawCleanVignette(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number\n): void {\n  const layers = 4;\n  for (let i = 0; i < layers; i++) {\n    const inset = i * 25;\n    const alpha = 0.08 * (1 - i / layers);\n    g.lineStyle(50, 0x000000, alpha);\n    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n  }\n}\n\nexport function drawTears(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const tear of state.tears) {\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha * 0.3);\n    g.fillCircle(tear.x, tear.y, tear.size * 2);\n\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha);\n    g.fillCircle(tear.x, tear.y - tear.size * 0.3, tear.size);\n    g.fillCircle(tear.x, tear.y + tear.size * 0.5, tear.size * 0.7);\n\n    g.fillStyle(CLEAN_COLORS.tearHighlight, tear.alpha * 0.6);\n    g.fillCircle(tear.x - tear.size * 0.25, tear.y - tear.size * 0.4, tear.size * 0.3);\n  }\n}\n\nexport function drawBlood(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const drop of state.blood) {\n    const effectiveAlpha = drop.alpha * drop.life;\n\n    if (drop.splashed) {\n      g.fillStyle(CLEAN_COLORS.bloodDark, effectiveAlpha * 0.5);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.7);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius * 0.6);\n    } else {\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.4);\n      g.fillCircle(drop.x, drop.y, drop.size * 2);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha);\n      g.fillCircle(drop.x, drop.y, drop.size);\n      g.fillStyle(0xffffff, effectiveAlpha * 0.3);\n      g.fillCircle(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.25);\n    }\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {\n  const padding = 15;\n  const digitSize = 12;\n  const digitSpacing = digitSize * 0.6;\n\n  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n\n  const scoreStr = String(score).padStart(4, '0');\n  let xPos = padding;\n\n  for (let i = 0; i < scoreStr.length; i++) {\n    const digit = scoreStr[i];\n    g.fillStyle(CLEAN_COLORS.text, pulse);\n    drawDigit(g, digit, xPos, padding, digitSize);\n    xPos += digitSpacing;\n  }\n\n  const lengthStr = String(snakeLength);\n  xPos = width - padding - lengthStr.length * digitSpacing;\n\n  for (let i = 0; i < lengthStr.length; i++) {\n    const digit = lengthStr[i];\n    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n    xPos += digitSpacing * 0.9;\n  }\n}\n","structuredPatch":[{"oldStart":90,"oldLines":6,"newStart":90,"newLines":7,"lines":[" const MAX_TRAIL_LENGTH = 15;"," const MAX_TEARS = 12;"," const MAX_BLOOD = 20;","+const MAX_SNOWFLAKES = 30;"," "," export function createCleanEffectsState() {","   return {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RhB38L5a1w28WKtJ6sLrMk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CheHmeVx2DLDEyyhoryZtG","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","old_string":"export function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    frameCount: 0,\n  };\n}","new_string":"export function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    snowflakes: [] as Snowflake[],\n    frameCount: 0,\n  };\n}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":330,"cache_read_input_tokens":36127,"cache_creation":{"ephemeral_5m_input_tokens":330,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"eaec157a-5864-4589-9ddb-97a43cc6f488"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CheHmeVx2DLDEyyhoryZtG","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"6f75e702-882d-43c8-b660-06e87e0d21e6","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","oldString":"export function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    frameCount: 0,\n  };\n}","newString":"export function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    snowflakes: [] as Snowflake[],\n    frameCount: 0,\n  };\n}","originalFile":"export interface CleanRipple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport interface FloatingMote {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  pulsePhase: number;\n}\n\nexport interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport interface TearDrop {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n}\n\nexport interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}\n\nexport interface Snowflake {\n  x: number;\n  y: number;\n  vy: number;\n  vx: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n  wobbleSpeed: number;\n}\n\nexport const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n};\n\nconst MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;\nconst MAX_SNOWFLAKES = 30;\n\nexport function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    frameCount: 0,\n  };\n}\n\nexport type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n\nexport function initMotes(state: CleanEffectsState, width: number, height: number): void {\n  state.motes = [];\n  for (let i = 0; i < MAX_MOTES; i++) {\n    state.motes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: (Math.random() - 0.5) * 0.3,\n      vy: (Math.random() - 0.5) * 0.3,\n      size: 1 + Math.random() * 2,\n      alpha: 0.1 + Math.random() * 0.2,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n  for (const mote of state.motes) {\n    mote.x += mote.vx;\n    mote.y += mote.vy;\n    mote.pulsePhase += 0.02;\n\n    if (mote.x < 0) mote.x = width;\n    if (mote.x > width) mote.x = 0;\n    if (mote.y < 0) mote.y = height;\n    if (mote.y > height) mote.y = 0;\n  }\n}\n\nexport function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n  if (state.ripples.length >= MAX_RIPPLES) {\n    state.ripples.shift();\n  }\n\n  state.ripples.push({\n    x,\n    y,\n    radius: 5,\n    maxRadius: 60,\n    alpha: 0.6,\n    thickness: 2,\n  });\n}\n\nexport function updateRipples(state: CleanEffectsState): void {\n  for (let i = state.ripples.length - 1; i >= 0; i--) {\n    const ripple = state.ripples[i];\n    ripple.radius += 2;\n    ripple.alpha *= 0.94;\n    ripple.thickness *= 0.98;\n\n    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n      state.ripples.splice(i, 1);\n    }\n  }\n}\n\nexport function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function spawnTears(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.tears.length >= MAX_TEARS) {\n      state.tears.shift();\n    }\n    state.tears.push({\n      x: x + (Math.random() - 0.5) * 20,\n      y: y + (Math.random() - 0.5) * 10,\n      vy: 0.5 + Math.random() * 1.5,\n      size: 3 + Math.random() * 3,\n      alpha: 0.7 + Math.random() * 0.3,\n      wobblePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateTears(state: CleanEffectsState, height: number): void {\n  for (let i = state.tears.length - 1; i >= 0; i--) {\n    const tear = state.tears[i];\n    tear.vy += 0.08;\n    tear.y += tear.vy;\n    tear.wobblePhase += 0.1;\n    tear.x += Math.sin(tear.wobblePhase) * 0.3;\n    tear.alpha *= 0.99;\n\n    if (tear.y > height + 10 || tear.alpha < 0.05) {\n      state.tears.splice(i, 1);\n    }\n  }\n}\n\nexport function spawnBlood(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.blood.length >= MAX_BLOOD) {\n      state.blood.shift();\n    }\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 1 + Math.random() * 3;\n    state.blood.push({\n      x,\n      y,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 1,\n      size: 2 + Math.random() * 4,\n      alpha: 0.8 + Math.random() * 0.2,\n      life: 1.0,\n      splashed: false,\n      splashRadius: 0,\n    });\n  }\n}\n\nexport function updateBlood(state: CleanEffectsState, height: number): void {\n  for (let i = state.blood.length - 1; i >= 0; i--) {\n    const drop = state.blood[i];\n\n    if (!drop.splashed) {\n      drop.vy += 0.15;\n      drop.x += drop.vx;\n      drop.y += drop.vy;\n      drop.vx *= 0.98;\n\n      if (drop.y >= height - 5) {\n        drop.splashed = true;\n        drop.y = height - 5;\n        drop.splashRadius = drop.size * 1.5;\n      }\n    } else {\n      drop.splashRadius += 0.3;\n      drop.alpha *= 0.95;\n    }\n\n    drop.life -= 0.015;\n\n    if (drop.life <= 0 || drop.alpha < 0.02) {\n      state.blood.splice(i, 1);\n    }\n  }\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}\n\nexport function drawCleanGrid(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  cellSize: number,\n  gridSize: number,\n  frameCount: number\n): void {\n  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n\n  for (let i = 0; i <= gridSize; i++) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n\n  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n  for (let i = 0; i <= gridSize; i += 5) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n}\n\nexport function drawMotes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const mote of state.motes) {\n    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n    const alpha = mote.alpha * pulse;\n\n    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n    g.fillCircle(mote.x, mote.y, mote.size * 2);\n    g.fillStyle(CLEAN_COLORS.mote, alpha);\n    g.fillCircle(mote.x, mote.y, mote.size);\n  }\n}\n\nexport function drawRipples(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const ripple of state.ripples) {\n    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n\n    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n  }\n}\n\nexport function drawGlowTrail(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const trail of state.glowTrail) {\n    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n    g.fillCircle(trail.x, trail.y, trail.size);\n  }\n}\n\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n  const foodSize = (cellSize / 2 - 2) * pulseScale;\n\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n  g.fillCircle(foodX, foodY, foodSize + 12);\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n  g.fillCircle(foodX, foodY, foodSize + 6);\n\n  g.fillStyle(CLEAN_COLORS.food, 0.9);\n  g.fillCircle(foodX, foodY, foodSize);\n  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n  g.fillCircle(foodX, foodY, foodSize * 0.5);\n\n  g.fillStyle(0xffffff, 0.6);\n  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n}\n\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  const snakeLen = snake.length;\n  if (snakeLen === 0) return;\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n\n    const glowAlpha = 0.15 * (1 - t * 0.5);\n    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n    g.fillCircle(centerX, centerY, glowSize);\n  }\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n\n    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n\n    const r = Math.round(r1 + (r2 - r1) * t);\n    const gVal = Math.round(g1 + (g2 - g1) * t);\n    const b = Math.round(b1 + (b2 - b1) * t);\n    const color = (r << 16) | (gVal << 8) | b;\n\n    g.fillStyle(color, 0.95);\n    g.fillCircle(centerX, centerY, radius);\n\n    if (i === 0) {\n      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n      g.fillCircle(centerX, centerY, radius + 4);\n\n      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n      g.fillCircle(centerX, centerY, radius);\n\n      g.fillStyle(0xffffff, 0.7);\n      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n    }\n  }\n}\n\nexport function drawCleanVignette(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number\n): void {\n  const layers = 4;\n  for (let i = 0; i < layers; i++) {\n    const inset = i * 25;\n    const alpha = 0.08 * (1 - i / layers);\n    g.lineStyle(50, 0x000000, alpha);\n    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n  }\n}\n\nexport function drawTears(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const tear of state.tears) {\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha * 0.3);\n    g.fillCircle(tear.x, tear.y, tear.size * 2);\n\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha);\n    g.fillCircle(tear.x, tear.y - tear.size * 0.3, tear.size);\n    g.fillCircle(tear.x, tear.y + tear.size * 0.5, tear.size * 0.7);\n\n    g.fillStyle(CLEAN_COLORS.tearHighlight, tear.alpha * 0.6);\n    g.fillCircle(tear.x - tear.size * 0.25, tear.y - tear.size * 0.4, tear.size * 0.3);\n  }\n}\n\nexport function drawBlood(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const drop of state.blood) {\n    const effectiveAlpha = drop.alpha * drop.life;\n\n    if (drop.splashed) {\n      g.fillStyle(CLEAN_COLORS.bloodDark, effectiveAlpha * 0.5);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.7);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius * 0.6);\n    } else {\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.4);\n      g.fillCircle(drop.x, drop.y, drop.size * 2);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha);\n      g.fillCircle(drop.x, drop.y, drop.size);\n      g.fillStyle(0xffffff, effectiveAlpha * 0.3);\n      g.fillCircle(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.25);\n    }\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {\n  const padding = 15;\n  const digitSize = 12;\n  const digitSpacing = digitSize * 0.6;\n\n  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n\n  const scoreStr = String(score).padStart(4, '0');\n  let xPos = padding;\n\n  for (let i = 0; i < scoreStr.length; i++) {\n    const digit = scoreStr[i];\n    g.fillStyle(CLEAN_COLORS.text, pulse);\n    drawDigit(g, digit, xPos, padding, digitSize);\n    xPos += digitSpacing;\n  }\n\n  const lengthStr = String(snakeLength);\n  xPos = width - padding - lengthStr.length * digitSpacing;\n\n  for (let i = 0; i < lengthStr.length; i++) {\n    const digit = lengthStr[i];\n    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n    xPos += digitSpacing * 0.9;\n  }\n}\n","structuredPatch":[{"oldStart":99,"oldLines":6,"newStart":99,"newLines":7,"lines":["     glowTrail: [] as SnakeGlowTrail[],","     tears: [] as TearDrop[],","     blood: [] as BloodSplatter[],","+    snowflakes: [] as Snowflake[],","     frameCount: 0,","   };"," }"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VTs4zNNxD55DSaAHNCDEy8","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the Christmas color palette and update the colors."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":424,"cache_read_input_tokens":36457,"cache_creation":{"ephemeral_5m_input_tokens":424,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"ad1d6b3c-afa4-46c9-8432-f3314c5dbe07"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VTs4zNNxD55DSaAHNCDEy8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KaKPaRr9QzWACE9DXHrAKR","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","old_string":"export const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n};","new_string":"export const CLEAN_COLORS = {\n  bgDark: 0x0d1f2d,\n  bgMid: 0x1a3a4a,\n  bgLight: 0x2a5a6a,\n\n  gridLine: 0x1e4a5e,\n  gridAccent: 0x2e6a7e,\n\n  snakeHead: 0xcc2936,\n  snakeBody: 0x228b22,\n  snakeTail: 0x1a6b1a,\n  snakeGlow: 0xff6b6b,\n\n  food: 0xffd700,\n  foodCore: 0xffec8b,\n  foodGlow: 0xffa500,\n\n  ripple: 0xffd700,\n  mote: 0xe8e8e8,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n\n  snow: 0xffffff,\n  snowGlow: 0xe8f4ff,\n};"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":424,"cache_read_input_tokens":36457,"cache_creation":{"ephemeral_5m_input_tokens":424,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"dc85e2b2-517b-416d-a07f-f9a3d5c81494"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KaKPaRr9QzWACE9DXHrAKR","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"171f8d3e-a5c9-4bf8-b438-0437b24944ce","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","oldString":"export const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n};","newString":"export const CLEAN_COLORS = {\n  bgDark: 0x0d1f2d,\n  bgMid: 0x1a3a4a,\n  bgLight: 0x2a5a6a,\n\n  gridLine: 0x1e4a5e,\n  gridAccent: 0x2e6a7e,\n\n  snakeHead: 0xcc2936,\n  snakeBody: 0x228b22,\n  snakeTail: 0x1a6b1a,\n  snakeGlow: 0xff6b6b,\n\n  food: 0xffd700,\n  foodCore: 0xffec8b,\n  foodGlow: 0xffa500,\n\n  ripple: 0xffd700,\n  mote: 0xe8e8e8,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n\n  snow: 0xffffff,\n  snowGlow: 0xe8f4ff,\n};","originalFile":"export interface CleanRipple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport interface FloatingMote {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  pulsePhase: number;\n}\n\nexport interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport interface TearDrop {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n}\n\nexport interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}\n\nexport interface Snowflake {\n  x: number;\n  y: number;\n  vy: number;\n  vx: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n  wobbleSpeed: number;\n}\n\nexport const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n};\n\nconst MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;\nconst MAX_SNOWFLAKES = 30;\n\nexport function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    snowflakes: [] as Snowflake[],\n    frameCount: 0,\n  };\n}\n\nexport type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n\nexport function initMotes(state: CleanEffectsState, width: number, height: number): void {\n  state.motes = [];\n  for (let i = 0; i < MAX_MOTES; i++) {\n    state.motes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: (Math.random() - 0.5) * 0.3,\n      vy: (Math.random() - 0.5) * 0.3,\n      size: 1 + Math.random() * 2,\n      alpha: 0.1 + Math.random() * 0.2,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n  for (const mote of state.motes) {\n    mote.x += mote.vx;\n    mote.y += mote.vy;\n    mote.pulsePhase += 0.02;\n\n    if (mote.x < 0) mote.x = width;\n    if (mote.x > width) mote.x = 0;\n    if (mote.y < 0) mote.y = height;\n    if (mote.y > height) mote.y = 0;\n  }\n}\n\nexport function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n  if (state.ripples.length >= MAX_RIPPLES) {\n    state.ripples.shift();\n  }\n\n  state.ripples.push({\n    x,\n    y,\n    radius: 5,\n    maxRadius: 60,\n    alpha: 0.6,\n    thickness: 2,\n  });\n}\n\nexport function updateRipples(state: CleanEffectsState): void {\n  for (let i = state.ripples.length - 1; i >= 0; i--) {\n    const ripple = state.ripples[i];\n    ripple.radius += 2;\n    ripple.alpha *= 0.94;\n    ripple.thickness *= 0.98;\n\n    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n      state.ripples.splice(i, 1);\n    }\n  }\n}\n\nexport function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function spawnTears(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.tears.length >= MAX_TEARS) {\n      state.tears.shift();\n    }\n    state.tears.push({\n      x: x + (Math.random() - 0.5) * 20,\n      y: y + (Math.random() - 0.5) * 10,\n      vy: 0.5 + Math.random() * 1.5,\n      size: 3 + Math.random() * 3,\n      alpha: 0.7 + Math.random() * 0.3,\n      wobblePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateTears(state: CleanEffectsState, height: number): void {\n  for (let i = state.tears.length - 1; i >= 0; i--) {\n    const tear = state.tears[i];\n    tear.vy += 0.08;\n    tear.y += tear.vy;\n    tear.wobblePhase += 0.1;\n    tear.x += Math.sin(tear.wobblePhase) * 0.3;\n    tear.alpha *= 0.99;\n\n    if (tear.y > height + 10 || tear.alpha < 0.05) {\n      state.tears.splice(i, 1);\n    }\n  }\n}\n\nexport function spawnBlood(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.blood.length >= MAX_BLOOD) {\n      state.blood.shift();\n    }\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 1 + Math.random() * 3;\n    state.blood.push({\n      x,\n      y,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 1,\n      size: 2 + Math.random() * 4,\n      alpha: 0.8 + Math.random() * 0.2,\n      life: 1.0,\n      splashed: false,\n      splashRadius: 0,\n    });\n  }\n}\n\nexport function updateBlood(state: CleanEffectsState, height: number): void {\n  for (let i = state.blood.length - 1; i >= 0; i--) {\n    const drop = state.blood[i];\n\n    if (!drop.splashed) {\n      drop.vy += 0.15;\n      drop.x += drop.vx;\n      drop.y += drop.vy;\n      drop.vx *= 0.98;\n\n      if (drop.y >= height - 5) {\n        drop.splashed = true;\n        drop.y = height - 5;\n        drop.splashRadius = drop.size * 1.5;\n      }\n    } else {\n      drop.splashRadius += 0.3;\n      drop.alpha *= 0.95;\n    }\n\n    drop.life -= 0.015;\n\n    if (drop.life <= 0 || drop.alpha < 0.02) {\n      state.blood.splice(i, 1);\n    }\n  }\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}\n\nexport function drawCleanGrid(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  cellSize: number,\n  gridSize: number,\n  frameCount: number\n): void {\n  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n\n  for (let i = 0; i <= gridSize; i++) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n\n  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n  for (let i = 0; i <= gridSize; i += 5) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n}\n\nexport function drawMotes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const mote of state.motes) {\n    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n    const alpha = mote.alpha * pulse;\n\n    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n    g.fillCircle(mote.x, mote.y, mote.size * 2);\n    g.fillStyle(CLEAN_COLORS.mote, alpha);\n    g.fillCircle(mote.x, mote.y, mote.size);\n  }\n}\n\nexport function drawRipples(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const ripple of state.ripples) {\n    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n\n    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n  }\n}\n\nexport function drawGlowTrail(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const trail of state.glowTrail) {\n    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n    g.fillCircle(trail.x, trail.y, trail.size);\n  }\n}\n\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n  const foodSize = (cellSize / 2 - 2) * pulseScale;\n\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n  g.fillCircle(foodX, foodY, foodSize + 12);\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n  g.fillCircle(foodX, foodY, foodSize + 6);\n\n  g.fillStyle(CLEAN_COLORS.food, 0.9);\n  g.fillCircle(foodX, foodY, foodSize);\n  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n  g.fillCircle(foodX, foodY, foodSize * 0.5);\n\n  g.fillStyle(0xffffff, 0.6);\n  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n}\n\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  const snakeLen = snake.length;\n  if (snakeLen === 0) return;\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n\n    const glowAlpha = 0.15 * (1 - t * 0.5);\n    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n    g.fillCircle(centerX, centerY, glowSize);\n  }\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n\n    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n\n    const r = Math.round(r1 + (r2 - r1) * t);\n    const gVal = Math.round(g1 + (g2 - g1) * t);\n    const b = Math.round(b1 + (b2 - b1) * t);\n    const color = (r << 16) | (gVal << 8) | b;\n\n    g.fillStyle(color, 0.95);\n    g.fillCircle(centerX, centerY, radius);\n\n    if (i === 0) {\n      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n      g.fillCircle(centerX, centerY, radius + 4);\n\n      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n      g.fillCircle(centerX, centerY, radius);\n\n      g.fillStyle(0xffffff, 0.7);\n      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n    }\n  }\n}\n\nexport function drawCleanVignette(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number\n): void {\n  const layers = 4;\n  for (let i = 0; i < layers; i++) {\n    const inset = i * 25;\n    const alpha = 0.08 * (1 - i / layers);\n    g.lineStyle(50, 0x000000, alpha);\n    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n  }\n}\n\nexport function drawTears(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const tear of state.tears) {\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha * 0.3);\n    g.fillCircle(tear.x, tear.y, tear.size * 2);\n\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha);\n    g.fillCircle(tear.x, tear.y - tear.size * 0.3, tear.size);\n    g.fillCircle(tear.x, tear.y + tear.size * 0.5, tear.size * 0.7);\n\n    g.fillStyle(CLEAN_COLORS.tearHighlight, tear.alpha * 0.6);\n    g.fillCircle(tear.x - tear.size * 0.25, tear.y - tear.size * 0.4, tear.size * 0.3);\n  }\n}\n\nexport function drawBlood(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const drop of state.blood) {\n    const effectiveAlpha = drop.alpha * drop.life;\n\n    if (drop.splashed) {\n      g.fillStyle(CLEAN_COLORS.bloodDark, effectiveAlpha * 0.5);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.7);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius * 0.6);\n    } else {\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.4);\n      g.fillCircle(drop.x, drop.y, drop.size * 2);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha);\n      g.fillCircle(drop.x, drop.y, drop.size);\n      g.fillStyle(0xffffff, effectiveAlpha * 0.3);\n      g.fillCircle(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.25);\n    }\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {\n  const padding = 15;\n  const digitSize = 12;\n  const digitSpacing = digitSize * 0.6;\n\n  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n\n  const scoreStr = String(score).padStart(4, '0');\n  let xPos = padding;\n\n  for (let i = 0; i < scoreStr.length; i++) {\n    const digit = scoreStr[i];\n    g.fillStyle(CLEAN_COLORS.text, pulse);\n    drawDigit(g, digit, xPos, padding, digitSize);\n    xPos += digitSpacing;\n  }\n\n  const lengthStr = String(snakeLength);\n  xPos = width - padding - lengthStr.length * digitSpacing;\n\n  for (let i = 0; i < lengthStr.length; i++) {\n    const digit = lengthStr[i];\n    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n    xPos += digitSpacing * 0.9;\n  }\n}\n","structuredPatch":[{"oldStart":57,"oldLines":24,"newStart":57,"newLines":24,"lines":[" }"," "," export const CLEAN_COLORS = {","-  bgDark: 0x0a1628,","-  bgMid: 0x0f1d32,","-  bgLight: 0x14253e,","+  bgDark: 0x0d1f2d,","+  bgMid: 0x1a3a4a,","+  bgLight: 0x2a5a6a,"," ","-  gridLine: 0x1a3050,","-  gridAccent: 0x254060,","+  gridLine: 0x1e4a5e,","+  gridAccent: 0x2e6a7e,"," ","-  snakeHead: 0x4fd1c5,","-  snakeBody: 0x38b2ac,","-  snakeTail: 0x2c9a94,","-  snakeGlow: 0x81e6d9,","+  snakeHead: 0xcc2936,","+  snakeBody: 0x228b22,","+  snakeTail: 0x1a6b1a,","+  snakeGlow: 0xff6b6b,"," ","-  food: 0xe2e8f0,","-  foodCore: 0xffffff,","-  foodGlow: 0xcbd5e1,","+  food: 0xffd700,","+  foodCore: 0xffec8b,","+  foodGlow: 0xffa500,"," ","-  ripple: 0x81e6d9,","-  mote: 0x4fd1c5,","+  ripple: 0xffd700,","+  mote: 0xe8e8e8,"," ","   text: 0xe2e8f0,","   textDim: 0x94a3b8,"]},{"oldStart":83,"oldLines":6,"newStart":83,"newLines":9,"lines":["   bloodDark: 0x991b1b,","   tear: 0x60a5fa,","   tearHighlight: 0x93c5fd,","+","+  snow: 0xffffff,","+  snowGlow: 0xe8f4ff,"," };"," "," const MAX_RIPPLES = 5;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KNtHp9k4ZtcG2vZMkpo1G7","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the snowflake initialization, update, and draw functions. I'll add them after the blood functions."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":821,"cache_read_input_tokens":36881,"cache_creation":{"ephemeral_5m_input_tokens":821,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"4d07521e-7b1e-4736-a5da-d58f93b86844"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KNtHp9k4ZtcG2vZMkpo1G7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016t5rS1hpQH8NxUiLDNUjb5","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","old_string":"export function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}","new_string":"export function initSnowflakes(state: CleanEffectsState, width: number, height: number): void {\n  state.snowflakes = [];\n  for (let i = 0; i < MAX_SNOWFLAKES; i++) {\n    state.snowflakes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vy: 0.3 + Math.random() * 0.7,\n      vx: (Math.random() - 0.5) * 0.2,\n      size: 1 + Math.random() * 3,\n      alpha: 0.3 + Math.random() * 0.5,\n      wobblePhase: Math.random() * Math.PI * 2,\n      wobbleSpeed: 0.02 + Math.random() * 0.03,\n    });\n  }\n}\n\nexport function updateSnowflakes(state: CleanEffectsState, width: number, height: number): void {\n  for (const flake of state.snowflakes) {\n    flake.wobblePhase += flake.wobbleSpeed;\n    flake.x += flake.vx + Math.sin(flake.wobblePhase) * 0.5;\n    flake.y += flake.vy;\n\n    if (flake.y > height + 10) {\n      flake.y = -10;\n      flake.x = Math.random() * width;\n    }\n    if (flake.x < -10) flake.x = width + 10;\n    if (flake.x > width + 10) flake.x = -10;\n  }\n}\n\nexport function drawSnowflakes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const flake of state.snowflakes) {\n    g.fillStyle(CLEAN_COLORS.snowGlow, flake.alpha * 0.3);\n    g.fillCircle(flake.x, flake.y, flake.size * 2);\n\n    g.fillStyle(CLEAN_COLORS.snow, flake.alpha);\n    g.fillCircle(flake.x, flake.y, flake.size);\n  }\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":821,"cache_read_input_tokens":36881,"cache_creation":{"ephemeral_5m_input_tokens":821,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"7437130b-22fc-43c3-8d5e-5204b5084fef"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016t5rS1hpQH8NxUiLDNUjb5","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"8ec6bca0-43c3-4800-8643-9a6c41cbf163","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","oldString":"export function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}","newString":"export function initSnowflakes(state: CleanEffectsState, width: number, height: number): void {\n  state.snowflakes = [];\n  for (let i = 0; i < MAX_SNOWFLAKES; i++) {\n    state.snowflakes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vy: 0.3 + Math.random() * 0.7,\n      vx: (Math.random() - 0.5) * 0.2,\n      size: 1 + Math.random() * 3,\n      alpha: 0.3 + Math.random() * 0.5,\n      wobblePhase: Math.random() * Math.PI * 2,\n      wobbleSpeed: 0.02 + Math.random() * 0.03,\n    });\n  }\n}\n\nexport function updateSnowflakes(state: CleanEffectsState, width: number, height: number): void {\n  for (const flake of state.snowflakes) {\n    flake.wobblePhase += flake.wobbleSpeed;\n    flake.x += flake.vx + Math.sin(flake.wobblePhase) * 0.5;\n    flake.y += flake.vy;\n\n    if (flake.y > height + 10) {\n      flake.y = -10;\n      flake.x = Math.random() * width;\n    }\n    if (flake.x < -10) flake.x = width + 10;\n    if (flake.x > width + 10) flake.x = -10;\n  }\n}\n\nexport function drawSnowflakes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const flake of state.snowflakes) {\n    g.fillStyle(CLEAN_COLORS.snowGlow, flake.alpha * 0.3);\n    g.fillCircle(flake.x, flake.y, flake.size * 2);\n\n    g.fillStyle(CLEAN_COLORS.snow, flake.alpha);\n    g.fillCircle(flake.x, flake.y, flake.size);\n  }\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}","originalFile":"export interface CleanRipple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport interface FloatingMote {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  pulsePhase: number;\n}\n\nexport interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport interface TearDrop {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n}\n\nexport interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}\n\nexport interface Snowflake {\n  x: number;\n  y: number;\n  vy: number;\n  vx: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n  wobbleSpeed: number;\n}\n\nexport const CLEAN_COLORS = {\n  bgDark: 0x0d1f2d,\n  bgMid: 0x1a3a4a,\n  bgLight: 0x2a5a6a,\n\n  gridLine: 0x1e4a5e,\n  gridAccent: 0x2e6a7e,\n\n  snakeHead: 0xcc2936,\n  snakeBody: 0x228b22,\n  snakeTail: 0x1a6b1a,\n  snakeGlow: 0xff6b6b,\n\n  food: 0xffd700,\n  foodCore: 0xffec8b,\n  foodGlow: 0xffa500,\n\n  ripple: 0xffd700,\n  mote: 0xe8e8e8,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n\n  snow: 0xffffff,\n  snowGlow: 0xe8f4ff,\n};\n\nconst MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;\nconst MAX_SNOWFLAKES = 30;\n\nexport function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    snowflakes: [] as Snowflake[],\n    frameCount: 0,\n  };\n}\n\nexport type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n\nexport function initMotes(state: CleanEffectsState, width: number, height: number): void {\n  state.motes = [];\n  for (let i = 0; i < MAX_MOTES; i++) {\n    state.motes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: (Math.random() - 0.5) * 0.3,\n      vy: (Math.random() - 0.5) * 0.3,\n      size: 1 + Math.random() * 2,\n      alpha: 0.1 + Math.random() * 0.2,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n  for (const mote of state.motes) {\n    mote.x += mote.vx;\n    mote.y += mote.vy;\n    mote.pulsePhase += 0.02;\n\n    if (mote.x < 0) mote.x = width;\n    if (mote.x > width) mote.x = 0;\n    if (mote.y < 0) mote.y = height;\n    if (mote.y > height) mote.y = 0;\n  }\n}\n\nexport function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n  if (state.ripples.length >= MAX_RIPPLES) {\n    state.ripples.shift();\n  }\n\n  state.ripples.push({\n    x,\n    y,\n    radius: 5,\n    maxRadius: 60,\n    alpha: 0.6,\n    thickness: 2,\n  });\n}\n\nexport function updateRipples(state: CleanEffectsState): void {\n  for (let i = state.ripples.length - 1; i >= 0; i--) {\n    const ripple = state.ripples[i];\n    ripple.radius += 2;\n    ripple.alpha *= 0.94;\n    ripple.thickness *= 0.98;\n\n    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n      state.ripples.splice(i, 1);\n    }\n  }\n}\n\nexport function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function spawnTears(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.tears.length >= MAX_TEARS) {\n      state.tears.shift();\n    }\n    state.tears.push({\n      x: x + (Math.random() - 0.5) * 20,\n      y: y + (Math.random() - 0.5) * 10,\n      vy: 0.5 + Math.random() * 1.5,\n      size: 3 + Math.random() * 3,\n      alpha: 0.7 + Math.random() * 0.3,\n      wobblePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateTears(state: CleanEffectsState, height: number): void {\n  for (let i = state.tears.length - 1; i >= 0; i--) {\n    const tear = state.tears[i];\n    tear.vy += 0.08;\n    tear.y += tear.vy;\n    tear.wobblePhase += 0.1;\n    tear.x += Math.sin(tear.wobblePhase) * 0.3;\n    tear.alpha *= 0.99;\n\n    if (tear.y > height + 10 || tear.alpha < 0.05) {\n      state.tears.splice(i, 1);\n    }\n  }\n}\n\nexport function spawnBlood(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.blood.length >= MAX_BLOOD) {\n      state.blood.shift();\n    }\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 1 + Math.random() * 3;\n    state.blood.push({\n      x,\n      y,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 1,\n      size: 2 + Math.random() * 4,\n      alpha: 0.8 + Math.random() * 0.2,\n      life: 1.0,\n      splashed: false,\n      splashRadius: 0,\n    });\n  }\n}\n\nexport function updateBlood(state: CleanEffectsState, height: number): void {\n  for (let i = state.blood.length - 1; i >= 0; i--) {\n    const drop = state.blood[i];\n\n    if (!drop.splashed) {\n      drop.vy += 0.15;\n      drop.x += drop.vx;\n      drop.y += drop.vy;\n      drop.vx *= 0.98;\n\n      if (drop.y >= height - 5) {\n        drop.splashed = true;\n        drop.y = height - 5;\n        drop.splashRadius = drop.size * 1.5;\n      }\n    } else {\n      drop.splashRadius += 0.3;\n      drop.alpha *= 0.95;\n    }\n\n    drop.life -= 0.015;\n\n    if (drop.life <= 0 || drop.alpha < 0.02) {\n      state.blood.splice(i, 1);\n    }\n  }\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}\n\nexport function drawCleanGrid(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  cellSize: number,\n  gridSize: number,\n  frameCount: number\n): void {\n  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n\n  for (let i = 0; i <= gridSize; i++) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n\n  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n  for (let i = 0; i <= gridSize; i += 5) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n}\n\nexport function drawMotes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const mote of state.motes) {\n    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n    const alpha = mote.alpha * pulse;\n\n    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n    g.fillCircle(mote.x, mote.y, mote.size * 2);\n    g.fillStyle(CLEAN_COLORS.mote, alpha);\n    g.fillCircle(mote.x, mote.y, mote.size);\n  }\n}\n\nexport function drawRipples(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const ripple of state.ripples) {\n    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n\n    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n  }\n}\n\nexport function drawGlowTrail(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const trail of state.glowTrail) {\n    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n    g.fillCircle(trail.x, trail.y, trail.size);\n  }\n}\n\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n  const foodSize = (cellSize / 2 - 2) * pulseScale;\n\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n  g.fillCircle(foodX, foodY, foodSize + 12);\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n  g.fillCircle(foodX, foodY, foodSize + 6);\n\n  g.fillStyle(CLEAN_COLORS.food, 0.9);\n  g.fillCircle(foodX, foodY, foodSize);\n  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n  g.fillCircle(foodX, foodY, foodSize * 0.5);\n\n  g.fillStyle(0xffffff, 0.6);\n  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n}\n\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  const snakeLen = snake.length;\n  if (snakeLen === 0) return;\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n\n    const glowAlpha = 0.15 * (1 - t * 0.5);\n    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n    g.fillCircle(centerX, centerY, glowSize);\n  }\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n\n    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n\n    const r = Math.round(r1 + (r2 - r1) * t);\n    const gVal = Math.round(g1 + (g2 - g1) * t);\n    const b = Math.round(b1 + (b2 - b1) * t);\n    const color = (r << 16) | (gVal << 8) | b;\n\n    g.fillStyle(color, 0.95);\n    g.fillCircle(centerX, centerY, radius);\n\n    if (i === 0) {\n      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n      g.fillCircle(centerX, centerY, radius + 4);\n\n      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n      g.fillCircle(centerX, centerY, radius);\n\n      g.fillStyle(0xffffff, 0.7);\n      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n    }\n  }\n}\n\nexport function drawCleanVignette(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number\n): void {\n  const layers = 4;\n  for (let i = 0; i < layers; i++) {\n    const inset = i * 25;\n    const alpha = 0.08 * (1 - i / layers);\n    g.lineStyle(50, 0x000000, alpha);\n    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n  }\n}\n\nexport function drawTears(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const tear of state.tears) {\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha * 0.3);\n    g.fillCircle(tear.x, tear.y, tear.size * 2);\n\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha);\n    g.fillCircle(tear.x, tear.y - tear.size * 0.3, tear.size);\n    g.fillCircle(tear.x, tear.y + tear.size * 0.5, tear.size * 0.7);\n\n    g.fillStyle(CLEAN_COLORS.tearHighlight, tear.alpha * 0.6);\n    g.fillCircle(tear.x - tear.size * 0.25, tear.y - tear.size * 0.4, tear.size * 0.3);\n  }\n}\n\nexport function drawBlood(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const drop of state.blood) {\n    const effectiveAlpha = drop.alpha * drop.life;\n\n    if (drop.splashed) {\n      g.fillStyle(CLEAN_COLORS.bloodDark, effectiveAlpha * 0.5);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.7);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius * 0.6);\n    } else {\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.4);\n      g.fillCircle(drop.x, drop.y, drop.size * 2);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha);\n      g.fillCircle(drop.x, drop.y, drop.size);\n      g.fillStyle(0xffffff, effectiveAlpha * 0.3);\n      g.fillCircle(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.25);\n    }\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {\n  const padding = 15;\n  const digitSize = 12;\n  const digitSpacing = digitSize * 0.6;\n\n  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n\n  const scoreStr = String(score).padStart(4, '0');\n  let xPos = padding;\n\n  for (let i = 0; i < scoreStr.length; i++) {\n    const digit = scoreStr[i];\n    g.fillStyle(CLEAN_COLORS.text, pulse);\n    drawDigit(g, digit, xPos, padding, digitSize);\n    xPos += digitSpacing;\n  }\n\n  const lengthStr = String(snakeLength);\n  xPos = width - padding - lengthStr.length * digitSpacing;\n\n  for (let i = 0; i < lengthStr.length; i++) {\n    const digit = lengthStr[i];\n    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n    xPos += digitSpacing * 0.9;\n  }\n}\n","structuredPatch":[{"oldStart":270,"oldLines":6,"newStart":270,"newLines":50,"lines":["   }"," }"," ","+export function initSnowflakes(state: CleanEffectsState, width: number, height: number): void {","+  state.snowflakes = [];","+  for (let i = 0; i < MAX_SNOWFLAKES; i++) {","+    state.snowflakes.push({","+      x: Math.random() * width,","+      y: Math.random() * height,","+      vy: 0.3 + Math.random() * 0.7,","+      vx: (Math.random() - 0.5) * 0.2,","+      size: 1 + Math.random() * 3,","+      alpha: 0.3 + Math.random() * 0.5,","+      wobblePhase: Math.random() * Math.PI * 2,","+      wobbleSpeed: 0.02 + Math.random() * 0.03,","+    });","+  }","+}","+","+export function updateSnowflakes(state: CleanEffectsState, width: number, height: number): void {","+  for (const flake of state.snowflakes) {","+    flake.wobblePhase += flake.wobbleSpeed;","+    flake.x += flake.vx + Math.sin(flake.wobblePhase) * 0.5;","+    flake.y += flake.vy;","+","+    if (flake.y > height + 10) {","+      flake.y = -10;","+      flake.x = Math.random() * width;","+    }","+    if (flake.x < -10) flake.x = width + 10;","+    if (flake.x > width + 10) flake.x = -10;","+  }","+}","+","+export function drawSnowflakes(","+  g: Phaser.GameObjects.Graphics,","+  state: CleanEffectsState","+): void {","+  for (const flake of state.snowflakes) {","+    g.fillStyle(CLEAN_COLORS.snowGlow, flake.alpha * 0.3);","+    g.fillCircle(flake.x, flake.y, flake.size * 2);","+","+    g.fillStyle(CLEAN_COLORS.snow, flake.alpha);","+    g.fillCircle(flake.x, flake.y, flake.size);","+  }","+}","+"," export function drawCleanBackground(","   g: Phaser.GameObjects.Graphics,","   width: number,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PZF8i4nxiCykpfkj97eggn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Qc2uJ3gMF28mwB2Ut8MWFv","name":"TodoWrite","input":{"todos":[{"content":"Add snowflake particle interface and state to cleanEffects.ts","status":"completed","activeForm":"Adding snowflake particle interface and state"},{"content":"Create snowflake update and draw functions","status":"completed","activeForm":"Creating snowflake update and draw functions"},{"content":"Update Christmas color palette for food and snake","status":"completed","activeForm":"Updating Christmas color palette"},{"content":"Import and integrate snowflakes in SnakeScene.ts","status":"in_progress","activeForm":"Importing and integrating snowflakes"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1213,"cache_read_input_tokens":37702,"cache_creation":{"ephemeral_5m_input_tokens":1213,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"25da0879-8cab-4162-95aa-eebcb517522b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Qc2uJ3gMF28mwB2Ut8MWFv","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"207fb985-31c0-4c0b-b647-b7f8bb55ed20","tool_use_result":{"oldTodos":[{"content":"Add snowflake particle interface and state to cleanEffects.ts","status":"in_progress","activeForm":"Adding snowflake particle interface and state"},{"content":"Create snowflake update and draw functions","status":"pending","activeForm":"Creating snowflake update and draw functions"},{"content":"Update Christmas color palette for food and snake","status":"pending","activeForm":"Updating Christmas color palette"},{"content":"Import and integrate snowflakes in SnakeScene.ts","status":"pending","activeForm":"Importing and integrating snowflakes"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}],"newTodos":[{"content":"Add snowflake particle interface and state to cleanEffects.ts","status":"completed","activeForm":"Adding snowflake particle interface and state"},{"content":"Create snowflake update and draw functions","status":"completed","activeForm":"Creating snowflake update and draw functions"},{"content":"Update Christmas color palette for food and snake","status":"completed","activeForm":"Updating Christmas color palette"},{"content":"Import and integrate snowflakes in SnakeScene.ts","status":"in_progress","activeForm":"Importing and integrating snowflakes"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Mvo8wZfnxvpffQkcASWqYv","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to integrate the snowflakes into SnakeScene.ts. Let me see the imports first and update them."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":333,"cache_read_input_tokens":38915,"cache_creation":{"ephemeral_5m_input_tokens":333,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"8d21b658-4cee-4a5d-9ec0-691e5891df56"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Mvo8wZfnxvpffQkcASWqYv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JDmnBYyxznf2dQMGQ1EJVM","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":1,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":333,"cache_read_input_tokens":38915,"cache_creation":{"ephemeral_5m_input_tokens":333,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"47e18269-d8a4-46be-b246-62cbac5fbd87"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JDmnBYyxznf2dQMGQ1EJVM","type":"tool_result","content":"     1→import Phaser from 'phaser';\n     2→import {\n     3→  createCleanEffectsState,\n     4→  initMotes,\n     5→  updateMotes,\n     6→  updateRipples,\n     7→  updateGlowTrail,\n     8→  spawnRipple,\n     9→  spawnTears,\n    10→  spawnBlood,\n    11→  updateTears,\n    12→  updateBlood,\n    13→  drawCleanBackground,\n    14→  drawCleanGrid,\n    15→  drawMotes,\n    16→  drawRipples,\n    17→  drawGlowTrail,\n    18→  drawCleanFood,\n    19→  drawCleanSnake,\n    20→  drawCleanVignette,\n    21→  drawCleanHUD,\n    22→  drawTears,\n    23→  drawBlood,\n    24→  CLEAN_COLORS,\n    25→  CleanEffectsState,\n    26→} from './cleanEffects';\n    27→\n    28→interface Position {\n    29→  x: number;\n    30→  y: number;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"90f48f2c-e6bc-47e0-88d4-bbc35d496d0b","tool_use_result":{"type":"text","file":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","content":"import Phaser from 'phaser';\nimport {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';\n\ninterface Position {\n  x: number;\n  y: number;","numLines":30,"startLine":1,"totalLines":4143}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JGJf49isRT6RN7Bkok9yna","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HW7eejMu8DHj84jrSLoQGe","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","old_string":"import {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';","new_string":"import {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  initSnowflakes,\n  updateSnowflakes,\n  drawSnowflakes,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":560,"cache_read_input_tokens":39248,"cache_creation":{"ephemeral_5m_input_tokens":560,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"bb9050a8-ad6a-47dc-affc-f12ac04afb74"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HW7eejMu8DHj84jrSLoQGe","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"5e5bcace-867b-404f-9659-e2020a6d84f9","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","oldString":"import {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';","newString":"import {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  initSnowflakes,\n  updateSnowflakes,\n  drawSnowflakes,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';","originalFile":"import Phaser from 'phaser';\nimport {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface GameState {\n  snake: Position[];\n  food: Position;\n  gameOver: boolean;\n  gameStarted?: boolean;\n  score?: number;\n}\n\ninterface Star {\n  x: number;\n  y: number;\n  size: number;\n  speed: number;\n  brightness: number;\n}\n\ninterface PlasmaWave {\n  phase: number;\n  speed: number;\n  amplitude: number;\n  wavelength: number;\n  hue: number;\n}\n\ninterface AuroraWave {\n  y: number;\n  phase: number;\n  speed: number;\n  hue: number;\n  thickness: number;\n  amplitude: number;\n}\n\ninterface NebulaCloud {\n  x: number;\n  y: number;\n  radius: number;\n  hue: number;\n  alpha: number;\n  driftX: number;\n  driftY: number;\n  pulsePhase: number;\n  pulseSpeed: number;\n}\n\ninterface VortexRing {\n  radius: number;\n  baseRadius: number;\n  rotationOffset: number;\n  rotationSpeed: number;\n  thickness: number;\n  hue: number;\n  pulsePhase: number;\n}\n\ninterface VortexParticle {\n  angle: number;\n  radius: number;\n  baseRadius: number;\n  speed: number;\n  size: number;\n  hue: number;\n  alpha: number;\n}\n\ninterface SnakeAfterimage {\n  segments: Position[];\n  life: number;\n  maxLife: number;\n  hueOffset: number;\n}\n\ninterface FoodParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n}\n\ninterface SnakeTrailParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n  hue: number;\n}\n\ninterface ShockWave {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n}\n\ninterface LightningBolt {\n  points: { x: number; y: number }[];\n  life: number;\n  maxLife: number;\n  hue: number;\n}\n\nconst CELL_SIZE = 20;\nconst GRID_SIZE = 20;\nconst NUM_STARS = 30;\nconst MAX_FOOD_PARTICLES = 8;\nconst MAX_TRAIL_PARTICLES = 40;\nconst MAX_SHOCKWAVES = 3;\nconst MAX_LIGHTNING_BOLTS = 5;\nconst MAX_BURST_PARTICLES = 12;\nconst NUM_PLASMA_WAVES = 3;\nconst MAX_AFTERIMAGES = 4;\nconst NUM_AURORA_WAVES = 5;\nconst NUM_NEBULA_CLOUDS = 6;\nconst NUM_VORTEX_RINGS = 5;\nconst NUM_VORTEX_PARTICLES = 20;\nconst NUM_METEORS = 8;\nconst MAX_DEATH_DEBRIS = 24;\nconst NUM_SPIRITS_PER_EDGE = 2;\nconst MAX_FLAME_PARTICLES = 60;\nconst MAX_COMET_TRAIL_LENGTH = 30;\nconst MAX_ETHEREAL_PARTICLES = 50;\nconst NUM_BEES = 8;\nconst BEE_SPAWN_CHANCE = 0.02;\n\n// Comet trail segment - stores historical snake positions for smooth trail rendering\ninterface CometTrailSegment {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n  hue: number;\n}\n\n// Ethereal trail particle - luminous particles that drift away from trail\ninterface EtherealParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n  pulsePhase: number;\n}\n\n// Thrown food animation - food launched onto screen with arc trajectory\ninterface ThrownFood {\n  startX: number;\n  startY: number;\n  targetX: number;\n  targetY: number;\n  x: number;\n  y: number;\n  progress: number; // 0 to 1\n  rotation: number;\n  rotationSpeed: number;\n  trail: { x: number; y: number; alpha: number; rotation: number }[];\n  landed: boolean;\n  landingParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number }[];\n  impactRings: { radius: number; alpha: number }[];\n}\n\n// Meteor shower types\ninterface Meteor {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  alpha: number;\n  trail: { x: number; y: number; alpha: number }[];\n  life: number;\n}\n\n// Death debris particle\ninterface DeathDebris {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  rotation: number;\n  rotationSpeed: number;\n  life: number;\n  type: 'shard' | 'spark' | 'ember';\n}\n\n// Guardian spirit - ethereal protectors at edges\ninterface GuardianSpirit {\n  x: number;\n  y: number;\n  baseX: number;\n  baseY: number;\n  size: number;\n  phase: number;\n  speed: number;\n  haloPhase: number;\n  orbPhase: number;\n  edge: 'top' | 'bottom' | 'left' | 'right';\n  targetAlpha: number;\n  currentAlpha: number;\n  hue: number;\n  orbs: { angle: number; distance: number; size: number; speed: number }[];\n}\n\n// Flame particle for burning effect\ninterface FlameParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n}\n\n// Mystical bee - glowing magical creatures that swarm around food\ninterface MysticalBee {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  targetX: number;\n  targetY: number;\n  wingPhase: number;\n  wingSpeed: number;\n  size: number;\n  hue: number;\n  glowIntensity: number;\n  bobPhase: number;\n  bobSpeed: number;\n  trail: { x: number; y: number; alpha: number }[];\n  state: 'flying' | 'hovering' | 'attracted';\n  sparkleTimer: number;\n}\n\n// Rival snake - spectral AI nemesis that competes for food\ninterface RivalSnake {\n  segments: { x: number; y: number }[];\n  direction: { dx: number; dy: number };\n  targetX: number;\n  targetY: number;\n  moveTimer: number;\n  moveInterval: number;\n  pulsePhase: number;\n  glowIntensity: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n  energyTrail: { x: number; y: number; alpha: number; size: number }[];\n  state: 'hunting' | 'fleeing' | 'circling';\n  aggression: number;\n  nearMissTimer: number;\n  electricArcs: { x1: number; y1: number; x2: number; y2: number; life: number }[];\n}\n\nconst RIVAL_SNAKE_LENGTH = 10;\nconst RIVAL_MOVE_INTERVAL = 8;\n\n// Armageddon Chaos effect types\ninterface GroundFissure {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  width: number;\n  glowIntensity: number;\n  pulsePhase: number;\n}\n\ninterface FireRainParticle {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n}\n\ninterface ChaosExplosion {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n  rings: { radius: number; alpha: number }[];\n  debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[];\n}\n\ninterface ApocalypticSkull {\n  x: number;\n  y: number;\n  size: number;\n  alpha: number;\n  rotation: number;\n  pulsePhase: number;\n}\n\nconst NUM_FISSURES = 6;\nconst MAX_FIRE_RAIN = 30;\nconst MAX_CHAOS_EXPLOSIONS = 3;\nconst NUM_SKULLS = 4;\n\n// High score entry for scoreboard\ninterface HighScoreEntry {\n  score: number;\n  date: number;\n  rank: number;\n}\n\nconst MAX_HIGH_SCORES = 5;\n\n// Color palette - HALLOWEEN theme: spooky purple/orange, ghostly greens, pumpkin glow\nconst COLORS = {\n  bgDark: 0x0a0012,\n  bgMid: 0x150825,\n  gridLine: 0x2a1540,\n  gridAccent: 0x401860,\n  snakeHead: 0x00ff66,\n  snakeBody: 0x00cc55,\n  snakeTail: 0x009944,\n  snakeHighlight: 0x66ffaa,\n  snakeScale: 0x00aa44,\n  snakeEye: 0xff0000,\n  snakePupil: 0x000000,\n  snakeGlow: 0x00ff80,\n  food: 0xff6600,\n  foodCore: 0xffcc00,\n  foodGlow: 0xff8800,\n  foodParticle: 0xffaa00,\n  star: 0x8844ff,\n  gameOverOverlay: 0x0a0015,\n  gameOverText: 0xff6600,\n  plasma1: 0x9933ff,\n  plasma2: 0xbb55ff,\n  plasma3: 0x7722cc,\n  screenFlash: 0xff6600,\n  // Halloween specific colors\n  noirWhite: 0xeeddff,\n  noirGray: 0x8866aa,\n  noirDark: 0x2a1540,\n  spotlight: 0xff8800,\n  // Halloween additions\n  chaosRed: 0x9933ff,\n  chaosOrange: 0xff6600,\n  chaosYellow: 0xffcc00,\n  lavaGlow: 0x9944ff,\n  ashGray: 0x554466,\n  bloodRed: 0x660088,\n  hellfire: 0xff6600,\n  // New Halloween colors\n  pumpkinOrange: 0xff6600,\n  ghostWhite: 0xeeffee,\n  witchPurple: 0x9933ff,\n  spiderBlack: 0x111122,\n  candyCorn1: 0xffcc00,\n  candyCorn2: 0xff8800,\n  candyCorn3: 0xffffff,\n};\n\nexport class SnakeScene extends Phaser.Scene {\n  private graphics!: Phaser.GameObjects.Graphics;\n  private currentState: GameState | null = null;\n  private needsRedraw = false;\n  private frameCount = 0;\n  private stars: Star[] = [];\n  private foodParticles: FoodParticle[] = [];\n  private trailParticles: SnakeTrailParticle[] = [];\n  private shockWaves: ShockWave[] = [];\n  private lightningBolts: LightningBolt[] = [];\n  private plasmaWaves: PlasmaWave[] = [];\n  private snakeAfterimages: SnakeAfterimage[] = [];\n  private auroraWaves: AuroraWave[] = [];\n  private nebulaClouds: NebulaCloud[] = [];\n  private vortexRings: VortexRing[] = [];\n  private vortexParticles: VortexParticle[] = [];\n  private vortexPulse = 0;\n  private meteors: Meteor[] = [];\n  private deathDebris: DeathDebris[] = [];\n  private deathExplosionPhase = 0;\n  private gameOverAlpha = 0;\n  private lastHeadPos: Position | null = null;\n  private lastSnakeLength = 0;\n  private hueOffset = 0;\n  private screenFlashAlpha = 0;\n  private gameOverGlitchOffset = 0;\n  private screenShakeX = 0;\n  private screenShakeY = 0;\n  private screenShakeIntensity = 0;\n  private energyFieldPulse = 0;\n  private foodBurstParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number; hue: number; trail: { x: number; y: number }[] }[] = [];\n  private chromaticIntensity = 0;\n  // Film noir effects\n  private venetianPhase = 0;\n  private spotlightX = 0;\n  private spotlightY = 0;\n  private smokeParticles: { x: number; y: number; vx: number; vy: number; size: number; alpha: number; life: number }[] = [];\n  private guardianSpirits: GuardianSpirit[] = [];\n  // Burning flame particles trailing behind snake\n  private flameParticles: FlameParticle[] = [];\n  // Comet trail system - historical positions for smooth ribbon trail\n  private cometTrail: CometTrailSegment[] = [];\n  // Ethereal particles that drift away from the trail\n  private etherealParticles: EtherealParticle[] = [];\n  // Track last few head positions for smooth interpolation\n  private headHistory: { x: number; y: number; time: number }[] = [];\n  // Thrown food animation system\n  private thrownFood: ThrownFood | null = null;\n  private lastFoodPos: Position | null = null;\n  // Mystical bees swarming around\n  private bees: MysticalBee[] = [];\n  // Rival snake - spectral AI nemesis\n  private rivalSnake: RivalSnake | null = null;\n  // Scoreboard system\n  private highScores: HighScoreEntry[] = [];\n  private highScoresLoaded = false;\n  private newHighScoreRank = -1;\n  private scoreboardAnimPhase = 0;\n  private scoreboardRevealProgress = 0;\n  private lastGameOverState = false;\n  private hudPulsePhase = 0;\n  private lastHudScore = 0;\n  private scoreFlashIntensity = 0;\n  // Armageddon Chaos effects\n  private groundFissures: GroundFissure[] = [];\n  private fireRainParticles: FireRainParticle[] = [];\n  private chaosExplosions: ChaosExplosion[] = [];\n  private apocalypticSkulls: ApocalypticSkull[] = [];\n  private armageddonPulse = 0;\n  private chaosIntensity = 0;\n  private cleanEffects: CleanEffectsState = createCleanEffectsState();\n\n  constructor() {\n    super({ key: 'SnakeScene' });\n  }\n\n  create(): void {\n    this.graphics = this.add.graphics();\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    initMotes(this.cleanEffects, width, height);\n\n    if (this.currentState) {\n      this.needsRedraw = true;\n    }\n  }\n\n  private initArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Initialize ground fissures - cracks in the earth with lava\n    this.groundFissures = [];\n    for (let i = 0; i < NUM_FISSURES; i++) {\n      const startX = Math.random() * width;\n      const startY = Math.random() * height;\n      const angle = Math.random() * Math.PI;\n      const length = 40 + Math.random() * 80;\n      this.groundFissures.push({\n        x1: startX,\n        y1: startY,\n        x2: startX + Math.cos(angle) * length,\n        y2: startY + Math.sin(angle) * length,\n        width: 2 + Math.random() * 4,\n        glowIntensity: 0.5 + Math.random() * 0.5,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n\n    // Initialize fire rain\n    this.fireRainParticles = [];\n\n    // Initialize chaos explosions\n    this.chaosExplosions = [];\n\n    // Initialize apocalyptic skulls floating in background\n    this.apocalypticSkulls = [];\n    for (let i = 0; i < NUM_SKULLS; i++) {\n      this.apocalypticSkulls.push({\n        x: 30 + Math.random() * (width - 60),\n        y: 30 + Math.random() * (height - 60),\n        size: 15 + Math.random() * 10,\n        alpha: 0.03 + Math.random() * 0.04,\n        rotation: Math.random() * Math.PI * 2,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n  }\n\n  private initSmokeParticles(): void {\n    this.smokeParticles = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < 12; i++) {\n      this.smokeParticles.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        vx: (Math.random() - 0.5) * 0.3,\n        vy: -0.1 - Math.random() * 0.2,\n        size: 30 + Math.random() * 50,\n        alpha: 0.02 + Math.random() * 0.03,\n        life: Math.random(),\n      });\n    }\n  }\n\n  private updateArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    this.armageddonPulse += 0.04;\n\n    // Update ground fissures - pulsing lava glow\n    for (const fissure of this.groundFissures) {\n      fissure.pulsePhase += 0.06;\n      fissure.glowIntensity = 0.5 + Math.sin(fissure.pulsePhase) * 0.3;\n    }\n\n    // Spawn fire rain particles\n    if (this.fireRainParticles.length < MAX_FIRE_RAIN && Math.random() < 0.3) {\n      const hueVariation = Math.random();\n      this.fireRainParticles.push({\n        x: Math.random() * width,\n        y: -20,\n        vy: 2 + Math.random() * 3,\n        size: 2 + Math.random() * 4,\n        alpha: 0.6 + Math.random() * 0.4,\n        hue: hueVariation < 0.6 ? 0 : (hueVariation < 0.85 ? 20 : 40), // Red, orange, yellow\n        trail: [],\n      });\n    }\n\n    // Update fire rain\n    for (let i = this.fireRainParticles.length - 1; i >= 0; i--) {\n      const p = this.fireRainParticles[i];\n      p.trail.unshift({ x: p.x, y: p.y, alpha: p.alpha });\n      if (p.trail.length > 6) p.trail.pop();\n      for (const t of p.trail) { t.alpha *= 0.7; }\n\n      p.y += p.vy;\n      p.x += Math.sin(this.armageddonPulse + p.y * 0.05) * 0.3;\n      p.alpha *= 0.995;\n\n      if (p.y > height + 20 || p.alpha < 0.05) {\n        this.fireRainParticles.splice(i, 1);\n      }\n    }\n\n    // Update chaos explosions\n    for (let i = this.chaosExplosions.length - 1; i >= 0; i--) {\n      const exp = this.chaosExplosions[i];\n      exp.radius += 4;\n      exp.life -= 0.03;\n\n      for (const ring of exp.rings) {\n        ring.radius += 3;\n        ring.alpha *= 0.92;\n      }\n      exp.rings = exp.rings.filter(r => r.alpha > 0.02);\n\n      for (const d of exp.debris) {\n        d.x += d.vx;\n        d.y += d.vy;\n        d.vy += 0.1;\n        d.alpha *= 0.96;\n      }\n      exp.debris = exp.debris.filter(d => d.alpha > 0.02);\n\n      if (exp.life <= 0 && exp.rings.length === 0 && exp.debris.length === 0) {\n        this.chaosExplosions.splice(i, 1);\n      }\n    }\n\n    // Update apocalyptic skulls - slow drift and pulse\n    for (const skull of this.apocalypticSkulls) {\n      skull.pulsePhase += 0.02;\n      skull.rotation += 0.002;\n      skull.x += Math.sin(skull.pulsePhase * 0.5) * 0.1;\n      skull.y += Math.cos(skull.pulsePhase * 0.3) * 0.1;\n\n      // Keep in bounds\n      if (skull.x < 20) skull.x = 20;\n      if (skull.x > width - 20) skull.x = width - 20;\n      if (skull.y < 20) skull.y = 20;\n      if (skull.y > height - 20) skull.y = height - 20;\n    }\n\n    // Chaos intensity increases when snake eats or dies\n    this.chaosIntensity *= 0.97;\n  }\n\n  private spawnChaosExplosion(x: number, y: number): void {\n    if (this.chaosExplosions.length >= MAX_CHAOS_EXPLOSIONS) {\n      this.chaosExplosions.shift();\n    }\n\n    const debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[] = [];\n    for (let i = 0; i < 12; i++) {\n      const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 5;\n      debris.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 2,\n        size: 2 + Math.random() * 4,\n        alpha: 1,\n      });\n    }\n\n    this.chaosExplosions.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: 80,\n      life: 1,\n      rings: [\n        { radius: 10, alpha: 1 },\n        { radius: 5, alpha: 0.8 },\n        { radius: 15, alpha: 0.6 },\n      ],\n      debris,\n    });\n\n    this.chaosIntensity = Math.min(1, this.chaosIntensity + 0.5);\n    this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 12);\n  }\n\n  private drawArmageddonBackground(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Spooky Halloween night sky\n    const skyPulse = 0.8 + Math.sin(this.armageddonPulse * 0.5) * 0.2;\n\n    // Layer 1: Deep purple-black night base\n    g.fillStyle(0x0a0018, 1);\n    g.fillRect(0, 0, width, height);\n\n    // Layer 2: Eerie purple glow from below (like fog)\n    g.fillStyle(0x200840, 0.3 * skyPulse);\n    g.fillRect(0, height * 0.7, width, height * 0.3);\n\n    // Layer 3: Misty purple clouds\n    for (let i = 0; i < 4; i++) {\n      const cloudY = i * 30 + Math.sin(this.armageddonPulse + i) * 10;\n      const cloudAlpha = 0.1 - i * 0.02;\n      g.fillStyle(0x301040, cloudAlpha * skyPulse);\n      g.fillRect(0, cloudY, width, 40);\n    }\n\n    // Draw haunted moon\n    this.drawHauntedMoon(g, width);\n\n    // Draw flying bats in background\n    this.drawFlyingBats(g, width, height);\n\n    // Draw apocalyptic skulls (very faint, background layer)\n    this.drawApocalypticSkulls(g);\n  }\n\n  private drawHauntedMoon(g: Phaser.GameObjects.Graphics, width: number): void {\n    const moonX = width * 0.8;\n    const moonY = 60;\n    const moonRadius = 35;\n    const moonPulse = 0.9 + Math.sin(this.frameCount * 0.02) * 0.1;\n\n    // Moon glow\n    g.fillStyle(0xff8800, 0.1 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 2);\n    g.fillStyle(0xffaa00, 0.15 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 1.5);\n\n    // Main moon (orange harvest moon)\n    g.fillStyle(0xffaa33, 0.9);\n    g.fillCircle(moonX, moonY, moonRadius);\n\n    // Moon craters\n    g.fillStyle(0xcc8822, 0.4);\n    g.fillCircle(moonX - 10, moonY - 5, 8);\n    g.fillCircle(moonX + 12, moonY + 8, 6);\n    g.fillCircle(moonX - 5, moonY + 12, 5);\n  }\n\n  private drawFlyingBats(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const batCount = 6;\n    for (let i = 0; i < batCount; i++) {\n      const phase = this.frameCount * 0.03 + i * 1.5;\n      const batX = ((i * 127 + this.frameCount * 0.5) % (width + 100)) - 50;\n      const batY = 40 + i * 20 + Math.sin(phase) * 15;\n      const wingPhase = Math.sin(this.frameCount * 0.15 + i * 2);\n\n      // Bat body\n      g.fillStyle(0x111122, 0.8);\n      g.fillCircle(batX, batY, 4);\n\n      // Bat wings (flapping)\n      const wingSpread = 8 + wingPhase * 4;\n      g.fillStyle(0x111122, 0.7);\n\n      // Left wing\n      g.beginPath();\n      g.moveTo(batX - 2, batY);\n      g.lineTo(batX - wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX - wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n\n      // Right wing\n      g.beginPath();\n      g.moveTo(batX + 2, batY);\n      g.lineTo(batX + wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX + wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawGroundFissures(g: Phaser.GameObjects.Graphics): void {\n    for (const fissure of this.groundFissures) {\n      const pulse = fissure.glowIntensity;\n\n      // Ghostly purple glow underneath\n      g.lineStyle(fissure.width * 3, COLORS.lavaGlow, 0.12 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Crack edges (dark purple)\n      g.lineStyle(fissure.width + 2, 0x200030, 0.4);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ethereal core (bright purple)\n      g.lineStyle(fissure.width, COLORS.witchPurple, 0.3 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ghostly white center\n      g.lineStyle(fissure.width * 0.3, COLORS.ghostWhite, 0.2 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n    }\n  }\n\n  private drawFireRain(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.fireRainParticles) {\n      // Draw ghostly trail\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailSize = p.size * (1 - i / p.trail.length) * 0.6;\n        // Ghostly purple/green trail\n        const ghostHue = 0.75 + (p.hue % 60) / 360;\n        const trailColor = this.hslToRgb(ghostHue, 0.6, 0.6);\n        g.fillStyle(trailColor, t.alpha * 0.3);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Main spirit particle (ghostly appearance)\n      const outerColor = this.hslToRgb(0.8, 0.5, 0.5);\n      const coreColor = this.hslToRgb(0.85, 0.3, 0.8);\n\n      g.fillStyle(outerColor, p.alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      g.fillStyle(coreColor, p.alpha * 0.6);\n      g.fillCircle(p.x, p.y, p.size);\n\n      g.fillStyle(COLORS.ghostWhite, p.alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawChaosExplosions(g: Phaser.GameObjects.Graphics): void {\n    for (const exp of this.chaosExplosions) {\n      // Central flash\n      if (exp.life > 0.7) {\n        const flashAlpha = (exp.life - 0.7) * 3;\n        g.fillStyle(0xffffff, flashAlpha * 0.5);\n        g.fillCircle(exp.x, exp.y, exp.radius * 0.5);\n        g.fillStyle(COLORS.chaosYellow, flashAlpha * 0.4);\n        g.fillCircle(exp.x, exp.y, exp.radius);\n      }\n\n      // Expanding rings\n      for (const ring of exp.rings) {\n        g.lineStyle(4, COLORS.chaosRed, ring.alpha * 0.5);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(2, COLORS.chaosOrange, ring.alpha * 0.7);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(1, 0xffffff, ring.alpha * 0.4);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n      }\n\n      // Flying debris\n      for (const d of exp.debris) {\n        g.fillStyle(COLORS.chaosOrange, d.alpha * 0.6);\n        g.fillCircle(d.x, d.y, d.size * 1.3);\n        g.fillStyle(COLORS.chaosYellow, d.alpha * 0.9);\n        g.fillCircle(d.x, d.y, d.size);\n      }\n    }\n  }\n\n  private drawApocalypticSkulls(g: Phaser.GameObjects.Graphics): void {\n    for (const skull of this.apocalypticSkulls) {\n      const pulse = 0.7 + Math.sin(skull.pulsePhase) * 0.3;\n      const alpha = skull.alpha * pulse;\n      const s = skull.size;\n\n      // Ghostly purple glow\n      g.fillStyle(COLORS.witchPurple, alpha * 0.2);\n      g.fillCircle(skull.x, skull.y, s * 1.5);\n\n      // Skull outline (bone white)\n      g.fillStyle(0xcccccc, alpha * 0.8);\n      // Cranium\n      g.fillCircle(skull.x, skull.y - s * 0.1, s * 0.8);\n      // Jaw\n      g.fillRect(skull.x - s * 0.4, skull.y + s * 0.3, s * 0.8, s * 0.4);\n\n      // Eye sockets (glowing green - spooky!)\n      g.fillStyle(COLORS.snakeHead, alpha * 1.2);\n      g.fillCircle(skull.x - s * 0.25, skull.y - s * 0.1, s * 0.2);\n      g.fillCircle(skull.x + s * 0.25, skull.y - s * 0.1, s * 0.2);\n\n      // Nose hole\n      g.fillStyle(0x000000, alpha);\n      g.fillTriangle(\n        skull.x, skull.y + s * 0.1,\n        skull.x - s * 0.1, skull.y + s * 0.25,\n        skull.x + s * 0.1, skull.y + s * 0.25\n      );\n    }\n  }\n\n  private drawChaosOverlay(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (this.chaosIntensity <= 0) return;\n\n    // Purple tint overlay when chaos is active\n    g.fillStyle(COLORS.witchPurple, this.chaosIntensity * 0.1);\n    g.fillRect(0, 0, width, height);\n\n    // Pulsing purple vignette edges\n    const vignetteAlpha = this.chaosIntensity * 0.25;\n    g.lineStyle(80, COLORS.bloodRed, vignetteAlpha);\n    g.strokeRect(-40, -40, width + 80, height + 80);\n  }\n\n  private initGuardianSpirits(): void {\n    this.guardianSpirits = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const spiritHues = [180, 220, 280, 320];\n\n    const edges: ('top' | 'bottom' | 'left' | 'right')[] = ['top', 'bottom', 'left', 'right'];\n    for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      const edge = edges[edgeIndex];\n      for (let i = 0; i < NUM_SPIRITS_PER_EDGE; i++) {\n        let x = 0, y = 0;\n        const offset = (i + 0.5) / NUM_SPIRITS_PER_EDGE;\n\n        switch (edge) {\n          case 'top':\n            x = width * offset;\n            y = -15;\n            break;\n          case 'bottom':\n            x = width * offset;\n            y = height + 15;\n            break;\n          case 'left':\n            x = -15;\n            y = height * offset;\n            break;\n          case 'right':\n            x = width + 15;\n            y = height * offset;\n            break;\n        }\n\n        const orbs: { angle: number; distance: number; size: number; speed: number }[] = [];\n        const numOrbs = 3;\n        for (let o = 0; o < numOrbs; o++) {\n          orbs.push({\n            angle: (o / numOrbs) * Math.PI * 2,\n            distance: 15 + Math.random() * 10,\n            size: 3 + Math.random() * 2,\n            speed: 0.03 + Math.random() * 0.02,\n          });\n        }\n\n        this.guardianSpirits.push({\n          x,\n          y,\n          baseX: x,\n          baseY: y,\n          size: 20 + Math.random() * 10,\n          phase: Math.random() * Math.PI * 2,\n          speed: 0.015 + Math.random() * 0.01,\n          haloPhase: Math.random() * Math.PI * 2,\n          orbPhase: Math.random() * Math.PI * 2,\n          edge,\n          targetAlpha: 0.4 + Math.random() * 0.2,\n          currentAlpha: 0,\n          hue: spiritHues[edgeIndex % spiritHues.length] + Math.random() * 30 - 15,\n          orbs,\n        });\n      }\n    }\n  }\n\n  private initBees(): void {\n    this.bees = [];\n  }\n\n  private initRivalSnake(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    const startX = width - 50 - Math.random() * 50;\n    const startY = height - 50 - Math.random() * 50;\n\n    const segments: { x: number; y: number }[] = [];\n    for (let i = 0; i < RIVAL_SNAKE_LENGTH; i++) {\n      segments.push({\n        x: startX + i * CELL_SIZE * 0.6,\n        y: startY,\n      });\n    }\n\n    this.rivalSnake = {\n      segments,\n      direction: { dx: -1, dy: 0 },\n      targetX: width / 2,\n      targetY: height / 2,\n      moveTimer: 0,\n      moveInterval: RIVAL_MOVE_INTERVAL,\n      pulsePhase: 0,\n      glowIntensity: 0.8,\n      hue: 200,\n      trail: [],\n      energyTrail: [],\n      state: 'hunting',\n      aggression: 0.5,\n      nearMissTimer: 0,\n      electricArcs: [],\n    };\n  }\n\n  private updateRivalSnake(): void {\n    if (!this.rivalSnake || !this.currentState) return;\n\n    const rs = this.rivalSnake;\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    rs.pulsePhase += 0.1;\n    rs.glowIntensity = 0.6 + Math.sin(rs.pulsePhase) * 0.3;\n\n    if (rs.segments.length > 0) {\n      rs.trail.unshift({ x: rs.segments[0].x, y: rs.segments[0].y, alpha: 0.7 });\n      if (rs.trail.length > 20) rs.trail.pop();\n\n      rs.energyTrail.unshift({\n        x: rs.segments[0].x + (Math.random() - 0.5) * 8,\n        y: rs.segments[0].y + (Math.random() - 0.5) * 8,\n        alpha: 0.8,\n        size: 3 + Math.random() * 4\n      });\n      if (rs.energyTrail.length > 30) rs.energyTrail.pop();\n    }\n\n    for (const t of rs.trail) {\n      t.alpha *= 0.92;\n    }\n    rs.trail = rs.trail.filter(t => t.alpha > 0.02);\n\n    for (const e of rs.energyTrail) {\n      e.alpha *= 0.88;\n      e.size *= 0.95;\n    }\n    rs.energyTrail = rs.energyTrail.filter(e => e.alpha > 0.02);\n\n    rs.electricArcs = rs.electricArcs.filter(arc => {\n      arc.life -= 0.15;\n      return arc.life > 0;\n    });\n\n    if (rs.nearMissTimer > 0) rs.nearMissTimer--;\n\n    const playerHead = this.currentState.snake[0];\n    const playerX = playerHead.x * CELL_SIZE + CELL_SIZE / 2;\n    const playerY = playerHead.y * CELL_SIZE + CELL_SIZE / 2;\n    const rivalHead = rs.segments[0];\n    const distToPlayer = Math.sqrt(\n      Math.pow(playerX - rivalHead.x, 2) + Math.pow(playerY - rivalHead.y, 2)\n    );\n\n    if (distToPlayer < 60 && rs.nearMissTimer === 0) {\n      rs.nearMissTimer = 30;\n      rs.electricArcs.push({\n        x1: rivalHead.x,\n        y1: rivalHead.y,\n        x2: playerX,\n        y2: playerY,\n        life: 1.0\n      });\n      rs.aggression = Math.min(1.0, rs.aggression + 0.1);\n    }\n\n    rs.moveTimer++;\n    if (rs.moveTimer >= rs.moveInterval) {\n      rs.moveTimer = 0;\n\n      const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n      const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n      const distToFood = Math.sqrt(\n        Math.pow(foodX - rivalHead.x, 2) + Math.pow(foodY - rivalHead.y, 2)\n      );\n\n      if (distToPlayer < 80) {\n        rs.state = 'fleeing';\n        const fleeAngle = Math.atan2(rivalHead.y - playerY, rivalHead.x - playerX);\n        rs.targetX = rivalHead.x + Math.cos(fleeAngle) * 100;\n        rs.targetY = rivalHead.y + Math.sin(fleeAngle) * 100;\n      } else if (distToFood < 150 || rs.aggression > 0.7) {\n        rs.state = 'hunting';\n        rs.targetX = foodX;\n        rs.targetY = foodY;\n      } else {\n        rs.state = 'circling';\n        const circleAngle = rs.pulsePhase * 0.3;\n        rs.targetX = width / 2 + Math.cos(circleAngle) * 120;\n        rs.targetY = height / 2 + Math.sin(circleAngle) * 120;\n      }\n\n      rs.targetX = Math.max(30, Math.min(width - 30, rs.targetX));\n      rs.targetY = Math.max(30, Math.min(height - 30, rs.targetY));\n\n      const dx = rs.targetX - rivalHead.x;\n      const dy = rs.targetY - rivalHead.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 5) {\n        const targetDx = dx / dist;\n        const targetDy = dy / dist;\n        const turnSpeed = rs.state === 'fleeing' ? 0.5 : 0.35;\n\n        rs.direction.dx = rs.direction.dx * (1 - turnSpeed) + targetDx * turnSpeed;\n        rs.direction.dy = rs.direction.dy * (1 - turnSpeed) + targetDy * turnSpeed;\n\n        const len = Math.sqrt(rs.direction.dx * rs.direction.dx + rs.direction.dy * rs.direction.dy);\n        if (len > 0) {\n          rs.direction.dx /= len;\n          rs.direction.dy /= len;\n        }\n      }\n\n      const moveSpeed = rs.state === 'fleeing' ? CELL_SIZE * 0.7 : CELL_SIZE * 0.55;\n      const newHead = {\n        x: rivalHead.x + rs.direction.dx * moveSpeed,\n        y: rivalHead.y + rs.direction.dy * moveSpeed,\n      };\n\n      if (newHead.x < 10) newHead.x = width - 10;\n      if (newHead.x > width - 10) newHead.x = 10;\n      if (newHead.y < 10) newHead.y = height - 10;\n      if (newHead.y > height - 10) newHead.y = 10;\n\n      rs.segments.unshift(newHead);\n      rs.segments.pop();\n    } else {\n      const head = rs.segments[0];\n      const moveSpeed = CELL_SIZE * 0.5;\n\n      head.x += rs.direction.dx * moveSpeed * 0.06;\n      head.y += rs.direction.dy * moveSpeed * 0.06;\n\n      for (let i = 1; i < rs.segments.length; i++) {\n        const seg = rs.segments[i];\n        const prev = rs.segments[i - 1];\n        const pullStrength = 0.18;\n        seg.x += (prev.x - seg.x) * pullStrength;\n        seg.y += (prev.y - seg.y) * pullStrength;\n      }\n    }\n\n    if (this.currentState.gameOver) {\n      rs.hue = 180;\n      rs.glowIntensity *= 0.95;\n      rs.state = 'circling';\n    } else {\n      rs.hue = rs.state === 'hunting' ? 190 : (rs.state === 'fleeing' ? 220 : 200);\n      rs.hue += Math.sin(rs.pulsePhase * 0.5) * 10;\n    }\n\n    rs.aggression *= 0.998;\n  }\n\n  private drawRivalSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.rivalSnake || this.rivalSnake.segments.length === 0) return;\n\n    const rs = this.rivalSnake;\n    const pulse = rs.glowIntensity;\n\n    for (const arc of rs.electricArcs) {\n      this.drawElectricArc(g, arc.x1, arc.y1, arc.x2, arc.y2, arc.life);\n    }\n\n    for (const e of rs.energyTrail) {\n      g.fillStyle(this.hslToHex(rs.hue + 20, 80, 70), e.alpha * 0.6);\n      g.fillCircle(e.x, e.y, e.size);\n      g.fillStyle(this.hslToHex(rs.hue, 90, 85), e.alpha * 0.3);\n      g.fillCircle(e.x, e.y, e.size * 0.5);\n    }\n\n    for (let i = 0; i < rs.trail.length; i++) {\n      const t = rs.trail[i];\n      const trailSize = 5 * (1 - i / rs.trail.length);\n      g.fillStyle(this.hslToHex(rs.hue, 80, 55), t.alpha * 0.4);\n      g.fillCircle(t.x, t.y, trailSize * 2);\n      g.fillStyle(this.hslToHex(rs.hue + 30, 70, 70), t.alpha * 0.2);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    g.lineStyle(14, this.hslToHex(rs.hue, 70, 40), 0.2 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    g.lineStyle(8, this.hslToHex(rs.hue, 80, 55), 0.35 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    for (let i = rs.segments.length - 1; i >= 0; i--) {\n      const seg = rs.segments[i];\n      const t = rs.segments.length > 1 ? i / (rs.segments.length - 1) : 1;\n      const segmentPulse = pulse * (0.8 + Math.sin(rs.pulsePhase + i * 0.4) * 0.2);\n\n      const baseSize = 7 + t * 5;\n      const size = baseSize * (0.9 + segmentPulse * 0.15);\n\n      g.fillStyle(this.hslToHex(rs.hue - 10, 60, 35), 0.15 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 2.8);\n\n      g.fillStyle(this.hslToHex(rs.hue, 75, 50), 0.3 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 1.6);\n\n      g.fillStyle(this.hslToHex(rs.hue + 10, 85, 65), 0.6 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size);\n\n      g.fillStyle(this.hslToHex(rs.hue + 40, 60, 90), 0.5 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 0.35);\n\n      if (i === 0) {\n        const dx = rs.direction.dx;\n        const dy = rs.direction.dy;\n        const perpX = -dy;\n        const perpY = dx;\n\n        g.fillStyle(this.hslToHex(rs.hue, 90, 70), 0.3);\n        g.fillCircle(seg.x - dx * 3, seg.y - dy * 3, size * 1.8);\n\n        const eyeOffset = 4;\n        const eyeForward = 5;\n        const leftEyeX = seg.x + perpX * eyeOffset + dx * eyeForward;\n        const leftEyeY = seg.y + perpY * eyeOffset + dy * eyeForward;\n        const rightEyeX = seg.x - perpX * eyeOffset + dx * eyeForward;\n        const rightEyeY = seg.y - perpY * eyeOffset + dy * eyeForward;\n\n        const eyeColor = rs.state === 'hunting' ? 0xff4444 :\n                         rs.state === 'fleeing' ? 0xffff44 : 0x44ffff;\n\n        g.fillStyle(0x000000, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 4);\n        g.fillCircle(rightEyeX, rightEyeY, 4);\n\n        g.fillStyle(eyeColor, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 3);\n        g.fillCircle(rightEyeX, rightEyeY, 3);\n\n        g.fillStyle(0xffffff, 0.95 * segmentPulse);\n        g.fillCircle(leftEyeX + dx, leftEyeY + dy, 1.2);\n        g.fillCircle(rightEyeX + dx, rightEyeY + dy, 1.2);\n\n        const hornLength = 8;\n        const hornAngle = 0.4;\n        g.lineStyle(3, this.hslToHex(rs.hue - 20, 70, 45), 0.8 * segmentPulse);\n        g.beginPath();\n        g.moveTo(seg.x + perpX * 5, seg.y + perpY * 5);\n        g.lineTo(\n          seg.x + perpX * 5 + Math.cos(Math.atan2(dy, dx) - hornAngle) * hornLength,\n          seg.y + perpY * 5 + Math.sin(Math.atan2(dy, dx) - hornAngle) * hornLength\n        );\n        g.strokePath();\n        g.beginPath();\n        g.moveTo(seg.x - perpX * 5, seg.y - perpY * 5);\n        g.lineTo(\n          seg.x - perpX * 5 + Math.cos(Math.atan2(dy, dx) + hornAngle) * hornLength,\n          seg.y - perpY * 5 + Math.sin(Math.atan2(dy, dx) + hornAngle) * hornLength\n        );\n        g.strokePath();\n      }\n    }\n  }\n\n  private drawElectricArc(g: Phaser.GameObjects.Graphics, x1: number, y1: number, x2: number, y2: number, life: number): void {\n    const segments = 6;\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n    const jitter = 15 * life;\n\n    g.lineStyle(4, 0x00ffff, 0.2 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter;\n      const jy = (Math.random() - 0.5) * jitter;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(2, 0x88ffff, 0.5 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter * 0.5;\n      const jy = (Math.random() - 0.5) * jitter * 0.5;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(1, 0xffffff, 0.8 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    g.lineTo(x2, y2);\n    g.strokePath();\n  }\n\n  private spawnBee(): void {\n    if (this.bees.length >= NUM_BEES) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Spawn from random edge\n    const edge = Math.floor(Math.random() * 4);\n    let x: number, y: number;\n\n    switch (edge) {\n      case 0: // top\n        x = Math.random() * width;\n        y = -20;\n        break;\n      case 1: // right\n        x = width + 20;\n        y = Math.random() * height;\n        break;\n      case 2: // bottom\n        x = Math.random() * width;\n        y = height + 20;\n        break;\n      default: // left\n        x = -20;\n        y = Math.random() * height;\n        break;\n    }\n\n    // Random target inside the play area\n    const targetX = 50 + Math.random() * (width - 100);\n    const targetY = 50 + Math.random() * (height - 100);\n\n    this.bees.push({\n      x,\n      y,\n      vx: 0,\n      vy: 0,\n      targetX,\n      targetY,\n      wingPhase: Math.random() * Math.PI * 2,\n      wingSpeed: 0.4 + Math.random() * 0.2,\n      size: 6 + Math.random() * 3,\n      hue: 0 + Math.random() * 20, // Crimson/red volcanic color\n      glowIntensity: 0.5 + Math.random() * 0.5,\n      bobPhase: Math.random() * Math.PI * 2,\n      bobSpeed: 0.08 + Math.random() * 0.04,\n      trail: [],\n      state: 'flying',\n      sparkleTimer: 0,\n    });\n  }\n\n  private updateBees(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n    const gameOver = this.currentState.gameOver;\n\n    // Randomly spawn new bees\n    if (!gameOver && Math.random() < BEE_SPAWN_CHANCE && this.bees.length < NUM_BEES) {\n      this.spawnBee();\n    }\n\n    for (let i = this.bees.length - 1; i >= 0; i--) {\n      const bee = this.bees[i];\n\n      // Update wing animation\n      bee.wingPhase += bee.wingSpeed;\n      bee.bobPhase += bee.bobSpeed;\n      bee.sparkleTimer += 0.1;\n\n      // Store trail position\n      if (this.frameCount % 2 === 0) {\n        bee.trail.unshift({ x: bee.x, y: bee.y, alpha: 0.6 });\n        if (bee.trail.length > 8) bee.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of bee.trail) {\n        t.alpha *= 0.85;\n      }\n      bee.trail = bee.trail.filter(t => t.alpha > 0.05);\n\n      // Bees are attracted to food\n      const dxFood = foodX - bee.x;\n      const dyFood = foodY - bee.y;\n      const distFood = Math.sqrt(dxFood * dxFood + dyFood * dyFood);\n\n      // Determine behavior based on distance to food\n      if (distFood < 80) {\n        bee.state = 'attracted';\n        bee.targetX = foodX + Math.cos(bee.bobPhase * 3) * 30;\n        bee.targetY = foodY + Math.sin(bee.bobPhase * 3) * 30;\n      } else if (distFood < 150) {\n        bee.state = 'hovering';\n        // Circle around food loosely\n        const angle = Math.atan2(dyFood, dxFood) + Math.sin(bee.bobPhase) * 0.5;\n        bee.targetX = foodX - Math.cos(angle) * 60;\n        bee.targetY = foodY - Math.sin(angle) * 60;\n      } else {\n        bee.state = 'flying';\n        // Wander towards food with some randomness\n        if (Math.random() < 0.02) {\n          bee.targetX = foodX + (Math.random() - 0.5) * 200;\n          bee.targetY = foodY + (Math.random() - 0.5) * 200;\n        }\n      }\n\n      // Move towards target with smooth steering\n      const dx = bee.targetX - bee.x;\n      const dy = bee.targetY - bee.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 1) {\n        const speed = bee.state === 'attracted' ? 2.5 : (bee.state === 'hovering' ? 1.5 : 2);\n        const ax = (dx / dist) * speed * 0.1;\n        const ay = (dy / dist) * speed * 0.1;\n\n        bee.vx += ax;\n        bee.vy += ay;\n\n        // Add bobbing motion\n        bee.vy += Math.sin(bee.bobPhase) * 0.05;\n      }\n\n      // Limit velocity\n      const maxSpeed = bee.state === 'attracted' ? 3 : 2;\n      const currentSpeed = Math.sqrt(bee.vx * bee.vx + bee.vy * bee.vy);\n      if (currentSpeed > maxSpeed) {\n        bee.vx = (bee.vx / currentSpeed) * maxSpeed;\n        bee.vy = (bee.vy / currentSpeed) * maxSpeed;\n      }\n\n      // Apply velocity with damping\n      bee.x += bee.vx;\n      bee.y += bee.vy;\n      bee.vx *= 0.95;\n      bee.vy *= 0.95;\n\n      // Pulsing glow when near food\n      if (bee.state === 'attracted') {\n        bee.glowIntensity = 0.7 + Math.sin(bee.bobPhase * 4) * 0.3;\n      } else {\n        bee.glowIntensity = 0.5 + Math.sin(bee.bobPhase * 2) * 0.2;\n      }\n\n      // Remove bees that fly too far off screen\n      if (bee.x < -100 || bee.x > width + 100 || bee.y < -100 || bee.y > height + 100) {\n        this.bees.splice(i, 1);\n      }\n\n      // Scatter bees on game over\n      if (gameOver) {\n        bee.targetX = bee.x + (Math.random() - 0.5) * 400;\n        bee.targetY = bee.y - 200 - Math.random() * 200;\n        bee.vx += (Math.random() - 0.5) * 2;\n        bee.vy -= 1 + Math.random();\n      }\n    }\n  }\n\n  private drawBees(g: Phaser.GameObjects.Graphics): void {\n    for (const bee of this.bees) {\n      const { x, y, size, wingPhase, hue, glowIntensity, trail, state, sparkleTimer } = bee;\n\n      // Draw trail\n      for (let i = 0; i < trail.length; i++) {\n        const t = trail[i];\n        const trailSize = size * 0.4 * (1 - i / trail.length);\n        g.fillStyle(this.hslToHex(hue, 80, 60), t.alpha * 0.4);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      const glowSize = size * 2 * glowIntensity;\n      g.fillStyle(this.hslToHex(hue, 90, 50), 0.2 * glowIntensity);\n      g.fillCircle(x, y, glowSize);\n\n      // Mid glow\n      g.fillStyle(this.hslToHex(hue, 85, 60), 0.3 * glowIntensity);\n      g.fillCircle(x, y, glowSize * 0.6);\n\n      // Bee body - striped pattern\n      const bodyLength = size * 1.2;\n      const bodyWidth = size * 0.7;\n\n      // Body shadow/glow\n      g.fillStyle(this.hslToHex(hue, 70, 30), 0.5);\n      g.fillEllipse(x, y, bodyLength + 2, bodyWidth + 2);\n\n      // Main body (amber/golden)\n      g.fillStyle(this.hslToHex(hue, 90, 55), 1);\n      g.fillEllipse(x, y, bodyLength, bodyWidth);\n\n      // Dark stripes\n      g.fillStyle(0x1a1a1a, 0.8);\n      g.fillRect(x - bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n      g.fillRect(x + bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n\n      // Head\n      g.fillStyle(this.hslToHex(hue - 10, 80, 40), 1);\n      g.fillCircle(x - bodyLength * 0.4, y, size * 0.4);\n\n      // Wings - animated flutter\n      const wingAngle = Math.sin(wingPhase) * 0.8;\n      const wingSize = size * 0.9;\n\n      // Wing glow (ethereal effect)\n      g.fillStyle(0xffffff, 0.2 + Math.abs(Math.sin(wingPhase)) * 0.2);\n      g.fillEllipse(x + Math.cos(wingAngle + 0.5) * wingSize * 0.3, y - wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n      g.fillEllipse(x + Math.cos(-wingAngle + 0.5) * wingSize * 0.3, y + wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n\n      // Wing bodies\n      g.fillStyle(0xffffff, 0.5 + Math.abs(Math.sin(wingPhase)) * 0.3);\n      g.fillEllipse(x + Math.cos(wingAngle) * wingSize * 0.2, y - wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n      g.fillEllipse(x + Math.cos(-wingAngle) * wingSize * 0.2, y + wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n\n      // Eyes\n      g.fillStyle(0x000000, 1);\n      g.fillCircle(x - bodyLength * 0.45, y - size * 0.12, size * 0.12);\n      g.fillCircle(x - bodyLength * 0.45, y + size * 0.12, size * 0.12);\n\n      // Sparkles when attracted to food\n      if (state === 'attracted' && Math.sin(sparkleTimer * 3) > 0.7) {\n        const sparkleAngle = sparkleTimer * 2;\n        const sparkleDist = size * 1.5;\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n\n        g.fillStyle(0xffffff, 0.8);\n        g.fillCircle(sparkleX, sparkleY, 2);\n        g.fillStyle(this.hslToHex(hue, 100, 80), 0.6);\n        g.fillCircle(sparkleX, sparkleY, 3);\n      }\n    }\n  }\n\n  // Helper to convert HSL to hex for Phaser\n  private hslToHex(h: number, s: number, l: number): number {\n    h = h / 360;\n    s = s / 100;\n    l = l / 100;\n\n    let r: number, g: number, b: number;\n\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    return (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255);\n  }\n\n  private updateGuardianSpirits(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const gameOver = this.currentState.gameOver;\n    const snakeHead = this.currentState.snake.length > 0 ? this.currentState.snake[0] : null;\n\n    for (const spirit of this.guardianSpirits) {\n      spirit.phase += spirit.speed;\n      spirit.haloPhase += 0.04;\n      spirit.orbPhase += 0.02;\n\n      for (const orb of spirit.orbs) {\n        orb.angle += orb.speed;\n      }\n\n      const floatAmount = gameOver ? 20 : 12;\n      const waveAmount = 5;\n      const wave = Math.sin(spirit.phase) * waveAmount;\n\n      let targetX = spirit.baseX;\n      let targetY = spirit.baseY;\n\n      switch (spirit.edge) {\n        case 'top':\n          targetY = spirit.baseY + floatAmount + wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'bottom':\n          targetY = spirit.baseY - floatAmount - wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'left':\n          targetX = spirit.baseX + floatAmount + wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'right':\n          targetX = spirit.baseX - floatAmount - wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n      }\n\n      if (snakeHead && !gameOver) {\n        const headX = snakeHead.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = snakeHead.y * CELL_SIZE + CELL_SIZE / 2;\n        const dx = spirit.x - headX;\n        const dy = spirit.y - headY;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        if (dist < 120) {\n          const attraction = (120 - dist) / 120 * 15;\n          targetX += (dx / dist) * attraction;\n          targetY += (dy / dist) * attraction;\n        }\n      }\n\n      spirit.x += (targetX - spirit.x) * 0.04;\n      spirit.y += (targetY - spirit.y) * 0.04;\n      spirit.x = Math.max(-50, Math.min(width + 50, spirit.x));\n      spirit.y = Math.max(-50, Math.min(height + 50, spirit.y));\n\n      const baseAlpha = gameOver ? 0.8 : spirit.targetAlpha;\n      spirit.currentAlpha += (baseAlpha - spirit.currentAlpha) * 0.05;\n    }\n  }\n\n  private drawGuardianSpirits(g: Phaser.GameObjects.Graphics): void {\n    for (const spirit of this.guardianSpirits) {\n      if (spirit.currentAlpha < 0.01) continue;\n\n      const { x, y, size, phase, haloPhase, currentAlpha, hue, orbs } = spirit;\n      const breathPulse = 1 + Math.sin(phase * 2) * 0.15;\n      const coreSize = size * breathPulse;\n\n      const spiritColor = this.hslToHex(hue, 0.7, 0.6);\n      const glowColor = this.hslToHex(hue, 0.5, 0.8);\n      const haloColor = this.hslToHex(hue, 0.3, 0.9);\n\n      g.fillStyle(glowColor, currentAlpha * 0.1);\n      g.fillCircle(x, y, coreSize * 2.5);\n\n      g.fillStyle(glowColor, currentAlpha * 0.15);\n      g.fillCircle(x, y, coreSize * 1.8);\n\n      const haloRadius = coreSize * 1.4 + Math.sin(haloPhase) * 3;\n      g.lineStyle(2, haloColor, currentAlpha * 0.4);\n      g.strokeCircle(x, y, haloRadius);\n\n      const innerHaloRadius = coreSize * 1.1 + Math.sin(haloPhase + 1) * 2;\n      g.lineStyle(1.5, haloColor, currentAlpha * 0.3);\n      g.strokeCircle(x, y, innerHaloRadius);\n\n      for (const orb of orbs) {\n        const orbX = x + Math.cos(orb.angle) * orb.distance;\n        const orbY = y + Math.sin(orb.angle) * orb.distance;\n        const orbPulse = 1 + Math.sin(phase + orb.angle) * 0.3;\n\n        g.fillStyle(glowColor, currentAlpha * 0.3);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse * 1.5);\n\n        g.fillStyle(spiritColor, currentAlpha * 0.8);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse);\n      }\n\n      g.fillStyle(spiritColor, currentAlpha * 0.9);\n      g.fillCircle(x, y, coreSize * 0.5);\n\n      g.fillStyle(0xffffff, currentAlpha * 0.7);\n      g.fillCircle(x, y, coreSize * 0.25);\n\n      const sparkleCount = 4;\n      for (let i = 0; i < sparkleCount; i++) {\n        const sparkleAngle = (i / sparkleCount) * Math.PI * 2 + phase * 0.5;\n        const sparkleDist = coreSize * (0.8 + Math.sin(phase * 2 + i) * 0.3);\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n        const sparkleSize = 1.5 + Math.sin(phase * 3 + i * 2) * 0.5;\n\n        g.fillStyle(0xffffff, currentAlpha * (0.4 + Math.sin(phase * 2 + i) * 0.3));\n        g.fillCircle(sparkleX, sparkleY, sparkleSize);\n      }\n    }\n  }\n\n  private initStars(): void {\n    this.stars = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_STARS; i++) {\n      this.stars.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: 0.5 + Math.random() * 1.5,\n        speed: 0.02 + Math.random() * 0.03,\n        brightness: 0.3 + Math.random() * 0.7,\n      });\n    }\n  }\n\n  private initPlasmaWaves(): void {\n    this.plasmaWaves = [];\n    const hues = [0, 15, 30]; // Red/orange volcanic variations\n    for (let i = 0; i < NUM_PLASMA_WAVES; i++) {\n      this.plasmaWaves.push({\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.015 + Math.random() * 0.01,\n        amplitude: 30 + Math.random() * 20,\n        wavelength: 80 + Math.random() * 40,\n        hue: hues[i % hues.length],\n      });\n    }\n  }\n\n  private initAuroraWaves(): void {\n    this.auroraWaves = [];\n    const height = GRID_SIZE * CELL_SIZE;\n    // Aurora hues: volcanic reds, oranges, crimsons\n    const auroraHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_AURORA_WAVES; i++) {\n      this.auroraWaves.push({\n        y: height * 0.2 + (height * 0.6 * i) / NUM_AURORA_WAVES,\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.008 + Math.random() * 0.006,\n        hue: auroraHues[i % auroraHues.length],\n        thickness: 25 + Math.random() * 20,\n        amplitude: 15 + Math.random() * 25,\n      });\n    }\n  }\n\n  private initNebulaClouds(): void {\n    this.nebulaClouds = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    // Volcanic smoke and lava glow colors: reds, oranges, crimsons\n    const nebulaHues = [0, 10, 20, 30, 350, 340];\n    for (let i = 0; i < NUM_NEBULA_CLOUDS; i++) {\n      this.nebulaClouds.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        radius: 40 + Math.random() * 60,\n        hue: nebulaHues[i % nebulaHues.length],\n        alpha: 0.04 + Math.random() * 0.04,\n        driftX: (Math.random() - 0.5) * 0.15,\n        driftY: (Math.random() - 0.5) * 0.15,\n        pulsePhase: Math.random() * Math.PI * 2,\n        pulseSpeed: 0.01 + Math.random() * 0.01,\n      });\n    }\n  }\n\n  private initVortex(): void {\n    this.vortexRings = [];\n    this.vortexParticles = [];\n\n    // Create concentric rings with different properties\n    const ringHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_VORTEX_RINGS; i++) {\n      const baseRadius = 25 + i * 18;\n      this.vortexRings.push({\n        radius: baseRadius,\n        baseRadius,\n        rotationOffset: (i * Math.PI * 2) / NUM_VORTEX_RINGS,\n        rotationSpeed: 0.02 - i * 0.003,\n        thickness: 2 + (NUM_VORTEX_RINGS - i) * 0.5,\n        hue: ringHues[i % ringHues.length],\n        pulsePhase: i * 0.5,\n      });\n    }\n\n    // Create orbiting particles\n    for (let i = 0; i < NUM_VORTEX_PARTICLES; i++) {\n      const baseRadius = 20 + Math.random() * 80;\n      this.vortexParticles.push({\n        angle: Math.random() * Math.PI * 2,\n        radius: baseRadius,\n        baseRadius,\n        speed: 0.02 + Math.random() * 0.03,\n        size: 1 + Math.random() * 2,\n        hue: Math.random() * 360,\n        alpha: 0.3 + Math.random() * 0.5,\n      });\n    }\n  }\n\n  private initMeteors(): void {\n    this.meteors = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_METEORS; i++) {\n      this.spawnMeteor(width, height, true);\n    }\n  }\n\n  private spawnMeteor(width: number, height: number, initial = false): void {\n    if (this.meteors.length >= NUM_METEORS) return;\n\n    // Meteors come from top-right and travel to bottom-left\n    const startX = initial ? Math.random() * width * 1.5 : width + 20 + Math.random() * 40;\n    const startY = initial ? Math.random() * height * 0.5 - height * 0.25 : -20 - Math.random() * 40;\n\n    // Random angle variation (mostly diagonal)\n    const angle = Math.PI * 0.65 + (Math.random() - 0.5) * 0.4;\n    const speed = 1.5 + Math.random() * 2;\n\n    this.meteors.push({\n      x: startX,\n      y: startY,\n      vx: -Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed,\n      size: 2 + Math.random() * 3,\n      hue: Math.random() < 0.3 ? 0 + Math.random() * 30 : 20 + Math.random() * 40, // Red or orange volcanic\n      alpha: 0.6 + Math.random() * 0.4,\n      trail: [],\n      life: 1,\n    });\n  }\n\n  private updateMeteors(width: number, height: number): void {\n    for (let i = this.meteors.length - 1; i >= 0; i--) {\n      const m = this.meteors[i];\n\n      // Store trail position\n      m.trail.unshift({ x: m.x, y: m.y, alpha: m.alpha });\n      if (m.trail.length > 12) m.trail.pop();\n\n      // Update position\n      m.x += m.vx;\n      m.y += m.vy;\n\n      // Check if meteor is out of bounds\n      if (m.x < -50 || m.y > height + 50) {\n        this.meteors.splice(i, 1);\n        // Spawn a new one\n        this.spawnMeteor(width, height, false);\n      }\n    }\n  }\n\n  private spawnDeathExplosion(): void {\n    if (!this.currentState) return;\n\n    this.deathDebris = [];\n    this.deathExplosionPhase = 1;\n\n    // Spawn debris from each snake segment\n    for (let i = 0; i < this.currentState.snake.length; i++) {\n      const seg = this.currentState.snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const segHue = (this.hueOffset + i * 15) % 360;\n\n      // Create debris particles per segment (limit total)\n      const debrisPerSeg = Math.min(3, Math.floor(MAX_DEATH_DEBRIS / this.currentState.snake.length));\n      for (let j = 0; j < debrisPerSeg; j++) {\n        if (this.deathDebris.length >= MAX_DEATH_DEBRIS) break;\n\n        const angle = Math.random() * Math.PI * 2;\n        const speed = 2 + Math.random() * 4;\n        const types: ('shard' | 'spark' | 'ember')[] = ['shard', 'spark', 'ember'];\n\n        this.deathDebris.push({\n          x: cx + (Math.random() - 0.5) * 8,\n          y: cy + (Math.random() - 0.5) * 8,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed - 1,\n          size: 3 + Math.random() * 5,\n          hue: segHue + (Math.random() - 0.5) * 40,\n          rotation: Math.random() * Math.PI * 2,\n          rotationSpeed: (Math.random() - 0.5) * 0.4,\n          life: 1,\n          type: types[Math.floor(Math.random() * types.length)],\n        });\n      }\n    }\n  }\n\n  private updateDeathDebris(): void {\n    // Decay explosion phase\n    if (this.deathExplosionPhase > 0) {\n      this.deathExplosionPhase *= 0.95;\n      if (this.deathExplosionPhase < 0.01) this.deathExplosionPhase = 0;\n    }\n\n    for (let i = this.deathDebris.length - 1; i >= 0; i--) {\n      const d = this.deathDebris[i];\n\n      // Update position with gravity\n      d.x += d.vx;\n      d.y += d.vy;\n      d.vy += 0.08; // gravity\n      d.vx *= 0.99; // air resistance\n\n      // Update rotation\n      d.rotation += d.rotationSpeed;\n\n      // Decay life\n      d.life -= 0.015;\n\n      if (d.life <= 0) {\n        this.deathDebris.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnFoodParticles(foodX: number, foodY: number): void {\n    if (this.foodParticles.length < MAX_FOOD_PARTICLES && Math.random() < 0.15) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.3 + Math.random() * 0.5;\n      this.foodParticles.push({\n        x: foodX,\n        y: foodY,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 0.5,\n        life: 1,\n        maxLife: 40 + Math.random() * 20,\n        size: 1 + Math.random() * 2,\n      });\n    }\n  }\n\n  private updateParticles(): void {\n    for (let i = this.foodParticles.length - 1; i >= 0; i--) {\n      const p = this.foodParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy += 0.02;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.foodParticles.splice(i, 1);\n      }\n    }\n    // Update trail particles\n    for (let i = this.trailParticles.length - 1; i >= 0; i--) {\n      const p = this.trailParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.trailParticles.splice(i, 1);\n      }\n    }\n    // Update shockwaves\n    for (let i = this.shockWaves.length - 1; i >= 0; i--) {\n      const sw = this.shockWaves[i];\n      sw.radius += 3;\n      sw.life -= 0.04;\n      if (sw.life <= 0 || sw.radius >= sw.maxRadius) {\n        this.shockWaves.splice(i, 1);\n      }\n    }\n    // Update lightning bolts\n    for (let i = this.lightningBolts.length - 1; i >= 0; i--) {\n      const bolt = this.lightningBolts[i];\n      bolt.life -= 1 / bolt.maxLife;\n      if (bolt.life <= 0) {\n        this.lightningBolts.splice(i, 1);\n      }\n    }\n    // Update afterimages\n    for (let i = this.snakeAfterimages.length - 1; i >= 0; i--) {\n      const ai = this.snakeAfterimages[i];\n      ai.life -= 1 / ai.maxLife;\n      if (ai.life <= 0) {\n        this.snakeAfterimages.splice(i, 1);\n      }\n    }\n    // Decay screen flash\n    if (this.screenFlashAlpha > 0) {\n      this.screenFlashAlpha -= 0.08;\n      if (this.screenFlashAlpha < 0) this.screenFlashAlpha = 0;\n    }\n\n    // Update screen shake\n    if (this.screenShakeIntensity > 0) {\n      this.screenShakeX = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeY = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeIntensity *= 0.9;\n      if (this.screenShakeIntensity < 0.5) {\n        this.screenShakeIntensity = 0;\n        this.screenShakeX = 0;\n        this.screenShakeY = 0;\n      }\n    }\n\n    // Decay chromatic aberration\n    if (this.chromaticIntensity > 0) {\n      this.chromaticIntensity *= 0.92;\n      if (this.chromaticIntensity < 0.05) this.chromaticIntensity = 0;\n    }\n\n    // Decay energy field pulse\n    if (this.energyFieldPulse > 0) {\n      this.energyFieldPulse *= 0.95;\n      if (this.energyFieldPulse < 0.05) this.energyFieldPulse = 0;\n    }\n\n    // Update food burst particles\n    for (let i = this.foodBurstParticles.length - 1; i >= 0; i--) {\n      const p = this.foodBurstParticles[i];\n      // Store trail position\n      p.trail.unshift({ x: p.x, y: p.y });\n      if (p.trail.length > 6) p.trail.pop();\n      // Update position\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vx *= 0.96;\n      p.vy *= 0.96;\n      p.life -= 0.025;\n      if (p.life <= 0) {\n        this.foodBurstParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnTrailParticles(x: number, y: number): void {\n    if (this.trailParticles.length >= MAX_TRAIL_PARTICLES) return;\n    // Spawn 2-3 particles per movement\n    const count = 2 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < count; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.2 + Math.random() * 0.4;\n      this.trailParticles.push({\n        x: x + (Math.random() - 0.5) * 8,\n        y: y + (Math.random() - 0.5) * 8,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        maxLife: 25 + Math.random() * 15,\n        size: 2 + Math.random() * 3,\n        hue: this.hueOffset + Math.random() * 30,\n      });\n    }\n  }\n\n  updateGameState(state: GameState): void {\n    // Detect food eaten - snake got longer\n    if (this.currentState && state.snake.length > this.lastSnakeLength) {\n      const head = state.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n      this.spawnShockWave(headX, headY);\n      this.spawnLightningBurst(headX, headY);\n      this.spawnFoodBurst(headX, headY);\n      this.spawnChaosExplosion(headX, headY); // Armageddon chaos explosion\n      this.screenFlashAlpha = 0.8; // More intense flash for armageddon\n      this.chromaticIntensity = 1.5; // Stronger chromatic aberration\n      this.energyFieldPulse = 1.0; // Trigger energy field expansion\n    }\n    this.lastSnakeLength = state.snake.length;\n\n    // Detect food position change - trigger thrown food animation\n    const newFood = state.food;\n    if (this.lastFoodPos && (newFood.x !== this.lastFoodPos.x || newFood.y !== this.lastFoodPos.y)) {\n      this.spawnThrownFood(newFood.x, newFood.y);\n    } else if (!this.lastFoodPos && !state.gameOver) {\n      // First food spawn\n      this.spawnThrownFood(newFood.x, newFood.y);\n    }\n    this.lastFoodPos = { x: newFood.x, y: newFood.y };\n\n    // Create afterimage when snake moves\n    if (this.currentState && state.snake.length > 0) {\n      const oldHead = this.currentState.snake[0];\n      const newHead = state.snake[0];\n      if (oldHead && newHead && (oldHead.x !== newHead.x || oldHead.y !== newHead.y)) {\n        this.spawnAfterimage(this.currentState.snake);\n      }\n    }\n\n    // Detect game over transition - ARMAGEDDON CHAOS death sequence\n    if (state.gameOver && this.currentState && !this.currentState.gameOver) {\n      this.screenShakeIntensity = 25; // Massive screen shake on death\n      this.chromaticIntensity = 3.0; // Maximum chromatic aberration on death\n      this.chaosIntensity = 1.0; // Full chaos overlay\n      this.spawnDeathExplosion(); // Dramatic death explosion\n      // Spawn chaos explosions across the snake body\n      for (let i = 0; i < Math.min(3, state.snake.length); i++) {\n        const seg = state.snake[Math.floor(i * state.snake.length / 3)];\n        setTimeout(() => {\n          this.spawnChaosExplosion(\n            seg.x * CELL_SIZE + CELL_SIZE / 2,\n            seg.y * CELL_SIZE + CELL_SIZE / 2\n          );\n        }, i * 50);\n      }\n    }\n\n    this.currentState = state;\n    this.needsRedraw = true;\n    if (!state.gameOver) {\n      this.gameOverAlpha = 0;\n      this.gameOverGlitchOffset = 0;\n      this.screenShakeIntensity = 0;\n    }\n  }\n\n  private spawnShockWave(x: number, y: number): void {\n    if (this.shockWaves.length >= MAX_SHOCKWAVES) {\n      this.shockWaves.shift();\n    }\n    this.shockWaves.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: CELL_SIZE * 3,\n      life: 1,\n    });\n  }\n\n  private spawnAfterimage(snake: Position[]): void {\n    if (this.snakeAfterimages.length >= MAX_AFTERIMAGES) {\n      this.snakeAfterimages.shift();\n    }\n    this.snakeAfterimages.push({\n      segments: snake.map(s => ({ x: s.x, y: s.y })),\n      life: 1,\n      maxLife: 12,\n      hueOffset: this.hueOffset,\n    });\n  }\n\n  private spawnLightningBurst(x: number, y: number): void {\n    const numBolts = 3 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < numBolts; i++) {\n      if (this.lightningBolts.length >= MAX_LIGHTNING_BOLTS) {\n        this.lightningBolts.shift();\n      }\n      const angle = (Math.PI * 2 * i) / numBolts + Math.random() * 0.5;\n      const length = 30 + Math.random() * 40;\n      const endX = x + Math.cos(angle) * length;\n      const endY = y + Math.sin(angle) * length;\n      this.lightningBolts.push({\n        points: this.generateLightningPath(x, y, endX, endY),\n        life: 1,\n        maxLife: 15 + Math.random() * 10,\n        hue: this.hueOffset + Math.random() * 60,\n      });\n    }\n  }\n\n  private generateLightningPath(x1: number, y1: number, x2: number, y2: number): { x: number; y: number }[] {\n    const points: { x: number; y: number }[] = [{ x: x1, y: y1 }];\n    const segments = 4 + Math.floor(Math.random() * 3);\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n\n    for (let i = 1; i < segments; i++) {\n      const jitter = 8;\n      points.push({\n        x: x1 + dx * i + (Math.random() - 0.5) * jitter,\n        y: y1 + dy * i + (Math.random() - 0.5) * jitter,\n      });\n    }\n    points.push({ x: x2, y: y2 });\n    return points;\n  }\n\n  private spawnFoodBurst(x: number, y: number): void {\n    // Clear old particles and spawn new dramatic burst\n    this.foodBurstParticles = [];\n    const numParticles = MAX_BURST_PARTICLES;\n    for (let i = 0; i < numParticles; i++) {\n      const angle = (i / numParticles) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 4;\n      this.foodBurstParticles.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        size: 3 + Math.random() * 4,\n        hue: this.hueOffset + Math.random() * 60,\n        trail: [],\n      });\n    }\n  }\n\n  private spawnThrownFood(targetGridX: number, targetGridY: number): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const targetX = targetGridX * CELL_SIZE + CELL_SIZE / 2;\n    const targetY = targetGridY * CELL_SIZE + CELL_SIZE / 2;\n\n    // Choose random edge to throw from\n    const edge = Math.floor(Math.random() * 4);\n    let startX: number, startY: number;\n\n    switch (edge) {\n      case 0: // top\n        startX = Math.random() * width;\n        startY = -40;\n        break;\n      case 1: // right\n        startX = width + 40;\n        startY = Math.random() * height;\n        break;\n      case 2: // bottom\n        startX = Math.random() * width;\n        startY = height + 40;\n        break;\n      default: // left\n        startX = -40;\n        startY = Math.random() * height;\n        break;\n    }\n\n    this.thrownFood = {\n      startX,\n      startY,\n      targetX,\n      targetY,\n      x: startX,\n      y: startY,\n      progress: 0,\n      rotation: 0,\n      rotationSpeed: (Math.random() - 0.5) * 0.6,\n      trail: [],\n      landed: false,\n      landingParticles: [],\n      impactRings: [],\n    };\n  }\n\n  private updateThrownFood(): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    if (!tf.landed) {\n      // Update progress\n      tf.progress += 0.04;\n\n      // Store trail\n      if (this.frameCount % 2 === 0) {\n        tf.trail.unshift({ x: tf.x, y: tf.y, alpha: 1, rotation: tf.rotation });\n        if (tf.trail.length > 12) tf.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.85;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Calculate position with parabolic arc\n      const t = tf.progress;\n      const arcHeight = 80;\n      const arc = 4 * arcHeight * t * (1 - t);\n      tf.x = tf.startX + (tf.targetX - tf.startX) * t;\n      tf.y = tf.startY + (tf.targetY - tf.startY) * t - arc;\n\n      // Rotation\n      tf.rotation += tf.rotationSpeed;\n\n      // Check if landed\n      if (tf.progress >= 1) {\n        tf.landed = true;\n        tf.x = tf.targetX;\n        tf.y = tf.targetY;\n\n        // Spawn landing effects\n        this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 6);\n\n        // Impact rings\n        tf.impactRings = [\n          { radius: 5, alpha: 1 },\n          { radius: 3, alpha: 0.8 },\n        ];\n\n        // Landing particles\n        for (let i = 0; i < 10; i++) {\n          const angle = (i / 10) * Math.PI * 2 + Math.random() * 0.3;\n          const speed = 2 + Math.random() * 3;\n          tf.landingParticles.push({\n            x: tf.targetX,\n            y: tf.targetY,\n            vx: Math.cos(angle) * speed,\n            vy: Math.sin(angle) * speed - 1,\n            life: 1,\n            size: 2 + Math.random() * 3,\n          });\n        }\n      }\n    } else {\n      // Update landing effects\n      for (const ring of tf.impactRings) {\n        ring.radius += 3;\n        ring.alpha *= 0.9;\n      }\n      tf.impactRings = tf.impactRings.filter(r => r.alpha > 0.05);\n\n      for (let i = tf.landingParticles.length - 1; i >= 0; i--) {\n        const p = tf.landingParticles[i];\n        p.x += p.vx;\n        p.y += p.vy;\n        p.vy += 0.15;\n        p.vx *= 0.98;\n        p.life -= 0.04;\n        if (p.life <= 0) {\n          tf.landingParticles.splice(i, 1);\n        }\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.8;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Clear thrown food when effects are done\n      if (tf.impactRings.length === 0 && tf.landingParticles.length === 0 && tf.trail.length === 0) {\n        this.thrownFood = null;\n      }\n    }\n  }\n\n  private drawThrownFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    // Draw trail\n    for (let i = 0; i < tf.trail.length; i++) {\n      const t = tf.trail[i];\n      const trailProgress = i / tf.trail.length;\n      const trailSize = (CELL_SIZE / 2) * (1 - trailProgress * 0.5) * t.alpha;\n\n      // Trail glow\n      g.fillStyle(COLORS.foodGlow, t.alpha * 0.3);\n      g.fillCircle(t.x, t.y, trailSize * 1.5);\n\n      // Trail core\n      g.fillStyle(COLORS.food, t.alpha * 0.6);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    // Draw impact rings\n    for (const ring of tf.impactRings) {\n      g.lineStyle(3, COLORS.foodGlow, ring.alpha * 0.5);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n      g.lineStyle(1.5, COLORS.noirWhite, ring.alpha * 0.7);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n    }\n\n    // Draw landing particles\n    for (const p of tf.landingParticles) {\n      g.fillStyle(COLORS.foodGlow, p.life * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Draw the flying food if not landed\n    if (!tf.landed) {\n      const scale = 0.8 + tf.progress * 0.4;\n      const foodSize = (CELL_SIZE / 2) * scale;\n\n      // Motion blur glow\n      g.fillStyle(COLORS.foodGlow, 0.3);\n      g.fillCircle(tf.x, tf.y, foodSize * 2);\n\n      // Outer glow\n      g.fillStyle(COLORS.noirWhite, 0.4);\n      g.fillCircle(tf.x, tf.y, foodSize * 1.5);\n\n      // Main food body\n      g.fillStyle(COLORS.food, 0.95);\n      g.fillCircle(tf.x, tf.y, foodSize);\n\n      // Spinning highlight\n      const highlightAngle = tf.rotation;\n      const highlightX = tf.x + Math.cos(highlightAngle) * foodSize * 0.3;\n      const highlightY = tf.y + Math.sin(highlightAngle) * foodSize * 0.3;\n      g.fillStyle(0xffffff, 0.9);\n      g.fillCircle(highlightX, highlightY, foodSize * 0.25);\n\n      // Secondary sparkle\n      const sparkleAngle = tf.rotation + Math.PI * 0.7;\n      const sparkleX = tf.x + Math.cos(sparkleAngle) * foodSize * 0.4;\n      const sparkleY = tf.y + Math.sin(sparkleAngle) * foodSize * 0.4;\n      g.fillStyle(0xffffff, 0.6);\n      g.fillCircle(sparkleX, sparkleY, foodSize * 0.15);\n    }\n  }\n\n  update(): void {\n    this.frameCount++;\n    this.cleanEffects.frameCount = this.frameCount;\n\n    const width = this.scale.width;\n    const height = this.scale.height;\n\n    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n    updateTears(this.cleanEffects, height);\n    updateBlood(this.cleanEffects, height);\n\n    if (this.currentState && this.currentState.snake.length > 0) {\n      const head = this.currentState.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n        updateGlowTrail(this.cleanEffects, headX, headY);\n      }\n      this.lastHeadPos = { x: head.x, y: head.y };\n\n      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n        const food = this.currentState.food;\n        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnRipple(this.cleanEffects, foodX, foodY);\n      }\n      this.lastSnakeLength = this.currentState.snake.length;\n    }\n\n    const g = this.graphics;\n    g.clear();\n    g.setPosition(0, 0);\n\n    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n\n    if (!this.currentState) return;\n\n    drawGlowTrail(g, this.cleanEffects);\n    drawRipples(g, this.cleanEffects);\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n\n    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawTears(g, this.cleanEffects);\n    drawBlood(g, this.cleanEffects);\n\n    drawCleanVignette(g, width, height);\n\n    const score = this.currentState.score || 0;\n    const snakeLength = this.currentState.snake.length;\n    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n\n    if (this.currentState.gameOver) {\n      this.drawGameOver(g, width, height);\n      this.drawScoreboard(g, width, height);\n    }\n\n    this.checkAndSaveHighScore();\n    this.needsRedraw = false;\n  }\n\n  private drawStars(g: Phaser.GameObjects.Graphics): void {\n    // In film noir mode, stars are subtle distant lights\n    for (const star of this.stars) {\n      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n      const alpha = star.brightness * twinkle * 0.25;\n      g.fillStyle(COLORS.star, alpha);\n      g.fillCircle(star.x, star.y, star.size * 0.7);\n    }\n  }\n\n  private updateSmokeParticles(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (const smoke of this.smokeParticles) {\n      smoke.x += smoke.vx;\n      smoke.y += smoke.vy;\n      smoke.life -= 0.002;\n      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n        smoke.x = Math.random() * width;\n        smoke.y = height + smoke.size;\n        smoke.life = 1;\n        smoke.size = 30 + Math.random() * 50;\n        smoke.alpha = 0.02 + Math.random() * 0.03;\n      }\n      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n    }\n  }\n\n  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Create dramatic spotlight effect centered on snake\n    const cx = this.spotlightX || width / 2;\n    const cy = this.spotlightY || height / 2;\n    const pulse = 0.9 + Math.sin(this.frameCount * 0.03) * 0.1;\n\n    // Outer darkness vignette\n    g.fillStyle(0x000000, 0.6);\n    g.fillRect(0, 0, width, height);\n\n    // Spotlight cone - multiple layers for smooth falloff\n    const layers = 4;\n    for (let i = layers; i > 0; i--) {\n      const layerRadius = (width * 0.4 + i * 30) * pulse;\n      const layerAlpha = 0.15 * (1 - i / (layers + 1));\n      g.fillStyle(COLORS.spotlight, layerAlpha);\n      g.fillCircle(cx, cy, layerRadius);\n    }\n\n    // Bright center\n    g.fillStyle(COLORS.noirWhite, 0.08 * pulse);\n    g.fillCircle(cx, cy, width * 0.25);\n  }\n\n  private drawVenetianBlinds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Horizontal light streaks simulating light through venetian blinds\n    const blindSpacing = 25;\n    const blindWidth = 8;\n    const waveOffset = Math.sin(this.venetianPhase) * 10;\n\n    for (let y = waveOffset; y < height; y += blindSpacing) {\n      const brightness = 0.03 + Math.sin(y * 0.02 + this.venetianPhase * 2) * 0.015;\n      g.fillStyle(COLORS.noirWhite, brightness);\n      g.fillRect(0, y, width, blindWidth);\n    }\n\n    // Diagonal shadow bars from window frame\n    const diagonalAlpha = 0.04 + Math.sin(this.frameCount * 0.02) * 0.01;\n    g.fillStyle(0x000000, diagonalAlpha);\n    for (let i = -2; i < 6; i++) {\n      const x1 = i * 100 + Math.sin(this.venetianPhase) * 20;\n      g.beginPath();\n      g.moveTo(x1, 0);\n      g.lineTo(x1 + 40, 0);\n      g.lineTo(x1 + 40 + height * 0.3, height);\n      g.lineTo(x1 + height * 0.3, height);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawSmoke(g: Phaser.GameObjects.Graphics): void {\n    for (const smoke of this.smokeParticles) {\n      const alpha = smoke.alpha * smoke.life;\n      g.fillStyle(COLORS.noirGray, alpha);\n      g.fillCircle(smoke.x, smoke.y, smoke.size);\n      g.fillStyle(COLORS.noirWhite, alpha * 0.3);\n      g.fillCircle(smoke.x, smoke.y, smoke.size * 0.5);\n    }\n  }\n\n  private spawnFlameParticle(x: number, y: number, intensity: number): void {\n    if (this.flameParticles.length >= MAX_FLAME_PARTICLES) {\n      this.flameParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.6;\n    const life = 0.5 + Math.random() * 0.5;\n\n    this.flameParticles.push({\n      x: x + (Math.random() - 0.5) * 6,\n      y: y + (Math.random() - 0.5) * 6,\n      vx: Math.cos(angle) * speed * 0.3,\n      vy: -0.5 - Math.random() * 1.5 * intensity,\n      size: 3 + Math.random() * 4 * intensity,\n      life,\n      maxLife: life,\n      hue: 10 + Math.random() * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n    });\n  }\n\n  private updateFlameParticles(): void {\n    for (let i = this.flameParticles.length - 1; i >= 0; i--) {\n      const p = this.flameParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.02;\n      p.vx *= 0.98;\n      p.size *= 0.97;\n      p.life -= 0.025;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.flameParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private drawFlameParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.flameParticles) {\n      const lifeRatio = p.life / p.maxLife;\n\n      // Hue shifts from yellow-orange (high life) to red (low life)\n      const hue = p.hue - (1 - lifeRatio) * 15;\n      const outerColor = this.hslToRgb(hue / 360, 1, 0.3 + lifeRatio * 0.2);\n      const midColor = this.hslToRgb(hue / 360, 1, 0.5 + lifeRatio * 0.2);\n      const coreColor = this.hslToRgb((hue + 20) / 360, 0.7, 0.7 + lifeRatio * 0.2);\n\n      // Outer glow\n      g.fillStyle(outerColor, lifeRatio * 0.3);\n      g.fillCircle(p.x, p.y, p.size * 2);\n\n      // Mid flame\n      g.fillStyle(midColor, lifeRatio * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3);\n\n      // Core (bright yellow/white)\n      g.fillStyle(coreColor, lifeRatio * 0.8);\n      g.fillCircle(p.x, p.y, p.size * 0.6);\n    }\n  }\n\n  private spawnFlamesAlongSnake(): void {\n    if (!this.currentState || this.currentState.gameOver) return;\n\n    const snake = this.currentState.snake;\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const segX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const segY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const intensity = 1 - (i / snake.length) * 0.6;\n      if (Math.random() < 0.4 * intensity) {\n        this.spawnFlameParticle(segX, segY, intensity);\n      }\n    }\n  }\n\n  private drawMeteors(g: Phaser.GameObjects.Graphics): void {\n    for (const m of this.meteors) {\n      const meteorColor = this.hslToRgb(m.hue / 360, 0.9, 0.6);\n      const coreColor = this.hslToRgb(m.hue / 360, 0.6, 0.9);\n\n      // Draw trail (oldest to newest for proper layering)\n      for (let i = m.trail.length - 1; i >= 0; i--) {\n        const t = m.trail[i];\n        const trailProgress = 1 - i / m.trail.length;\n        const trailAlpha = t.alpha * trailProgress * 0.4;\n        const trailSize = m.size * trailProgress * 0.6;\n\n        g.fillStyle(meteorColor, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      g.fillStyle(meteorColor, m.alpha * 0.3);\n      g.fillCircle(m.x, m.y, m.size * 2);\n\n      // Main meteor body\n      g.fillStyle(meteorColor, m.alpha * 0.8);\n      g.fillCircle(m.x, m.y, m.size);\n\n      // Bright core\n      g.fillStyle(coreColor, m.alpha);\n      g.fillCircle(m.x, m.y, m.size * 0.5);\n    }\n  }\n\n  private drawDeathDebris(g: Phaser.GameObjects.Graphics): void {\n    // Draw explosion flash at the beginning\n    if (this.deathExplosionPhase > 0.7) {\n      const flashAlpha = (this.deathExplosionPhase - 0.7) * 2;\n      g.fillStyle(0xffffff, flashAlpha * 0.5);\n      g.fillRect(0, 0, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);\n    }\n\n    for (const d of this.deathDebris) {\n      // Film noir: grayscale debris\n      const brightness = 0.4 + (d.hue % 60) / 100;\n      const color = this.hslToRgb(0, 0, brightness);\n      const alpha = d.life * 0.9;\n\n      g.save();\n\n      if (d.type === 'shard') {\n        // Draw triangular shards\n        const cx = d.x;\n        const cy = d.y;\n        const size = d.size * d.life;\n\n        // Calculate rotated triangle points\n        const cos = Math.cos(d.rotation);\n        const sin = Math.sin(d.rotation);\n\n        const p1x = cx + cos * size;\n        const p1y = cy + sin * size;\n        const p2x = cx + cos * (-size * 0.5) - sin * (size * 0.7);\n        const p2y = cy + sin * (-size * 0.5) + cos * (size * 0.7);\n        const p3x = cx + cos * (-size * 0.5) - sin * (-size * 0.7);\n        const p3y = cy + sin * (-size * 0.5) + cos * (-size * 0.7);\n\n        // Glow\n        g.fillStyle(color, alpha * 0.4);\n        g.fillCircle(cx, cy, size * 1.5);\n\n        // Shard body\n        g.fillStyle(color, alpha);\n        g.fillTriangle(p1x, p1y, p2x, p2y, p3x, p3y);\n\n        // Highlight edge\n        g.lineStyle(1, 0xffffff, alpha * 0.6);\n        g.lineBetween(p1x, p1y, p2x, p2y);\n\n      } else if (d.type === 'spark') {\n        // Draw elongated spark\n        const sparkLength = d.size * 2 * d.life;\n        const sparkWidth = d.size * 0.3 * d.life;\n\n        // Direction based on velocity\n        const vLen = Math.sqrt(d.vx * d.vx + d.vy * d.vy);\n        const nx = vLen > 0 ? d.vx / vLen : 1;\n        const ny = vLen > 0 ? d.vy / vLen : 0;\n\n        // Glow\n        g.fillStyle(color, alpha * 0.3);\n        g.fillCircle(d.x, d.y, sparkLength * 0.8);\n\n        // Spark line\n        g.lineStyle(sparkWidth * 2, color, alpha * 0.6);\n        g.lineBetween(d.x - nx * sparkLength, d.y - ny * sparkLength, d.x, d.y);\n\n        // Bright tip\n        g.lineStyle(sparkWidth, 0xffffff, alpha);\n        g.lineBetween(d.x - nx * sparkLength * 0.3, d.y - ny * sparkLength * 0.3, d.x, d.y);\n\n      } else {\n        // Ember - glowing circle\n        const emberSize = d.size * d.life;\n\n        // Outer glow\n        g.fillStyle(color, alpha * 0.2);\n        g.fillCircle(d.x, d.y, emberSize * 2);\n\n        // Mid glow\n        g.fillStyle(color, alpha * 0.5);\n        g.fillCircle(d.x, d.y, emberSize * 1.3);\n\n        // Core\n        g.fillStyle(color, alpha);\n        g.fillCircle(d.x, d.y, emberSize);\n\n        // Hot center\n        g.fillStyle(0xffffff, alpha * 0.7);\n        g.fillCircle(d.x, d.y, emberSize * 0.4);\n      }\n\n      g.restore();\n    }\n  }\n\n  private drawNebulaClouds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const cloud of this.nebulaClouds) {\n      // Update cloud position (slow drift)\n      cloud.x += cloud.driftX;\n      cloud.y += cloud.driftY;\n      cloud.pulsePhase += cloud.pulseSpeed;\n\n      // Wrap around edges\n      if (cloud.x < -cloud.radius) cloud.x = width + cloud.radius;\n      if (cloud.x > width + cloud.radius) cloud.x = -cloud.radius;\n      if (cloud.y < -cloud.radius) cloud.y = height + cloud.radius;\n      if (cloud.y > height + cloud.radius) cloud.y = -cloud.radius;\n\n      // Pulsing alpha\n      const pulseAlpha = cloud.alpha * (0.7 + Math.sin(cloud.pulsePhase) * 0.3);\n      const color = this.hslToRgb(cloud.hue / 360, 0.6, 0.3);\n\n      // Draw multiple concentric layers for soft cloud effect\n      const layers = 4;\n      for (let i = layers; i > 0; i--) {\n        const layerRadius = cloud.radius * (i / layers);\n        const layerAlpha = pulseAlpha * (1 - i / (layers + 1)) * 0.6;\n        g.fillStyle(color, layerAlpha);\n        g.fillCircle(cloud.x, cloud.y, layerRadius);\n      }\n\n      // Core glow\n      const coreColor = this.hslToRgb(cloud.hue / 360, 0.8, 0.5);\n      g.fillStyle(coreColor, pulseAlpha * 0.4);\n      g.fillCircle(cloud.x, cloud.y, cloud.radius * 0.3);\n    }\n  }\n\n  private drawVortex(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Update vortex pulse\n    this.vortexPulse += 0.03;\n    const globalPulse = 0.8 + Math.sin(this.vortexPulse) * 0.2;\n\n    // Draw outer glow/halo\n    const outerGlowColor = this.hslToRgb(280 / 360, 0.7, 0.3);\n    g.fillStyle(outerGlowColor, 0.08 * globalPulse);\n    g.fillCircle(centerX, centerY, 120);\n    g.fillStyle(outerGlowColor, 0.05 * globalPulse);\n    g.fillCircle(centerX, centerY, 140);\n\n    // Draw orbiting particles (behind rings)\n    for (const particle of this.vortexParticles) {\n      // Update particle position - spiral inward slightly then reset\n      particle.angle += particle.speed;\n      particle.radius = particle.baseRadius + Math.sin(particle.angle * 3) * 8;\n\n      const px = centerX + Math.cos(particle.angle) * particle.radius;\n      const py = centerY + Math.sin(particle.angle) * particle.radius;\n\n      // Particle hue shifts over time\n      particle.hue = (particle.hue + 0.5) % 360;\n      const particleColor = this.hslToRgb(particle.hue / 360, 0.8, 0.6);\n\n      // Draw particle with trail\n      const trailAngle = particle.angle - 0.3;\n      const trailX = centerX + Math.cos(trailAngle) * particle.radius;\n      const trailY = centerY + Math.sin(trailAngle) * particle.radius;\n\n      g.lineStyle(particle.size * 0.8, particleColor, particle.alpha * 0.3 * globalPulse);\n      g.lineBetween(trailX, trailY, px, py);\n\n      g.fillStyle(particleColor, particle.alpha * globalPulse);\n      g.fillCircle(px, py, particle.size);\n\n      // Bright core\n      g.fillStyle(0xffffff, particle.alpha * 0.5 * globalPulse);\n      g.fillCircle(px, py, particle.size * 0.4);\n    }\n\n    // Draw rotating rings\n    for (const ring of this.vortexRings) {\n      ring.rotationOffset += ring.rotationSpeed;\n      ring.pulsePhase += 0.02;\n\n      const ringPulse = 0.7 + Math.sin(ring.pulsePhase) * 0.3;\n      const adjustedRadius = ring.baseRadius * (0.95 + ringPulse * 0.1);\n\n      const ringColor = this.hslToRgb(ring.hue / 360, 0.8, 0.5);\n\n      // Draw ring as series of arc segments with gaps\n      const segments = 6;\n      const arcLength = (Math.PI * 2) / segments * 0.7;\n\n      for (let i = 0; i < segments; i++) {\n        const startAngle = ring.rotationOffset + (i * Math.PI * 2) / segments;\n        const endAngle = startAngle + arcLength;\n\n        // Calculate alpha based on segment position for 3D effect\n        const segmentAlpha = 0.15 + Math.sin(startAngle + this.frameCount * 0.02) * 0.1;\n\n        g.lineStyle(ring.thickness, ringColor, segmentAlpha * ringPulse * globalPulse);\n        g.beginPath();\n        g.arc(centerX, centerY, adjustedRadius, startAngle, endAngle, false);\n        g.strokePath();\n      }\n\n      // Inner glow line\n      g.lineStyle(ring.thickness * 0.5, 0xffffff, 0.1 * ringPulse * globalPulse);\n      g.beginPath();\n      g.arc(centerX, centerY, adjustedRadius - 1, ring.rotationOffset, ring.rotationOffset + Math.PI, false);\n      g.strokePath();\n    }\n\n    // Central dark core (event horizon)\n    g.fillStyle(0x000000, 0.9);\n    g.fillCircle(centerX, centerY, 12);\n    g.fillStyle(0x000000, 0.7);\n    g.fillCircle(centerX, centerY, 18);\n    g.fillStyle(0x000000, 0.4);\n    g.fillCircle(centerX, centerY, 25);\n\n    // Bright accretion ring at edge of event horizon\n    const accretionHue = (this.frameCount * 2) % 360;\n    const accretionColor = this.hslToRgb(accretionHue / 360, 1, 0.6);\n    g.lineStyle(2, accretionColor, 0.4 * globalPulse);\n    g.strokeCircle(centerX, centerY, 14);\n    g.lineStyle(1, 0xffffff, 0.3 * globalPulse);\n    g.strokeCircle(centerX, centerY, 13);\n\n    // Gravitational lensing effect - distorted light streaks\n    const numStreaks = 4;\n    for (let i = 0; i < numStreaks; i++) {\n      const streakAngle = (i * Math.PI * 2) / numStreaks + this.frameCount * 0.01;\n      const streakHue = (accretionHue + i * 60) % 360;\n      const streakColor = this.hslToRgb(streakHue / 360, 0.9, 0.7);\n\n      const innerRadius = 20;\n      const outerRadius = 35 + Math.sin(this.frameCount * 0.05 + i) * 10;\n\n      const x1 = centerX + Math.cos(streakAngle) * innerRadius;\n      const y1 = centerY + Math.sin(streakAngle) * innerRadius;\n      const x2 = centerX + Math.cos(streakAngle + 0.2) * outerRadius;\n      const y2 = centerY + Math.sin(streakAngle + 0.2) * outerRadius;\n\n      g.lineStyle(3, streakColor, 0.15 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n      g.lineStyle(1.5, 0xffffff, 0.2 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n    }\n  }\n\n  private drawAuroraWaves(g: Phaser.GameObjects.Graphics, width: number): void {\n    for (const aurora of this.auroraWaves) {\n      aurora.phase += aurora.speed;\n\n      // Draw multiple ribbon layers for each aurora\n      const ribbonLayers = 3;\n      for (let layer = 0; layer < ribbonLayers; layer++) {\n        const layerOffset = layer * 5;\n        const layerAlpha = 0.06 - layer * 0.015;\n\n        // Calculate shifting hue for color variation\n        const shiftedHue = (aurora.hue + Math.sin(aurora.phase * 0.5) * 20) % 360;\n        const color = this.hslToRgb(shiftedHue / 360, 0.7, 0.5);\n\n        // Draw aurora as a series of connected curves\n        g.fillStyle(color, layerAlpha);\n        const step = 4;\n        for (let x = 0; x < width; x += step) {\n          // Multiple sine waves combined for organic movement\n          const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n          const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n          const wave3 = Math.sin(x * 0.01 + aurora.phase * 0.7) * aurora.amplitude * 0.3;\n          const yOffset = wave1 + wave2 + wave3;\n\n          const segmentY = aurora.y + yOffset + layerOffset;\n          const thickness = aurora.thickness * (0.7 + Math.sin(x * 0.05 + aurora.phase) * 0.3);\n\n          g.fillRect(x, segmentY - thickness / 2, step + 1, thickness);\n        }\n      }\n\n      // Add bright core line\n      const coreHue = (aurora.hue + 40) % 360;\n      const coreColor = this.hslToRgb(coreHue / 360, 0.9, 0.7);\n      g.lineStyle(1.5, coreColor, 0.15);\n      g.beginPath();\n      for (let x = 0; x < width; x += 3) {\n        const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n        const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n        const y = aurora.y + wave1 + wave2;\n        if (x === 0) {\n          g.moveTo(x, y);\n        } else {\n          g.lineTo(x, y);\n        }\n      }\n      g.strokePath();\n    }\n  }\n\n  private drawPlasmaWaves(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const wave of this.plasmaWaves) {\n      wave.phase += wave.speed;\n      const color = this.hslToRgb(wave.hue / 360, 0.7, 0.4);\n\n      // Draw flowing plasma lines\n      for (let y = 0; y < height; y += 8) {\n        const waveOffset = Math.sin(y / wave.wavelength + wave.phase) * wave.amplitude;\n        const intensity = 0.03 + Math.sin(wave.phase + y * 0.01) * 0.02;\n\n        g.fillStyle(color, intensity);\n        const x1 = width / 2 + waveOffset - 40;\n        const x2 = width / 2 + waveOffset + 40;\n        g.fillRect(x1, y, x2 - x1, 2);\n      }\n    }\n  }\n\n  private drawSnakeAfterimages(g: Phaser.GameObjects.Graphics): void {\n    for (const ai of this.snakeAfterimages) {\n      const alpha = ai.life * 0.25;\n      for (let i = 0; i < ai.segments.length; i++) {\n        const seg = ai.segments[i];\n        const centerX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n        const centerY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n        const t = ai.segments.length > 1 ? i / (ai.segments.length - 1) : 1;\n        const radius = (CELL_SIZE / 2 - 2) * (0.7 + t * 0.2);\n\n        const segmentHue = (ai.hueOffset + i * 15) % 360;\n        const color = this.hslToRgb(segmentHue / 360, 0.6, 0.4);\n\n        g.fillStyle(color, alpha * t);\n        g.fillCircle(centerX, centerY, radius);\n      }\n    }\n  }\n\n  private drawTrailParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.trailParticles) {\n      // Film noir: grayscale trail\n      g.fillStyle(COLORS.noirGray, p.life * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 1.5 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.5);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n  }\n\n  // Update comet trail - add new segments and fade old ones\n  private updateCometTrail(): void {\n    if (!this.currentState || this.currentState.gameOver) {\n      // Fade out trail on game over\n      for (const seg of this.cometTrail) {\n        seg.alpha *= 0.9;\n      }\n      this.cometTrail = this.cometTrail.filter(s => s.alpha > 0.01);\n      return;\n    }\n\n    const snake = this.currentState.snake;\n    if (snake.length === 0) return;\n\n    const head = snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Track head history for smooth interpolation\n    this.headHistory.unshift({ x: headX, y: headY, time: this.frameCount });\n    if (this.headHistory.length > 10) this.headHistory.pop();\n\n    // Add new trail segment at head position\n    if (this.frameCount % 2 === 0) {\n      const hue = 270 + Math.sin(this.frameCount * 0.05) * 20;\n      this.cometTrail.unshift({\n        x: headX,\n        y: headY,\n        alpha: 1,\n        size: CELL_SIZE / 2 + 2,\n        hue,\n      });\n\n      // Spawn ethereal particles from trail\n      if (Math.random() < 0.6) {\n        this.spawnEtherealParticle(headX, headY, hue);\n      }\n    }\n\n    // Limit trail length and fade segments\n    while (this.cometTrail.length > MAX_COMET_TRAIL_LENGTH) {\n      this.cometTrail.pop();\n    }\n\n    // Fade all segments\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const fadeRate = 0.06 + (i / this.cometTrail.length) * 0.04;\n      this.cometTrail[i].alpha -= fadeRate;\n      this.cometTrail[i].size *= 0.97;\n    }\n\n    // Remove fully faded segments\n    this.cometTrail = this.cometTrail.filter(s => s.alpha > 0);\n  }\n\n  // Spawn an ethereal particle that drifts away from the trail\n  private spawnEtherealParticle(x: number, y: number, hue: number): void {\n    if (this.etherealParticles.length >= MAX_ETHEREAL_PARTICLES) {\n      this.etherealParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.5;\n    const life = 0.8 + Math.random() * 0.4;\n\n    this.etherealParticles.push({\n      x: x + (Math.random() - 0.5) * 10,\n      y: y + (Math.random() - 0.5) * 10,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 0.3,\n      size: 3 + Math.random() * 4,\n      life,\n      maxLife: life,\n      hue: hue + (Math.random() - 0.5) * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n\n  // Update ethereal particles\n  private updateEtherealParticles(): void {\n    for (let i = this.etherealParticles.length - 1; i >= 0; i--) {\n      const p = this.etherealParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.015; // Slight upward drift\n      p.vx *= 0.98;\n      p.size *= 0.985;\n      p.life -= 0.02;\n      p.pulsePhase += 0.15;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.etherealParticles.splice(i, 1);\n      }\n    }\n  }\n\n  // Draw the comet trail - smooth glowing ribbon\n  private drawCometTrail(g: Phaser.GameObjects.Graphics): void {\n    if (this.cometTrail.length < 2) return;\n\n    // Draw outer glow layer\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.05) continue;\n\n      const progress = i / this.cometTrail.length;\n      const glowSize = seg.size * (1.5 + progress * 0.5);\n      const glowAlpha = seg.alpha * 0.15 * (1 - progress * 0.5);\n\n      // Outer ethereal glow\n      const outerColor = this.hslToRgb(seg.hue / 360, 0.6, 0.4);\n      g.fillStyle(outerColor, glowAlpha);\n      g.fillCircle(seg.x, seg.y, glowSize * 1.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(seg.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, glowAlpha * 1.5);\n      g.fillCircle(seg.x, seg.y, glowSize);\n    }\n\n    // Draw connecting ribbon between segments\n    if (this.cometTrail.length >= 2) {\n      for (let i = 0; i < this.cometTrail.length - 1; i++) {\n        const seg1 = this.cometTrail[i];\n        const seg2 = this.cometTrail[i + 1];\n        if (seg1.alpha < 0.1 || seg2.alpha < 0.1) continue;\n\n        const progress = i / this.cometTrail.length;\n        const ribbonAlpha = Math.min(seg1.alpha, seg2.alpha) * 0.4 * (1 - progress * 0.5);\n        const ribbonWidth = (seg1.size + seg2.size) / 2 * 0.6;\n\n        // Ribbon core\n        const ribbonColor = this.hslToRgb(seg1.hue / 360, 0.8, 0.6);\n        g.lineStyle(ribbonWidth, ribbonColor, ribbonAlpha);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n\n        // Bright inner ribbon\n        g.lineStyle(ribbonWidth * 0.4, 0xffffff, ribbonAlpha * 0.6);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n      }\n    }\n\n    // Draw core particles at each segment\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.1) continue;\n\n      const progress = i / this.cometTrail.length;\n      const coreAlpha = seg.alpha * 0.6 * (1 - progress * 0.7);\n      const coreSize = seg.size * 0.5 * (1 - progress * 0.3);\n\n      // Core glow\n      const coreColor = this.hslToRgb(seg.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, coreAlpha);\n      g.fillCircle(seg.x, seg.y, coreSize);\n\n      // Bright white center\n      g.fillStyle(0xffffff, coreAlpha * 0.5);\n      g.fillCircle(seg.x, seg.y, coreSize * 0.4);\n    }\n  }\n\n  // Draw ethereal particles - luminous drifting particles\n  private drawEtherealParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.etherealParticles) {\n      const lifeRatio = p.life / p.maxLife;\n      const pulse = 0.7 + Math.sin(p.pulsePhase) * 0.3;\n      const alpha = lifeRatio * pulse;\n\n      // Outer glow\n      const glowColor = this.hslToRgb(p.hue / 360, 0.5, 0.3);\n      g.fillStyle(glowColor, alpha * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 2.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(p.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      // Core\n      const coreColor = this.hslToRgb(p.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, alpha * 0.7);\n      g.fillCircle(p.x, p.y, p.size);\n\n      // Bright center\n      g.fillStyle(0xffffff, alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawShockWaves(g: Phaser.GameObjects.Graphics): void {\n    for (const sw of this.shockWaves) {\n      const alpha = sw.life * 0.6;\n      // Outer ring\n      g.lineStyle(3, 0xffffff, alpha * 0.3);\n      g.strokeCircle(sw.x, sw.y, sw.radius);\n      // Inner bright ring\n      g.lineStyle(2, 0x00ffff, alpha * 0.7);\n      g.strokeCircle(sw.x, sw.y, sw.radius * 0.8);\n      // Core flash\n      if (sw.life > 0.8) {\n        g.fillStyle(0xffffff, (sw.life - 0.8) * 3);\n        g.fillCircle(sw.x, sw.y, sw.radius * 0.3);\n      }\n    }\n  }\n\n  private drawLightningBolts(g: Phaser.GameObjects.Graphics): void {\n    for (const bolt of this.lightningBolts) {\n      const alpha = bolt.life;\n\n      // Film noir: white lightning\n      g.lineStyle(4, COLORS.noirGray, alpha * 0.3);\n      this.drawLightningPath(g, bolt.points);\n\n      g.lineStyle(2, 0xffffff, alpha * 0.8);\n      this.drawLightningPath(g, bolt.points);\n    }\n  }\n\n  private drawLightningPath(g: Phaser.GameObjects.Graphics, points: { x: number; y: number }[]): void {\n    if (points.length < 2) return;\n    g.beginPath();\n    g.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      g.lineTo(points[i].x, points[i].y);\n    }\n    g.strokePath();\n  }\n\n  private drawSnakeElectricity(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n    const snake = this.currentState.snake;\n    if (snake.length < 2) return;\n\n    // Draw electric arcs between segments every few frames\n    if (this.frameCount % 3 !== 0) return;\n\n    for (let i = 0; i < snake.length - 1; i++) {\n      if (Math.random() > 0.4) continue;\n\n      const seg1 = snake[i];\n      const seg2 = snake[i + 1];\n      const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n      const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n      const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n      const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const arcPoints = this.generateLightningPath(x1, y1, x2, y2);\n\n      // Film noir: grayscale arcs\n      g.lineStyle(3, COLORS.noirGray, 0.3);\n      this.drawLightningPath(g, arcPoints);\n      g.lineStyle(1, 0xffffff, 0.7);\n      this.drawLightningPath(g, arcPoints);\n    }\n  }\n\n  private hslToRgb(h: number, s: number, l: number): number {\n    let r: number, g: number, b: number;\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return (Math.round(r * 255) << 16) | (Math.round(g * 255) << 8) | Math.round(b * 255);\n  }\n\n  private loadHighScores(): HighScoreEntry[] {\n    if (this.highScoresLoaded && this.highScores.length > 0) {\n      return this.highScores;\n    }\n    try {\n      const stored = localStorage.getItem('snake_high_scores');\n      if (stored) {\n        const parsed = JSON.parse(stored) as HighScoreEntry[];\n        this.highScores = parsed.slice(0, MAX_HIGH_SCORES);\n        this.highScoresLoaded = true;\n        return this.highScores;\n      }\n    } catch {\n      // localStorage not available\n    }\n    this.highScores = [];\n    this.highScoresLoaded = true;\n    return this.highScores;\n  }\n\n  private saveHighScore(score: number): number {\n    const highScores = this.loadHighScores();\n    const newEntry: HighScoreEntry = { score, date: Date.now(), rank: 0 };\n\n    let insertIndex = highScores.findIndex(entry => score > entry.score);\n    if (insertIndex === -1) insertIndex = highScores.length;\n\n    if (insertIndex < MAX_HIGH_SCORES && score > 0) {\n      highScores.splice(insertIndex, 0, newEntry);\n      highScores.forEach((entry, i) => { entry.rank = i + 1; });\n      this.highScores = highScores.slice(0, MAX_HIGH_SCORES);\n\n      try {\n        localStorage.setItem('snake_high_scores', JSON.stringify(this.highScores));\n      } catch {\n        // localStorage not available\n      }\n      return insertIndex + 1;\n    }\n    return -1;\n  }\n\n  private checkAndSaveHighScore(): void {\n    if (!this.currentState) return;\n\n    if (this.currentState.gameOver && !this.lastGameOverState) {\n      const score = this.currentState.score || 0;\n      const rank = this.saveHighScore(score);\n      this.newHighScoreRank = rank > 0 ? rank : -1;\n      this.scoreboardRevealProgress = 0;\n\n      const head = this.currentState.snake[0];\n      if (head) {\n        const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnBlood(this.cleanEffects, headX, headY, 15);\n        spawnTears(this.cleanEffects, headX, headY - 10, 6);\n      }\n    }\n    this.lastGameOverState = this.currentState.gameOver;\n\n    if (this.currentState.gameStarted && !this.currentState.gameOver) {\n      this.newHighScoreRank = -1;\n    }\n  }\n\n  private drawHUD(g: Phaser.GameObjects.Graphics, width: number): void {\n    if (!this.currentState || !this.currentState.gameStarted) return;\n\n    this.hudPulsePhase += 0.08;\n    const score = this.currentState.score || 0;\n\n    if (score > this.lastHudScore) {\n      this.scoreFlashIntensity = 1;\n    }\n    this.lastHudScore = score;\n    this.scoreFlashIntensity *= 0.92;\n\n    const padding = 12;\n    const scorePanelWidth = 120;\n    const scorePanelHeight = 50;\n\n    // Score panel background - volcanic lava theme\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Glowing border\n    const borderGlow = 0.6 + this.scoreFlashIntensity * 0.4;\n    g.lineStyle(2, COLORS.snakeGlow, borderGlow);\n    g.strokeRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Score label\n    this.drawText(g, 'SCORE', padding + 10, padding + 12, 10, COLORS.snakeBody, 0.9);\n\n    // Score value with flash effect\n    const scoreColor = this.scoreFlashIntensity > 0.5 ? 0xffffff : COLORS.snakeHead;\n    this.drawText(g, String(score).padStart(5, '0'), padding + 10, padding + 32, 18, scoreColor, 1);\n\n    // Outer glow on score when flashing\n    if (this.scoreFlashIntensity > 0.1) {\n      g.fillStyle(COLORS.snakeGlow, this.scoreFlashIntensity * 0.3);\n      g.fillRoundedRect(padding + 5, padding + 20, 100, 28, 4);\n    }\n\n    // Length panel on the right\n    const lengthPanelWidth = 80;\n    const lengthPanelHeight = 50;\n    const lengthX = width - padding - lengthPanelWidth;\n\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    g.lineStyle(2, COLORS.foodGlow, 0.6);\n    g.strokeRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    this.drawText(g, 'LENGTH', lengthX + 10, padding + 12, 10, COLORS.food, 0.9);\n    this.drawText(g, String(this.currentState.snake.length), lengthX + 10, padding + 32, 18, COLORS.foodCore, 1);\n  }\n\n  private drawText(\n    g: Phaser.GameObjects.Graphics,\n    text: string,\n    x: number,\n    y: number,\n    size: number,\n    color: number,\n    alpha: number\n  ): void {\n    // Use simple block characters for text rendering\n    const charWidth = size * 0.6;\n    const charHeight = size;\n\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const cx = x + i * charWidth;\n\n      g.fillStyle(color, alpha);\n\n      // Simple pixel-style character rendering\n      if (char >= '0' && char <= '9') {\n        this.drawDigit(g, char, cx, y, size);\n      } else {\n        this.drawLetter(g, char, cx, y, size);\n      }\n    }\n  }\n\n  private drawDigit(g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15; // thickness\n\n    // 7-segment style digits\n    const segments: Record<string, number[]> = {\n      '0': [1, 1, 1, 0, 1, 1, 1],\n      '1': [0, 0, 1, 0, 0, 1, 0],\n      '2': [1, 0, 1, 1, 1, 0, 1],\n      '3': [1, 0, 1, 1, 0, 1, 1],\n      '4': [0, 1, 1, 1, 0, 1, 0],\n      '5': [1, 1, 0, 1, 0, 1, 1],\n      '6': [1, 1, 0, 1, 1, 1, 1],\n      '7': [1, 0, 1, 0, 0, 1, 0],\n      '8': [1, 1, 1, 1, 1, 1, 1],\n      '9': [1, 1, 1, 1, 0, 1, 1],\n    };\n\n    const seg = segments[digit] || segments['0'];\n\n    // Top horizontal\n    if (seg[0]) g.fillRect(x, y - h / 2, w, t);\n    // Top-left vertical\n    if (seg[1]) g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n    // Top-right vertical\n    if (seg[2]) g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n    // Middle horizontal\n    if (seg[3]) g.fillRect(x, y - t / 2, w, t);\n    // Bottom-left vertical\n    if (seg[4]) g.fillRect(x - t / 2, y, t, h / 2);\n    // Bottom-right vertical\n    if (seg[5]) g.fillRect(x + w - t / 2, y, t, h / 2);\n    // Bottom horizontal\n    if (seg[6]) g.fillRect(x, y + h / 2 - t, w, t);\n  }\n\n  private drawLetter(g: Phaser.GameObjects.Graphics, letter: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15;\n\n    // Simple block letters\n    switch (letter.toUpperCase()) {\n      case 'S':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'C':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'O':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'R':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w / 2, y, t, h / 2);\n        break;\n      case 'E':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w * 0.7, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'L':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'N':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - h / 2 + t, w, t);\n        break;\n      case 'G':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x + w / 2, y - t / 2, w / 2, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'T':\n        g.fillRect(x - t, y - h / 2, w + t * 2, t);\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'H':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n      case 'I':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'Y':\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        break;\n      case 'U':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'W':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case '!':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h * 0.6);\n        g.fillRect(x + w / 2 - t / 2, y + h / 2 - t * 2, t, t);\n        break;\n      case ' ':\n        break;\n      default:\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n    }\n  }\n\n  private drawScoreboard(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (!this.currentState || !this.currentState.gameOver) return;\n\n    this.scoreboardAnimPhase += 0.06;\n    this.scoreboardRevealProgress = Math.min(1, this.scoreboardRevealProgress + 0.02);\n\n    const highScores = this.loadHighScores();\n    const centerX = width / 2;\n    const baseY = height * 0.18;\n    const panelWidth = 180;\n    const panelHeight = 170;\n    const panelX = centerX - panelWidth / 2;\n    const panelY = baseY;\n    const slideOffset = (1 - this.scoreboardRevealProgress) * 50;\n    const alphaMultiplier = this.scoreboardRevealProgress;\n\n    // Panel background - volcanic lava glow\n    g.fillStyle(0x150510, 0.95 * alphaMultiplier);\n    g.fillRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Glowing border - animated\n    const borderHue = this.newHighScoreRank > 0 ? 45 : 0;\n    const borderPulse = 0.6 + Math.sin(this.scoreboardAnimPhase) * 0.2;\n    const borderColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    g.lineStyle(3, borderColor, borderPulse * alphaMultiplier);\n    g.strokeRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Title\n    const titleY = panelY - slideOffset + 22;\n    this.drawText(g, 'HIGH SCORES', centerX - 55, titleY, 10, COLORS.foodCore, alphaMultiplier);\n\n    // Divider line\n    g.lineStyle(1, COLORS.snakeGlow, 0.5 * alphaMultiplier);\n    g.lineBetween(panelX + 20, titleY + 8, panelX + panelWidth - 20, titleY + 8);\n\n    const entryStartY = titleY + 25;\n    const entryHeight = 22;\n\n    if (highScores.length === 0) {\n      this.drawText(g, 'NO SCORES YET', centerX - 50, entryStartY + 30, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n    } else {\n      for (let i = 0; i < Math.min(highScores.length, 5); i++) {\n        const entry = highScores[i];\n        const entryY = entryStartY + i * entryHeight;\n        const isNewScore = this.newHighScoreRank === i + 1;\n        const entryDelay = i * 0.15;\n        const entryProgress = Math.max(0, Math.min(1, (this.scoreboardRevealProgress - entryDelay) * 2));\n        if (entryProgress <= 0) continue;\n\n        const entryAlpha = alphaMultiplier * entryProgress;\n\n        // Highlight new high score row\n        if (isNewScore) {\n          const flashIntensity = 0.3 + Math.sin(this.scoreboardAnimPhase * 3) * 0.2;\n          g.fillStyle(0xffcc00, flashIntensity * entryAlpha);\n          g.fillRoundedRect(panelX + 8, entryY - slideOffset - 8, panelWidth - 16, entryHeight - 2, 4);\n        }\n\n        // Rank colors: gold, silver, bronze, then volcanic colors\n        const rankColors = [0xffd700, 0xc0c0c0, 0xcd7f32, COLORS.snakeGlow, COLORS.foodGlow];\n        const rankColor = rankColors[i] || 0x888888;\n\n        // Rank number\n        this.drawText(g, `${i + 1}`, panelX + 18, entryY - slideOffset, 10, rankColor, entryAlpha);\n\n        // Score value\n        const scoreColor = isNewScore ? 0xffffff : COLORS.foodCore;\n        this.drawText(g, String(entry.score).padStart(5, '0'), panelX + panelWidth - 70, entryY - slideOffset, 10, scoreColor, entryAlpha);\n\n        // NEW! label\n        if (isNewScore) {\n          const newAlpha = 0.8 + Math.sin(this.scoreboardAnimPhase * 4) * 0.2;\n          this.drawText(g, 'NEW', panelX + 50, entryY - slideOffset, 7, 0xffcc00, newAlpha * entryAlpha);\n        }\n      }\n    }\n\n    // Current score at bottom\n    const currentScoreY = panelY - slideOffset + panelHeight - 30;\n    this.drawText(g, 'YOUR SCORE', centerX - 40, currentScoreY - 10, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n\n    const currentScore = this.currentState.score || 0;\n    const scoreColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    this.drawText(g, String(currentScore).padStart(5, '0'), centerX - 25, currentScoreY + 8, 14, scoreColor, alphaMultiplier);\n  }\n\n  private drawGrid(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir grid: subtle, dark lines suggesting tile floor or city grid\n    g.lineStyle(1, COLORS.gridLine, 0.08);\n    for (let i = 0; i <= GRID_SIZE; i++) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Accent lines every 5 cells - subtle gray\n    const accentPulse = 0.12 + Math.sin(this.frameCount * 0.03) * 0.04;\n    g.lineStyle(1, COLORS.gridAccent, accentPulse);\n    for (let i = 0; i <= GRID_SIZE; i += 5) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Heavy vignette for dramatic noir look\n    this.drawVignette(g, width, height);\n  }\n\n  private drawVignette(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Multiple layers of vignette for smooth falloff\n    const layers = 5;\n    for (let i = 0; i < layers; i++) {\n      const inset = i * 30;\n      const alpha = 0.15 * (1 - i / layers);\n      g.lineStyle(60, 0x000000, alpha);\n      g.strokeRect(inset - 30, inset - 30, width - inset * 2 + 60, height - inset * 2 + 60);\n    }\n  }\n\n  private drawFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    // Don't draw food if it's still being thrown\n    if (this.thrownFood && !this.thrownFood.landed) return;\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    const pulseScale = 1 + Math.sin(this.frameCount * 0.15) * 0.08;\n    const glowPulse = 0.4 + Math.sin(this.frameCount * 0.1) * 0.2;\n\n    // Spawn particles (orange/yellow for Halloween)\n    this.spawnFoodParticles(foodX, foodY);\n\n    // Draw particles\n    for (const p of this.foodParticles) {\n      g.fillStyle(COLORS.pumpkinOrange, p.life * 0.4);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Halloween pumpkin!\n    const pumpkinSize = (CELL_SIZE / 2) * pulseScale;\n\n    // Shadow underneath\n    g.fillStyle(0x000000, 0.5);\n    g.fillEllipse(foodX + 2, foodY + pumpkinSize * 0.8, pumpkinSize * 1.2, pumpkinSize * 0.4);\n\n    // Outer orange glow (candlelight effect)\n    g.fillStyle(COLORS.pumpkinOrange, glowPulse * 0.15);\n    g.fillCircle(foodX, foodY, pumpkinSize + 12);\n    g.fillStyle(COLORS.candyCorn1, glowPulse * 0.2);\n    g.fillCircle(foodX, foodY, pumpkinSize + 6);\n\n    // Pumpkin body (slightly squashed circle)\n    g.fillStyle(COLORS.pumpkinOrange, 0.95);\n    g.fillEllipse(foodX, foodY, pumpkinSize * 1.1, pumpkinSize * 0.9);\n\n    // Pumpkin segments (darker lines)\n    g.lineStyle(2, 0xcc4400, 0.5);\n    g.lineBetween(foodX, foodY - pumpkinSize * 0.8, foodX, foodY + pumpkinSize * 0.7);\n    g.lineStyle(1.5, 0xcc4400, 0.3);\n    g.lineBetween(foodX - pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX - pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n    g.lineBetween(foodX + pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX + pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n\n    // Pumpkin stem\n    g.fillStyle(0x228822, 0.9);\n    g.fillRect(foodX - 2, foodY - pumpkinSize * 0.9 - 4, 4, 6);\n\n    // Jack-o-lantern face - glowing eyes and mouth\n    const faceGlow = 0.8 + Math.sin(this.frameCount * 0.12) * 0.2;\n    g.fillStyle(COLORS.candyCorn1, faceGlow);\n\n    // Eyes (triangles)\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n\n    // Mouth (jagged smile)\n    g.fillStyle(COLORS.candyCorn1, faceGlow * 0.9);\n    g.fillRect(foodX - pumpkinSize * 0.35, foodY + pumpkinSize * 0.15, pumpkinSize * 0.7, pumpkinSize * 0.25);\n\n    // Teeth (dark gaps in mouth)\n    g.fillStyle(COLORS.pumpkinOrange, 1);\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX, foodY + pumpkinSize * 0.15,\n      foodX - pumpkinSize * 0.075, foodY + pumpkinSize * 0.3\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.3, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.225, foodY + pumpkinSize * 0.3\n    );\n  }\n\n  private drawEnergyTendrils(g: Phaser.GameObjects.Graphics, foodX: number, foodY: number): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const head = this.currentState.snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Calculate distance to snake head\n    const dx = headX - foodX;\n    const dy = headY - foodY;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    // Only draw tendrils when snake is somewhat close\n    if (dist > CELL_SIZE * 6) return;\n\n    // Intensity increases as snake gets closer\n    const intensity = 1 - dist / (CELL_SIZE * 6);\n    const numTendrils = 2 + Math.floor(intensity * 2);\n\n    for (let i = 0; i < numTendrils; i++) {\n      // Tendril reaches partway toward the snake\n      const reach = 0.3 + intensity * 0.4;\n      const targetX = foodX + dx * reach;\n      const targetY = foodY + dy * reach;\n\n      // Add some wave offset for each tendril\n      const waveOffset = Math.sin(this.frameCount * 0.15 + i * 2) * 10;\n      const perpX = -dy / dist;\n      const perpY = dx / dist;\n      const wavyTargetX = targetX + perpX * waveOffset * (1 - reach);\n      const wavyTargetY = targetY + perpY * waveOffset * (1 - reach);\n\n      // Generate tendril path\n      const points = this.generateLightningPath(foodX, foodY, wavyTargetX, wavyTargetY);\n\n      // Draw tendril with glow\n      g.lineStyle(3, COLORS.foodGlow, intensity * 0.3);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1.5, COLORS.food, intensity * 0.7);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1, 0xffffff, intensity * 0.5);\n      this.drawLightningPath(g, points);\n    }\n  }\n\n  private drawSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const snakeLen = snake.length;\n\n    // Spooky shadow under snake\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const shadowRadius = (CELL_SIZE / 2) * (0.9 + t * 0.1);\n      g.fillStyle(0x000000, 0.5 * t);\n      g.fillCircle(centerX, centerY, shadowRadius);\n    }\n\n    // Draw trailing glow (ghostly green)\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const glowAlpha = 0.2 * t;\n      const glowSize = (CELL_SIZE / 2 + 4) * (0.5 + t * 0.5);\n\n      g.fillStyle(COLORS.snakeGlow, glowAlpha);\n      g.fillCircle(centerX, centerY, glowSize);\n    }\n\n    // Draw snake segments from tail to head with green gradient\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n\n      // Green gradient from tail (dark) to head (bright)\n      const brightness = 0.3 + t * 0.4;\n      const segmentColor = this.hslToRgb(0.4, 0.9, brightness);\n\n      if (i === 0) {\n        // Head: brightest green with eerie glow\n        g.fillStyle(COLORS.snakeGlow, 0.4);\n        g.fillCircle(centerX, centerY, radius + 8);\n\n        g.fillStyle(COLORS.snakeHead, 1);\n        g.fillCircle(centerX, centerY, radius + 1);\n\n        // Slimy highlight\n        g.fillStyle(0xaaffcc, 0.6);\n        g.fillCircle(centerX - 2, centerY - 2, radius * 0.35);\n\n        this.drawSnakeHead(g, segment, snake[1]);\n      } else {\n        // Body segment with green tones\n        g.fillStyle(COLORS.snakeGlow, 0.15);\n        g.fillCircle(centerX, centerY, radius + 2);\n\n        g.fillStyle(segmentColor, 1);\n        g.fillCircle(centerX, centerY, radius);\n\n        // Slimy specular highlight\n        g.fillStyle(0xaaffcc, 0.15 * t);\n        g.fillCircle(centerX - 1, centerY - 1, radius * 0.25);\n      }\n    }\n  }\n\n  private drawFoodBurst(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.foodBurstParticles) {\n      // Halloween: orange pumpkin burst\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailAlpha = p.life * 0.4 * (1 - i / p.trail.length);\n        const trailSize = p.size * p.life * (1 - i / p.trail.length);\n        g.fillStyle(COLORS.pumpkinOrange, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      g.fillStyle(COLORS.candyCorn1, p.life * 0.7);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n      g.fillStyle(COLORS.candyCorn3, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life * 0.4);\n    }\n  }\n\n  private drawEnergyField(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const snake = this.currentState.snake;\n    const baseIntensity = 0.06 + this.energyFieldPulse * 0.2;\n    const pulseOffset = Math.sin(this.frameCount * 0.1) * 0.02;\n    const alpha = Math.min(0.3, baseIntensity + pulseOffset);\n\n    // Halloween: ghostly green energy field\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const fieldRadius = CELL_SIZE * (0.8 + this.energyFieldPulse * 0.5) + Math.sin(this.frameCount * 0.15 + i * 0.5) * 2;\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.2);\n      g.fillCircle(cx, cy, fieldRadius + 4);\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.35);\n      g.fillCircle(cx, cy, fieldRadius);\n    }\n\n    // Connecting lines when pulse is active\n    if (this.energyFieldPulse > 0.3 && snake.length > 1) {\n      for (let i = 0; i < snake.length - 1; i++) {\n        const seg1 = snake[i];\n        const seg2 = snake[i + 1];\n        const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n        const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n        const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n        const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n        g.lineStyle(3, COLORS.noirGray, this.energyFieldPulse * 0.3);\n        g.lineBetween(x1, y1, x2, y2);\n        g.lineStyle(1.5, 0xffffff, this.energyFieldPulse * 0.5);\n        g.lineBetween(x1, y1, x2, y2);\n      }\n    }\n  }\n\n  private drawChromaticAberration(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const offset = this.chromaticIntensity * 3;\n\n    // Film noir: grayscale ghosting effect instead of color split\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snake.length > 1 ? i / (snake.length - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n      const alpha = this.chromaticIntensity * 0.3 * (i === 0 ? 1 : 0.5);\n\n      // Light ghost - offset left\n      g.fillStyle(0xffffff, alpha);\n      g.fillCircle(cx - offset, cy, radius);\n\n      // Dark ghost - offset right\n      g.fillStyle(0x404040, alpha);\n      g.fillCircle(cx + offset, cy, radius);\n    }\n  }\n\n  private drawGameOver(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir game over: dramatic fade to black with spotlight\n    if (this.gameOverAlpha < 0.85) {\n      this.gameOverAlpha += 0.03;\n    }\n\n    // Heavy dark overlay\n    g.fillStyle(COLORS.gameOverOverlay, this.gameOverAlpha);\n    g.fillRect(0, 0, width, height);\n\n    // Film grain effect (subtle noise lines)\n    for (let y = 0; y < height; y += 3) {\n      const grainAlpha = 0.05 + Math.random() * 0.05;\n      g.fillStyle(Math.random() > 0.5 ? 0xffffff : 0x000000, grainAlpha);\n      g.fillRect(0, y, width, 1);\n    }\n\n    // Dramatic spotlight in center\n    const spotPulse = 0.15 + Math.sin(this.frameCount * 0.05) * 0.05;\n    g.fillStyle(COLORS.noirWhite, spotPulse);\n    g.fillCircle(width / 2, height / 2, 80);\n    g.fillStyle(COLORS.noirWhite, spotPulse * 0.5);\n    g.fillCircle(width / 2, height / 2, 120);\n\n    // Noir border: thick black frame\n    const borderSize = 8;\n    g.fillStyle(0x000000, 0.8);\n    g.fillRect(0, 0, width, borderSize);\n    g.fillRect(0, height - borderSize, width, borderSize);\n    g.fillRect(0, 0, borderSize, height);\n    g.fillRect(width - borderSize, 0, borderSize, height);\n\n    // White inner border\n    const innerBorder = 2;\n    const innerOffset = borderSize;\n    g.fillStyle(COLORS.noirWhite, 0.3);\n    g.fillRect(innerOffset, innerOffset, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, height - innerOffset - innerBorder, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, innerOffset, innerBorder, height - innerOffset * 2);\n    g.fillRect(width - innerOffset - innerBorder, innerOffset, innerBorder, height - innerOffset * 2);\n  }\n\n  private drawSnakeHead(\n    g: Phaser.GameObjects.Graphics,\n    head: Position,\n    nextSegment: Position | undefined\n  ): void {\n    const centerX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const centerY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Determine direction for eye placement\n    let dx = 1, dy = 0;\n    if (nextSegment) {\n      dx = head.x - nextSegment.x;\n      dy = head.y - nextSegment.y;\n      // Normalize\n      const len = Math.sqrt(dx * dx + dy * dy);\n      if (len > 0) {\n        dx /= len;\n        dy /= len;\n      }\n    }\n\n    // Perpendicular for eye offset\n    const perpX = -dy;\n    const perpY = dx;\n\n    const eyeOffset = 4;\n    const eyeForward = 3;\n    const eyeRadius = 3;\n    const pupilRadius = 1.5;\n\n    // Left eye\n    const leftEyeX = centerX + perpX * eyeOffset + dx * eyeForward;\n    const leftEyeY = centerY + perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(leftEyeX, leftEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(leftEyeX + dx * 1, leftEyeY + dy * 1, pupilRadius);\n\n    // Right eye\n    const rightEyeX = centerX - perpX * eyeOffset + dx * eyeForward;\n    const rightEyeY = centerY - perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(rightEyeX, rightEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(rightEyeX + dx * 1, rightEyeY + dy * 1, pupilRadius);\n\n    // Draw the royal crown\n    this.drawCrown(g, centerX, centerY, dx, dy, perpX, perpY);\n  }\n\n  private drawCrown(\n    g: Phaser.GameObjects.Graphics,\n    headX: number,\n    headY: number,\n    dx: number,\n    dy: number,\n    perpX: number,\n    perpY: number\n  ): void {\n    // Volcanic crown: molten gold with ruby gems\n    const crownOffset = -8;\n    const crownBaseX = headX - dx * crownOffset;\n    const crownBaseY = headY - dy * crownOffset;\n\n    const crownWidth = 14;\n    const crownHeight = 10;\n    const halfWidth = crownWidth / 2;\n\n    const sparkle = 0.7 + Math.sin(this.frameCount * 0.15) * 0.3;\n\n    const baseLeft = {\n      x: crownBaseX + perpX * halfWidth,\n      y: crownBaseY + perpY * halfWidth\n    };\n    const baseRight = {\n      x: crownBaseX - perpX * halfWidth,\n      y: crownBaseY - perpY * halfWidth\n    };\n\n    const pointOffset = -dx * crownHeight;\n    const pointOffsetY = -dy * crownHeight;\n\n    const crownPoints = [\n      baseLeft,\n      { x: baseLeft.x + pointOffset * 0.4, y: baseLeft.y + pointOffsetY * 0.4 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: crownBaseX + perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY + perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY },\n      { x: crownBaseX - perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY - perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: baseRight.x + pointOffset * 0.4, y: baseRight.y + pointOffsetY * 0.4 },\n      baseRight\n    ];\n\n    // Crown glow (molten orange/red aura)\n    g.fillStyle(COLORS.noirWhite, 0.25 * sparkle);\n    g.fillCircle(crownBaseX + pointOffset * 0.5, crownBaseY + pointOffsetY * 0.5, crownHeight + 4);\n\n    // Crown base (molten gold)\n    g.fillStyle(0xffa500, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.fillPath();\n\n    // Crown outline (dark crimson)\n    g.lineStyle(1.5, 0x801010, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.strokePath();\n\n    // Crown band\n    const bandY1 = {\n      x: baseLeft.x + pointOffset * 0.15,\n      y: baseLeft.y + pointOffsetY * 0.15\n    };\n    const bandY2 = {\n      x: baseRight.x + pointOffset * 0.15,\n      y: baseRight.y + pointOffsetY * 0.15\n    };\n    g.lineStyle(3, 0xcc6600, 1);\n    g.lineBetween(bandY1.x, bandY1.y, bandY2.x, bandY2.y);\n\n    // Ruby jewels: glowing red gems\n    const jewelPositions = [\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY, size: 2.5 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n    ];\n\n    for (const jewel of jewelPositions) {\n      g.fillStyle(0xff4020, 0.5 * sparkle);\n      g.fillCircle(jewel.x, jewel.y, jewel.size + 2);\n\n      g.fillStyle(0xff2000, 1);\n      g.fillCircle(jewel.x, jewel.y, jewel.size);\n\n      g.fillStyle(0xffff80, 0.9 * sparkle);\n      g.fillCircle(jewel.x - 0.5, jewel.y - 0.5, jewel.size * 0.4);\n    }\n\n    // Crown highlight (golden gleam)\n    g.fillStyle(0xffff80, 0.6 * sparkle);\n    g.fillCircle(crownBaseX + perpX * 3 + pointOffset * 0.3, crownBaseY + perpY * 3 + pointOffsetY * 0.3, 2);\n  }\n}\n","structuredPatch":[{"oldStart":10,"oldLines":6,"newStart":10,"newLines":9,"lines":["   spawnBlood,","   updateTears,","   updateBlood,","+  initSnowflakes,","+  updateSnowflakes,","+  drawSnowflakes,","   drawCleanBackground,","   drawCleanGrid,","   drawMotes,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Q8ALzwizk8eigsrcuM4A8j","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to find where initMotes is called to add initSnowflakes nearby. Let me search for it."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":598,"cache_read_input_tokens":39808,"cache_creation":{"ephemeral_5m_input_tokens":598,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"5c71459d-94a6-4f93-a30e-7180a948c7e6"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Q8ALzwizk8eigsrcuM4A8j","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KupSBf5oYaoC6LAk73oxJy","name":"Grep","input":{"pattern":"initMotes","path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","output_mode":"content","-n":true,"-C":3},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":598,"cache_read_input_tokens":39808,"cache_creation":{"ephemeral_5m_input_tokens":598,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"ba3f3465-9a8f-4985-b32c-e09cc5501d16"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KupSBf5oYaoC6LAk73oxJy","type":"tool_result","content":"1-import Phaser from 'phaser';\n2-import {\n3-  createCleanEffectsState,\n4:  initMotes,\n5-  updateMotes,\n6-  updateRipples,\n7-  updateGlowTrail,\n--\n486-    this.graphics = this.add.graphics();\n487-    const width = GRID_SIZE * CELL_SIZE;\n488-    const height = GRID_SIZE * CELL_SIZE;\n489:    initMotes(this.cleanEffects, width, height);\n490-\n491-    if (this.currentState) {\n492-      this.needsRedraw = true;"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"10fff601-d46c-46b5-ace1-718b8f400f35","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"1-import Phaser from 'phaser';\n2-import {\n3-  createCleanEffectsState,\n4:  initMotes,\n5-  updateMotes,\n6-  updateRipples,\n7-  updateGlowTrail,\n--\n486-    this.graphics = this.add.graphics();\n487-    const width = GRID_SIZE * CELL_SIZE;\n488-    const height = GRID_SIZE * CELL_SIZE;\n489:    initMotes(this.cleanEffects, width, height);\n490-\n491-    if (this.currentState) {\n492-      this.needsRedraw = true;","numLines":15}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DMPiMCtGma4iG65YaviCF1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0157PuYaDQnXQuJhAdLjKJzh","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":485,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":384,"cache_read_input_tokens":40406,"cache_creation":{"ephemeral_5m_input_tokens":384,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"d4142850-6828-4724-9de2-f451814d3c65"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0157PuYaDQnXQuJhAdLjKJzh","type":"tool_result","content":"   485→  create(): void {\n   486→    this.graphics = this.add.graphics();\n   487→    const width = GRID_SIZE * CELL_SIZE;\n   488→    const height = GRID_SIZE * CELL_SIZE;\n   489→    initMotes(this.cleanEffects, width, height);\n   490→\n   491→    if (this.currentState) {\n   492→      this.needsRedraw = true;\n   493→    }\n   494→  }\n   495→\n   496→  private initArmageddonEffects(): void {\n   497→    const width = GRID_SIZE * CELL_SIZE;\n   498→    const height = GRID_SIZE * CELL_SIZE;\n   499→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"0d6b9c27-fa49-4467-9840-7af277487d28","tool_use_result":{"type":"text","file":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","content":"  create(): void {\n    this.graphics = this.add.graphics();\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    initMotes(this.cleanEffects, width, height);\n\n    if (this.currentState) {\n      this.needsRedraw = true;\n    }\n  }\n\n  private initArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n","numLines":15,"startLine":485,"totalLines":4146}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Pb1CBZZ2JY4Q3tRdkRWCai","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FVuiz7trC4NtVdEhnCsRtA","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","old_string":"  create(): void {\n    this.graphics = this.add.graphics();\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    initMotes(this.cleanEffects, width, height);\n\n    if (this.currentState) {\n      this.needsRedraw = true;\n    }\n  }","new_string":"  create(): void {\n    this.graphics = this.add.graphics();\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    initMotes(this.cleanEffects, width, height);\n    initSnowflakes(this.cleanEffects, width, height);\n\n    if (this.currentState) {\n      this.needsRedraw = true;\n    }\n  }"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":416,"cache_read_input_tokens":40790,"cache_creation":{"ephemeral_5m_input_tokens":416,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"6d67e019-ba46-42bc-84e0-66a4befed0ab"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FVuiz7trC4NtVdEhnCsRtA","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"35450cf1-d41b-4b5e-945d-7ec5b48d49cf","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","oldString":"  create(): void {\n    this.graphics = this.add.graphics();\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    initMotes(this.cleanEffects, width, height);\n\n    if (this.currentState) {\n      this.needsRedraw = true;\n    }\n  }","newString":"  create(): void {\n    this.graphics = this.add.graphics();\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    initMotes(this.cleanEffects, width, height);\n    initSnowflakes(this.cleanEffects, width, height);\n\n    if (this.currentState) {\n      this.needsRedraw = true;\n    }\n  }","originalFile":"import Phaser from 'phaser';\nimport {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  initSnowflakes,\n  updateSnowflakes,\n  drawSnowflakes,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface GameState {\n  snake: Position[];\n  food: Position;\n  gameOver: boolean;\n  gameStarted?: boolean;\n  score?: number;\n}\n\ninterface Star {\n  x: number;\n  y: number;\n  size: number;\n  speed: number;\n  brightness: number;\n}\n\ninterface PlasmaWave {\n  phase: number;\n  speed: number;\n  amplitude: number;\n  wavelength: number;\n  hue: number;\n}\n\ninterface AuroraWave {\n  y: number;\n  phase: number;\n  speed: number;\n  hue: number;\n  thickness: number;\n  amplitude: number;\n}\n\ninterface NebulaCloud {\n  x: number;\n  y: number;\n  radius: number;\n  hue: number;\n  alpha: number;\n  driftX: number;\n  driftY: number;\n  pulsePhase: number;\n  pulseSpeed: number;\n}\n\ninterface VortexRing {\n  radius: number;\n  baseRadius: number;\n  rotationOffset: number;\n  rotationSpeed: number;\n  thickness: number;\n  hue: number;\n  pulsePhase: number;\n}\n\ninterface VortexParticle {\n  angle: number;\n  radius: number;\n  baseRadius: number;\n  speed: number;\n  size: number;\n  hue: number;\n  alpha: number;\n}\n\ninterface SnakeAfterimage {\n  segments: Position[];\n  life: number;\n  maxLife: number;\n  hueOffset: number;\n}\n\ninterface FoodParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n}\n\ninterface SnakeTrailParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n  hue: number;\n}\n\ninterface ShockWave {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n}\n\ninterface LightningBolt {\n  points: { x: number; y: number }[];\n  life: number;\n  maxLife: number;\n  hue: number;\n}\n\nconst CELL_SIZE = 20;\nconst GRID_SIZE = 20;\nconst NUM_STARS = 30;\nconst MAX_FOOD_PARTICLES = 8;\nconst MAX_TRAIL_PARTICLES = 40;\nconst MAX_SHOCKWAVES = 3;\nconst MAX_LIGHTNING_BOLTS = 5;\nconst MAX_BURST_PARTICLES = 12;\nconst NUM_PLASMA_WAVES = 3;\nconst MAX_AFTERIMAGES = 4;\nconst NUM_AURORA_WAVES = 5;\nconst NUM_NEBULA_CLOUDS = 6;\nconst NUM_VORTEX_RINGS = 5;\nconst NUM_VORTEX_PARTICLES = 20;\nconst NUM_METEORS = 8;\nconst MAX_DEATH_DEBRIS = 24;\nconst NUM_SPIRITS_PER_EDGE = 2;\nconst MAX_FLAME_PARTICLES = 60;\nconst MAX_COMET_TRAIL_LENGTH = 30;\nconst MAX_ETHEREAL_PARTICLES = 50;\nconst NUM_BEES = 8;\nconst BEE_SPAWN_CHANCE = 0.02;\n\n// Comet trail segment - stores historical snake positions for smooth trail rendering\ninterface CometTrailSegment {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n  hue: number;\n}\n\n// Ethereal trail particle - luminous particles that drift away from trail\ninterface EtherealParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n  pulsePhase: number;\n}\n\n// Thrown food animation - food launched onto screen with arc trajectory\ninterface ThrownFood {\n  startX: number;\n  startY: number;\n  targetX: number;\n  targetY: number;\n  x: number;\n  y: number;\n  progress: number; // 0 to 1\n  rotation: number;\n  rotationSpeed: number;\n  trail: { x: number; y: number; alpha: number; rotation: number }[];\n  landed: boolean;\n  landingParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number }[];\n  impactRings: { radius: number; alpha: number }[];\n}\n\n// Meteor shower types\ninterface Meteor {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  alpha: number;\n  trail: { x: number; y: number; alpha: number }[];\n  life: number;\n}\n\n// Death debris particle\ninterface DeathDebris {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  rotation: number;\n  rotationSpeed: number;\n  life: number;\n  type: 'shard' | 'spark' | 'ember';\n}\n\n// Guardian spirit - ethereal protectors at edges\ninterface GuardianSpirit {\n  x: number;\n  y: number;\n  baseX: number;\n  baseY: number;\n  size: number;\n  phase: number;\n  speed: number;\n  haloPhase: number;\n  orbPhase: number;\n  edge: 'top' | 'bottom' | 'left' | 'right';\n  targetAlpha: number;\n  currentAlpha: number;\n  hue: number;\n  orbs: { angle: number; distance: number; size: number; speed: number }[];\n}\n\n// Flame particle for burning effect\ninterface FlameParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n}\n\n// Mystical bee - glowing magical creatures that swarm around food\ninterface MysticalBee {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  targetX: number;\n  targetY: number;\n  wingPhase: number;\n  wingSpeed: number;\n  size: number;\n  hue: number;\n  glowIntensity: number;\n  bobPhase: number;\n  bobSpeed: number;\n  trail: { x: number; y: number; alpha: number }[];\n  state: 'flying' | 'hovering' | 'attracted';\n  sparkleTimer: number;\n}\n\n// Rival snake - spectral AI nemesis that competes for food\ninterface RivalSnake {\n  segments: { x: number; y: number }[];\n  direction: { dx: number; dy: number };\n  targetX: number;\n  targetY: number;\n  moveTimer: number;\n  moveInterval: number;\n  pulsePhase: number;\n  glowIntensity: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n  energyTrail: { x: number; y: number; alpha: number; size: number }[];\n  state: 'hunting' | 'fleeing' | 'circling';\n  aggression: number;\n  nearMissTimer: number;\n  electricArcs: { x1: number; y1: number; x2: number; y2: number; life: number }[];\n}\n\nconst RIVAL_SNAKE_LENGTH = 10;\nconst RIVAL_MOVE_INTERVAL = 8;\n\n// Armageddon Chaos effect types\ninterface GroundFissure {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  width: number;\n  glowIntensity: number;\n  pulsePhase: number;\n}\n\ninterface FireRainParticle {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n}\n\ninterface ChaosExplosion {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n  rings: { radius: number; alpha: number }[];\n  debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[];\n}\n\ninterface ApocalypticSkull {\n  x: number;\n  y: number;\n  size: number;\n  alpha: number;\n  rotation: number;\n  pulsePhase: number;\n}\n\nconst NUM_FISSURES = 6;\nconst MAX_FIRE_RAIN = 30;\nconst MAX_CHAOS_EXPLOSIONS = 3;\nconst NUM_SKULLS = 4;\n\n// High score entry for scoreboard\ninterface HighScoreEntry {\n  score: number;\n  date: number;\n  rank: number;\n}\n\nconst MAX_HIGH_SCORES = 5;\n\n// Color palette - HALLOWEEN theme: spooky purple/orange, ghostly greens, pumpkin glow\nconst COLORS = {\n  bgDark: 0x0a0012,\n  bgMid: 0x150825,\n  gridLine: 0x2a1540,\n  gridAccent: 0x401860,\n  snakeHead: 0x00ff66,\n  snakeBody: 0x00cc55,\n  snakeTail: 0x009944,\n  snakeHighlight: 0x66ffaa,\n  snakeScale: 0x00aa44,\n  snakeEye: 0xff0000,\n  snakePupil: 0x000000,\n  snakeGlow: 0x00ff80,\n  food: 0xff6600,\n  foodCore: 0xffcc00,\n  foodGlow: 0xff8800,\n  foodParticle: 0xffaa00,\n  star: 0x8844ff,\n  gameOverOverlay: 0x0a0015,\n  gameOverText: 0xff6600,\n  plasma1: 0x9933ff,\n  plasma2: 0xbb55ff,\n  plasma3: 0x7722cc,\n  screenFlash: 0xff6600,\n  // Halloween specific colors\n  noirWhite: 0xeeddff,\n  noirGray: 0x8866aa,\n  noirDark: 0x2a1540,\n  spotlight: 0xff8800,\n  // Halloween additions\n  chaosRed: 0x9933ff,\n  chaosOrange: 0xff6600,\n  chaosYellow: 0xffcc00,\n  lavaGlow: 0x9944ff,\n  ashGray: 0x554466,\n  bloodRed: 0x660088,\n  hellfire: 0xff6600,\n  // New Halloween colors\n  pumpkinOrange: 0xff6600,\n  ghostWhite: 0xeeffee,\n  witchPurple: 0x9933ff,\n  spiderBlack: 0x111122,\n  candyCorn1: 0xffcc00,\n  candyCorn2: 0xff8800,\n  candyCorn3: 0xffffff,\n};\n\nexport class SnakeScene extends Phaser.Scene {\n  private graphics!: Phaser.GameObjects.Graphics;\n  private currentState: GameState | null = null;\n  private needsRedraw = false;\n  private frameCount = 0;\n  private stars: Star[] = [];\n  private foodParticles: FoodParticle[] = [];\n  private trailParticles: SnakeTrailParticle[] = [];\n  private shockWaves: ShockWave[] = [];\n  private lightningBolts: LightningBolt[] = [];\n  private plasmaWaves: PlasmaWave[] = [];\n  private snakeAfterimages: SnakeAfterimage[] = [];\n  private auroraWaves: AuroraWave[] = [];\n  private nebulaClouds: NebulaCloud[] = [];\n  private vortexRings: VortexRing[] = [];\n  private vortexParticles: VortexParticle[] = [];\n  private vortexPulse = 0;\n  private meteors: Meteor[] = [];\n  private deathDebris: DeathDebris[] = [];\n  private deathExplosionPhase = 0;\n  private gameOverAlpha = 0;\n  private lastHeadPos: Position | null = null;\n  private lastSnakeLength = 0;\n  private hueOffset = 0;\n  private screenFlashAlpha = 0;\n  private gameOverGlitchOffset = 0;\n  private screenShakeX = 0;\n  private screenShakeY = 0;\n  private screenShakeIntensity = 0;\n  private energyFieldPulse = 0;\n  private foodBurstParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number; hue: number; trail: { x: number; y: number }[] }[] = [];\n  private chromaticIntensity = 0;\n  // Film noir effects\n  private venetianPhase = 0;\n  private spotlightX = 0;\n  private spotlightY = 0;\n  private smokeParticles: { x: number; y: number; vx: number; vy: number; size: number; alpha: number; life: number }[] = [];\n  private guardianSpirits: GuardianSpirit[] = [];\n  // Burning flame particles trailing behind snake\n  private flameParticles: FlameParticle[] = [];\n  // Comet trail system - historical positions for smooth ribbon trail\n  private cometTrail: CometTrailSegment[] = [];\n  // Ethereal particles that drift away from the trail\n  private etherealParticles: EtherealParticle[] = [];\n  // Track last few head positions for smooth interpolation\n  private headHistory: { x: number; y: number; time: number }[] = [];\n  // Thrown food animation system\n  private thrownFood: ThrownFood | null = null;\n  private lastFoodPos: Position | null = null;\n  // Mystical bees swarming around\n  private bees: MysticalBee[] = [];\n  // Rival snake - spectral AI nemesis\n  private rivalSnake: RivalSnake | null = null;\n  // Scoreboard system\n  private highScores: HighScoreEntry[] = [];\n  private highScoresLoaded = false;\n  private newHighScoreRank = -1;\n  private scoreboardAnimPhase = 0;\n  private scoreboardRevealProgress = 0;\n  private lastGameOverState = false;\n  private hudPulsePhase = 0;\n  private lastHudScore = 0;\n  private scoreFlashIntensity = 0;\n  // Armageddon Chaos effects\n  private groundFissures: GroundFissure[] = [];\n  private fireRainParticles: FireRainParticle[] = [];\n  private chaosExplosions: ChaosExplosion[] = [];\n  private apocalypticSkulls: ApocalypticSkull[] = [];\n  private armageddonPulse = 0;\n  private chaosIntensity = 0;\n  private cleanEffects: CleanEffectsState = createCleanEffectsState();\n\n  constructor() {\n    super({ key: 'SnakeScene' });\n  }\n\n  create(): void {\n    this.graphics = this.add.graphics();\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    initMotes(this.cleanEffects, width, height);\n\n    if (this.currentState) {\n      this.needsRedraw = true;\n    }\n  }\n\n  private initArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Initialize ground fissures - cracks in the earth with lava\n    this.groundFissures = [];\n    for (let i = 0; i < NUM_FISSURES; i++) {\n      const startX = Math.random() * width;\n      const startY = Math.random() * height;\n      const angle = Math.random() * Math.PI;\n      const length = 40 + Math.random() * 80;\n      this.groundFissures.push({\n        x1: startX,\n        y1: startY,\n        x2: startX + Math.cos(angle) * length,\n        y2: startY + Math.sin(angle) * length,\n        width: 2 + Math.random() * 4,\n        glowIntensity: 0.5 + Math.random() * 0.5,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n\n    // Initialize fire rain\n    this.fireRainParticles = [];\n\n    // Initialize chaos explosions\n    this.chaosExplosions = [];\n\n    // Initialize apocalyptic skulls floating in background\n    this.apocalypticSkulls = [];\n    for (let i = 0; i < NUM_SKULLS; i++) {\n      this.apocalypticSkulls.push({\n        x: 30 + Math.random() * (width - 60),\n        y: 30 + Math.random() * (height - 60),\n        size: 15 + Math.random() * 10,\n        alpha: 0.03 + Math.random() * 0.04,\n        rotation: Math.random() * Math.PI * 2,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n  }\n\n  private initSmokeParticles(): void {\n    this.smokeParticles = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < 12; i++) {\n      this.smokeParticles.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        vx: (Math.random() - 0.5) * 0.3,\n        vy: -0.1 - Math.random() * 0.2,\n        size: 30 + Math.random() * 50,\n        alpha: 0.02 + Math.random() * 0.03,\n        life: Math.random(),\n      });\n    }\n  }\n\n  private updateArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    this.armageddonPulse += 0.04;\n\n    // Update ground fissures - pulsing lava glow\n    for (const fissure of this.groundFissures) {\n      fissure.pulsePhase += 0.06;\n      fissure.glowIntensity = 0.5 + Math.sin(fissure.pulsePhase) * 0.3;\n    }\n\n    // Spawn fire rain particles\n    if (this.fireRainParticles.length < MAX_FIRE_RAIN && Math.random() < 0.3) {\n      const hueVariation = Math.random();\n      this.fireRainParticles.push({\n        x: Math.random() * width,\n        y: -20,\n        vy: 2 + Math.random() * 3,\n        size: 2 + Math.random() * 4,\n        alpha: 0.6 + Math.random() * 0.4,\n        hue: hueVariation < 0.6 ? 0 : (hueVariation < 0.85 ? 20 : 40), // Red, orange, yellow\n        trail: [],\n      });\n    }\n\n    // Update fire rain\n    for (let i = this.fireRainParticles.length - 1; i >= 0; i--) {\n      const p = this.fireRainParticles[i];\n      p.trail.unshift({ x: p.x, y: p.y, alpha: p.alpha });\n      if (p.trail.length > 6) p.trail.pop();\n      for (const t of p.trail) { t.alpha *= 0.7; }\n\n      p.y += p.vy;\n      p.x += Math.sin(this.armageddonPulse + p.y * 0.05) * 0.3;\n      p.alpha *= 0.995;\n\n      if (p.y > height + 20 || p.alpha < 0.05) {\n        this.fireRainParticles.splice(i, 1);\n      }\n    }\n\n    // Update chaos explosions\n    for (let i = this.chaosExplosions.length - 1; i >= 0; i--) {\n      const exp = this.chaosExplosions[i];\n      exp.radius += 4;\n      exp.life -= 0.03;\n\n      for (const ring of exp.rings) {\n        ring.radius += 3;\n        ring.alpha *= 0.92;\n      }\n      exp.rings = exp.rings.filter(r => r.alpha > 0.02);\n\n      for (const d of exp.debris) {\n        d.x += d.vx;\n        d.y += d.vy;\n        d.vy += 0.1;\n        d.alpha *= 0.96;\n      }\n      exp.debris = exp.debris.filter(d => d.alpha > 0.02);\n\n      if (exp.life <= 0 && exp.rings.length === 0 && exp.debris.length === 0) {\n        this.chaosExplosions.splice(i, 1);\n      }\n    }\n\n    // Update apocalyptic skulls - slow drift and pulse\n    for (const skull of this.apocalypticSkulls) {\n      skull.pulsePhase += 0.02;\n      skull.rotation += 0.002;\n      skull.x += Math.sin(skull.pulsePhase * 0.5) * 0.1;\n      skull.y += Math.cos(skull.pulsePhase * 0.3) * 0.1;\n\n      // Keep in bounds\n      if (skull.x < 20) skull.x = 20;\n      if (skull.x > width - 20) skull.x = width - 20;\n      if (skull.y < 20) skull.y = 20;\n      if (skull.y > height - 20) skull.y = height - 20;\n    }\n\n    // Chaos intensity increases when snake eats or dies\n    this.chaosIntensity *= 0.97;\n  }\n\n  private spawnChaosExplosion(x: number, y: number): void {\n    if (this.chaosExplosions.length >= MAX_CHAOS_EXPLOSIONS) {\n      this.chaosExplosions.shift();\n    }\n\n    const debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[] = [];\n    for (let i = 0; i < 12; i++) {\n      const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 5;\n      debris.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 2,\n        size: 2 + Math.random() * 4,\n        alpha: 1,\n      });\n    }\n\n    this.chaosExplosions.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: 80,\n      life: 1,\n      rings: [\n        { radius: 10, alpha: 1 },\n        { radius: 5, alpha: 0.8 },\n        { radius: 15, alpha: 0.6 },\n      ],\n      debris,\n    });\n\n    this.chaosIntensity = Math.min(1, this.chaosIntensity + 0.5);\n    this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 12);\n  }\n\n  private drawArmageddonBackground(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Spooky Halloween night sky\n    const skyPulse = 0.8 + Math.sin(this.armageddonPulse * 0.5) * 0.2;\n\n    // Layer 1: Deep purple-black night base\n    g.fillStyle(0x0a0018, 1);\n    g.fillRect(0, 0, width, height);\n\n    // Layer 2: Eerie purple glow from below (like fog)\n    g.fillStyle(0x200840, 0.3 * skyPulse);\n    g.fillRect(0, height * 0.7, width, height * 0.3);\n\n    // Layer 3: Misty purple clouds\n    for (let i = 0; i < 4; i++) {\n      const cloudY = i * 30 + Math.sin(this.armageddonPulse + i) * 10;\n      const cloudAlpha = 0.1 - i * 0.02;\n      g.fillStyle(0x301040, cloudAlpha * skyPulse);\n      g.fillRect(0, cloudY, width, 40);\n    }\n\n    // Draw haunted moon\n    this.drawHauntedMoon(g, width);\n\n    // Draw flying bats in background\n    this.drawFlyingBats(g, width, height);\n\n    // Draw apocalyptic skulls (very faint, background layer)\n    this.drawApocalypticSkulls(g);\n  }\n\n  private drawHauntedMoon(g: Phaser.GameObjects.Graphics, width: number): void {\n    const moonX = width * 0.8;\n    const moonY = 60;\n    const moonRadius = 35;\n    const moonPulse = 0.9 + Math.sin(this.frameCount * 0.02) * 0.1;\n\n    // Moon glow\n    g.fillStyle(0xff8800, 0.1 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 2);\n    g.fillStyle(0xffaa00, 0.15 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 1.5);\n\n    // Main moon (orange harvest moon)\n    g.fillStyle(0xffaa33, 0.9);\n    g.fillCircle(moonX, moonY, moonRadius);\n\n    // Moon craters\n    g.fillStyle(0xcc8822, 0.4);\n    g.fillCircle(moonX - 10, moonY - 5, 8);\n    g.fillCircle(moonX + 12, moonY + 8, 6);\n    g.fillCircle(moonX - 5, moonY + 12, 5);\n  }\n\n  private drawFlyingBats(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const batCount = 6;\n    for (let i = 0; i < batCount; i++) {\n      const phase = this.frameCount * 0.03 + i * 1.5;\n      const batX = ((i * 127 + this.frameCount * 0.5) % (width + 100)) - 50;\n      const batY = 40 + i * 20 + Math.sin(phase) * 15;\n      const wingPhase = Math.sin(this.frameCount * 0.15 + i * 2);\n\n      // Bat body\n      g.fillStyle(0x111122, 0.8);\n      g.fillCircle(batX, batY, 4);\n\n      // Bat wings (flapping)\n      const wingSpread = 8 + wingPhase * 4;\n      g.fillStyle(0x111122, 0.7);\n\n      // Left wing\n      g.beginPath();\n      g.moveTo(batX - 2, batY);\n      g.lineTo(batX - wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX - wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n\n      // Right wing\n      g.beginPath();\n      g.moveTo(batX + 2, batY);\n      g.lineTo(batX + wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX + wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawGroundFissures(g: Phaser.GameObjects.Graphics): void {\n    for (const fissure of this.groundFissures) {\n      const pulse = fissure.glowIntensity;\n\n      // Ghostly purple glow underneath\n      g.lineStyle(fissure.width * 3, COLORS.lavaGlow, 0.12 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Crack edges (dark purple)\n      g.lineStyle(fissure.width + 2, 0x200030, 0.4);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ethereal core (bright purple)\n      g.lineStyle(fissure.width, COLORS.witchPurple, 0.3 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ghostly white center\n      g.lineStyle(fissure.width * 0.3, COLORS.ghostWhite, 0.2 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n    }\n  }\n\n  private drawFireRain(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.fireRainParticles) {\n      // Draw ghostly trail\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailSize = p.size * (1 - i / p.trail.length) * 0.6;\n        // Ghostly purple/green trail\n        const ghostHue = 0.75 + (p.hue % 60) / 360;\n        const trailColor = this.hslToRgb(ghostHue, 0.6, 0.6);\n        g.fillStyle(trailColor, t.alpha * 0.3);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Main spirit particle (ghostly appearance)\n      const outerColor = this.hslToRgb(0.8, 0.5, 0.5);\n      const coreColor = this.hslToRgb(0.85, 0.3, 0.8);\n\n      g.fillStyle(outerColor, p.alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      g.fillStyle(coreColor, p.alpha * 0.6);\n      g.fillCircle(p.x, p.y, p.size);\n\n      g.fillStyle(COLORS.ghostWhite, p.alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawChaosExplosions(g: Phaser.GameObjects.Graphics): void {\n    for (const exp of this.chaosExplosions) {\n      // Central flash\n      if (exp.life > 0.7) {\n        const flashAlpha = (exp.life - 0.7) * 3;\n        g.fillStyle(0xffffff, flashAlpha * 0.5);\n        g.fillCircle(exp.x, exp.y, exp.radius * 0.5);\n        g.fillStyle(COLORS.chaosYellow, flashAlpha * 0.4);\n        g.fillCircle(exp.x, exp.y, exp.radius);\n      }\n\n      // Expanding rings\n      for (const ring of exp.rings) {\n        g.lineStyle(4, COLORS.chaosRed, ring.alpha * 0.5);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(2, COLORS.chaosOrange, ring.alpha * 0.7);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(1, 0xffffff, ring.alpha * 0.4);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n      }\n\n      // Flying debris\n      for (const d of exp.debris) {\n        g.fillStyle(COLORS.chaosOrange, d.alpha * 0.6);\n        g.fillCircle(d.x, d.y, d.size * 1.3);\n        g.fillStyle(COLORS.chaosYellow, d.alpha * 0.9);\n        g.fillCircle(d.x, d.y, d.size);\n      }\n    }\n  }\n\n  private drawApocalypticSkulls(g: Phaser.GameObjects.Graphics): void {\n    for (const skull of this.apocalypticSkulls) {\n      const pulse = 0.7 + Math.sin(skull.pulsePhase) * 0.3;\n      const alpha = skull.alpha * pulse;\n      const s = skull.size;\n\n      // Ghostly purple glow\n      g.fillStyle(COLORS.witchPurple, alpha * 0.2);\n      g.fillCircle(skull.x, skull.y, s * 1.5);\n\n      // Skull outline (bone white)\n      g.fillStyle(0xcccccc, alpha * 0.8);\n      // Cranium\n      g.fillCircle(skull.x, skull.y - s * 0.1, s * 0.8);\n      // Jaw\n      g.fillRect(skull.x - s * 0.4, skull.y + s * 0.3, s * 0.8, s * 0.4);\n\n      // Eye sockets (glowing green - spooky!)\n      g.fillStyle(COLORS.snakeHead, alpha * 1.2);\n      g.fillCircle(skull.x - s * 0.25, skull.y - s * 0.1, s * 0.2);\n      g.fillCircle(skull.x + s * 0.25, skull.y - s * 0.1, s * 0.2);\n\n      // Nose hole\n      g.fillStyle(0x000000, alpha);\n      g.fillTriangle(\n        skull.x, skull.y + s * 0.1,\n        skull.x - s * 0.1, skull.y + s * 0.25,\n        skull.x + s * 0.1, skull.y + s * 0.25\n      );\n    }\n  }\n\n  private drawChaosOverlay(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (this.chaosIntensity <= 0) return;\n\n    // Purple tint overlay when chaos is active\n    g.fillStyle(COLORS.witchPurple, this.chaosIntensity * 0.1);\n    g.fillRect(0, 0, width, height);\n\n    // Pulsing purple vignette edges\n    const vignetteAlpha = this.chaosIntensity * 0.25;\n    g.lineStyle(80, COLORS.bloodRed, vignetteAlpha);\n    g.strokeRect(-40, -40, width + 80, height + 80);\n  }\n\n  private initGuardianSpirits(): void {\n    this.guardianSpirits = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const spiritHues = [180, 220, 280, 320];\n\n    const edges: ('top' | 'bottom' | 'left' | 'right')[] = ['top', 'bottom', 'left', 'right'];\n    for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      const edge = edges[edgeIndex];\n      for (let i = 0; i < NUM_SPIRITS_PER_EDGE; i++) {\n        let x = 0, y = 0;\n        const offset = (i + 0.5) / NUM_SPIRITS_PER_EDGE;\n\n        switch (edge) {\n          case 'top':\n            x = width * offset;\n            y = -15;\n            break;\n          case 'bottom':\n            x = width * offset;\n            y = height + 15;\n            break;\n          case 'left':\n            x = -15;\n            y = height * offset;\n            break;\n          case 'right':\n            x = width + 15;\n            y = height * offset;\n            break;\n        }\n\n        const orbs: { angle: number; distance: number; size: number; speed: number }[] = [];\n        const numOrbs = 3;\n        for (let o = 0; o < numOrbs; o++) {\n          orbs.push({\n            angle: (o / numOrbs) * Math.PI * 2,\n            distance: 15 + Math.random() * 10,\n            size: 3 + Math.random() * 2,\n            speed: 0.03 + Math.random() * 0.02,\n          });\n        }\n\n        this.guardianSpirits.push({\n          x,\n          y,\n          baseX: x,\n          baseY: y,\n          size: 20 + Math.random() * 10,\n          phase: Math.random() * Math.PI * 2,\n          speed: 0.015 + Math.random() * 0.01,\n          haloPhase: Math.random() * Math.PI * 2,\n          orbPhase: Math.random() * Math.PI * 2,\n          edge,\n          targetAlpha: 0.4 + Math.random() * 0.2,\n          currentAlpha: 0,\n          hue: spiritHues[edgeIndex % spiritHues.length] + Math.random() * 30 - 15,\n          orbs,\n        });\n      }\n    }\n  }\n\n  private initBees(): void {\n    this.bees = [];\n  }\n\n  private initRivalSnake(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    const startX = width - 50 - Math.random() * 50;\n    const startY = height - 50 - Math.random() * 50;\n\n    const segments: { x: number; y: number }[] = [];\n    for (let i = 0; i < RIVAL_SNAKE_LENGTH; i++) {\n      segments.push({\n        x: startX + i * CELL_SIZE * 0.6,\n        y: startY,\n      });\n    }\n\n    this.rivalSnake = {\n      segments,\n      direction: { dx: -1, dy: 0 },\n      targetX: width / 2,\n      targetY: height / 2,\n      moveTimer: 0,\n      moveInterval: RIVAL_MOVE_INTERVAL,\n      pulsePhase: 0,\n      glowIntensity: 0.8,\n      hue: 200,\n      trail: [],\n      energyTrail: [],\n      state: 'hunting',\n      aggression: 0.5,\n      nearMissTimer: 0,\n      electricArcs: [],\n    };\n  }\n\n  private updateRivalSnake(): void {\n    if (!this.rivalSnake || !this.currentState) return;\n\n    const rs = this.rivalSnake;\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    rs.pulsePhase += 0.1;\n    rs.glowIntensity = 0.6 + Math.sin(rs.pulsePhase) * 0.3;\n\n    if (rs.segments.length > 0) {\n      rs.trail.unshift({ x: rs.segments[0].x, y: rs.segments[0].y, alpha: 0.7 });\n      if (rs.trail.length > 20) rs.trail.pop();\n\n      rs.energyTrail.unshift({\n        x: rs.segments[0].x + (Math.random() - 0.5) * 8,\n        y: rs.segments[0].y + (Math.random() - 0.5) * 8,\n        alpha: 0.8,\n        size: 3 + Math.random() * 4\n      });\n      if (rs.energyTrail.length > 30) rs.energyTrail.pop();\n    }\n\n    for (const t of rs.trail) {\n      t.alpha *= 0.92;\n    }\n    rs.trail = rs.trail.filter(t => t.alpha > 0.02);\n\n    for (const e of rs.energyTrail) {\n      e.alpha *= 0.88;\n      e.size *= 0.95;\n    }\n    rs.energyTrail = rs.energyTrail.filter(e => e.alpha > 0.02);\n\n    rs.electricArcs = rs.electricArcs.filter(arc => {\n      arc.life -= 0.15;\n      return arc.life > 0;\n    });\n\n    if (rs.nearMissTimer > 0) rs.nearMissTimer--;\n\n    const playerHead = this.currentState.snake[0];\n    const playerX = playerHead.x * CELL_SIZE + CELL_SIZE / 2;\n    const playerY = playerHead.y * CELL_SIZE + CELL_SIZE / 2;\n    const rivalHead = rs.segments[0];\n    const distToPlayer = Math.sqrt(\n      Math.pow(playerX - rivalHead.x, 2) + Math.pow(playerY - rivalHead.y, 2)\n    );\n\n    if (distToPlayer < 60 && rs.nearMissTimer === 0) {\n      rs.nearMissTimer = 30;\n      rs.electricArcs.push({\n        x1: rivalHead.x,\n        y1: rivalHead.y,\n        x2: playerX,\n        y2: playerY,\n        life: 1.0\n      });\n      rs.aggression = Math.min(1.0, rs.aggression + 0.1);\n    }\n\n    rs.moveTimer++;\n    if (rs.moveTimer >= rs.moveInterval) {\n      rs.moveTimer = 0;\n\n      const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n      const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n      const distToFood = Math.sqrt(\n        Math.pow(foodX - rivalHead.x, 2) + Math.pow(foodY - rivalHead.y, 2)\n      );\n\n      if (distToPlayer < 80) {\n        rs.state = 'fleeing';\n        const fleeAngle = Math.atan2(rivalHead.y - playerY, rivalHead.x - playerX);\n        rs.targetX = rivalHead.x + Math.cos(fleeAngle) * 100;\n        rs.targetY = rivalHead.y + Math.sin(fleeAngle) * 100;\n      } else if (distToFood < 150 || rs.aggression > 0.7) {\n        rs.state = 'hunting';\n        rs.targetX = foodX;\n        rs.targetY = foodY;\n      } else {\n        rs.state = 'circling';\n        const circleAngle = rs.pulsePhase * 0.3;\n        rs.targetX = width / 2 + Math.cos(circleAngle) * 120;\n        rs.targetY = height / 2 + Math.sin(circleAngle) * 120;\n      }\n\n      rs.targetX = Math.max(30, Math.min(width - 30, rs.targetX));\n      rs.targetY = Math.max(30, Math.min(height - 30, rs.targetY));\n\n      const dx = rs.targetX - rivalHead.x;\n      const dy = rs.targetY - rivalHead.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 5) {\n        const targetDx = dx / dist;\n        const targetDy = dy / dist;\n        const turnSpeed = rs.state === 'fleeing' ? 0.5 : 0.35;\n\n        rs.direction.dx = rs.direction.dx * (1 - turnSpeed) + targetDx * turnSpeed;\n        rs.direction.dy = rs.direction.dy * (1 - turnSpeed) + targetDy * turnSpeed;\n\n        const len = Math.sqrt(rs.direction.dx * rs.direction.dx + rs.direction.dy * rs.direction.dy);\n        if (len > 0) {\n          rs.direction.dx /= len;\n          rs.direction.dy /= len;\n        }\n      }\n\n      const moveSpeed = rs.state === 'fleeing' ? CELL_SIZE * 0.7 : CELL_SIZE * 0.55;\n      const newHead = {\n        x: rivalHead.x + rs.direction.dx * moveSpeed,\n        y: rivalHead.y + rs.direction.dy * moveSpeed,\n      };\n\n      if (newHead.x < 10) newHead.x = width - 10;\n      if (newHead.x > width - 10) newHead.x = 10;\n      if (newHead.y < 10) newHead.y = height - 10;\n      if (newHead.y > height - 10) newHead.y = 10;\n\n      rs.segments.unshift(newHead);\n      rs.segments.pop();\n    } else {\n      const head = rs.segments[0];\n      const moveSpeed = CELL_SIZE * 0.5;\n\n      head.x += rs.direction.dx * moveSpeed * 0.06;\n      head.y += rs.direction.dy * moveSpeed * 0.06;\n\n      for (let i = 1; i < rs.segments.length; i++) {\n        const seg = rs.segments[i];\n        const prev = rs.segments[i - 1];\n        const pullStrength = 0.18;\n        seg.x += (prev.x - seg.x) * pullStrength;\n        seg.y += (prev.y - seg.y) * pullStrength;\n      }\n    }\n\n    if (this.currentState.gameOver) {\n      rs.hue = 180;\n      rs.glowIntensity *= 0.95;\n      rs.state = 'circling';\n    } else {\n      rs.hue = rs.state === 'hunting' ? 190 : (rs.state === 'fleeing' ? 220 : 200);\n      rs.hue += Math.sin(rs.pulsePhase * 0.5) * 10;\n    }\n\n    rs.aggression *= 0.998;\n  }\n\n  private drawRivalSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.rivalSnake || this.rivalSnake.segments.length === 0) return;\n\n    const rs = this.rivalSnake;\n    const pulse = rs.glowIntensity;\n\n    for (const arc of rs.electricArcs) {\n      this.drawElectricArc(g, arc.x1, arc.y1, arc.x2, arc.y2, arc.life);\n    }\n\n    for (const e of rs.energyTrail) {\n      g.fillStyle(this.hslToHex(rs.hue + 20, 80, 70), e.alpha * 0.6);\n      g.fillCircle(e.x, e.y, e.size);\n      g.fillStyle(this.hslToHex(rs.hue, 90, 85), e.alpha * 0.3);\n      g.fillCircle(e.x, e.y, e.size * 0.5);\n    }\n\n    for (let i = 0; i < rs.trail.length; i++) {\n      const t = rs.trail[i];\n      const trailSize = 5 * (1 - i / rs.trail.length);\n      g.fillStyle(this.hslToHex(rs.hue, 80, 55), t.alpha * 0.4);\n      g.fillCircle(t.x, t.y, trailSize * 2);\n      g.fillStyle(this.hslToHex(rs.hue + 30, 70, 70), t.alpha * 0.2);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    g.lineStyle(14, this.hslToHex(rs.hue, 70, 40), 0.2 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    g.lineStyle(8, this.hslToHex(rs.hue, 80, 55), 0.35 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    for (let i = rs.segments.length - 1; i >= 0; i--) {\n      const seg = rs.segments[i];\n      const t = rs.segments.length > 1 ? i / (rs.segments.length - 1) : 1;\n      const segmentPulse = pulse * (0.8 + Math.sin(rs.pulsePhase + i * 0.4) * 0.2);\n\n      const baseSize = 7 + t * 5;\n      const size = baseSize * (0.9 + segmentPulse * 0.15);\n\n      g.fillStyle(this.hslToHex(rs.hue - 10, 60, 35), 0.15 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 2.8);\n\n      g.fillStyle(this.hslToHex(rs.hue, 75, 50), 0.3 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 1.6);\n\n      g.fillStyle(this.hslToHex(rs.hue + 10, 85, 65), 0.6 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size);\n\n      g.fillStyle(this.hslToHex(rs.hue + 40, 60, 90), 0.5 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 0.35);\n\n      if (i === 0) {\n        const dx = rs.direction.dx;\n        const dy = rs.direction.dy;\n        const perpX = -dy;\n        const perpY = dx;\n\n        g.fillStyle(this.hslToHex(rs.hue, 90, 70), 0.3);\n        g.fillCircle(seg.x - dx * 3, seg.y - dy * 3, size * 1.8);\n\n        const eyeOffset = 4;\n        const eyeForward = 5;\n        const leftEyeX = seg.x + perpX * eyeOffset + dx * eyeForward;\n        const leftEyeY = seg.y + perpY * eyeOffset + dy * eyeForward;\n        const rightEyeX = seg.x - perpX * eyeOffset + dx * eyeForward;\n        const rightEyeY = seg.y - perpY * eyeOffset + dy * eyeForward;\n\n        const eyeColor = rs.state === 'hunting' ? 0xff4444 :\n                         rs.state === 'fleeing' ? 0xffff44 : 0x44ffff;\n\n        g.fillStyle(0x000000, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 4);\n        g.fillCircle(rightEyeX, rightEyeY, 4);\n\n        g.fillStyle(eyeColor, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 3);\n        g.fillCircle(rightEyeX, rightEyeY, 3);\n\n        g.fillStyle(0xffffff, 0.95 * segmentPulse);\n        g.fillCircle(leftEyeX + dx, leftEyeY + dy, 1.2);\n        g.fillCircle(rightEyeX + dx, rightEyeY + dy, 1.2);\n\n        const hornLength = 8;\n        const hornAngle = 0.4;\n        g.lineStyle(3, this.hslToHex(rs.hue - 20, 70, 45), 0.8 * segmentPulse);\n        g.beginPath();\n        g.moveTo(seg.x + perpX * 5, seg.y + perpY * 5);\n        g.lineTo(\n          seg.x + perpX * 5 + Math.cos(Math.atan2(dy, dx) - hornAngle) * hornLength,\n          seg.y + perpY * 5 + Math.sin(Math.atan2(dy, dx) - hornAngle) * hornLength\n        );\n        g.strokePath();\n        g.beginPath();\n        g.moveTo(seg.x - perpX * 5, seg.y - perpY * 5);\n        g.lineTo(\n          seg.x - perpX * 5 + Math.cos(Math.atan2(dy, dx) + hornAngle) * hornLength,\n          seg.y - perpY * 5 + Math.sin(Math.atan2(dy, dx) + hornAngle) * hornLength\n        );\n        g.strokePath();\n      }\n    }\n  }\n\n  private drawElectricArc(g: Phaser.GameObjects.Graphics, x1: number, y1: number, x2: number, y2: number, life: number): void {\n    const segments = 6;\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n    const jitter = 15 * life;\n\n    g.lineStyle(4, 0x00ffff, 0.2 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter;\n      const jy = (Math.random() - 0.5) * jitter;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(2, 0x88ffff, 0.5 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter * 0.5;\n      const jy = (Math.random() - 0.5) * jitter * 0.5;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(1, 0xffffff, 0.8 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    g.lineTo(x2, y2);\n    g.strokePath();\n  }\n\n  private spawnBee(): void {\n    if (this.bees.length >= NUM_BEES) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Spawn from random edge\n    const edge = Math.floor(Math.random() * 4);\n    let x: number, y: number;\n\n    switch (edge) {\n      case 0: // top\n        x = Math.random() * width;\n        y = -20;\n        break;\n      case 1: // right\n        x = width + 20;\n        y = Math.random() * height;\n        break;\n      case 2: // bottom\n        x = Math.random() * width;\n        y = height + 20;\n        break;\n      default: // left\n        x = -20;\n        y = Math.random() * height;\n        break;\n    }\n\n    // Random target inside the play area\n    const targetX = 50 + Math.random() * (width - 100);\n    const targetY = 50 + Math.random() * (height - 100);\n\n    this.bees.push({\n      x,\n      y,\n      vx: 0,\n      vy: 0,\n      targetX,\n      targetY,\n      wingPhase: Math.random() * Math.PI * 2,\n      wingSpeed: 0.4 + Math.random() * 0.2,\n      size: 6 + Math.random() * 3,\n      hue: 0 + Math.random() * 20, // Crimson/red volcanic color\n      glowIntensity: 0.5 + Math.random() * 0.5,\n      bobPhase: Math.random() * Math.PI * 2,\n      bobSpeed: 0.08 + Math.random() * 0.04,\n      trail: [],\n      state: 'flying',\n      sparkleTimer: 0,\n    });\n  }\n\n  private updateBees(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n    const gameOver = this.currentState.gameOver;\n\n    // Randomly spawn new bees\n    if (!gameOver && Math.random() < BEE_SPAWN_CHANCE && this.bees.length < NUM_BEES) {\n      this.spawnBee();\n    }\n\n    for (let i = this.bees.length - 1; i >= 0; i--) {\n      const bee = this.bees[i];\n\n      // Update wing animation\n      bee.wingPhase += bee.wingSpeed;\n      bee.bobPhase += bee.bobSpeed;\n      bee.sparkleTimer += 0.1;\n\n      // Store trail position\n      if (this.frameCount % 2 === 0) {\n        bee.trail.unshift({ x: bee.x, y: bee.y, alpha: 0.6 });\n        if (bee.trail.length > 8) bee.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of bee.trail) {\n        t.alpha *= 0.85;\n      }\n      bee.trail = bee.trail.filter(t => t.alpha > 0.05);\n\n      // Bees are attracted to food\n      const dxFood = foodX - bee.x;\n      const dyFood = foodY - bee.y;\n      const distFood = Math.sqrt(dxFood * dxFood + dyFood * dyFood);\n\n      // Determine behavior based on distance to food\n      if (distFood < 80) {\n        bee.state = 'attracted';\n        bee.targetX = foodX + Math.cos(bee.bobPhase * 3) * 30;\n        bee.targetY = foodY + Math.sin(bee.bobPhase * 3) * 30;\n      } else if (distFood < 150) {\n        bee.state = 'hovering';\n        // Circle around food loosely\n        const angle = Math.atan2(dyFood, dxFood) + Math.sin(bee.bobPhase) * 0.5;\n        bee.targetX = foodX - Math.cos(angle) * 60;\n        bee.targetY = foodY - Math.sin(angle) * 60;\n      } else {\n        bee.state = 'flying';\n        // Wander towards food with some randomness\n        if (Math.random() < 0.02) {\n          bee.targetX = foodX + (Math.random() - 0.5) * 200;\n          bee.targetY = foodY + (Math.random() - 0.5) * 200;\n        }\n      }\n\n      // Move towards target with smooth steering\n      const dx = bee.targetX - bee.x;\n      const dy = bee.targetY - bee.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 1) {\n        const speed = bee.state === 'attracted' ? 2.5 : (bee.state === 'hovering' ? 1.5 : 2);\n        const ax = (dx / dist) * speed * 0.1;\n        const ay = (dy / dist) * speed * 0.1;\n\n        bee.vx += ax;\n        bee.vy += ay;\n\n        // Add bobbing motion\n        bee.vy += Math.sin(bee.bobPhase) * 0.05;\n      }\n\n      // Limit velocity\n      const maxSpeed = bee.state === 'attracted' ? 3 : 2;\n      const currentSpeed = Math.sqrt(bee.vx * bee.vx + bee.vy * bee.vy);\n      if (currentSpeed > maxSpeed) {\n        bee.vx = (bee.vx / currentSpeed) * maxSpeed;\n        bee.vy = (bee.vy / currentSpeed) * maxSpeed;\n      }\n\n      // Apply velocity with damping\n      bee.x += bee.vx;\n      bee.y += bee.vy;\n      bee.vx *= 0.95;\n      bee.vy *= 0.95;\n\n      // Pulsing glow when near food\n      if (bee.state === 'attracted') {\n        bee.glowIntensity = 0.7 + Math.sin(bee.bobPhase * 4) * 0.3;\n      } else {\n        bee.glowIntensity = 0.5 + Math.sin(bee.bobPhase * 2) * 0.2;\n      }\n\n      // Remove bees that fly too far off screen\n      if (bee.x < -100 || bee.x > width + 100 || bee.y < -100 || bee.y > height + 100) {\n        this.bees.splice(i, 1);\n      }\n\n      // Scatter bees on game over\n      if (gameOver) {\n        bee.targetX = bee.x + (Math.random() - 0.5) * 400;\n        bee.targetY = bee.y - 200 - Math.random() * 200;\n        bee.vx += (Math.random() - 0.5) * 2;\n        bee.vy -= 1 + Math.random();\n      }\n    }\n  }\n\n  private drawBees(g: Phaser.GameObjects.Graphics): void {\n    for (const bee of this.bees) {\n      const { x, y, size, wingPhase, hue, glowIntensity, trail, state, sparkleTimer } = bee;\n\n      // Draw trail\n      for (let i = 0; i < trail.length; i++) {\n        const t = trail[i];\n        const trailSize = size * 0.4 * (1 - i / trail.length);\n        g.fillStyle(this.hslToHex(hue, 80, 60), t.alpha * 0.4);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      const glowSize = size * 2 * glowIntensity;\n      g.fillStyle(this.hslToHex(hue, 90, 50), 0.2 * glowIntensity);\n      g.fillCircle(x, y, glowSize);\n\n      // Mid glow\n      g.fillStyle(this.hslToHex(hue, 85, 60), 0.3 * glowIntensity);\n      g.fillCircle(x, y, glowSize * 0.6);\n\n      // Bee body - striped pattern\n      const bodyLength = size * 1.2;\n      const bodyWidth = size * 0.7;\n\n      // Body shadow/glow\n      g.fillStyle(this.hslToHex(hue, 70, 30), 0.5);\n      g.fillEllipse(x, y, bodyLength + 2, bodyWidth + 2);\n\n      // Main body (amber/golden)\n      g.fillStyle(this.hslToHex(hue, 90, 55), 1);\n      g.fillEllipse(x, y, bodyLength, bodyWidth);\n\n      // Dark stripes\n      g.fillStyle(0x1a1a1a, 0.8);\n      g.fillRect(x - bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n      g.fillRect(x + bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n\n      // Head\n      g.fillStyle(this.hslToHex(hue - 10, 80, 40), 1);\n      g.fillCircle(x - bodyLength * 0.4, y, size * 0.4);\n\n      // Wings - animated flutter\n      const wingAngle = Math.sin(wingPhase) * 0.8;\n      const wingSize = size * 0.9;\n\n      // Wing glow (ethereal effect)\n      g.fillStyle(0xffffff, 0.2 + Math.abs(Math.sin(wingPhase)) * 0.2);\n      g.fillEllipse(x + Math.cos(wingAngle + 0.5) * wingSize * 0.3, y - wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n      g.fillEllipse(x + Math.cos(-wingAngle + 0.5) * wingSize * 0.3, y + wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n\n      // Wing bodies\n      g.fillStyle(0xffffff, 0.5 + Math.abs(Math.sin(wingPhase)) * 0.3);\n      g.fillEllipse(x + Math.cos(wingAngle) * wingSize * 0.2, y - wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n      g.fillEllipse(x + Math.cos(-wingAngle) * wingSize * 0.2, y + wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n\n      // Eyes\n      g.fillStyle(0x000000, 1);\n      g.fillCircle(x - bodyLength * 0.45, y - size * 0.12, size * 0.12);\n      g.fillCircle(x - bodyLength * 0.45, y + size * 0.12, size * 0.12);\n\n      // Sparkles when attracted to food\n      if (state === 'attracted' && Math.sin(sparkleTimer * 3) > 0.7) {\n        const sparkleAngle = sparkleTimer * 2;\n        const sparkleDist = size * 1.5;\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n\n        g.fillStyle(0xffffff, 0.8);\n        g.fillCircle(sparkleX, sparkleY, 2);\n        g.fillStyle(this.hslToHex(hue, 100, 80), 0.6);\n        g.fillCircle(sparkleX, sparkleY, 3);\n      }\n    }\n  }\n\n  // Helper to convert HSL to hex for Phaser\n  private hslToHex(h: number, s: number, l: number): number {\n    h = h / 360;\n    s = s / 100;\n    l = l / 100;\n\n    let r: number, g: number, b: number;\n\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    return (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255);\n  }\n\n  private updateGuardianSpirits(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const gameOver = this.currentState.gameOver;\n    const snakeHead = this.currentState.snake.length > 0 ? this.currentState.snake[0] : null;\n\n    for (const spirit of this.guardianSpirits) {\n      spirit.phase += spirit.speed;\n      spirit.haloPhase += 0.04;\n      spirit.orbPhase += 0.02;\n\n      for (const orb of spirit.orbs) {\n        orb.angle += orb.speed;\n      }\n\n      const floatAmount = gameOver ? 20 : 12;\n      const waveAmount = 5;\n      const wave = Math.sin(spirit.phase) * waveAmount;\n\n      let targetX = spirit.baseX;\n      let targetY = spirit.baseY;\n\n      switch (spirit.edge) {\n        case 'top':\n          targetY = spirit.baseY + floatAmount + wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'bottom':\n          targetY = spirit.baseY - floatAmount - wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'left':\n          targetX = spirit.baseX + floatAmount + wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'right':\n          targetX = spirit.baseX - floatAmount - wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n      }\n\n      if (snakeHead && !gameOver) {\n        const headX = snakeHead.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = snakeHead.y * CELL_SIZE + CELL_SIZE / 2;\n        const dx = spirit.x - headX;\n        const dy = spirit.y - headY;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        if (dist < 120) {\n          const attraction = (120 - dist) / 120 * 15;\n          targetX += (dx / dist) * attraction;\n          targetY += (dy / dist) * attraction;\n        }\n      }\n\n      spirit.x += (targetX - spirit.x) * 0.04;\n      spirit.y += (targetY - spirit.y) * 0.04;\n      spirit.x = Math.max(-50, Math.min(width + 50, spirit.x));\n      spirit.y = Math.max(-50, Math.min(height + 50, spirit.y));\n\n      const baseAlpha = gameOver ? 0.8 : spirit.targetAlpha;\n      spirit.currentAlpha += (baseAlpha - spirit.currentAlpha) * 0.05;\n    }\n  }\n\n  private drawGuardianSpirits(g: Phaser.GameObjects.Graphics): void {\n    for (const spirit of this.guardianSpirits) {\n      if (spirit.currentAlpha < 0.01) continue;\n\n      const { x, y, size, phase, haloPhase, currentAlpha, hue, orbs } = spirit;\n      const breathPulse = 1 + Math.sin(phase * 2) * 0.15;\n      const coreSize = size * breathPulse;\n\n      const spiritColor = this.hslToHex(hue, 0.7, 0.6);\n      const glowColor = this.hslToHex(hue, 0.5, 0.8);\n      const haloColor = this.hslToHex(hue, 0.3, 0.9);\n\n      g.fillStyle(glowColor, currentAlpha * 0.1);\n      g.fillCircle(x, y, coreSize * 2.5);\n\n      g.fillStyle(glowColor, currentAlpha * 0.15);\n      g.fillCircle(x, y, coreSize * 1.8);\n\n      const haloRadius = coreSize * 1.4 + Math.sin(haloPhase) * 3;\n      g.lineStyle(2, haloColor, currentAlpha * 0.4);\n      g.strokeCircle(x, y, haloRadius);\n\n      const innerHaloRadius = coreSize * 1.1 + Math.sin(haloPhase + 1) * 2;\n      g.lineStyle(1.5, haloColor, currentAlpha * 0.3);\n      g.strokeCircle(x, y, innerHaloRadius);\n\n      for (const orb of orbs) {\n        const orbX = x + Math.cos(orb.angle) * orb.distance;\n        const orbY = y + Math.sin(orb.angle) * orb.distance;\n        const orbPulse = 1 + Math.sin(phase + orb.angle) * 0.3;\n\n        g.fillStyle(glowColor, currentAlpha * 0.3);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse * 1.5);\n\n        g.fillStyle(spiritColor, currentAlpha * 0.8);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse);\n      }\n\n      g.fillStyle(spiritColor, currentAlpha * 0.9);\n      g.fillCircle(x, y, coreSize * 0.5);\n\n      g.fillStyle(0xffffff, currentAlpha * 0.7);\n      g.fillCircle(x, y, coreSize * 0.25);\n\n      const sparkleCount = 4;\n      for (let i = 0; i < sparkleCount; i++) {\n        const sparkleAngle = (i / sparkleCount) * Math.PI * 2 + phase * 0.5;\n        const sparkleDist = coreSize * (0.8 + Math.sin(phase * 2 + i) * 0.3);\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n        const sparkleSize = 1.5 + Math.sin(phase * 3 + i * 2) * 0.5;\n\n        g.fillStyle(0xffffff, currentAlpha * (0.4 + Math.sin(phase * 2 + i) * 0.3));\n        g.fillCircle(sparkleX, sparkleY, sparkleSize);\n      }\n    }\n  }\n\n  private initStars(): void {\n    this.stars = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_STARS; i++) {\n      this.stars.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: 0.5 + Math.random() * 1.5,\n        speed: 0.02 + Math.random() * 0.03,\n        brightness: 0.3 + Math.random() * 0.7,\n      });\n    }\n  }\n\n  private initPlasmaWaves(): void {\n    this.plasmaWaves = [];\n    const hues = [0, 15, 30]; // Red/orange volcanic variations\n    for (let i = 0; i < NUM_PLASMA_WAVES; i++) {\n      this.plasmaWaves.push({\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.015 + Math.random() * 0.01,\n        amplitude: 30 + Math.random() * 20,\n        wavelength: 80 + Math.random() * 40,\n        hue: hues[i % hues.length],\n      });\n    }\n  }\n\n  private initAuroraWaves(): void {\n    this.auroraWaves = [];\n    const height = GRID_SIZE * CELL_SIZE;\n    // Aurora hues: volcanic reds, oranges, crimsons\n    const auroraHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_AURORA_WAVES; i++) {\n      this.auroraWaves.push({\n        y: height * 0.2 + (height * 0.6 * i) / NUM_AURORA_WAVES,\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.008 + Math.random() * 0.006,\n        hue: auroraHues[i % auroraHues.length],\n        thickness: 25 + Math.random() * 20,\n        amplitude: 15 + Math.random() * 25,\n      });\n    }\n  }\n\n  private initNebulaClouds(): void {\n    this.nebulaClouds = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    // Volcanic smoke and lava glow colors: reds, oranges, crimsons\n    const nebulaHues = [0, 10, 20, 30, 350, 340];\n    for (let i = 0; i < NUM_NEBULA_CLOUDS; i++) {\n      this.nebulaClouds.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        radius: 40 + Math.random() * 60,\n        hue: nebulaHues[i % nebulaHues.length],\n        alpha: 0.04 + Math.random() * 0.04,\n        driftX: (Math.random() - 0.5) * 0.15,\n        driftY: (Math.random() - 0.5) * 0.15,\n        pulsePhase: Math.random() * Math.PI * 2,\n        pulseSpeed: 0.01 + Math.random() * 0.01,\n      });\n    }\n  }\n\n  private initVortex(): void {\n    this.vortexRings = [];\n    this.vortexParticles = [];\n\n    // Create concentric rings with different properties\n    const ringHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_VORTEX_RINGS; i++) {\n      const baseRadius = 25 + i * 18;\n      this.vortexRings.push({\n        radius: baseRadius,\n        baseRadius,\n        rotationOffset: (i * Math.PI * 2) / NUM_VORTEX_RINGS,\n        rotationSpeed: 0.02 - i * 0.003,\n        thickness: 2 + (NUM_VORTEX_RINGS - i) * 0.5,\n        hue: ringHues[i % ringHues.length],\n        pulsePhase: i * 0.5,\n      });\n    }\n\n    // Create orbiting particles\n    for (let i = 0; i < NUM_VORTEX_PARTICLES; i++) {\n      const baseRadius = 20 + Math.random() * 80;\n      this.vortexParticles.push({\n        angle: Math.random() * Math.PI * 2,\n        radius: baseRadius,\n        baseRadius,\n        speed: 0.02 + Math.random() * 0.03,\n        size: 1 + Math.random() * 2,\n        hue: Math.random() * 360,\n        alpha: 0.3 + Math.random() * 0.5,\n      });\n    }\n  }\n\n  private initMeteors(): void {\n    this.meteors = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_METEORS; i++) {\n      this.spawnMeteor(width, height, true);\n    }\n  }\n\n  private spawnMeteor(width: number, height: number, initial = false): void {\n    if (this.meteors.length >= NUM_METEORS) return;\n\n    // Meteors come from top-right and travel to bottom-left\n    const startX = initial ? Math.random() * width * 1.5 : width + 20 + Math.random() * 40;\n    const startY = initial ? Math.random() * height * 0.5 - height * 0.25 : -20 - Math.random() * 40;\n\n    // Random angle variation (mostly diagonal)\n    const angle = Math.PI * 0.65 + (Math.random() - 0.5) * 0.4;\n    const speed = 1.5 + Math.random() * 2;\n\n    this.meteors.push({\n      x: startX,\n      y: startY,\n      vx: -Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed,\n      size: 2 + Math.random() * 3,\n      hue: Math.random() < 0.3 ? 0 + Math.random() * 30 : 20 + Math.random() * 40, // Red or orange volcanic\n      alpha: 0.6 + Math.random() * 0.4,\n      trail: [],\n      life: 1,\n    });\n  }\n\n  private updateMeteors(width: number, height: number): void {\n    for (let i = this.meteors.length - 1; i >= 0; i--) {\n      const m = this.meteors[i];\n\n      // Store trail position\n      m.trail.unshift({ x: m.x, y: m.y, alpha: m.alpha });\n      if (m.trail.length > 12) m.trail.pop();\n\n      // Update position\n      m.x += m.vx;\n      m.y += m.vy;\n\n      // Check if meteor is out of bounds\n      if (m.x < -50 || m.y > height + 50) {\n        this.meteors.splice(i, 1);\n        // Spawn a new one\n        this.spawnMeteor(width, height, false);\n      }\n    }\n  }\n\n  private spawnDeathExplosion(): void {\n    if (!this.currentState) return;\n\n    this.deathDebris = [];\n    this.deathExplosionPhase = 1;\n\n    // Spawn debris from each snake segment\n    for (let i = 0; i < this.currentState.snake.length; i++) {\n      const seg = this.currentState.snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const segHue = (this.hueOffset + i * 15) % 360;\n\n      // Create debris particles per segment (limit total)\n      const debrisPerSeg = Math.min(3, Math.floor(MAX_DEATH_DEBRIS / this.currentState.snake.length));\n      for (let j = 0; j < debrisPerSeg; j++) {\n        if (this.deathDebris.length >= MAX_DEATH_DEBRIS) break;\n\n        const angle = Math.random() * Math.PI * 2;\n        const speed = 2 + Math.random() * 4;\n        const types: ('shard' | 'spark' | 'ember')[] = ['shard', 'spark', 'ember'];\n\n        this.deathDebris.push({\n          x: cx + (Math.random() - 0.5) * 8,\n          y: cy + (Math.random() - 0.5) * 8,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed - 1,\n          size: 3 + Math.random() * 5,\n          hue: segHue + (Math.random() - 0.5) * 40,\n          rotation: Math.random() * Math.PI * 2,\n          rotationSpeed: (Math.random() - 0.5) * 0.4,\n          life: 1,\n          type: types[Math.floor(Math.random() * types.length)],\n        });\n      }\n    }\n  }\n\n  private updateDeathDebris(): void {\n    // Decay explosion phase\n    if (this.deathExplosionPhase > 0) {\n      this.deathExplosionPhase *= 0.95;\n      if (this.deathExplosionPhase < 0.01) this.deathExplosionPhase = 0;\n    }\n\n    for (let i = this.deathDebris.length - 1; i >= 0; i--) {\n      const d = this.deathDebris[i];\n\n      // Update position with gravity\n      d.x += d.vx;\n      d.y += d.vy;\n      d.vy += 0.08; // gravity\n      d.vx *= 0.99; // air resistance\n\n      // Update rotation\n      d.rotation += d.rotationSpeed;\n\n      // Decay life\n      d.life -= 0.015;\n\n      if (d.life <= 0) {\n        this.deathDebris.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnFoodParticles(foodX: number, foodY: number): void {\n    if (this.foodParticles.length < MAX_FOOD_PARTICLES && Math.random() < 0.15) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.3 + Math.random() * 0.5;\n      this.foodParticles.push({\n        x: foodX,\n        y: foodY,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 0.5,\n        life: 1,\n        maxLife: 40 + Math.random() * 20,\n        size: 1 + Math.random() * 2,\n      });\n    }\n  }\n\n  private updateParticles(): void {\n    for (let i = this.foodParticles.length - 1; i >= 0; i--) {\n      const p = this.foodParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy += 0.02;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.foodParticles.splice(i, 1);\n      }\n    }\n    // Update trail particles\n    for (let i = this.trailParticles.length - 1; i >= 0; i--) {\n      const p = this.trailParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.trailParticles.splice(i, 1);\n      }\n    }\n    // Update shockwaves\n    for (let i = this.shockWaves.length - 1; i >= 0; i--) {\n      const sw = this.shockWaves[i];\n      sw.radius += 3;\n      sw.life -= 0.04;\n      if (sw.life <= 0 || sw.radius >= sw.maxRadius) {\n        this.shockWaves.splice(i, 1);\n      }\n    }\n    // Update lightning bolts\n    for (let i = this.lightningBolts.length - 1; i >= 0; i--) {\n      const bolt = this.lightningBolts[i];\n      bolt.life -= 1 / bolt.maxLife;\n      if (bolt.life <= 0) {\n        this.lightningBolts.splice(i, 1);\n      }\n    }\n    // Update afterimages\n    for (let i = this.snakeAfterimages.length - 1; i >= 0; i--) {\n      const ai = this.snakeAfterimages[i];\n      ai.life -= 1 / ai.maxLife;\n      if (ai.life <= 0) {\n        this.snakeAfterimages.splice(i, 1);\n      }\n    }\n    // Decay screen flash\n    if (this.screenFlashAlpha > 0) {\n      this.screenFlashAlpha -= 0.08;\n      if (this.screenFlashAlpha < 0) this.screenFlashAlpha = 0;\n    }\n\n    // Update screen shake\n    if (this.screenShakeIntensity > 0) {\n      this.screenShakeX = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeY = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeIntensity *= 0.9;\n      if (this.screenShakeIntensity < 0.5) {\n        this.screenShakeIntensity = 0;\n        this.screenShakeX = 0;\n        this.screenShakeY = 0;\n      }\n    }\n\n    // Decay chromatic aberration\n    if (this.chromaticIntensity > 0) {\n      this.chromaticIntensity *= 0.92;\n      if (this.chromaticIntensity < 0.05) this.chromaticIntensity = 0;\n    }\n\n    // Decay energy field pulse\n    if (this.energyFieldPulse > 0) {\n      this.energyFieldPulse *= 0.95;\n      if (this.energyFieldPulse < 0.05) this.energyFieldPulse = 0;\n    }\n\n    // Update food burst particles\n    for (let i = this.foodBurstParticles.length - 1; i >= 0; i--) {\n      const p = this.foodBurstParticles[i];\n      // Store trail position\n      p.trail.unshift({ x: p.x, y: p.y });\n      if (p.trail.length > 6) p.trail.pop();\n      // Update position\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vx *= 0.96;\n      p.vy *= 0.96;\n      p.life -= 0.025;\n      if (p.life <= 0) {\n        this.foodBurstParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnTrailParticles(x: number, y: number): void {\n    if (this.trailParticles.length >= MAX_TRAIL_PARTICLES) return;\n    // Spawn 2-3 particles per movement\n    const count = 2 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < count; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.2 + Math.random() * 0.4;\n      this.trailParticles.push({\n        x: x + (Math.random() - 0.5) * 8,\n        y: y + (Math.random() - 0.5) * 8,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        maxLife: 25 + Math.random() * 15,\n        size: 2 + Math.random() * 3,\n        hue: this.hueOffset + Math.random() * 30,\n      });\n    }\n  }\n\n  updateGameState(state: GameState): void {\n    // Detect food eaten - snake got longer\n    if (this.currentState && state.snake.length > this.lastSnakeLength) {\n      const head = state.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n      this.spawnShockWave(headX, headY);\n      this.spawnLightningBurst(headX, headY);\n      this.spawnFoodBurst(headX, headY);\n      this.spawnChaosExplosion(headX, headY); // Armageddon chaos explosion\n      this.screenFlashAlpha = 0.8; // More intense flash for armageddon\n      this.chromaticIntensity = 1.5; // Stronger chromatic aberration\n      this.energyFieldPulse = 1.0; // Trigger energy field expansion\n    }\n    this.lastSnakeLength = state.snake.length;\n\n    // Detect food position change - trigger thrown food animation\n    const newFood = state.food;\n    if (this.lastFoodPos && (newFood.x !== this.lastFoodPos.x || newFood.y !== this.lastFoodPos.y)) {\n      this.spawnThrownFood(newFood.x, newFood.y);\n    } else if (!this.lastFoodPos && !state.gameOver) {\n      // First food spawn\n      this.spawnThrownFood(newFood.x, newFood.y);\n    }\n    this.lastFoodPos = { x: newFood.x, y: newFood.y };\n\n    // Create afterimage when snake moves\n    if (this.currentState && state.snake.length > 0) {\n      const oldHead = this.currentState.snake[0];\n      const newHead = state.snake[0];\n      if (oldHead && newHead && (oldHead.x !== newHead.x || oldHead.y !== newHead.y)) {\n        this.spawnAfterimage(this.currentState.snake);\n      }\n    }\n\n    // Detect game over transition - ARMAGEDDON CHAOS death sequence\n    if (state.gameOver && this.currentState && !this.currentState.gameOver) {\n      this.screenShakeIntensity = 25; // Massive screen shake on death\n      this.chromaticIntensity = 3.0; // Maximum chromatic aberration on death\n      this.chaosIntensity = 1.0; // Full chaos overlay\n      this.spawnDeathExplosion(); // Dramatic death explosion\n      // Spawn chaos explosions across the snake body\n      for (let i = 0; i < Math.min(3, state.snake.length); i++) {\n        const seg = state.snake[Math.floor(i * state.snake.length / 3)];\n        setTimeout(() => {\n          this.spawnChaosExplosion(\n            seg.x * CELL_SIZE + CELL_SIZE / 2,\n            seg.y * CELL_SIZE + CELL_SIZE / 2\n          );\n        }, i * 50);\n      }\n    }\n\n    this.currentState = state;\n    this.needsRedraw = true;\n    if (!state.gameOver) {\n      this.gameOverAlpha = 0;\n      this.gameOverGlitchOffset = 0;\n      this.screenShakeIntensity = 0;\n    }\n  }\n\n  private spawnShockWave(x: number, y: number): void {\n    if (this.shockWaves.length >= MAX_SHOCKWAVES) {\n      this.shockWaves.shift();\n    }\n    this.shockWaves.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: CELL_SIZE * 3,\n      life: 1,\n    });\n  }\n\n  private spawnAfterimage(snake: Position[]): void {\n    if (this.snakeAfterimages.length >= MAX_AFTERIMAGES) {\n      this.snakeAfterimages.shift();\n    }\n    this.snakeAfterimages.push({\n      segments: snake.map(s => ({ x: s.x, y: s.y })),\n      life: 1,\n      maxLife: 12,\n      hueOffset: this.hueOffset,\n    });\n  }\n\n  private spawnLightningBurst(x: number, y: number): void {\n    const numBolts = 3 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < numBolts; i++) {\n      if (this.lightningBolts.length >= MAX_LIGHTNING_BOLTS) {\n        this.lightningBolts.shift();\n      }\n      const angle = (Math.PI * 2 * i) / numBolts + Math.random() * 0.5;\n      const length = 30 + Math.random() * 40;\n      const endX = x + Math.cos(angle) * length;\n      const endY = y + Math.sin(angle) * length;\n      this.lightningBolts.push({\n        points: this.generateLightningPath(x, y, endX, endY),\n        life: 1,\n        maxLife: 15 + Math.random() * 10,\n        hue: this.hueOffset + Math.random() * 60,\n      });\n    }\n  }\n\n  private generateLightningPath(x1: number, y1: number, x2: number, y2: number): { x: number; y: number }[] {\n    const points: { x: number; y: number }[] = [{ x: x1, y: y1 }];\n    const segments = 4 + Math.floor(Math.random() * 3);\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n\n    for (let i = 1; i < segments; i++) {\n      const jitter = 8;\n      points.push({\n        x: x1 + dx * i + (Math.random() - 0.5) * jitter,\n        y: y1 + dy * i + (Math.random() - 0.5) * jitter,\n      });\n    }\n    points.push({ x: x2, y: y2 });\n    return points;\n  }\n\n  private spawnFoodBurst(x: number, y: number): void {\n    // Clear old particles and spawn new dramatic burst\n    this.foodBurstParticles = [];\n    const numParticles = MAX_BURST_PARTICLES;\n    for (let i = 0; i < numParticles; i++) {\n      const angle = (i / numParticles) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 4;\n      this.foodBurstParticles.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        size: 3 + Math.random() * 4,\n        hue: this.hueOffset + Math.random() * 60,\n        trail: [],\n      });\n    }\n  }\n\n  private spawnThrownFood(targetGridX: number, targetGridY: number): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const targetX = targetGridX * CELL_SIZE + CELL_SIZE / 2;\n    const targetY = targetGridY * CELL_SIZE + CELL_SIZE / 2;\n\n    // Choose random edge to throw from\n    const edge = Math.floor(Math.random() * 4);\n    let startX: number, startY: number;\n\n    switch (edge) {\n      case 0: // top\n        startX = Math.random() * width;\n        startY = -40;\n        break;\n      case 1: // right\n        startX = width + 40;\n        startY = Math.random() * height;\n        break;\n      case 2: // bottom\n        startX = Math.random() * width;\n        startY = height + 40;\n        break;\n      default: // left\n        startX = -40;\n        startY = Math.random() * height;\n        break;\n    }\n\n    this.thrownFood = {\n      startX,\n      startY,\n      targetX,\n      targetY,\n      x: startX,\n      y: startY,\n      progress: 0,\n      rotation: 0,\n      rotationSpeed: (Math.random() - 0.5) * 0.6,\n      trail: [],\n      landed: false,\n      landingParticles: [],\n      impactRings: [],\n    };\n  }\n\n  private updateThrownFood(): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    if (!tf.landed) {\n      // Update progress\n      tf.progress += 0.04;\n\n      // Store trail\n      if (this.frameCount % 2 === 0) {\n        tf.trail.unshift({ x: tf.x, y: tf.y, alpha: 1, rotation: tf.rotation });\n        if (tf.trail.length > 12) tf.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.85;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Calculate position with parabolic arc\n      const t = tf.progress;\n      const arcHeight = 80;\n      const arc = 4 * arcHeight * t * (1 - t);\n      tf.x = tf.startX + (tf.targetX - tf.startX) * t;\n      tf.y = tf.startY + (tf.targetY - tf.startY) * t - arc;\n\n      // Rotation\n      tf.rotation += tf.rotationSpeed;\n\n      // Check if landed\n      if (tf.progress >= 1) {\n        tf.landed = true;\n        tf.x = tf.targetX;\n        tf.y = tf.targetY;\n\n        // Spawn landing effects\n        this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 6);\n\n        // Impact rings\n        tf.impactRings = [\n          { radius: 5, alpha: 1 },\n          { radius: 3, alpha: 0.8 },\n        ];\n\n        // Landing particles\n        for (let i = 0; i < 10; i++) {\n          const angle = (i / 10) * Math.PI * 2 + Math.random() * 0.3;\n          const speed = 2 + Math.random() * 3;\n          tf.landingParticles.push({\n            x: tf.targetX,\n            y: tf.targetY,\n            vx: Math.cos(angle) * speed,\n            vy: Math.sin(angle) * speed - 1,\n            life: 1,\n            size: 2 + Math.random() * 3,\n          });\n        }\n      }\n    } else {\n      // Update landing effects\n      for (const ring of tf.impactRings) {\n        ring.radius += 3;\n        ring.alpha *= 0.9;\n      }\n      tf.impactRings = tf.impactRings.filter(r => r.alpha > 0.05);\n\n      for (let i = tf.landingParticles.length - 1; i >= 0; i--) {\n        const p = tf.landingParticles[i];\n        p.x += p.vx;\n        p.y += p.vy;\n        p.vy += 0.15;\n        p.vx *= 0.98;\n        p.life -= 0.04;\n        if (p.life <= 0) {\n          tf.landingParticles.splice(i, 1);\n        }\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.8;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Clear thrown food when effects are done\n      if (tf.impactRings.length === 0 && tf.landingParticles.length === 0 && tf.trail.length === 0) {\n        this.thrownFood = null;\n      }\n    }\n  }\n\n  private drawThrownFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    // Draw trail\n    for (let i = 0; i < tf.trail.length; i++) {\n      const t = tf.trail[i];\n      const trailProgress = i / tf.trail.length;\n      const trailSize = (CELL_SIZE / 2) * (1 - trailProgress * 0.5) * t.alpha;\n\n      // Trail glow\n      g.fillStyle(COLORS.foodGlow, t.alpha * 0.3);\n      g.fillCircle(t.x, t.y, trailSize * 1.5);\n\n      // Trail core\n      g.fillStyle(COLORS.food, t.alpha * 0.6);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    // Draw impact rings\n    for (const ring of tf.impactRings) {\n      g.lineStyle(3, COLORS.foodGlow, ring.alpha * 0.5);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n      g.lineStyle(1.5, COLORS.noirWhite, ring.alpha * 0.7);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n    }\n\n    // Draw landing particles\n    for (const p of tf.landingParticles) {\n      g.fillStyle(COLORS.foodGlow, p.life * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Draw the flying food if not landed\n    if (!tf.landed) {\n      const scale = 0.8 + tf.progress * 0.4;\n      const foodSize = (CELL_SIZE / 2) * scale;\n\n      // Motion blur glow\n      g.fillStyle(COLORS.foodGlow, 0.3);\n      g.fillCircle(tf.x, tf.y, foodSize * 2);\n\n      // Outer glow\n      g.fillStyle(COLORS.noirWhite, 0.4);\n      g.fillCircle(tf.x, tf.y, foodSize * 1.5);\n\n      // Main food body\n      g.fillStyle(COLORS.food, 0.95);\n      g.fillCircle(tf.x, tf.y, foodSize);\n\n      // Spinning highlight\n      const highlightAngle = tf.rotation;\n      const highlightX = tf.x + Math.cos(highlightAngle) * foodSize * 0.3;\n      const highlightY = tf.y + Math.sin(highlightAngle) * foodSize * 0.3;\n      g.fillStyle(0xffffff, 0.9);\n      g.fillCircle(highlightX, highlightY, foodSize * 0.25);\n\n      // Secondary sparkle\n      const sparkleAngle = tf.rotation + Math.PI * 0.7;\n      const sparkleX = tf.x + Math.cos(sparkleAngle) * foodSize * 0.4;\n      const sparkleY = tf.y + Math.sin(sparkleAngle) * foodSize * 0.4;\n      g.fillStyle(0xffffff, 0.6);\n      g.fillCircle(sparkleX, sparkleY, foodSize * 0.15);\n    }\n  }\n\n  update(): void {\n    this.frameCount++;\n    this.cleanEffects.frameCount = this.frameCount;\n\n    const width = this.scale.width;\n    const height = this.scale.height;\n\n    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n    updateTears(this.cleanEffects, height);\n    updateBlood(this.cleanEffects, height);\n\n    if (this.currentState && this.currentState.snake.length > 0) {\n      const head = this.currentState.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n        updateGlowTrail(this.cleanEffects, headX, headY);\n      }\n      this.lastHeadPos = { x: head.x, y: head.y };\n\n      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n        const food = this.currentState.food;\n        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnRipple(this.cleanEffects, foodX, foodY);\n      }\n      this.lastSnakeLength = this.currentState.snake.length;\n    }\n\n    const g = this.graphics;\n    g.clear();\n    g.setPosition(0, 0);\n\n    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n\n    if (!this.currentState) return;\n\n    drawGlowTrail(g, this.cleanEffects);\n    drawRipples(g, this.cleanEffects);\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n\n    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawTears(g, this.cleanEffects);\n    drawBlood(g, this.cleanEffects);\n\n    drawCleanVignette(g, width, height);\n\n    const score = this.currentState.score || 0;\n    const snakeLength = this.currentState.snake.length;\n    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n\n    if (this.currentState.gameOver) {\n      this.drawGameOver(g, width, height);\n      this.drawScoreboard(g, width, height);\n    }\n\n    this.checkAndSaveHighScore();\n    this.needsRedraw = false;\n  }\n\n  private drawStars(g: Phaser.GameObjects.Graphics): void {\n    // In film noir mode, stars are subtle distant lights\n    for (const star of this.stars) {\n      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n      const alpha = star.brightness * twinkle * 0.25;\n      g.fillStyle(COLORS.star, alpha);\n      g.fillCircle(star.x, star.y, star.size * 0.7);\n    }\n  }\n\n  private updateSmokeParticles(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (const smoke of this.smokeParticles) {\n      smoke.x += smoke.vx;\n      smoke.y += smoke.vy;\n      smoke.life -= 0.002;\n      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n        smoke.x = Math.random() * width;\n        smoke.y = height + smoke.size;\n        smoke.life = 1;\n        smoke.size = 30 + Math.random() * 50;\n        smoke.alpha = 0.02 + Math.random() * 0.03;\n      }\n      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n    }\n  }\n\n  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Create dramatic spotlight effect centered on snake\n    const cx = this.spotlightX || width / 2;\n    const cy = this.spotlightY || height / 2;\n    const pulse = 0.9 + Math.sin(this.frameCount * 0.03) * 0.1;\n\n    // Outer darkness vignette\n    g.fillStyle(0x000000, 0.6);\n    g.fillRect(0, 0, width, height);\n\n    // Spotlight cone - multiple layers for smooth falloff\n    const layers = 4;\n    for (let i = layers; i > 0; i--) {\n      const layerRadius = (width * 0.4 + i * 30) * pulse;\n      const layerAlpha = 0.15 * (1 - i / (layers + 1));\n      g.fillStyle(COLORS.spotlight, layerAlpha);\n      g.fillCircle(cx, cy, layerRadius);\n    }\n\n    // Bright center\n    g.fillStyle(COLORS.noirWhite, 0.08 * pulse);\n    g.fillCircle(cx, cy, width * 0.25);\n  }\n\n  private drawVenetianBlinds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Horizontal light streaks simulating light through venetian blinds\n    const blindSpacing = 25;\n    const blindWidth = 8;\n    const waveOffset = Math.sin(this.venetianPhase) * 10;\n\n    for (let y = waveOffset; y < height; y += blindSpacing) {\n      const brightness = 0.03 + Math.sin(y * 0.02 + this.venetianPhase * 2) * 0.015;\n      g.fillStyle(COLORS.noirWhite, brightness);\n      g.fillRect(0, y, width, blindWidth);\n    }\n\n    // Diagonal shadow bars from window frame\n    const diagonalAlpha = 0.04 + Math.sin(this.frameCount * 0.02) * 0.01;\n    g.fillStyle(0x000000, diagonalAlpha);\n    for (let i = -2; i < 6; i++) {\n      const x1 = i * 100 + Math.sin(this.venetianPhase) * 20;\n      g.beginPath();\n      g.moveTo(x1, 0);\n      g.lineTo(x1 + 40, 0);\n      g.lineTo(x1 + 40 + height * 0.3, height);\n      g.lineTo(x1 + height * 0.3, height);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawSmoke(g: Phaser.GameObjects.Graphics): void {\n    for (const smoke of this.smokeParticles) {\n      const alpha = smoke.alpha * smoke.life;\n      g.fillStyle(COLORS.noirGray, alpha);\n      g.fillCircle(smoke.x, smoke.y, smoke.size);\n      g.fillStyle(COLORS.noirWhite, alpha * 0.3);\n      g.fillCircle(smoke.x, smoke.y, smoke.size * 0.5);\n    }\n  }\n\n  private spawnFlameParticle(x: number, y: number, intensity: number): void {\n    if (this.flameParticles.length >= MAX_FLAME_PARTICLES) {\n      this.flameParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.6;\n    const life = 0.5 + Math.random() * 0.5;\n\n    this.flameParticles.push({\n      x: x + (Math.random() - 0.5) * 6,\n      y: y + (Math.random() - 0.5) * 6,\n      vx: Math.cos(angle) * speed * 0.3,\n      vy: -0.5 - Math.random() * 1.5 * intensity,\n      size: 3 + Math.random() * 4 * intensity,\n      life,\n      maxLife: life,\n      hue: 10 + Math.random() * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n    });\n  }\n\n  private updateFlameParticles(): void {\n    for (let i = this.flameParticles.length - 1; i >= 0; i--) {\n      const p = this.flameParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.02;\n      p.vx *= 0.98;\n      p.size *= 0.97;\n      p.life -= 0.025;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.flameParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private drawFlameParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.flameParticles) {\n      const lifeRatio = p.life / p.maxLife;\n\n      // Hue shifts from yellow-orange (high life) to red (low life)\n      const hue = p.hue - (1 - lifeRatio) * 15;\n      const outerColor = this.hslToRgb(hue / 360, 1, 0.3 + lifeRatio * 0.2);\n      const midColor = this.hslToRgb(hue / 360, 1, 0.5 + lifeRatio * 0.2);\n      const coreColor = this.hslToRgb((hue + 20) / 360, 0.7, 0.7 + lifeRatio * 0.2);\n\n      // Outer glow\n      g.fillStyle(outerColor, lifeRatio * 0.3);\n      g.fillCircle(p.x, p.y, p.size * 2);\n\n      // Mid flame\n      g.fillStyle(midColor, lifeRatio * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3);\n\n      // Core (bright yellow/white)\n      g.fillStyle(coreColor, lifeRatio * 0.8);\n      g.fillCircle(p.x, p.y, p.size * 0.6);\n    }\n  }\n\n  private spawnFlamesAlongSnake(): void {\n    if (!this.currentState || this.currentState.gameOver) return;\n\n    const snake = this.currentState.snake;\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const segX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const segY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const intensity = 1 - (i / snake.length) * 0.6;\n      if (Math.random() < 0.4 * intensity) {\n        this.spawnFlameParticle(segX, segY, intensity);\n      }\n    }\n  }\n\n  private drawMeteors(g: Phaser.GameObjects.Graphics): void {\n    for (const m of this.meteors) {\n      const meteorColor = this.hslToRgb(m.hue / 360, 0.9, 0.6);\n      const coreColor = this.hslToRgb(m.hue / 360, 0.6, 0.9);\n\n      // Draw trail (oldest to newest for proper layering)\n      for (let i = m.trail.length - 1; i >= 0; i--) {\n        const t = m.trail[i];\n        const trailProgress = 1 - i / m.trail.length;\n        const trailAlpha = t.alpha * trailProgress * 0.4;\n        const trailSize = m.size * trailProgress * 0.6;\n\n        g.fillStyle(meteorColor, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      g.fillStyle(meteorColor, m.alpha * 0.3);\n      g.fillCircle(m.x, m.y, m.size * 2);\n\n      // Main meteor body\n      g.fillStyle(meteorColor, m.alpha * 0.8);\n      g.fillCircle(m.x, m.y, m.size);\n\n      // Bright core\n      g.fillStyle(coreColor, m.alpha);\n      g.fillCircle(m.x, m.y, m.size * 0.5);\n    }\n  }\n\n  private drawDeathDebris(g: Phaser.GameObjects.Graphics): void {\n    // Draw explosion flash at the beginning\n    if (this.deathExplosionPhase > 0.7) {\n      const flashAlpha = (this.deathExplosionPhase - 0.7) * 2;\n      g.fillStyle(0xffffff, flashAlpha * 0.5);\n      g.fillRect(0, 0, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);\n    }\n\n    for (const d of this.deathDebris) {\n      // Film noir: grayscale debris\n      const brightness = 0.4 + (d.hue % 60) / 100;\n      const color = this.hslToRgb(0, 0, brightness);\n      const alpha = d.life * 0.9;\n\n      g.save();\n\n      if (d.type === 'shard') {\n        // Draw triangular shards\n        const cx = d.x;\n        const cy = d.y;\n        const size = d.size * d.life;\n\n        // Calculate rotated triangle points\n        const cos = Math.cos(d.rotation);\n        const sin = Math.sin(d.rotation);\n\n        const p1x = cx + cos * size;\n        const p1y = cy + sin * size;\n        const p2x = cx + cos * (-size * 0.5) - sin * (size * 0.7);\n        const p2y = cy + sin * (-size * 0.5) + cos * (size * 0.7);\n        const p3x = cx + cos * (-size * 0.5) - sin * (-size * 0.7);\n        const p3y = cy + sin * (-size * 0.5) + cos * (-size * 0.7);\n\n        // Glow\n        g.fillStyle(color, alpha * 0.4);\n        g.fillCircle(cx, cy, size * 1.5);\n\n        // Shard body\n        g.fillStyle(color, alpha);\n        g.fillTriangle(p1x, p1y, p2x, p2y, p3x, p3y);\n\n        // Highlight edge\n        g.lineStyle(1, 0xffffff, alpha * 0.6);\n        g.lineBetween(p1x, p1y, p2x, p2y);\n\n      } else if (d.type === 'spark') {\n        // Draw elongated spark\n        const sparkLength = d.size * 2 * d.life;\n        const sparkWidth = d.size * 0.3 * d.life;\n\n        // Direction based on velocity\n        const vLen = Math.sqrt(d.vx * d.vx + d.vy * d.vy);\n        const nx = vLen > 0 ? d.vx / vLen : 1;\n        const ny = vLen > 0 ? d.vy / vLen : 0;\n\n        // Glow\n        g.fillStyle(color, alpha * 0.3);\n        g.fillCircle(d.x, d.y, sparkLength * 0.8);\n\n        // Spark line\n        g.lineStyle(sparkWidth * 2, color, alpha * 0.6);\n        g.lineBetween(d.x - nx * sparkLength, d.y - ny * sparkLength, d.x, d.y);\n\n        // Bright tip\n        g.lineStyle(sparkWidth, 0xffffff, alpha);\n        g.lineBetween(d.x - nx * sparkLength * 0.3, d.y - ny * sparkLength * 0.3, d.x, d.y);\n\n      } else {\n        // Ember - glowing circle\n        const emberSize = d.size * d.life;\n\n        // Outer glow\n        g.fillStyle(color, alpha * 0.2);\n        g.fillCircle(d.x, d.y, emberSize * 2);\n\n        // Mid glow\n        g.fillStyle(color, alpha * 0.5);\n        g.fillCircle(d.x, d.y, emberSize * 1.3);\n\n        // Core\n        g.fillStyle(color, alpha);\n        g.fillCircle(d.x, d.y, emberSize);\n\n        // Hot center\n        g.fillStyle(0xffffff, alpha * 0.7);\n        g.fillCircle(d.x, d.y, emberSize * 0.4);\n      }\n\n      g.restore();\n    }\n  }\n\n  private drawNebulaClouds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const cloud of this.nebulaClouds) {\n      // Update cloud position (slow drift)\n      cloud.x += cloud.driftX;\n      cloud.y += cloud.driftY;\n      cloud.pulsePhase += cloud.pulseSpeed;\n\n      // Wrap around edges\n      if (cloud.x < -cloud.radius) cloud.x = width + cloud.radius;\n      if (cloud.x > width + cloud.radius) cloud.x = -cloud.radius;\n      if (cloud.y < -cloud.radius) cloud.y = height + cloud.radius;\n      if (cloud.y > height + cloud.radius) cloud.y = -cloud.radius;\n\n      // Pulsing alpha\n      const pulseAlpha = cloud.alpha * (0.7 + Math.sin(cloud.pulsePhase) * 0.3);\n      const color = this.hslToRgb(cloud.hue / 360, 0.6, 0.3);\n\n      // Draw multiple concentric layers for soft cloud effect\n      const layers = 4;\n      for (let i = layers; i > 0; i--) {\n        const layerRadius = cloud.radius * (i / layers);\n        const layerAlpha = pulseAlpha * (1 - i / (layers + 1)) * 0.6;\n        g.fillStyle(color, layerAlpha);\n        g.fillCircle(cloud.x, cloud.y, layerRadius);\n      }\n\n      // Core glow\n      const coreColor = this.hslToRgb(cloud.hue / 360, 0.8, 0.5);\n      g.fillStyle(coreColor, pulseAlpha * 0.4);\n      g.fillCircle(cloud.x, cloud.y, cloud.radius * 0.3);\n    }\n  }\n\n  private drawVortex(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Update vortex pulse\n    this.vortexPulse += 0.03;\n    const globalPulse = 0.8 + Math.sin(this.vortexPulse) * 0.2;\n\n    // Draw outer glow/halo\n    const outerGlowColor = this.hslToRgb(280 / 360, 0.7, 0.3);\n    g.fillStyle(outerGlowColor, 0.08 * globalPulse);\n    g.fillCircle(centerX, centerY, 120);\n    g.fillStyle(outerGlowColor, 0.05 * globalPulse);\n    g.fillCircle(centerX, centerY, 140);\n\n    // Draw orbiting particles (behind rings)\n    for (const particle of this.vortexParticles) {\n      // Update particle position - spiral inward slightly then reset\n      particle.angle += particle.speed;\n      particle.radius = particle.baseRadius + Math.sin(particle.angle * 3) * 8;\n\n      const px = centerX + Math.cos(particle.angle) * particle.radius;\n      const py = centerY + Math.sin(particle.angle) * particle.radius;\n\n      // Particle hue shifts over time\n      particle.hue = (particle.hue + 0.5) % 360;\n      const particleColor = this.hslToRgb(particle.hue / 360, 0.8, 0.6);\n\n      // Draw particle with trail\n      const trailAngle = particle.angle - 0.3;\n      const trailX = centerX + Math.cos(trailAngle) * particle.radius;\n      const trailY = centerY + Math.sin(trailAngle) * particle.radius;\n\n      g.lineStyle(particle.size * 0.8, particleColor, particle.alpha * 0.3 * globalPulse);\n      g.lineBetween(trailX, trailY, px, py);\n\n      g.fillStyle(particleColor, particle.alpha * globalPulse);\n      g.fillCircle(px, py, particle.size);\n\n      // Bright core\n      g.fillStyle(0xffffff, particle.alpha * 0.5 * globalPulse);\n      g.fillCircle(px, py, particle.size * 0.4);\n    }\n\n    // Draw rotating rings\n    for (const ring of this.vortexRings) {\n      ring.rotationOffset += ring.rotationSpeed;\n      ring.pulsePhase += 0.02;\n\n      const ringPulse = 0.7 + Math.sin(ring.pulsePhase) * 0.3;\n      const adjustedRadius = ring.baseRadius * (0.95 + ringPulse * 0.1);\n\n      const ringColor = this.hslToRgb(ring.hue / 360, 0.8, 0.5);\n\n      // Draw ring as series of arc segments with gaps\n      const segments = 6;\n      const arcLength = (Math.PI * 2) / segments * 0.7;\n\n      for (let i = 0; i < segments; i++) {\n        const startAngle = ring.rotationOffset + (i * Math.PI * 2) / segments;\n        const endAngle = startAngle + arcLength;\n\n        // Calculate alpha based on segment position for 3D effect\n        const segmentAlpha = 0.15 + Math.sin(startAngle + this.frameCount * 0.02) * 0.1;\n\n        g.lineStyle(ring.thickness, ringColor, segmentAlpha * ringPulse * globalPulse);\n        g.beginPath();\n        g.arc(centerX, centerY, adjustedRadius, startAngle, endAngle, false);\n        g.strokePath();\n      }\n\n      // Inner glow line\n      g.lineStyle(ring.thickness * 0.5, 0xffffff, 0.1 * ringPulse * globalPulse);\n      g.beginPath();\n      g.arc(centerX, centerY, adjustedRadius - 1, ring.rotationOffset, ring.rotationOffset + Math.PI, false);\n      g.strokePath();\n    }\n\n    // Central dark core (event horizon)\n    g.fillStyle(0x000000, 0.9);\n    g.fillCircle(centerX, centerY, 12);\n    g.fillStyle(0x000000, 0.7);\n    g.fillCircle(centerX, centerY, 18);\n    g.fillStyle(0x000000, 0.4);\n    g.fillCircle(centerX, centerY, 25);\n\n    // Bright accretion ring at edge of event horizon\n    const accretionHue = (this.frameCount * 2) % 360;\n    const accretionColor = this.hslToRgb(accretionHue / 360, 1, 0.6);\n    g.lineStyle(2, accretionColor, 0.4 * globalPulse);\n    g.strokeCircle(centerX, centerY, 14);\n    g.lineStyle(1, 0xffffff, 0.3 * globalPulse);\n    g.strokeCircle(centerX, centerY, 13);\n\n    // Gravitational lensing effect - distorted light streaks\n    const numStreaks = 4;\n    for (let i = 0; i < numStreaks; i++) {\n      const streakAngle = (i * Math.PI * 2) / numStreaks + this.frameCount * 0.01;\n      const streakHue = (accretionHue + i * 60) % 360;\n      const streakColor = this.hslToRgb(streakHue / 360, 0.9, 0.7);\n\n      const innerRadius = 20;\n      const outerRadius = 35 + Math.sin(this.frameCount * 0.05 + i) * 10;\n\n      const x1 = centerX + Math.cos(streakAngle) * innerRadius;\n      const y1 = centerY + Math.sin(streakAngle) * innerRadius;\n      const x2 = centerX + Math.cos(streakAngle + 0.2) * outerRadius;\n      const y2 = centerY + Math.sin(streakAngle + 0.2) * outerRadius;\n\n      g.lineStyle(3, streakColor, 0.15 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n      g.lineStyle(1.5, 0xffffff, 0.2 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n    }\n  }\n\n  private drawAuroraWaves(g: Phaser.GameObjects.Graphics, width: number): void {\n    for (const aurora of this.auroraWaves) {\n      aurora.phase += aurora.speed;\n\n      // Draw multiple ribbon layers for each aurora\n      const ribbonLayers = 3;\n      for (let layer = 0; layer < ribbonLayers; layer++) {\n        const layerOffset = layer * 5;\n        const layerAlpha = 0.06 - layer * 0.015;\n\n        // Calculate shifting hue for color variation\n        const shiftedHue = (aurora.hue + Math.sin(aurora.phase * 0.5) * 20) % 360;\n        const color = this.hslToRgb(shiftedHue / 360, 0.7, 0.5);\n\n        // Draw aurora as a series of connected curves\n        g.fillStyle(color, layerAlpha);\n        const step = 4;\n        for (let x = 0; x < width; x += step) {\n          // Multiple sine waves combined for organic movement\n          const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n          const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n          const wave3 = Math.sin(x * 0.01 + aurora.phase * 0.7) * aurora.amplitude * 0.3;\n          const yOffset = wave1 + wave2 + wave3;\n\n          const segmentY = aurora.y + yOffset + layerOffset;\n          const thickness = aurora.thickness * (0.7 + Math.sin(x * 0.05 + aurora.phase) * 0.3);\n\n          g.fillRect(x, segmentY - thickness / 2, step + 1, thickness);\n        }\n      }\n\n      // Add bright core line\n      const coreHue = (aurora.hue + 40) % 360;\n      const coreColor = this.hslToRgb(coreHue / 360, 0.9, 0.7);\n      g.lineStyle(1.5, coreColor, 0.15);\n      g.beginPath();\n      for (let x = 0; x < width; x += 3) {\n        const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n        const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n        const y = aurora.y + wave1 + wave2;\n        if (x === 0) {\n          g.moveTo(x, y);\n        } else {\n          g.lineTo(x, y);\n        }\n      }\n      g.strokePath();\n    }\n  }\n\n  private drawPlasmaWaves(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const wave of this.plasmaWaves) {\n      wave.phase += wave.speed;\n      const color = this.hslToRgb(wave.hue / 360, 0.7, 0.4);\n\n      // Draw flowing plasma lines\n      for (let y = 0; y < height; y += 8) {\n        const waveOffset = Math.sin(y / wave.wavelength + wave.phase) * wave.amplitude;\n        const intensity = 0.03 + Math.sin(wave.phase + y * 0.01) * 0.02;\n\n        g.fillStyle(color, intensity);\n        const x1 = width / 2 + waveOffset - 40;\n        const x2 = width / 2 + waveOffset + 40;\n        g.fillRect(x1, y, x2 - x1, 2);\n      }\n    }\n  }\n\n  private drawSnakeAfterimages(g: Phaser.GameObjects.Graphics): void {\n    for (const ai of this.snakeAfterimages) {\n      const alpha = ai.life * 0.25;\n      for (let i = 0; i < ai.segments.length; i++) {\n        const seg = ai.segments[i];\n        const centerX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n        const centerY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n        const t = ai.segments.length > 1 ? i / (ai.segments.length - 1) : 1;\n        const radius = (CELL_SIZE / 2 - 2) * (0.7 + t * 0.2);\n\n        const segmentHue = (ai.hueOffset + i * 15) % 360;\n        const color = this.hslToRgb(segmentHue / 360, 0.6, 0.4);\n\n        g.fillStyle(color, alpha * t);\n        g.fillCircle(centerX, centerY, radius);\n      }\n    }\n  }\n\n  private drawTrailParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.trailParticles) {\n      // Film noir: grayscale trail\n      g.fillStyle(COLORS.noirGray, p.life * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 1.5 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.5);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n  }\n\n  // Update comet trail - add new segments and fade old ones\n  private updateCometTrail(): void {\n    if (!this.currentState || this.currentState.gameOver) {\n      // Fade out trail on game over\n      for (const seg of this.cometTrail) {\n        seg.alpha *= 0.9;\n      }\n      this.cometTrail = this.cometTrail.filter(s => s.alpha > 0.01);\n      return;\n    }\n\n    const snake = this.currentState.snake;\n    if (snake.length === 0) return;\n\n    const head = snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Track head history for smooth interpolation\n    this.headHistory.unshift({ x: headX, y: headY, time: this.frameCount });\n    if (this.headHistory.length > 10) this.headHistory.pop();\n\n    // Add new trail segment at head position\n    if (this.frameCount % 2 === 0) {\n      const hue = 270 + Math.sin(this.frameCount * 0.05) * 20;\n      this.cometTrail.unshift({\n        x: headX,\n        y: headY,\n        alpha: 1,\n        size: CELL_SIZE / 2 + 2,\n        hue,\n      });\n\n      // Spawn ethereal particles from trail\n      if (Math.random() < 0.6) {\n        this.spawnEtherealParticle(headX, headY, hue);\n      }\n    }\n\n    // Limit trail length and fade segments\n    while (this.cometTrail.length > MAX_COMET_TRAIL_LENGTH) {\n      this.cometTrail.pop();\n    }\n\n    // Fade all segments\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const fadeRate = 0.06 + (i / this.cometTrail.length) * 0.04;\n      this.cometTrail[i].alpha -= fadeRate;\n      this.cometTrail[i].size *= 0.97;\n    }\n\n    // Remove fully faded segments\n    this.cometTrail = this.cometTrail.filter(s => s.alpha > 0);\n  }\n\n  // Spawn an ethereal particle that drifts away from the trail\n  private spawnEtherealParticle(x: number, y: number, hue: number): void {\n    if (this.etherealParticles.length >= MAX_ETHEREAL_PARTICLES) {\n      this.etherealParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.5;\n    const life = 0.8 + Math.random() * 0.4;\n\n    this.etherealParticles.push({\n      x: x + (Math.random() - 0.5) * 10,\n      y: y + (Math.random() - 0.5) * 10,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 0.3,\n      size: 3 + Math.random() * 4,\n      life,\n      maxLife: life,\n      hue: hue + (Math.random() - 0.5) * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n\n  // Update ethereal particles\n  private updateEtherealParticles(): void {\n    for (let i = this.etherealParticles.length - 1; i >= 0; i--) {\n      const p = this.etherealParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.015; // Slight upward drift\n      p.vx *= 0.98;\n      p.size *= 0.985;\n      p.life -= 0.02;\n      p.pulsePhase += 0.15;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.etherealParticles.splice(i, 1);\n      }\n    }\n  }\n\n  // Draw the comet trail - smooth glowing ribbon\n  private drawCometTrail(g: Phaser.GameObjects.Graphics): void {\n    if (this.cometTrail.length < 2) return;\n\n    // Draw outer glow layer\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.05) continue;\n\n      const progress = i / this.cometTrail.length;\n      const glowSize = seg.size * (1.5 + progress * 0.5);\n      const glowAlpha = seg.alpha * 0.15 * (1 - progress * 0.5);\n\n      // Outer ethereal glow\n      const outerColor = this.hslToRgb(seg.hue / 360, 0.6, 0.4);\n      g.fillStyle(outerColor, glowAlpha);\n      g.fillCircle(seg.x, seg.y, glowSize * 1.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(seg.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, glowAlpha * 1.5);\n      g.fillCircle(seg.x, seg.y, glowSize);\n    }\n\n    // Draw connecting ribbon between segments\n    if (this.cometTrail.length >= 2) {\n      for (let i = 0; i < this.cometTrail.length - 1; i++) {\n        const seg1 = this.cometTrail[i];\n        const seg2 = this.cometTrail[i + 1];\n        if (seg1.alpha < 0.1 || seg2.alpha < 0.1) continue;\n\n        const progress = i / this.cometTrail.length;\n        const ribbonAlpha = Math.min(seg1.alpha, seg2.alpha) * 0.4 * (1 - progress * 0.5);\n        const ribbonWidth = (seg1.size + seg2.size) / 2 * 0.6;\n\n        // Ribbon core\n        const ribbonColor = this.hslToRgb(seg1.hue / 360, 0.8, 0.6);\n        g.lineStyle(ribbonWidth, ribbonColor, ribbonAlpha);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n\n        // Bright inner ribbon\n        g.lineStyle(ribbonWidth * 0.4, 0xffffff, ribbonAlpha * 0.6);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n      }\n    }\n\n    // Draw core particles at each segment\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.1) continue;\n\n      const progress = i / this.cometTrail.length;\n      const coreAlpha = seg.alpha * 0.6 * (1 - progress * 0.7);\n      const coreSize = seg.size * 0.5 * (1 - progress * 0.3);\n\n      // Core glow\n      const coreColor = this.hslToRgb(seg.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, coreAlpha);\n      g.fillCircle(seg.x, seg.y, coreSize);\n\n      // Bright white center\n      g.fillStyle(0xffffff, coreAlpha * 0.5);\n      g.fillCircle(seg.x, seg.y, coreSize * 0.4);\n    }\n  }\n\n  // Draw ethereal particles - luminous drifting particles\n  private drawEtherealParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.etherealParticles) {\n      const lifeRatio = p.life / p.maxLife;\n      const pulse = 0.7 + Math.sin(p.pulsePhase) * 0.3;\n      const alpha = lifeRatio * pulse;\n\n      // Outer glow\n      const glowColor = this.hslToRgb(p.hue / 360, 0.5, 0.3);\n      g.fillStyle(glowColor, alpha * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 2.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(p.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      // Core\n      const coreColor = this.hslToRgb(p.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, alpha * 0.7);\n      g.fillCircle(p.x, p.y, p.size);\n\n      // Bright center\n      g.fillStyle(0xffffff, alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawShockWaves(g: Phaser.GameObjects.Graphics): void {\n    for (const sw of this.shockWaves) {\n      const alpha = sw.life * 0.6;\n      // Outer ring\n      g.lineStyle(3, 0xffffff, alpha * 0.3);\n      g.strokeCircle(sw.x, sw.y, sw.radius);\n      // Inner bright ring\n      g.lineStyle(2, 0x00ffff, alpha * 0.7);\n      g.strokeCircle(sw.x, sw.y, sw.radius * 0.8);\n      // Core flash\n      if (sw.life > 0.8) {\n        g.fillStyle(0xffffff, (sw.life - 0.8) * 3);\n        g.fillCircle(sw.x, sw.y, sw.radius * 0.3);\n      }\n    }\n  }\n\n  private drawLightningBolts(g: Phaser.GameObjects.Graphics): void {\n    for (const bolt of this.lightningBolts) {\n      const alpha = bolt.life;\n\n      // Film noir: white lightning\n      g.lineStyle(4, COLORS.noirGray, alpha * 0.3);\n      this.drawLightningPath(g, bolt.points);\n\n      g.lineStyle(2, 0xffffff, alpha * 0.8);\n      this.drawLightningPath(g, bolt.points);\n    }\n  }\n\n  private drawLightningPath(g: Phaser.GameObjects.Graphics, points: { x: number; y: number }[]): void {\n    if (points.length < 2) return;\n    g.beginPath();\n    g.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      g.lineTo(points[i].x, points[i].y);\n    }\n    g.strokePath();\n  }\n\n  private drawSnakeElectricity(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n    const snake = this.currentState.snake;\n    if (snake.length < 2) return;\n\n    // Draw electric arcs between segments every few frames\n    if (this.frameCount % 3 !== 0) return;\n\n    for (let i = 0; i < snake.length - 1; i++) {\n      if (Math.random() > 0.4) continue;\n\n      const seg1 = snake[i];\n      const seg2 = snake[i + 1];\n      const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n      const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n      const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n      const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const arcPoints = this.generateLightningPath(x1, y1, x2, y2);\n\n      // Film noir: grayscale arcs\n      g.lineStyle(3, COLORS.noirGray, 0.3);\n      this.drawLightningPath(g, arcPoints);\n      g.lineStyle(1, 0xffffff, 0.7);\n      this.drawLightningPath(g, arcPoints);\n    }\n  }\n\n  private hslToRgb(h: number, s: number, l: number): number {\n    let r: number, g: number, b: number;\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return (Math.round(r * 255) << 16) | (Math.round(g * 255) << 8) | Math.round(b * 255);\n  }\n\n  private loadHighScores(): HighScoreEntry[] {\n    if (this.highScoresLoaded && this.highScores.length > 0) {\n      return this.highScores;\n    }\n    try {\n      const stored = localStorage.getItem('snake_high_scores');\n      if (stored) {\n        const parsed = JSON.parse(stored) as HighScoreEntry[];\n        this.highScores = parsed.slice(0, MAX_HIGH_SCORES);\n        this.highScoresLoaded = true;\n        return this.highScores;\n      }\n    } catch {\n      // localStorage not available\n    }\n    this.highScores = [];\n    this.highScoresLoaded = true;\n    return this.highScores;\n  }\n\n  private saveHighScore(score: number): number {\n    const highScores = this.loadHighScores();\n    const newEntry: HighScoreEntry = { score, date: Date.now(), rank: 0 };\n\n    let insertIndex = highScores.findIndex(entry => score > entry.score);\n    if (insertIndex === -1) insertIndex = highScores.length;\n\n    if (insertIndex < MAX_HIGH_SCORES && score > 0) {\n      highScores.splice(insertIndex, 0, newEntry);\n      highScores.forEach((entry, i) => { entry.rank = i + 1; });\n      this.highScores = highScores.slice(0, MAX_HIGH_SCORES);\n\n      try {\n        localStorage.setItem('snake_high_scores', JSON.stringify(this.highScores));\n      } catch {\n        // localStorage not available\n      }\n      return insertIndex + 1;\n    }\n    return -1;\n  }\n\n  private checkAndSaveHighScore(): void {\n    if (!this.currentState) return;\n\n    if (this.currentState.gameOver && !this.lastGameOverState) {\n      const score = this.currentState.score || 0;\n      const rank = this.saveHighScore(score);\n      this.newHighScoreRank = rank > 0 ? rank : -1;\n      this.scoreboardRevealProgress = 0;\n\n      const head = this.currentState.snake[0];\n      if (head) {\n        const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnBlood(this.cleanEffects, headX, headY, 15);\n        spawnTears(this.cleanEffects, headX, headY - 10, 6);\n      }\n    }\n    this.lastGameOverState = this.currentState.gameOver;\n\n    if (this.currentState.gameStarted && !this.currentState.gameOver) {\n      this.newHighScoreRank = -1;\n    }\n  }\n\n  private drawHUD(g: Phaser.GameObjects.Graphics, width: number): void {\n    if (!this.currentState || !this.currentState.gameStarted) return;\n\n    this.hudPulsePhase += 0.08;\n    const score = this.currentState.score || 0;\n\n    if (score > this.lastHudScore) {\n      this.scoreFlashIntensity = 1;\n    }\n    this.lastHudScore = score;\n    this.scoreFlashIntensity *= 0.92;\n\n    const padding = 12;\n    const scorePanelWidth = 120;\n    const scorePanelHeight = 50;\n\n    // Score panel background - volcanic lava theme\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Glowing border\n    const borderGlow = 0.6 + this.scoreFlashIntensity * 0.4;\n    g.lineStyle(2, COLORS.snakeGlow, borderGlow);\n    g.strokeRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Score label\n    this.drawText(g, 'SCORE', padding + 10, padding + 12, 10, COLORS.snakeBody, 0.9);\n\n    // Score value with flash effect\n    const scoreColor = this.scoreFlashIntensity > 0.5 ? 0xffffff : COLORS.snakeHead;\n    this.drawText(g, String(score).padStart(5, '0'), padding + 10, padding + 32, 18, scoreColor, 1);\n\n    // Outer glow on score when flashing\n    if (this.scoreFlashIntensity > 0.1) {\n      g.fillStyle(COLORS.snakeGlow, this.scoreFlashIntensity * 0.3);\n      g.fillRoundedRect(padding + 5, padding + 20, 100, 28, 4);\n    }\n\n    // Length panel on the right\n    const lengthPanelWidth = 80;\n    const lengthPanelHeight = 50;\n    const lengthX = width - padding - lengthPanelWidth;\n\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    g.lineStyle(2, COLORS.foodGlow, 0.6);\n    g.strokeRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    this.drawText(g, 'LENGTH', lengthX + 10, padding + 12, 10, COLORS.food, 0.9);\n    this.drawText(g, String(this.currentState.snake.length), lengthX + 10, padding + 32, 18, COLORS.foodCore, 1);\n  }\n\n  private drawText(\n    g: Phaser.GameObjects.Graphics,\n    text: string,\n    x: number,\n    y: number,\n    size: number,\n    color: number,\n    alpha: number\n  ): void {\n    // Use simple block characters for text rendering\n    const charWidth = size * 0.6;\n    const charHeight = size;\n\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const cx = x + i * charWidth;\n\n      g.fillStyle(color, alpha);\n\n      // Simple pixel-style character rendering\n      if (char >= '0' && char <= '9') {\n        this.drawDigit(g, char, cx, y, size);\n      } else {\n        this.drawLetter(g, char, cx, y, size);\n      }\n    }\n  }\n\n  private drawDigit(g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15; // thickness\n\n    // 7-segment style digits\n    const segments: Record<string, number[]> = {\n      '0': [1, 1, 1, 0, 1, 1, 1],\n      '1': [0, 0, 1, 0, 0, 1, 0],\n      '2': [1, 0, 1, 1, 1, 0, 1],\n      '3': [1, 0, 1, 1, 0, 1, 1],\n      '4': [0, 1, 1, 1, 0, 1, 0],\n      '5': [1, 1, 0, 1, 0, 1, 1],\n      '6': [1, 1, 0, 1, 1, 1, 1],\n      '7': [1, 0, 1, 0, 0, 1, 0],\n      '8': [1, 1, 1, 1, 1, 1, 1],\n      '9': [1, 1, 1, 1, 0, 1, 1],\n    };\n\n    const seg = segments[digit] || segments['0'];\n\n    // Top horizontal\n    if (seg[0]) g.fillRect(x, y - h / 2, w, t);\n    // Top-left vertical\n    if (seg[1]) g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n    // Top-right vertical\n    if (seg[2]) g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n    // Middle horizontal\n    if (seg[3]) g.fillRect(x, y - t / 2, w, t);\n    // Bottom-left vertical\n    if (seg[4]) g.fillRect(x - t / 2, y, t, h / 2);\n    // Bottom-right vertical\n    if (seg[5]) g.fillRect(x + w - t / 2, y, t, h / 2);\n    // Bottom horizontal\n    if (seg[6]) g.fillRect(x, y + h / 2 - t, w, t);\n  }\n\n  private drawLetter(g: Phaser.GameObjects.Graphics, letter: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15;\n\n    // Simple block letters\n    switch (letter.toUpperCase()) {\n      case 'S':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'C':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'O':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'R':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w / 2, y, t, h / 2);\n        break;\n      case 'E':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w * 0.7, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'L':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'N':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - h / 2 + t, w, t);\n        break;\n      case 'G':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x + w / 2, y - t / 2, w / 2, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'T':\n        g.fillRect(x - t, y - h / 2, w + t * 2, t);\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'H':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n      case 'I':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'Y':\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        break;\n      case 'U':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'W':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case '!':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h * 0.6);\n        g.fillRect(x + w / 2 - t / 2, y + h / 2 - t * 2, t, t);\n        break;\n      case ' ':\n        break;\n      default:\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n    }\n  }\n\n  private drawScoreboard(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (!this.currentState || !this.currentState.gameOver) return;\n\n    this.scoreboardAnimPhase += 0.06;\n    this.scoreboardRevealProgress = Math.min(1, this.scoreboardRevealProgress + 0.02);\n\n    const highScores = this.loadHighScores();\n    const centerX = width / 2;\n    const baseY = height * 0.18;\n    const panelWidth = 180;\n    const panelHeight = 170;\n    const panelX = centerX - panelWidth / 2;\n    const panelY = baseY;\n    const slideOffset = (1 - this.scoreboardRevealProgress) * 50;\n    const alphaMultiplier = this.scoreboardRevealProgress;\n\n    // Panel background - volcanic lava glow\n    g.fillStyle(0x150510, 0.95 * alphaMultiplier);\n    g.fillRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Glowing border - animated\n    const borderHue = this.newHighScoreRank > 0 ? 45 : 0;\n    const borderPulse = 0.6 + Math.sin(this.scoreboardAnimPhase) * 0.2;\n    const borderColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    g.lineStyle(3, borderColor, borderPulse * alphaMultiplier);\n    g.strokeRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Title\n    const titleY = panelY - slideOffset + 22;\n    this.drawText(g, 'HIGH SCORES', centerX - 55, titleY, 10, COLORS.foodCore, alphaMultiplier);\n\n    // Divider line\n    g.lineStyle(1, COLORS.snakeGlow, 0.5 * alphaMultiplier);\n    g.lineBetween(panelX + 20, titleY + 8, panelX + panelWidth - 20, titleY + 8);\n\n    const entryStartY = titleY + 25;\n    const entryHeight = 22;\n\n    if (highScores.length === 0) {\n      this.drawText(g, 'NO SCORES YET', centerX - 50, entryStartY + 30, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n    } else {\n      for (let i = 0; i < Math.min(highScores.length, 5); i++) {\n        const entry = highScores[i];\n        const entryY = entryStartY + i * entryHeight;\n        const isNewScore = this.newHighScoreRank === i + 1;\n        const entryDelay = i * 0.15;\n        const entryProgress = Math.max(0, Math.min(1, (this.scoreboardRevealProgress - entryDelay) * 2));\n        if (entryProgress <= 0) continue;\n\n        const entryAlpha = alphaMultiplier * entryProgress;\n\n        // Highlight new high score row\n        if (isNewScore) {\n          const flashIntensity = 0.3 + Math.sin(this.scoreboardAnimPhase * 3) * 0.2;\n          g.fillStyle(0xffcc00, flashIntensity * entryAlpha);\n          g.fillRoundedRect(panelX + 8, entryY - slideOffset - 8, panelWidth - 16, entryHeight - 2, 4);\n        }\n\n        // Rank colors: gold, silver, bronze, then volcanic colors\n        const rankColors = [0xffd700, 0xc0c0c0, 0xcd7f32, COLORS.snakeGlow, COLORS.foodGlow];\n        const rankColor = rankColors[i] || 0x888888;\n\n        // Rank number\n        this.drawText(g, `${i + 1}`, panelX + 18, entryY - slideOffset, 10, rankColor, entryAlpha);\n\n        // Score value\n        const scoreColor = isNewScore ? 0xffffff : COLORS.foodCore;\n        this.drawText(g, String(entry.score).padStart(5, '0'), panelX + panelWidth - 70, entryY - slideOffset, 10, scoreColor, entryAlpha);\n\n        // NEW! label\n        if (isNewScore) {\n          const newAlpha = 0.8 + Math.sin(this.scoreboardAnimPhase * 4) * 0.2;\n          this.drawText(g, 'NEW', panelX + 50, entryY - slideOffset, 7, 0xffcc00, newAlpha * entryAlpha);\n        }\n      }\n    }\n\n    // Current score at bottom\n    const currentScoreY = panelY - slideOffset + panelHeight - 30;\n    this.drawText(g, 'YOUR SCORE', centerX - 40, currentScoreY - 10, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n\n    const currentScore = this.currentState.score || 0;\n    const scoreColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    this.drawText(g, String(currentScore).padStart(5, '0'), centerX - 25, currentScoreY + 8, 14, scoreColor, alphaMultiplier);\n  }\n\n  private drawGrid(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir grid: subtle, dark lines suggesting tile floor or city grid\n    g.lineStyle(1, COLORS.gridLine, 0.08);\n    for (let i = 0; i <= GRID_SIZE; i++) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Accent lines every 5 cells - subtle gray\n    const accentPulse = 0.12 + Math.sin(this.frameCount * 0.03) * 0.04;\n    g.lineStyle(1, COLORS.gridAccent, accentPulse);\n    for (let i = 0; i <= GRID_SIZE; i += 5) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Heavy vignette for dramatic noir look\n    this.drawVignette(g, width, height);\n  }\n\n  private drawVignette(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Multiple layers of vignette for smooth falloff\n    const layers = 5;\n    for (let i = 0; i < layers; i++) {\n      const inset = i * 30;\n      const alpha = 0.15 * (1 - i / layers);\n      g.lineStyle(60, 0x000000, alpha);\n      g.strokeRect(inset - 30, inset - 30, width - inset * 2 + 60, height - inset * 2 + 60);\n    }\n  }\n\n  private drawFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    // Don't draw food if it's still being thrown\n    if (this.thrownFood && !this.thrownFood.landed) return;\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    const pulseScale = 1 + Math.sin(this.frameCount * 0.15) * 0.08;\n    const glowPulse = 0.4 + Math.sin(this.frameCount * 0.1) * 0.2;\n\n    // Spawn particles (orange/yellow for Halloween)\n    this.spawnFoodParticles(foodX, foodY);\n\n    // Draw particles\n    for (const p of this.foodParticles) {\n      g.fillStyle(COLORS.pumpkinOrange, p.life * 0.4);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Halloween pumpkin!\n    const pumpkinSize = (CELL_SIZE / 2) * pulseScale;\n\n    // Shadow underneath\n    g.fillStyle(0x000000, 0.5);\n    g.fillEllipse(foodX + 2, foodY + pumpkinSize * 0.8, pumpkinSize * 1.2, pumpkinSize * 0.4);\n\n    // Outer orange glow (candlelight effect)\n    g.fillStyle(COLORS.pumpkinOrange, glowPulse * 0.15);\n    g.fillCircle(foodX, foodY, pumpkinSize + 12);\n    g.fillStyle(COLORS.candyCorn1, glowPulse * 0.2);\n    g.fillCircle(foodX, foodY, pumpkinSize + 6);\n\n    // Pumpkin body (slightly squashed circle)\n    g.fillStyle(COLORS.pumpkinOrange, 0.95);\n    g.fillEllipse(foodX, foodY, pumpkinSize * 1.1, pumpkinSize * 0.9);\n\n    // Pumpkin segments (darker lines)\n    g.lineStyle(2, 0xcc4400, 0.5);\n    g.lineBetween(foodX, foodY - pumpkinSize * 0.8, foodX, foodY + pumpkinSize * 0.7);\n    g.lineStyle(1.5, 0xcc4400, 0.3);\n    g.lineBetween(foodX - pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX - pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n    g.lineBetween(foodX + pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX + pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n\n    // Pumpkin stem\n    g.fillStyle(0x228822, 0.9);\n    g.fillRect(foodX - 2, foodY - pumpkinSize * 0.9 - 4, 4, 6);\n\n    // Jack-o-lantern face - glowing eyes and mouth\n    const faceGlow = 0.8 + Math.sin(this.frameCount * 0.12) * 0.2;\n    g.fillStyle(COLORS.candyCorn1, faceGlow);\n\n    // Eyes (triangles)\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n\n    // Mouth (jagged smile)\n    g.fillStyle(COLORS.candyCorn1, faceGlow * 0.9);\n    g.fillRect(foodX - pumpkinSize * 0.35, foodY + pumpkinSize * 0.15, pumpkinSize * 0.7, pumpkinSize * 0.25);\n\n    // Teeth (dark gaps in mouth)\n    g.fillStyle(COLORS.pumpkinOrange, 1);\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX, foodY + pumpkinSize * 0.15,\n      foodX - pumpkinSize * 0.075, foodY + pumpkinSize * 0.3\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.3, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.225, foodY + pumpkinSize * 0.3\n    );\n  }\n\n  private drawEnergyTendrils(g: Phaser.GameObjects.Graphics, foodX: number, foodY: number): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const head = this.currentState.snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Calculate distance to snake head\n    const dx = headX - foodX;\n    const dy = headY - foodY;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    // Only draw tendrils when snake is somewhat close\n    if (dist > CELL_SIZE * 6) return;\n\n    // Intensity increases as snake gets closer\n    const intensity = 1 - dist / (CELL_SIZE * 6);\n    const numTendrils = 2 + Math.floor(intensity * 2);\n\n    for (let i = 0; i < numTendrils; i++) {\n      // Tendril reaches partway toward the snake\n      const reach = 0.3 + intensity * 0.4;\n      const targetX = foodX + dx * reach;\n      const targetY = foodY + dy * reach;\n\n      // Add some wave offset for each tendril\n      const waveOffset = Math.sin(this.frameCount * 0.15 + i * 2) * 10;\n      const perpX = -dy / dist;\n      const perpY = dx / dist;\n      const wavyTargetX = targetX + perpX * waveOffset * (1 - reach);\n      const wavyTargetY = targetY + perpY * waveOffset * (1 - reach);\n\n      // Generate tendril path\n      const points = this.generateLightningPath(foodX, foodY, wavyTargetX, wavyTargetY);\n\n      // Draw tendril with glow\n      g.lineStyle(3, COLORS.foodGlow, intensity * 0.3);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1.5, COLORS.food, intensity * 0.7);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1, 0xffffff, intensity * 0.5);\n      this.drawLightningPath(g, points);\n    }\n  }\n\n  private drawSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const snakeLen = snake.length;\n\n    // Spooky shadow under snake\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const shadowRadius = (CELL_SIZE / 2) * (0.9 + t * 0.1);\n      g.fillStyle(0x000000, 0.5 * t);\n      g.fillCircle(centerX, centerY, shadowRadius);\n    }\n\n    // Draw trailing glow (ghostly green)\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const glowAlpha = 0.2 * t;\n      const glowSize = (CELL_SIZE / 2 + 4) * (0.5 + t * 0.5);\n\n      g.fillStyle(COLORS.snakeGlow, glowAlpha);\n      g.fillCircle(centerX, centerY, glowSize);\n    }\n\n    // Draw snake segments from tail to head with green gradient\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n\n      // Green gradient from tail (dark) to head (bright)\n      const brightness = 0.3 + t * 0.4;\n      const segmentColor = this.hslToRgb(0.4, 0.9, brightness);\n\n      if (i === 0) {\n        // Head: brightest green with eerie glow\n        g.fillStyle(COLORS.snakeGlow, 0.4);\n        g.fillCircle(centerX, centerY, radius + 8);\n\n        g.fillStyle(COLORS.snakeHead, 1);\n        g.fillCircle(centerX, centerY, radius + 1);\n\n        // Slimy highlight\n        g.fillStyle(0xaaffcc, 0.6);\n        g.fillCircle(centerX - 2, centerY - 2, radius * 0.35);\n\n        this.drawSnakeHead(g, segment, snake[1]);\n      } else {\n        // Body segment with green tones\n        g.fillStyle(COLORS.snakeGlow, 0.15);\n        g.fillCircle(centerX, centerY, radius + 2);\n\n        g.fillStyle(segmentColor, 1);\n        g.fillCircle(centerX, centerY, radius);\n\n        // Slimy specular highlight\n        g.fillStyle(0xaaffcc, 0.15 * t);\n        g.fillCircle(centerX - 1, centerY - 1, radius * 0.25);\n      }\n    }\n  }\n\n  private drawFoodBurst(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.foodBurstParticles) {\n      // Halloween: orange pumpkin burst\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailAlpha = p.life * 0.4 * (1 - i / p.trail.length);\n        const trailSize = p.size * p.life * (1 - i / p.trail.length);\n        g.fillStyle(COLORS.pumpkinOrange, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      g.fillStyle(COLORS.candyCorn1, p.life * 0.7);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n      g.fillStyle(COLORS.candyCorn3, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life * 0.4);\n    }\n  }\n\n  private drawEnergyField(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const snake = this.currentState.snake;\n    const baseIntensity = 0.06 + this.energyFieldPulse * 0.2;\n    const pulseOffset = Math.sin(this.frameCount * 0.1) * 0.02;\n    const alpha = Math.min(0.3, baseIntensity + pulseOffset);\n\n    // Halloween: ghostly green energy field\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const fieldRadius = CELL_SIZE * (0.8 + this.energyFieldPulse * 0.5) + Math.sin(this.frameCount * 0.15 + i * 0.5) * 2;\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.2);\n      g.fillCircle(cx, cy, fieldRadius + 4);\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.35);\n      g.fillCircle(cx, cy, fieldRadius);\n    }\n\n    // Connecting lines when pulse is active\n    if (this.energyFieldPulse > 0.3 && snake.length > 1) {\n      for (let i = 0; i < snake.length - 1; i++) {\n        const seg1 = snake[i];\n        const seg2 = snake[i + 1];\n        const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n        const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n        const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n        const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n        g.lineStyle(3, COLORS.noirGray, this.energyFieldPulse * 0.3);\n        g.lineBetween(x1, y1, x2, y2);\n        g.lineStyle(1.5, 0xffffff, this.energyFieldPulse * 0.5);\n        g.lineBetween(x1, y1, x2, y2);\n      }\n    }\n  }\n\n  private drawChromaticAberration(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const offset = this.chromaticIntensity * 3;\n\n    // Film noir: grayscale ghosting effect instead of color split\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snake.length > 1 ? i / (snake.length - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n      const alpha = this.chromaticIntensity * 0.3 * (i === 0 ? 1 : 0.5);\n\n      // Light ghost - offset left\n      g.fillStyle(0xffffff, alpha);\n      g.fillCircle(cx - offset, cy, radius);\n\n      // Dark ghost - offset right\n      g.fillStyle(0x404040, alpha);\n      g.fillCircle(cx + offset, cy, radius);\n    }\n  }\n\n  private drawGameOver(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir game over: dramatic fade to black with spotlight\n    if (this.gameOverAlpha < 0.85) {\n      this.gameOverAlpha += 0.03;\n    }\n\n    // Heavy dark overlay\n    g.fillStyle(COLORS.gameOverOverlay, this.gameOverAlpha);\n    g.fillRect(0, 0, width, height);\n\n    // Film grain effect (subtle noise lines)\n    for (let y = 0; y < height; y += 3) {\n      const grainAlpha = 0.05 + Math.random() * 0.05;\n      g.fillStyle(Math.random() > 0.5 ? 0xffffff : 0x000000, grainAlpha);\n      g.fillRect(0, y, width, 1);\n    }\n\n    // Dramatic spotlight in center\n    const spotPulse = 0.15 + Math.sin(this.frameCount * 0.05) * 0.05;\n    g.fillStyle(COLORS.noirWhite, spotPulse);\n    g.fillCircle(width / 2, height / 2, 80);\n    g.fillStyle(COLORS.noirWhite, spotPulse * 0.5);\n    g.fillCircle(width / 2, height / 2, 120);\n\n    // Noir border: thick black frame\n    const borderSize = 8;\n    g.fillStyle(0x000000, 0.8);\n    g.fillRect(0, 0, width, borderSize);\n    g.fillRect(0, height - borderSize, width, borderSize);\n    g.fillRect(0, 0, borderSize, height);\n    g.fillRect(width - borderSize, 0, borderSize, height);\n\n    // White inner border\n    const innerBorder = 2;\n    const innerOffset = borderSize;\n    g.fillStyle(COLORS.noirWhite, 0.3);\n    g.fillRect(innerOffset, innerOffset, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, height - innerOffset - innerBorder, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, innerOffset, innerBorder, height - innerOffset * 2);\n    g.fillRect(width - innerOffset - innerBorder, innerOffset, innerBorder, height - innerOffset * 2);\n  }\n\n  private drawSnakeHead(\n    g: Phaser.GameObjects.Graphics,\n    head: Position,\n    nextSegment: Position | undefined\n  ): void {\n    const centerX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const centerY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Determine direction for eye placement\n    let dx = 1, dy = 0;\n    if (nextSegment) {\n      dx = head.x - nextSegment.x;\n      dy = head.y - nextSegment.y;\n      // Normalize\n      const len = Math.sqrt(dx * dx + dy * dy);\n      if (len > 0) {\n        dx /= len;\n        dy /= len;\n      }\n    }\n\n    // Perpendicular for eye offset\n    const perpX = -dy;\n    const perpY = dx;\n\n    const eyeOffset = 4;\n    const eyeForward = 3;\n    const eyeRadius = 3;\n    const pupilRadius = 1.5;\n\n    // Left eye\n    const leftEyeX = centerX + perpX * eyeOffset + dx * eyeForward;\n    const leftEyeY = centerY + perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(leftEyeX, leftEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(leftEyeX + dx * 1, leftEyeY + dy * 1, pupilRadius);\n\n    // Right eye\n    const rightEyeX = centerX - perpX * eyeOffset + dx * eyeForward;\n    const rightEyeY = centerY - perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(rightEyeX, rightEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(rightEyeX + dx * 1, rightEyeY + dy * 1, pupilRadius);\n\n    // Draw the royal crown\n    this.drawCrown(g, centerX, centerY, dx, dy, perpX, perpY);\n  }\n\n  private drawCrown(\n    g: Phaser.GameObjects.Graphics,\n    headX: number,\n    headY: number,\n    dx: number,\n    dy: number,\n    perpX: number,\n    perpY: number\n  ): void {\n    // Volcanic crown: molten gold with ruby gems\n    const crownOffset = -8;\n    const crownBaseX = headX - dx * crownOffset;\n    const crownBaseY = headY - dy * crownOffset;\n\n    const crownWidth = 14;\n    const crownHeight = 10;\n    const halfWidth = crownWidth / 2;\n\n    const sparkle = 0.7 + Math.sin(this.frameCount * 0.15) * 0.3;\n\n    const baseLeft = {\n      x: crownBaseX + perpX * halfWidth,\n      y: crownBaseY + perpY * halfWidth\n    };\n    const baseRight = {\n      x: crownBaseX - perpX * halfWidth,\n      y: crownBaseY - perpY * halfWidth\n    };\n\n    const pointOffset = -dx * crownHeight;\n    const pointOffsetY = -dy * crownHeight;\n\n    const crownPoints = [\n      baseLeft,\n      { x: baseLeft.x + pointOffset * 0.4, y: baseLeft.y + pointOffsetY * 0.4 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: crownBaseX + perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY + perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY },\n      { x: crownBaseX - perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY - perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: baseRight.x + pointOffset * 0.4, y: baseRight.y + pointOffsetY * 0.4 },\n      baseRight\n    ];\n\n    // Crown glow (molten orange/red aura)\n    g.fillStyle(COLORS.noirWhite, 0.25 * sparkle);\n    g.fillCircle(crownBaseX + pointOffset * 0.5, crownBaseY + pointOffsetY * 0.5, crownHeight + 4);\n\n    // Crown base (molten gold)\n    g.fillStyle(0xffa500, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.fillPath();\n\n    // Crown outline (dark crimson)\n    g.lineStyle(1.5, 0x801010, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.strokePath();\n\n    // Crown band\n    const bandY1 = {\n      x: baseLeft.x + pointOffset * 0.15,\n      y: baseLeft.y + pointOffsetY * 0.15\n    };\n    const bandY2 = {\n      x: baseRight.x + pointOffset * 0.15,\n      y: baseRight.y + pointOffsetY * 0.15\n    };\n    g.lineStyle(3, 0xcc6600, 1);\n    g.lineBetween(bandY1.x, bandY1.y, bandY2.x, bandY2.y);\n\n    // Ruby jewels: glowing red gems\n    const jewelPositions = [\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY, size: 2.5 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n    ];\n\n    for (const jewel of jewelPositions) {\n      g.fillStyle(0xff4020, 0.5 * sparkle);\n      g.fillCircle(jewel.x, jewel.y, jewel.size + 2);\n\n      g.fillStyle(0xff2000, 1);\n      g.fillCircle(jewel.x, jewel.y, jewel.size);\n\n      g.fillStyle(0xffff80, 0.9 * sparkle);\n      g.fillCircle(jewel.x - 0.5, jewel.y - 0.5, jewel.size * 0.4);\n    }\n\n    // Crown highlight (golden gleam)\n    g.fillStyle(0xffff80, 0.6 * sparkle);\n    g.fillCircle(crownBaseX + perpX * 3 + pointOffset * 0.3, crownBaseY + perpY * 3 + pointOffsetY * 0.3, 2);\n  }\n}\n","structuredPatch":[{"oldStart":487,"oldLines":6,"newStart":487,"newLines":7,"lines":["     const width = GRID_SIZE * CELL_SIZE;","     const height = GRID_SIZE * CELL_SIZE;","     initMotes(this.cleanEffects, width, height);","+    initSnowflakes(this.cleanEffects, width, height);"," ","     if (this.currentState) {","       this.needsRedraw = true;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LDpNbFDpAVBRw2hpJX8Zc1","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to find where updateMotes is called to add updateSnowflakes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":411,"cache_read_input_tokens":41206,"cache_creation":{"ephemeral_5m_input_tokens":411,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"3d6c0ca9-3877-40c8-8eea-4c7c1588fbc2"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LDpNbFDpAVBRw2hpJX8Zc1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T2uZRzoSL31N6Ni6FC5wdV","name":"Grep","input":{"pattern":"updateMotes","path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","output_mode":"content","-n":true,"-C":3},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":411,"cache_read_input_tokens":41206,"cache_creation":{"ephemeral_5m_input_tokens":411,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"74f66980-1118-470f-a433-0651c78d2006"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01T2uZRzoSL31N6Ni6FC5wdV","type":"tool_result","content":"2-import {\n3-  createCleanEffectsState,\n4-  initMotes,\n5:  updateMotes,\n6-  updateRipples,\n7-  updateGlowTrail,\n8-  spawnRipple,\n--\n2393-    const width = this.scale.width;\n2394-    const height = this.scale.height;\n2395-\n2396:    updateMotes(this.cleanEffects, width, height);\n2397-    updateRipples(this.cleanEffects);\n2398-    updateTears(this.cleanEffects, height);\n2399-    updateBlood(this.cleanEffects, height);"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"0bea850a-68fc-403c-b12e-106ddb7ef97f","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"2-import {\n3-  createCleanEffectsState,\n4-  initMotes,\n5:  updateMotes,\n6-  updateRipples,\n7-  updateGlowTrail,\n8-  spawnRipple,\n--\n2393-    const width = this.scale.width;\n2394-    const height = this.scale.height;\n2395-\n2396:    updateMotes(this.cleanEffects, width, height);\n2397-    updateRipples(this.cleanEffects);\n2398-    updateTears(this.cleanEffects, height);\n2399-    updateBlood(this.cleanEffects, height);","numLines":15}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011drMDG24CXVY15M6r9yBk4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TuTomJ3qemLcQQLQrA5NNv","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":2390,"limit":20},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":381,"cache_read_input_tokens":41617,"cache_creation":{"ephemeral_5m_input_tokens":381,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"04719291-1fd8-46bc-88fb-1146712cb7c1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TuTomJ3qemLcQQLQrA5NNv","type":"tool_result","content":"  2390→    this.frameCount++;\n  2391→    this.cleanEffects.frameCount = this.frameCount;\n  2392→\n  2393→    const width = this.scale.width;\n  2394→    const height = this.scale.height;\n  2395→\n  2396→    updateMotes(this.cleanEffects, width, height);\n  2397→    updateRipples(this.cleanEffects);\n  2398→    updateTears(this.cleanEffects, height);\n  2399→    updateBlood(this.cleanEffects, height);\n  2400→\n  2401→    if (this.currentState && this.currentState.snake.length > 0) {\n  2402→      const head = this.currentState.snake[0];\n  2403→      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n  2404→      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n  2405→\n  2406→      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n  2407→        updateGlowTrail(this.cleanEffects, headX, headY);\n  2408→      }\n  2409→      this.lastHeadPos = { x: head.x, y: head.y };\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"0c55b71d-a420-4b48-acf5-0d7f98311c7f","tool_use_result":{"type":"text","file":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","content":"    this.frameCount++;\n    this.cleanEffects.frameCount = this.frameCount;\n\n    const width = this.scale.width;\n    const height = this.scale.height;\n\n    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n    updateTears(this.cleanEffects, height);\n    updateBlood(this.cleanEffects, height);\n\n    if (this.currentState && this.currentState.snake.length > 0) {\n      const head = this.currentState.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n        updateGlowTrail(this.cleanEffects, headX, headY);\n      }\n      this.lastHeadPos = { x: head.x, y: head.y };","numLines":20,"startLine":2390,"totalLines":4147}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GTD7evYov98y9JRNe2Vs7m","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01U1XULJkRRN242YSXCV9oF6","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","old_string":"    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n    updateTears(this.cleanEffects, height);\n    updateBlood(this.cleanEffects, height);","new_string":"    updateMotes(this.cleanEffects, width, height);\n    updateSnowflakes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n    updateTears(this.cleanEffects, height);\n    updateBlood(this.cleanEffects, height);"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":804,"cache_read_input_tokens":41998,"cache_creation":{"ephemeral_5m_input_tokens":804,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"efc594aa-254f-4e62-9d28-c1dabb08a837"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01U1XULJkRRN242YSXCV9oF6","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"4ae8deca-2ddc-454a-a52e-9d895f16a8ba","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","oldString":"    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n    updateTears(this.cleanEffects, height);\n    updateBlood(this.cleanEffects, height);","newString":"    updateMotes(this.cleanEffects, width, height);\n    updateSnowflakes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n    updateTears(this.cleanEffects, height);\n    updateBlood(this.cleanEffects, height);","originalFile":"import Phaser from 'phaser';\nimport {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  initSnowflakes,\n  updateSnowflakes,\n  drawSnowflakes,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface GameState {\n  snake: Position[];\n  food: Position;\n  gameOver: boolean;\n  gameStarted?: boolean;\n  score?: number;\n}\n\ninterface Star {\n  x: number;\n  y: number;\n  size: number;\n  speed: number;\n  brightness: number;\n}\n\ninterface PlasmaWave {\n  phase: number;\n  speed: number;\n  amplitude: number;\n  wavelength: number;\n  hue: number;\n}\n\ninterface AuroraWave {\n  y: number;\n  phase: number;\n  speed: number;\n  hue: number;\n  thickness: number;\n  amplitude: number;\n}\n\ninterface NebulaCloud {\n  x: number;\n  y: number;\n  radius: number;\n  hue: number;\n  alpha: number;\n  driftX: number;\n  driftY: number;\n  pulsePhase: number;\n  pulseSpeed: number;\n}\n\ninterface VortexRing {\n  radius: number;\n  baseRadius: number;\n  rotationOffset: number;\n  rotationSpeed: number;\n  thickness: number;\n  hue: number;\n  pulsePhase: number;\n}\n\ninterface VortexParticle {\n  angle: number;\n  radius: number;\n  baseRadius: number;\n  speed: number;\n  size: number;\n  hue: number;\n  alpha: number;\n}\n\ninterface SnakeAfterimage {\n  segments: Position[];\n  life: number;\n  maxLife: number;\n  hueOffset: number;\n}\n\ninterface FoodParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n}\n\ninterface SnakeTrailParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n  hue: number;\n}\n\ninterface ShockWave {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n}\n\ninterface LightningBolt {\n  points: { x: number; y: number }[];\n  life: number;\n  maxLife: number;\n  hue: number;\n}\n\nconst CELL_SIZE = 20;\nconst GRID_SIZE = 20;\nconst NUM_STARS = 30;\nconst MAX_FOOD_PARTICLES = 8;\nconst MAX_TRAIL_PARTICLES = 40;\nconst MAX_SHOCKWAVES = 3;\nconst MAX_LIGHTNING_BOLTS = 5;\nconst MAX_BURST_PARTICLES = 12;\nconst NUM_PLASMA_WAVES = 3;\nconst MAX_AFTERIMAGES = 4;\nconst NUM_AURORA_WAVES = 5;\nconst NUM_NEBULA_CLOUDS = 6;\nconst NUM_VORTEX_RINGS = 5;\nconst NUM_VORTEX_PARTICLES = 20;\nconst NUM_METEORS = 8;\nconst MAX_DEATH_DEBRIS = 24;\nconst NUM_SPIRITS_PER_EDGE = 2;\nconst MAX_FLAME_PARTICLES = 60;\nconst MAX_COMET_TRAIL_LENGTH = 30;\nconst MAX_ETHEREAL_PARTICLES = 50;\nconst NUM_BEES = 8;\nconst BEE_SPAWN_CHANCE = 0.02;\n\n// Comet trail segment - stores historical snake positions for smooth trail rendering\ninterface CometTrailSegment {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n  hue: number;\n}\n\n// Ethereal trail particle - luminous particles that drift away from trail\ninterface EtherealParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n  pulsePhase: number;\n}\n\n// Thrown food animation - food launched onto screen with arc trajectory\ninterface ThrownFood {\n  startX: number;\n  startY: number;\n  targetX: number;\n  targetY: number;\n  x: number;\n  y: number;\n  progress: number; // 0 to 1\n  rotation: number;\n  rotationSpeed: number;\n  trail: { x: number; y: number; alpha: number; rotation: number }[];\n  landed: boolean;\n  landingParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number }[];\n  impactRings: { radius: number; alpha: number }[];\n}\n\n// Meteor shower types\ninterface Meteor {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  alpha: number;\n  trail: { x: number; y: number; alpha: number }[];\n  life: number;\n}\n\n// Death debris particle\ninterface DeathDebris {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  rotation: number;\n  rotationSpeed: number;\n  life: number;\n  type: 'shard' | 'spark' | 'ember';\n}\n\n// Guardian spirit - ethereal protectors at edges\ninterface GuardianSpirit {\n  x: number;\n  y: number;\n  baseX: number;\n  baseY: number;\n  size: number;\n  phase: number;\n  speed: number;\n  haloPhase: number;\n  orbPhase: number;\n  edge: 'top' | 'bottom' | 'left' | 'right';\n  targetAlpha: number;\n  currentAlpha: number;\n  hue: number;\n  orbs: { angle: number; distance: number; size: number; speed: number }[];\n}\n\n// Flame particle for burning effect\ninterface FlameParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n}\n\n// Mystical bee - glowing magical creatures that swarm around food\ninterface MysticalBee {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  targetX: number;\n  targetY: number;\n  wingPhase: number;\n  wingSpeed: number;\n  size: number;\n  hue: number;\n  glowIntensity: number;\n  bobPhase: number;\n  bobSpeed: number;\n  trail: { x: number; y: number; alpha: number }[];\n  state: 'flying' | 'hovering' | 'attracted';\n  sparkleTimer: number;\n}\n\n// Rival snake - spectral AI nemesis that competes for food\ninterface RivalSnake {\n  segments: { x: number; y: number }[];\n  direction: { dx: number; dy: number };\n  targetX: number;\n  targetY: number;\n  moveTimer: number;\n  moveInterval: number;\n  pulsePhase: number;\n  glowIntensity: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n  energyTrail: { x: number; y: number; alpha: number; size: number }[];\n  state: 'hunting' | 'fleeing' | 'circling';\n  aggression: number;\n  nearMissTimer: number;\n  electricArcs: { x1: number; y1: number; x2: number; y2: number; life: number }[];\n}\n\nconst RIVAL_SNAKE_LENGTH = 10;\nconst RIVAL_MOVE_INTERVAL = 8;\n\n// Armageddon Chaos effect types\ninterface GroundFissure {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  width: number;\n  glowIntensity: number;\n  pulsePhase: number;\n}\n\ninterface FireRainParticle {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n}\n\ninterface ChaosExplosion {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n  rings: { radius: number; alpha: number }[];\n  debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[];\n}\n\ninterface ApocalypticSkull {\n  x: number;\n  y: number;\n  size: number;\n  alpha: number;\n  rotation: number;\n  pulsePhase: number;\n}\n\nconst NUM_FISSURES = 6;\nconst MAX_FIRE_RAIN = 30;\nconst MAX_CHAOS_EXPLOSIONS = 3;\nconst NUM_SKULLS = 4;\n\n// High score entry for scoreboard\ninterface HighScoreEntry {\n  score: number;\n  date: number;\n  rank: number;\n}\n\nconst MAX_HIGH_SCORES = 5;\n\n// Color palette - HALLOWEEN theme: spooky purple/orange, ghostly greens, pumpkin glow\nconst COLORS = {\n  bgDark: 0x0a0012,\n  bgMid: 0x150825,\n  gridLine: 0x2a1540,\n  gridAccent: 0x401860,\n  snakeHead: 0x00ff66,\n  snakeBody: 0x00cc55,\n  snakeTail: 0x009944,\n  snakeHighlight: 0x66ffaa,\n  snakeScale: 0x00aa44,\n  snakeEye: 0xff0000,\n  snakePupil: 0x000000,\n  snakeGlow: 0x00ff80,\n  food: 0xff6600,\n  foodCore: 0xffcc00,\n  foodGlow: 0xff8800,\n  foodParticle: 0xffaa00,\n  star: 0x8844ff,\n  gameOverOverlay: 0x0a0015,\n  gameOverText: 0xff6600,\n  plasma1: 0x9933ff,\n  plasma2: 0xbb55ff,\n  plasma3: 0x7722cc,\n  screenFlash: 0xff6600,\n  // Halloween specific colors\n  noirWhite: 0xeeddff,\n  noirGray: 0x8866aa,\n  noirDark: 0x2a1540,\n  spotlight: 0xff8800,\n  // Halloween additions\n  chaosRed: 0x9933ff,\n  chaosOrange: 0xff6600,\n  chaosYellow: 0xffcc00,\n  lavaGlow: 0x9944ff,\n  ashGray: 0x554466,\n  bloodRed: 0x660088,\n  hellfire: 0xff6600,\n  // New Halloween colors\n  pumpkinOrange: 0xff6600,\n  ghostWhite: 0xeeffee,\n  witchPurple: 0x9933ff,\n  spiderBlack: 0x111122,\n  candyCorn1: 0xffcc00,\n  candyCorn2: 0xff8800,\n  candyCorn3: 0xffffff,\n};\n\nexport class SnakeScene extends Phaser.Scene {\n  private graphics!: Phaser.GameObjects.Graphics;\n  private currentState: GameState | null = null;\n  private needsRedraw = false;\n  private frameCount = 0;\n  private stars: Star[] = [];\n  private foodParticles: FoodParticle[] = [];\n  private trailParticles: SnakeTrailParticle[] = [];\n  private shockWaves: ShockWave[] = [];\n  private lightningBolts: LightningBolt[] = [];\n  private plasmaWaves: PlasmaWave[] = [];\n  private snakeAfterimages: SnakeAfterimage[] = [];\n  private auroraWaves: AuroraWave[] = [];\n  private nebulaClouds: NebulaCloud[] = [];\n  private vortexRings: VortexRing[] = [];\n  private vortexParticles: VortexParticle[] = [];\n  private vortexPulse = 0;\n  private meteors: Meteor[] = [];\n  private deathDebris: DeathDebris[] = [];\n  private deathExplosionPhase = 0;\n  private gameOverAlpha = 0;\n  private lastHeadPos: Position | null = null;\n  private lastSnakeLength = 0;\n  private hueOffset = 0;\n  private screenFlashAlpha = 0;\n  private gameOverGlitchOffset = 0;\n  private screenShakeX = 0;\n  private screenShakeY = 0;\n  private screenShakeIntensity = 0;\n  private energyFieldPulse = 0;\n  private foodBurstParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number; hue: number; trail: { x: number; y: number }[] }[] = [];\n  private chromaticIntensity = 0;\n  // Film noir effects\n  private venetianPhase = 0;\n  private spotlightX = 0;\n  private spotlightY = 0;\n  private smokeParticles: { x: number; y: number; vx: number; vy: number; size: number; alpha: number; life: number }[] = [];\n  private guardianSpirits: GuardianSpirit[] = [];\n  // Burning flame particles trailing behind snake\n  private flameParticles: FlameParticle[] = [];\n  // Comet trail system - historical positions for smooth ribbon trail\n  private cometTrail: CometTrailSegment[] = [];\n  // Ethereal particles that drift away from the trail\n  private etherealParticles: EtherealParticle[] = [];\n  // Track last few head positions for smooth interpolation\n  private headHistory: { x: number; y: number; time: number }[] = [];\n  // Thrown food animation system\n  private thrownFood: ThrownFood | null = null;\n  private lastFoodPos: Position | null = null;\n  // Mystical bees swarming around\n  private bees: MysticalBee[] = [];\n  // Rival snake - spectral AI nemesis\n  private rivalSnake: RivalSnake | null = null;\n  // Scoreboard system\n  private highScores: HighScoreEntry[] = [];\n  private highScoresLoaded = false;\n  private newHighScoreRank = -1;\n  private scoreboardAnimPhase = 0;\n  private scoreboardRevealProgress = 0;\n  private lastGameOverState = false;\n  private hudPulsePhase = 0;\n  private lastHudScore = 0;\n  private scoreFlashIntensity = 0;\n  // Armageddon Chaos effects\n  private groundFissures: GroundFissure[] = [];\n  private fireRainParticles: FireRainParticle[] = [];\n  private chaosExplosions: ChaosExplosion[] = [];\n  private apocalypticSkulls: ApocalypticSkull[] = [];\n  private armageddonPulse = 0;\n  private chaosIntensity = 0;\n  private cleanEffects: CleanEffectsState = createCleanEffectsState();\n\n  constructor() {\n    super({ key: 'SnakeScene' });\n  }\n\n  create(): void {\n    this.graphics = this.add.graphics();\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    initMotes(this.cleanEffects, width, height);\n    initSnowflakes(this.cleanEffects, width, height);\n\n    if (this.currentState) {\n      this.needsRedraw = true;\n    }\n  }\n\n  private initArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Initialize ground fissures - cracks in the earth with lava\n    this.groundFissures = [];\n    for (let i = 0; i < NUM_FISSURES; i++) {\n      const startX = Math.random() * width;\n      const startY = Math.random() * height;\n      const angle = Math.random() * Math.PI;\n      const length = 40 + Math.random() * 80;\n      this.groundFissures.push({\n        x1: startX,\n        y1: startY,\n        x2: startX + Math.cos(angle) * length,\n        y2: startY + Math.sin(angle) * length,\n        width: 2 + Math.random() * 4,\n        glowIntensity: 0.5 + Math.random() * 0.5,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n\n    // Initialize fire rain\n    this.fireRainParticles = [];\n\n    // Initialize chaos explosions\n    this.chaosExplosions = [];\n\n    // Initialize apocalyptic skulls floating in background\n    this.apocalypticSkulls = [];\n    for (let i = 0; i < NUM_SKULLS; i++) {\n      this.apocalypticSkulls.push({\n        x: 30 + Math.random() * (width - 60),\n        y: 30 + Math.random() * (height - 60),\n        size: 15 + Math.random() * 10,\n        alpha: 0.03 + Math.random() * 0.04,\n        rotation: Math.random() * Math.PI * 2,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n  }\n\n  private initSmokeParticles(): void {\n    this.smokeParticles = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < 12; i++) {\n      this.smokeParticles.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        vx: (Math.random() - 0.5) * 0.3,\n        vy: -0.1 - Math.random() * 0.2,\n        size: 30 + Math.random() * 50,\n        alpha: 0.02 + Math.random() * 0.03,\n        life: Math.random(),\n      });\n    }\n  }\n\n  private updateArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    this.armageddonPulse += 0.04;\n\n    // Update ground fissures - pulsing lava glow\n    for (const fissure of this.groundFissures) {\n      fissure.pulsePhase += 0.06;\n      fissure.glowIntensity = 0.5 + Math.sin(fissure.pulsePhase) * 0.3;\n    }\n\n    // Spawn fire rain particles\n    if (this.fireRainParticles.length < MAX_FIRE_RAIN && Math.random() < 0.3) {\n      const hueVariation = Math.random();\n      this.fireRainParticles.push({\n        x: Math.random() * width,\n        y: -20,\n        vy: 2 + Math.random() * 3,\n        size: 2 + Math.random() * 4,\n        alpha: 0.6 + Math.random() * 0.4,\n        hue: hueVariation < 0.6 ? 0 : (hueVariation < 0.85 ? 20 : 40), // Red, orange, yellow\n        trail: [],\n      });\n    }\n\n    // Update fire rain\n    for (let i = this.fireRainParticles.length - 1; i >= 0; i--) {\n      const p = this.fireRainParticles[i];\n      p.trail.unshift({ x: p.x, y: p.y, alpha: p.alpha });\n      if (p.trail.length > 6) p.trail.pop();\n      for (const t of p.trail) { t.alpha *= 0.7; }\n\n      p.y += p.vy;\n      p.x += Math.sin(this.armageddonPulse + p.y * 0.05) * 0.3;\n      p.alpha *= 0.995;\n\n      if (p.y > height + 20 || p.alpha < 0.05) {\n        this.fireRainParticles.splice(i, 1);\n      }\n    }\n\n    // Update chaos explosions\n    for (let i = this.chaosExplosions.length - 1; i >= 0; i--) {\n      const exp = this.chaosExplosions[i];\n      exp.radius += 4;\n      exp.life -= 0.03;\n\n      for (const ring of exp.rings) {\n        ring.radius += 3;\n        ring.alpha *= 0.92;\n      }\n      exp.rings = exp.rings.filter(r => r.alpha > 0.02);\n\n      for (const d of exp.debris) {\n        d.x += d.vx;\n        d.y += d.vy;\n        d.vy += 0.1;\n        d.alpha *= 0.96;\n      }\n      exp.debris = exp.debris.filter(d => d.alpha > 0.02);\n\n      if (exp.life <= 0 && exp.rings.length === 0 && exp.debris.length === 0) {\n        this.chaosExplosions.splice(i, 1);\n      }\n    }\n\n    // Update apocalyptic skulls - slow drift and pulse\n    for (const skull of this.apocalypticSkulls) {\n      skull.pulsePhase += 0.02;\n      skull.rotation += 0.002;\n      skull.x += Math.sin(skull.pulsePhase * 0.5) * 0.1;\n      skull.y += Math.cos(skull.pulsePhase * 0.3) * 0.1;\n\n      // Keep in bounds\n      if (skull.x < 20) skull.x = 20;\n      if (skull.x > width - 20) skull.x = width - 20;\n      if (skull.y < 20) skull.y = 20;\n      if (skull.y > height - 20) skull.y = height - 20;\n    }\n\n    // Chaos intensity increases when snake eats or dies\n    this.chaosIntensity *= 0.97;\n  }\n\n  private spawnChaosExplosion(x: number, y: number): void {\n    if (this.chaosExplosions.length >= MAX_CHAOS_EXPLOSIONS) {\n      this.chaosExplosions.shift();\n    }\n\n    const debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[] = [];\n    for (let i = 0; i < 12; i++) {\n      const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 5;\n      debris.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 2,\n        size: 2 + Math.random() * 4,\n        alpha: 1,\n      });\n    }\n\n    this.chaosExplosions.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: 80,\n      life: 1,\n      rings: [\n        { radius: 10, alpha: 1 },\n        { radius: 5, alpha: 0.8 },\n        { radius: 15, alpha: 0.6 },\n      ],\n      debris,\n    });\n\n    this.chaosIntensity = Math.min(1, this.chaosIntensity + 0.5);\n    this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 12);\n  }\n\n  private drawArmageddonBackground(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Spooky Halloween night sky\n    const skyPulse = 0.8 + Math.sin(this.armageddonPulse * 0.5) * 0.2;\n\n    // Layer 1: Deep purple-black night base\n    g.fillStyle(0x0a0018, 1);\n    g.fillRect(0, 0, width, height);\n\n    // Layer 2: Eerie purple glow from below (like fog)\n    g.fillStyle(0x200840, 0.3 * skyPulse);\n    g.fillRect(0, height * 0.7, width, height * 0.3);\n\n    // Layer 3: Misty purple clouds\n    for (let i = 0; i < 4; i++) {\n      const cloudY = i * 30 + Math.sin(this.armageddonPulse + i) * 10;\n      const cloudAlpha = 0.1 - i * 0.02;\n      g.fillStyle(0x301040, cloudAlpha * skyPulse);\n      g.fillRect(0, cloudY, width, 40);\n    }\n\n    // Draw haunted moon\n    this.drawHauntedMoon(g, width);\n\n    // Draw flying bats in background\n    this.drawFlyingBats(g, width, height);\n\n    // Draw apocalyptic skulls (very faint, background layer)\n    this.drawApocalypticSkulls(g);\n  }\n\n  private drawHauntedMoon(g: Phaser.GameObjects.Graphics, width: number): void {\n    const moonX = width * 0.8;\n    const moonY = 60;\n    const moonRadius = 35;\n    const moonPulse = 0.9 + Math.sin(this.frameCount * 0.02) * 0.1;\n\n    // Moon glow\n    g.fillStyle(0xff8800, 0.1 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 2);\n    g.fillStyle(0xffaa00, 0.15 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 1.5);\n\n    // Main moon (orange harvest moon)\n    g.fillStyle(0xffaa33, 0.9);\n    g.fillCircle(moonX, moonY, moonRadius);\n\n    // Moon craters\n    g.fillStyle(0xcc8822, 0.4);\n    g.fillCircle(moonX - 10, moonY - 5, 8);\n    g.fillCircle(moonX + 12, moonY + 8, 6);\n    g.fillCircle(moonX - 5, moonY + 12, 5);\n  }\n\n  private drawFlyingBats(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const batCount = 6;\n    for (let i = 0; i < batCount; i++) {\n      const phase = this.frameCount * 0.03 + i * 1.5;\n      const batX = ((i * 127 + this.frameCount * 0.5) % (width + 100)) - 50;\n      const batY = 40 + i * 20 + Math.sin(phase) * 15;\n      const wingPhase = Math.sin(this.frameCount * 0.15 + i * 2);\n\n      // Bat body\n      g.fillStyle(0x111122, 0.8);\n      g.fillCircle(batX, batY, 4);\n\n      // Bat wings (flapping)\n      const wingSpread = 8 + wingPhase * 4;\n      g.fillStyle(0x111122, 0.7);\n\n      // Left wing\n      g.beginPath();\n      g.moveTo(batX - 2, batY);\n      g.lineTo(batX - wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX - wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n\n      // Right wing\n      g.beginPath();\n      g.moveTo(batX + 2, batY);\n      g.lineTo(batX + wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX + wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawGroundFissures(g: Phaser.GameObjects.Graphics): void {\n    for (const fissure of this.groundFissures) {\n      const pulse = fissure.glowIntensity;\n\n      // Ghostly purple glow underneath\n      g.lineStyle(fissure.width * 3, COLORS.lavaGlow, 0.12 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Crack edges (dark purple)\n      g.lineStyle(fissure.width + 2, 0x200030, 0.4);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ethereal core (bright purple)\n      g.lineStyle(fissure.width, COLORS.witchPurple, 0.3 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ghostly white center\n      g.lineStyle(fissure.width * 0.3, COLORS.ghostWhite, 0.2 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n    }\n  }\n\n  private drawFireRain(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.fireRainParticles) {\n      // Draw ghostly trail\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailSize = p.size * (1 - i / p.trail.length) * 0.6;\n        // Ghostly purple/green trail\n        const ghostHue = 0.75 + (p.hue % 60) / 360;\n        const trailColor = this.hslToRgb(ghostHue, 0.6, 0.6);\n        g.fillStyle(trailColor, t.alpha * 0.3);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Main spirit particle (ghostly appearance)\n      const outerColor = this.hslToRgb(0.8, 0.5, 0.5);\n      const coreColor = this.hslToRgb(0.85, 0.3, 0.8);\n\n      g.fillStyle(outerColor, p.alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      g.fillStyle(coreColor, p.alpha * 0.6);\n      g.fillCircle(p.x, p.y, p.size);\n\n      g.fillStyle(COLORS.ghostWhite, p.alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawChaosExplosions(g: Phaser.GameObjects.Graphics): void {\n    for (const exp of this.chaosExplosions) {\n      // Central flash\n      if (exp.life > 0.7) {\n        const flashAlpha = (exp.life - 0.7) * 3;\n        g.fillStyle(0xffffff, flashAlpha * 0.5);\n        g.fillCircle(exp.x, exp.y, exp.radius * 0.5);\n        g.fillStyle(COLORS.chaosYellow, flashAlpha * 0.4);\n        g.fillCircle(exp.x, exp.y, exp.radius);\n      }\n\n      // Expanding rings\n      for (const ring of exp.rings) {\n        g.lineStyle(4, COLORS.chaosRed, ring.alpha * 0.5);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(2, COLORS.chaosOrange, ring.alpha * 0.7);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(1, 0xffffff, ring.alpha * 0.4);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n      }\n\n      // Flying debris\n      for (const d of exp.debris) {\n        g.fillStyle(COLORS.chaosOrange, d.alpha * 0.6);\n        g.fillCircle(d.x, d.y, d.size * 1.3);\n        g.fillStyle(COLORS.chaosYellow, d.alpha * 0.9);\n        g.fillCircle(d.x, d.y, d.size);\n      }\n    }\n  }\n\n  private drawApocalypticSkulls(g: Phaser.GameObjects.Graphics): void {\n    for (const skull of this.apocalypticSkulls) {\n      const pulse = 0.7 + Math.sin(skull.pulsePhase) * 0.3;\n      const alpha = skull.alpha * pulse;\n      const s = skull.size;\n\n      // Ghostly purple glow\n      g.fillStyle(COLORS.witchPurple, alpha * 0.2);\n      g.fillCircle(skull.x, skull.y, s * 1.5);\n\n      // Skull outline (bone white)\n      g.fillStyle(0xcccccc, alpha * 0.8);\n      // Cranium\n      g.fillCircle(skull.x, skull.y - s * 0.1, s * 0.8);\n      // Jaw\n      g.fillRect(skull.x - s * 0.4, skull.y + s * 0.3, s * 0.8, s * 0.4);\n\n      // Eye sockets (glowing green - spooky!)\n      g.fillStyle(COLORS.snakeHead, alpha * 1.2);\n      g.fillCircle(skull.x - s * 0.25, skull.y - s * 0.1, s * 0.2);\n      g.fillCircle(skull.x + s * 0.25, skull.y - s * 0.1, s * 0.2);\n\n      // Nose hole\n      g.fillStyle(0x000000, alpha);\n      g.fillTriangle(\n        skull.x, skull.y + s * 0.1,\n        skull.x - s * 0.1, skull.y + s * 0.25,\n        skull.x + s * 0.1, skull.y + s * 0.25\n      );\n    }\n  }\n\n  private drawChaosOverlay(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (this.chaosIntensity <= 0) return;\n\n    // Purple tint overlay when chaos is active\n    g.fillStyle(COLORS.witchPurple, this.chaosIntensity * 0.1);\n    g.fillRect(0, 0, width, height);\n\n    // Pulsing purple vignette edges\n    const vignetteAlpha = this.chaosIntensity * 0.25;\n    g.lineStyle(80, COLORS.bloodRed, vignetteAlpha);\n    g.strokeRect(-40, -40, width + 80, height + 80);\n  }\n\n  private initGuardianSpirits(): void {\n    this.guardianSpirits = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const spiritHues = [180, 220, 280, 320];\n\n    const edges: ('top' | 'bottom' | 'left' | 'right')[] = ['top', 'bottom', 'left', 'right'];\n    for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      const edge = edges[edgeIndex];\n      for (let i = 0; i < NUM_SPIRITS_PER_EDGE; i++) {\n        let x = 0, y = 0;\n        const offset = (i + 0.5) / NUM_SPIRITS_PER_EDGE;\n\n        switch (edge) {\n          case 'top':\n            x = width * offset;\n            y = -15;\n            break;\n          case 'bottom':\n            x = width * offset;\n            y = height + 15;\n            break;\n          case 'left':\n            x = -15;\n            y = height * offset;\n            break;\n          case 'right':\n            x = width + 15;\n            y = height * offset;\n            break;\n        }\n\n        const orbs: { angle: number; distance: number; size: number; speed: number }[] = [];\n        const numOrbs = 3;\n        for (let o = 0; o < numOrbs; o++) {\n          orbs.push({\n            angle: (o / numOrbs) * Math.PI * 2,\n            distance: 15 + Math.random() * 10,\n            size: 3 + Math.random() * 2,\n            speed: 0.03 + Math.random() * 0.02,\n          });\n        }\n\n        this.guardianSpirits.push({\n          x,\n          y,\n          baseX: x,\n          baseY: y,\n          size: 20 + Math.random() * 10,\n          phase: Math.random() * Math.PI * 2,\n          speed: 0.015 + Math.random() * 0.01,\n          haloPhase: Math.random() * Math.PI * 2,\n          orbPhase: Math.random() * Math.PI * 2,\n          edge,\n          targetAlpha: 0.4 + Math.random() * 0.2,\n          currentAlpha: 0,\n          hue: spiritHues[edgeIndex % spiritHues.length] + Math.random() * 30 - 15,\n          orbs,\n        });\n      }\n    }\n  }\n\n  private initBees(): void {\n    this.bees = [];\n  }\n\n  private initRivalSnake(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    const startX = width - 50 - Math.random() * 50;\n    const startY = height - 50 - Math.random() * 50;\n\n    const segments: { x: number; y: number }[] = [];\n    for (let i = 0; i < RIVAL_SNAKE_LENGTH; i++) {\n      segments.push({\n        x: startX + i * CELL_SIZE * 0.6,\n        y: startY,\n      });\n    }\n\n    this.rivalSnake = {\n      segments,\n      direction: { dx: -1, dy: 0 },\n      targetX: width / 2,\n      targetY: height / 2,\n      moveTimer: 0,\n      moveInterval: RIVAL_MOVE_INTERVAL,\n      pulsePhase: 0,\n      glowIntensity: 0.8,\n      hue: 200,\n      trail: [],\n      energyTrail: [],\n      state: 'hunting',\n      aggression: 0.5,\n      nearMissTimer: 0,\n      electricArcs: [],\n    };\n  }\n\n  private updateRivalSnake(): void {\n    if (!this.rivalSnake || !this.currentState) return;\n\n    const rs = this.rivalSnake;\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    rs.pulsePhase += 0.1;\n    rs.glowIntensity = 0.6 + Math.sin(rs.pulsePhase) * 0.3;\n\n    if (rs.segments.length > 0) {\n      rs.trail.unshift({ x: rs.segments[0].x, y: rs.segments[0].y, alpha: 0.7 });\n      if (rs.trail.length > 20) rs.trail.pop();\n\n      rs.energyTrail.unshift({\n        x: rs.segments[0].x + (Math.random() - 0.5) * 8,\n        y: rs.segments[0].y + (Math.random() - 0.5) * 8,\n        alpha: 0.8,\n        size: 3 + Math.random() * 4\n      });\n      if (rs.energyTrail.length > 30) rs.energyTrail.pop();\n    }\n\n    for (const t of rs.trail) {\n      t.alpha *= 0.92;\n    }\n    rs.trail = rs.trail.filter(t => t.alpha > 0.02);\n\n    for (const e of rs.energyTrail) {\n      e.alpha *= 0.88;\n      e.size *= 0.95;\n    }\n    rs.energyTrail = rs.energyTrail.filter(e => e.alpha > 0.02);\n\n    rs.electricArcs = rs.electricArcs.filter(arc => {\n      arc.life -= 0.15;\n      return arc.life > 0;\n    });\n\n    if (rs.nearMissTimer > 0) rs.nearMissTimer--;\n\n    const playerHead = this.currentState.snake[0];\n    const playerX = playerHead.x * CELL_SIZE + CELL_SIZE / 2;\n    const playerY = playerHead.y * CELL_SIZE + CELL_SIZE / 2;\n    const rivalHead = rs.segments[0];\n    const distToPlayer = Math.sqrt(\n      Math.pow(playerX - rivalHead.x, 2) + Math.pow(playerY - rivalHead.y, 2)\n    );\n\n    if (distToPlayer < 60 && rs.nearMissTimer === 0) {\n      rs.nearMissTimer = 30;\n      rs.electricArcs.push({\n        x1: rivalHead.x,\n        y1: rivalHead.y,\n        x2: playerX,\n        y2: playerY,\n        life: 1.0\n      });\n      rs.aggression = Math.min(1.0, rs.aggression + 0.1);\n    }\n\n    rs.moveTimer++;\n    if (rs.moveTimer >= rs.moveInterval) {\n      rs.moveTimer = 0;\n\n      const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n      const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n      const distToFood = Math.sqrt(\n        Math.pow(foodX - rivalHead.x, 2) + Math.pow(foodY - rivalHead.y, 2)\n      );\n\n      if (distToPlayer < 80) {\n        rs.state = 'fleeing';\n        const fleeAngle = Math.atan2(rivalHead.y - playerY, rivalHead.x - playerX);\n        rs.targetX = rivalHead.x + Math.cos(fleeAngle) * 100;\n        rs.targetY = rivalHead.y + Math.sin(fleeAngle) * 100;\n      } else if (distToFood < 150 || rs.aggression > 0.7) {\n        rs.state = 'hunting';\n        rs.targetX = foodX;\n        rs.targetY = foodY;\n      } else {\n        rs.state = 'circling';\n        const circleAngle = rs.pulsePhase * 0.3;\n        rs.targetX = width / 2 + Math.cos(circleAngle) * 120;\n        rs.targetY = height / 2 + Math.sin(circleAngle) * 120;\n      }\n\n      rs.targetX = Math.max(30, Math.min(width - 30, rs.targetX));\n      rs.targetY = Math.max(30, Math.min(height - 30, rs.targetY));\n\n      const dx = rs.targetX - rivalHead.x;\n      const dy = rs.targetY - rivalHead.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 5) {\n        const targetDx = dx / dist;\n        const targetDy = dy / dist;\n        const turnSpeed = rs.state === 'fleeing' ? 0.5 : 0.35;\n\n        rs.direction.dx = rs.direction.dx * (1 - turnSpeed) + targetDx * turnSpeed;\n        rs.direction.dy = rs.direction.dy * (1 - turnSpeed) + targetDy * turnSpeed;\n\n        const len = Math.sqrt(rs.direction.dx * rs.direction.dx + rs.direction.dy * rs.direction.dy);\n        if (len > 0) {\n          rs.direction.dx /= len;\n          rs.direction.dy /= len;\n        }\n      }\n\n      const moveSpeed = rs.state === 'fleeing' ? CELL_SIZE * 0.7 : CELL_SIZE * 0.55;\n      const newHead = {\n        x: rivalHead.x + rs.direction.dx * moveSpeed,\n        y: rivalHead.y + rs.direction.dy * moveSpeed,\n      };\n\n      if (newHead.x < 10) newHead.x = width - 10;\n      if (newHead.x > width - 10) newHead.x = 10;\n      if (newHead.y < 10) newHead.y = height - 10;\n      if (newHead.y > height - 10) newHead.y = 10;\n\n      rs.segments.unshift(newHead);\n      rs.segments.pop();\n    } else {\n      const head = rs.segments[0];\n      const moveSpeed = CELL_SIZE * 0.5;\n\n      head.x += rs.direction.dx * moveSpeed * 0.06;\n      head.y += rs.direction.dy * moveSpeed * 0.06;\n\n      for (let i = 1; i < rs.segments.length; i++) {\n        const seg = rs.segments[i];\n        const prev = rs.segments[i - 1];\n        const pullStrength = 0.18;\n        seg.x += (prev.x - seg.x) * pullStrength;\n        seg.y += (prev.y - seg.y) * pullStrength;\n      }\n    }\n\n    if (this.currentState.gameOver) {\n      rs.hue = 180;\n      rs.glowIntensity *= 0.95;\n      rs.state = 'circling';\n    } else {\n      rs.hue = rs.state === 'hunting' ? 190 : (rs.state === 'fleeing' ? 220 : 200);\n      rs.hue += Math.sin(rs.pulsePhase * 0.5) * 10;\n    }\n\n    rs.aggression *= 0.998;\n  }\n\n  private drawRivalSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.rivalSnake || this.rivalSnake.segments.length === 0) return;\n\n    const rs = this.rivalSnake;\n    const pulse = rs.glowIntensity;\n\n    for (const arc of rs.electricArcs) {\n      this.drawElectricArc(g, arc.x1, arc.y1, arc.x2, arc.y2, arc.life);\n    }\n\n    for (const e of rs.energyTrail) {\n      g.fillStyle(this.hslToHex(rs.hue + 20, 80, 70), e.alpha * 0.6);\n      g.fillCircle(e.x, e.y, e.size);\n      g.fillStyle(this.hslToHex(rs.hue, 90, 85), e.alpha * 0.3);\n      g.fillCircle(e.x, e.y, e.size * 0.5);\n    }\n\n    for (let i = 0; i < rs.trail.length; i++) {\n      const t = rs.trail[i];\n      const trailSize = 5 * (1 - i / rs.trail.length);\n      g.fillStyle(this.hslToHex(rs.hue, 80, 55), t.alpha * 0.4);\n      g.fillCircle(t.x, t.y, trailSize * 2);\n      g.fillStyle(this.hslToHex(rs.hue + 30, 70, 70), t.alpha * 0.2);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    g.lineStyle(14, this.hslToHex(rs.hue, 70, 40), 0.2 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    g.lineStyle(8, this.hslToHex(rs.hue, 80, 55), 0.35 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    for (let i = rs.segments.length - 1; i >= 0; i--) {\n      const seg = rs.segments[i];\n      const t = rs.segments.length > 1 ? i / (rs.segments.length - 1) : 1;\n      const segmentPulse = pulse * (0.8 + Math.sin(rs.pulsePhase + i * 0.4) * 0.2);\n\n      const baseSize = 7 + t * 5;\n      const size = baseSize * (0.9 + segmentPulse * 0.15);\n\n      g.fillStyle(this.hslToHex(rs.hue - 10, 60, 35), 0.15 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 2.8);\n\n      g.fillStyle(this.hslToHex(rs.hue, 75, 50), 0.3 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 1.6);\n\n      g.fillStyle(this.hslToHex(rs.hue + 10, 85, 65), 0.6 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size);\n\n      g.fillStyle(this.hslToHex(rs.hue + 40, 60, 90), 0.5 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 0.35);\n\n      if (i === 0) {\n        const dx = rs.direction.dx;\n        const dy = rs.direction.dy;\n        const perpX = -dy;\n        const perpY = dx;\n\n        g.fillStyle(this.hslToHex(rs.hue, 90, 70), 0.3);\n        g.fillCircle(seg.x - dx * 3, seg.y - dy * 3, size * 1.8);\n\n        const eyeOffset = 4;\n        const eyeForward = 5;\n        const leftEyeX = seg.x + perpX * eyeOffset + dx * eyeForward;\n        const leftEyeY = seg.y + perpY * eyeOffset + dy * eyeForward;\n        const rightEyeX = seg.x - perpX * eyeOffset + dx * eyeForward;\n        const rightEyeY = seg.y - perpY * eyeOffset + dy * eyeForward;\n\n        const eyeColor = rs.state === 'hunting' ? 0xff4444 :\n                         rs.state === 'fleeing' ? 0xffff44 : 0x44ffff;\n\n        g.fillStyle(0x000000, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 4);\n        g.fillCircle(rightEyeX, rightEyeY, 4);\n\n        g.fillStyle(eyeColor, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 3);\n        g.fillCircle(rightEyeX, rightEyeY, 3);\n\n        g.fillStyle(0xffffff, 0.95 * segmentPulse);\n        g.fillCircle(leftEyeX + dx, leftEyeY + dy, 1.2);\n        g.fillCircle(rightEyeX + dx, rightEyeY + dy, 1.2);\n\n        const hornLength = 8;\n        const hornAngle = 0.4;\n        g.lineStyle(3, this.hslToHex(rs.hue - 20, 70, 45), 0.8 * segmentPulse);\n        g.beginPath();\n        g.moveTo(seg.x + perpX * 5, seg.y + perpY * 5);\n        g.lineTo(\n          seg.x + perpX * 5 + Math.cos(Math.atan2(dy, dx) - hornAngle) * hornLength,\n          seg.y + perpY * 5 + Math.sin(Math.atan2(dy, dx) - hornAngle) * hornLength\n        );\n        g.strokePath();\n        g.beginPath();\n        g.moveTo(seg.x - perpX * 5, seg.y - perpY * 5);\n        g.lineTo(\n          seg.x - perpX * 5 + Math.cos(Math.atan2(dy, dx) + hornAngle) * hornLength,\n          seg.y - perpY * 5 + Math.sin(Math.atan2(dy, dx) + hornAngle) * hornLength\n        );\n        g.strokePath();\n      }\n    }\n  }\n\n  private drawElectricArc(g: Phaser.GameObjects.Graphics, x1: number, y1: number, x2: number, y2: number, life: number): void {\n    const segments = 6;\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n    const jitter = 15 * life;\n\n    g.lineStyle(4, 0x00ffff, 0.2 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter;\n      const jy = (Math.random() - 0.5) * jitter;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(2, 0x88ffff, 0.5 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter * 0.5;\n      const jy = (Math.random() - 0.5) * jitter * 0.5;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(1, 0xffffff, 0.8 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    g.lineTo(x2, y2);\n    g.strokePath();\n  }\n\n  private spawnBee(): void {\n    if (this.bees.length >= NUM_BEES) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Spawn from random edge\n    const edge = Math.floor(Math.random() * 4);\n    let x: number, y: number;\n\n    switch (edge) {\n      case 0: // top\n        x = Math.random() * width;\n        y = -20;\n        break;\n      case 1: // right\n        x = width + 20;\n        y = Math.random() * height;\n        break;\n      case 2: // bottom\n        x = Math.random() * width;\n        y = height + 20;\n        break;\n      default: // left\n        x = -20;\n        y = Math.random() * height;\n        break;\n    }\n\n    // Random target inside the play area\n    const targetX = 50 + Math.random() * (width - 100);\n    const targetY = 50 + Math.random() * (height - 100);\n\n    this.bees.push({\n      x,\n      y,\n      vx: 0,\n      vy: 0,\n      targetX,\n      targetY,\n      wingPhase: Math.random() * Math.PI * 2,\n      wingSpeed: 0.4 + Math.random() * 0.2,\n      size: 6 + Math.random() * 3,\n      hue: 0 + Math.random() * 20, // Crimson/red volcanic color\n      glowIntensity: 0.5 + Math.random() * 0.5,\n      bobPhase: Math.random() * Math.PI * 2,\n      bobSpeed: 0.08 + Math.random() * 0.04,\n      trail: [],\n      state: 'flying',\n      sparkleTimer: 0,\n    });\n  }\n\n  private updateBees(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n    const gameOver = this.currentState.gameOver;\n\n    // Randomly spawn new bees\n    if (!gameOver && Math.random() < BEE_SPAWN_CHANCE && this.bees.length < NUM_BEES) {\n      this.spawnBee();\n    }\n\n    for (let i = this.bees.length - 1; i >= 0; i--) {\n      const bee = this.bees[i];\n\n      // Update wing animation\n      bee.wingPhase += bee.wingSpeed;\n      bee.bobPhase += bee.bobSpeed;\n      bee.sparkleTimer += 0.1;\n\n      // Store trail position\n      if (this.frameCount % 2 === 0) {\n        bee.trail.unshift({ x: bee.x, y: bee.y, alpha: 0.6 });\n        if (bee.trail.length > 8) bee.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of bee.trail) {\n        t.alpha *= 0.85;\n      }\n      bee.trail = bee.trail.filter(t => t.alpha > 0.05);\n\n      // Bees are attracted to food\n      const dxFood = foodX - bee.x;\n      const dyFood = foodY - bee.y;\n      const distFood = Math.sqrt(dxFood * dxFood + dyFood * dyFood);\n\n      // Determine behavior based on distance to food\n      if (distFood < 80) {\n        bee.state = 'attracted';\n        bee.targetX = foodX + Math.cos(bee.bobPhase * 3) * 30;\n        bee.targetY = foodY + Math.sin(bee.bobPhase * 3) * 30;\n      } else if (distFood < 150) {\n        bee.state = 'hovering';\n        // Circle around food loosely\n        const angle = Math.atan2(dyFood, dxFood) + Math.sin(bee.bobPhase) * 0.5;\n        bee.targetX = foodX - Math.cos(angle) * 60;\n        bee.targetY = foodY - Math.sin(angle) * 60;\n      } else {\n        bee.state = 'flying';\n        // Wander towards food with some randomness\n        if (Math.random() < 0.02) {\n          bee.targetX = foodX + (Math.random() - 0.5) * 200;\n          bee.targetY = foodY + (Math.random() - 0.5) * 200;\n        }\n      }\n\n      // Move towards target with smooth steering\n      const dx = bee.targetX - bee.x;\n      const dy = bee.targetY - bee.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 1) {\n        const speed = bee.state === 'attracted' ? 2.5 : (bee.state === 'hovering' ? 1.5 : 2);\n        const ax = (dx / dist) * speed * 0.1;\n        const ay = (dy / dist) * speed * 0.1;\n\n        bee.vx += ax;\n        bee.vy += ay;\n\n        // Add bobbing motion\n        bee.vy += Math.sin(bee.bobPhase) * 0.05;\n      }\n\n      // Limit velocity\n      const maxSpeed = bee.state === 'attracted' ? 3 : 2;\n      const currentSpeed = Math.sqrt(bee.vx * bee.vx + bee.vy * bee.vy);\n      if (currentSpeed > maxSpeed) {\n        bee.vx = (bee.vx / currentSpeed) * maxSpeed;\n        bee.vy = (bee.vy / currentSpeed) * maxSpeed;\n      }\n\n      // Apply velocity with damping\n      bee.x += bee.vx;\n      bee.y += bee.vy;\n      bee.vx *= 0.95;\n      bee.vy *= 0.95;\n\n      // Pulsing glow when near food\n      if (bee.state === 'attracted') {\n        bee.glowIntensity = 0.7 + Math.sin(bee.bobPhase * 4) * 0.3;\n      } else {\n        bee.glowIntensity = 0.5 + Math.sin(bee.bobPhase * 2) * 0.2;\n      }\n\n      // Remove bees that fly too far off screen\n      if (bee.x < -100 || bee.x > width + 100 || bee.y < -100 || bee.y > height + 100) {\n        this.bees.splice(i, 1);\n      }\n\n      // Scatter bees on game over\n      if (gameOver) {\n        bee.targetX = bee.x + (Math.random() - 0.5) * 400;\n        bee.targetY = bee.y - 200 - Math.random() * 200;\n        bee.vx += (Math.random() - 0.5) * 2;\n        bee.vy -= 1 + Math.random();\n      }\n    }\n  }\n\n  private drawBees(g: Phaser.GameObjects.Graphics): void {\n    for (const bee of this.bees) {\n      const { x, y, size, wingPhase, hue, glowIntensity, trail, state, sparkleTimer } = bee;\n\n      // Draw trail\n      for (let i = 0; i < trail.length; i++) {\n        const t = trail[i];\n        const trailSize = size * 0.4 * (1 - i / trail.length);\n        g.fillStyle(this.hslToHex(hue, 80, 60), t.alpha * 0.4);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      const glowSize = size * 2 * glowIntensity;\n      g.fillStyle(this.hslToHex(hue, 90, 50), 0.2 * glowIntensity);\n      g.fillCircle(x, y, glowSize);\n\n      // Mid glow\n      g.fillStyle(this.hslToHex(hue, 85, 60), 0.3 * glowIntensity);\n      g.fillCircle(x, y, glowSize * 0.6);\n\n      // Bee body - striped pattern\n      const bodyLength = size * 1.2;\n      const bodyWidth = size * 0.7;\n\n      // Body shadow/glow\n      g.fillStyle(this.hslToHex(hue, 70, 30), 0.5);\n      g.fillEllipse(x, y, bodyLength + 2, bodyWidth + 2);\n\n      // Main body (amber/golden)\n      g.fillStyle(this.hslToHex(hue, 90, 55), 1);\n      g.fillEllipse(x, y, bodyLength, bodyWidth);\n\n      // Dark stripes\n      g.fillStyle(0x1a1a1a, 0.8);\n      g.fillRect(x - bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n      g.fillRect(x + bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n\n      // Head\n      g.fillStyle(this.hslToHex(hue - 10, 80, 40), 1);\n      g.fillCircle(x - bodyLength * 0.4, y, size * 0.4);\n\n      // Wings - animated flutter\n      const wingAngle = Math.sin(wingPhase) * 0.8;\n      const wingSize = size * 0.9;\n\n      // Wing glow (ethereal effect)\n      g.fillStyle(0xffffff, 0.2 + Math.abs(Math.sin(wingPhase)) * 0.2);\n      g.fillEllipse(x + Math.cos(wingAngle + 0.5) * wingSize * 0.3, y - wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n      g.fillEllipse(x + Math.cos(-wingAngle + 0.5) * wingSize * 0.3, y + wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n\n      // Wing bodies\n      g.fillStyle(0xffffff, 0.5 + Math.abs(Math.sin(wingPhase)) * 0.3);\n      g.fillEllipse(x + Math.cos(wingAngle) * wingSize * 0.2, y - wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n      g.fillEllipse(x + Math.cos(-wingAngle) * wingSize * 0.2, y + wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n\n      // Eyes\n      g.fillStyle(0x000000, 1);\n      g.fillCircle(x - bodyLength * 0.45, y - size * 0.12, size * 0.12);\n      g.fillCircle(x - bodyLength * 0.45, y + size * 0.12, size * 0.12);\n\n      // Sparkles when attracted to food\n      if (state === 'attracted' && Math.sin(sparkleTimer * 3) > 0.7) {\n        const sparkleAngle = sparkleTimer * 2;\n        const sparkleDist = size * 1.5;\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n\n        g.fillStyle(0xffffff, 0.8);\n        g.fillCircle(sparkleX, sparkleY, 2);\n        g.fillStyle(this.hslToHex(hue, 100, 80), 0.6);\n        g.fillCircle(sparkleX, sparkleY, 3);\n      }\n    }\n  }\n\n  // Helper to convert HSL to hex for Phaser\n  private hslToHex(h: number, s: number, l: number): number {\n    h = h / 360;\n    s = s / 100;\n    l = l / 100;\n\n    let r: number, g: number, b: number;\n\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    return (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255);\n  }\n\n  private updateGuardianSpirits(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const gameOver = this.currentState.gameOver;\n    const snakeHead = this.currentState.snake.length > 0 ? this.currentState.snake[0] : null;\n\n    for (const spirit of this.guardianSpirits) {\n      spirit.phase += spirit.speed;\n      spirit.haloPhase += 0.04;\n      spirit.orbPhase += 0.02;\n\n      for (const orb of spirit.orbs) {\n        orb.angle += orb.speed;\n      }\n\n      const floatAmount = gameOver ? 20 : 12;\n      const waveAmount = 5;\n      const wave = Math.sin(spirit.phase) * waveAmount;\n\n      let targetX = spirit.baseX;\n      let targetY = spirit.baseY;\n\n      switch (spirit.edge) {\n        case 'top':\n          targetY = spirit.baseY + floatAmount + wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'bottom':\n          targetY = spirit.baseY - floatAmount - wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'left':\n          targetX = spirit.baseX + floatAmount + wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'right':\n          targetX = spirit.baseX - floatAmount - wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n      }\n\n      if (snakeHead && !gameOver) {\n        const headX = snakeHead.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = snakeHead.y * CELL_SIZE + CELL_SIZE / 2;\n        const dx = spirit.x - headX;\n        const dy = spirit.y - headY;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        if (dist < 120) {\n          const attraction = (120 - dist) / 120 * 15;\n          targetX += (dx / dist) * attraction;\n          targetY += (dy / dist) * attraction;\n        }\n      }\n\n      spirit.x += (targetX - spirit.x) * 0.04;\n      spirit.y += (targetY - spirit.y) * 0.04;\n      spirit.x = Math.max(-50, Math.min(width + 50, spirit.x));\n      spirit.y = Math.max(-50, Math.min(height + 50, spirit.y));\n\n      const baseAlpha = gameOver ? 0.8 : spirit.targetAlpha;\n      spirit.currentAlpha += (baseAlpha - spirit.currentAlpha) * 0.05;\n    }\n  }\n\n  private drawGuardianSpirits(g: Phaser.GameObjects.Graphics): void {\n    for (const spirit of this.guardianSpirits) {\n      if (spirit.currentAlpha < 0.01) continue;\n\n      const { x, y, size, phase, haloPhase, currentAlpha, hue, orbs } = spirit;\n      const breathPulse = 1 + Math.sin(phase * 2) * 0.15;\n      const coreSize = size * breathPulse;\n\n      const spiritColor = this.hslToHex(hue, 0.7, 0.6);\n      const glowColor = this.hslToHex(hue, 0.5, 0.8);\n      const haloColor = this.hslToHex(hue, 0.3, 0.9);\n\n      g.fillStyle(glowColor, currentAlpha * 0.1);\n      g.fillCircle(x, y, coreSize * 2.5);\n\n      g.fillStyle(glowColor, currentAlpha * 0.15);\n      g.fillCircle(x, y, coreSize * 1.8);\n\n      const haloRadius = coreSize * 1.4 + Math.sin(haloPhase) * 3;\n      g.lineStyle(2, haloColor, currentAlpha * 0.4);\n      g.strokeCircle(x, y, haloRadius);\n\n      const innerHaloRadius = coreSize * 1.1 + Math.sin(haloPhase + 1) * 2;\n      g.lineStyle(1.5, haloColor, currentAlpha * 0.3);\n      g.strokeCircle(x, y, innerHaloRadius);\n\n      for (const orb of orbs) {\n        const orbX = x + Math.cos(orb.angle) * orb.distance;\n        const orbY = y + Math.sin(orb.angle) * orb.distance;\n        const orbPulse = 1 + Math.sin(phase + orb.angle) * 0.3;\n\n        g.fillStyle(glowColor, currentAlpha * 0.3);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse * 1.5);\n\n        g.fillStyle(spiritColor, currentAlpha * 0.8);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse);\n      }\n\n      g.fillStyle(spiritColor, currentAlpha * 0.9);\n      g.fillCircle(x, y, coreSize * 0.5);\n\n      g.fillStyle(0xffffff, currentAlpha * 0.7);\n      g.fillCircle(x, y, coreSize * 0.25);\n\n      const sparkleCount = 4;\n      for (let i = 0; i < sparkleCount; i++) {\n        const sparkleAngle = (i / sparkleCount) * Math.PI * 2 + phase * 0.5;\n        const sparkleDist = coreSize * (0.8 + Math.sin(phase * 2 + i) * 0.3);\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n        const sparkleSize = 1.5 + Math.sin(phase * 3 + i * 2) * 0.5;\n\n        g.fillStyle(0xffffff, currentAlpha * (0.4 + Math.sin(phase * 2 + i) * 0.3));\n        g.fillCircle(sparkleX, sparkleY, sparkleSize);\n      }\n    }\n  }\n\n  private initStars(): void {\n    this.stars = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_STARS; i++) {\n      this.stars.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: 0.5 + Math.random() * 1.5,\n        speed: 0.02 + Math.random() * 0.03,\n        brightness: 0.3 + Math.random() * 0.7,\n      });\n    }\n  }\n\n  private initPlasmaWaves(): void {\n    this.plasmaWaves = [];\n    const hues = [0, 15, 30]; // Red/orange volcanic variations\n    for (let i = 0; i < NUM_PLASMA_WAVES; i++) {\n      this.plasmaWaves.push({\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.015 + Math.random() * 0.01,\n        amplitude: 30 + Math.random() * 20,\n        wavelength: 80 + Math.random() * 40,\n        hue: hues[i % hues.length],\n      });\n    }\n  }\n\n  private initAuroraWaves(): void {\n    this.auroraWaves = [];\n    const height = GRID_SIZE * CELL_SIZE;\n    // Aurora hues: volcanic reds, oranges, crimsons\n    const auroraHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_AURORA_WAVES; i++) {\n      this.auroraWaves.push({\n        y: height * 0.2 + (height * 0.6 * i) / NUM_AURORA_WAVES,\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.008 + Math.random() * 0.006,\n        hue: auroraHues[i % auroraHues.length],\n        thickness: 25 + Math.random() * 20,\n        amplitude: 15 + Math.random() * 25,\n      });\n    }\n  }\n\n  private initNebulaClouds(): void {\n    this.nebulaClouds = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    // Volcanic smoke and lava glow colors: reds, oranges, crimsons\n    const nebulaHues = [0, 10, 20, 30, 350, 340];\n    for (let i = 0; i < NUM_NEBULA_CLOUDS; i++) {\n      this.nebulaClouds.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        radius: 40 + Math.random() * 60,\n        hue: nebulaHues[i % nebulaHues.length],\n        alpha: 0.04 + Math.random() * 0.04,\n        driftX: (Math.random() - 0.5) * 0.15,\n        driftY: (Math.random() - 0.5) * 0.15,\n        pulsePhase: Math.random() * Math.PI * 2,\n        pulseSpeed: 0.01 + Math.random() * 0.01,\n      });\n    }\n  }\n\n  private initVortex(): void {\n    this.vortexRings = [];\n    this.vortexParticles = [];\n\n    // Create concentric rings with different properties\n    const ringHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_VORTEX_RINGS; i++) {\n      const baseRadius = 25 + i * 18;\n      this.vortexRings.push({\n        radius: baseRadius,\n        baseRadius,\n        rotationOffset: (i * Math.PI * 2) / NUM_VORTEX_RINGS,\n        rotationSpeed: 0.02 - i * 0.003,\n        thickness: 2 + (NUM_VORTEX_RINGS - i) * 0.5,\n        hue: ringHues[i % ringHues.length],\n        pulsePhase: i * 0.5,\n      });\n    }\n\n    // Create orbiting particles\n    for (let i = 0; i < NUM_VORTEX_PARTICLES; i++) {\n      const baseRadius = 20 + Math.random() * 80;\n      this.vortexParticles.push({\n        angle: Math.random() * Math.PI * 2,\n        radius: baseRadius,\n        baseRadius,\n        speed: 0.02 + Math.random() * 0.03,\n        size: 1 + Math.random() * 2,\n        hue: Math.random() * 360,\n        alpha: 0.3 + Math.random() * 0.5,\n      });\n    }\n  }\n\n  private initMeteors(): void {\n    this.meteors = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_METEORS; i++) {\n      this.spawnMeteor(width, height, true);\n    }\n  }\n\n  private spawnMeteor(width: number, height: number, initial = false): void {\n    if (this.meteors.length >= NUM_METEORS) return;\n\n    // Meteors come from top-right and travel to bottom-left\n    const startX = initial ? Math.random() * width * 1.5 : width + 20 + Math.random() * 40;\n    const startY = initial ? Math.random() * height * 0.5 - height * 0.25 : -20 - Math.random() * 40;\n\n    // Random angle variation (mostly diagonal)\n    const angle = Math.PI * 0.65 + (Math.random() - 0.5) * 0.4;\n    const speed = 1.5 + Math.random() * 2;\n\n    this.meteors.push({\n      x: startX,\n      y: startY,\n      vx: -Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed,\n      size: 2 + Math.random() * 3,\n      hue: Math.random() < 0.3 ? 0 + Math.random() * 30 : 20 + Math.random() * 40, // Red or orange volcanic\n      alpha: 0.6 + Math.random() * 0.4,\n      trail: [],\n      life: 1,\n    });\n  }\n\n  private updateMeteors(width: number, height: number): void {\n    for (let i = this.meteors.length - 1; i >= 0; i--) {\n      const m = this.meteors[i];\n\n      // Store trail position\n      m.trail.unshift({ x: m.x, y: m.y, alpha: m.alpha });\n      if (m.trail.length > 12) m.trail.pop();\n\n      // Update position\n      m.x += m.vx;\n      m.y += m.vy;\n\n      // Check if meteor is out of bounds\n      if (m.x < -50 || m.y > height + 50) {\n        this.meteors.splice(i, 1);\n        // Spawn a new one\n        this.spawnMeteor(width, height, false);\n      }\n    }\n  }\n\n  private spawnDeathExplosion(): void {\n    if (!this.currentState) return;\n\n    this.deathDebris = [];\n    this.deathExplosionPhase = 1;\n\n    // Spawn debris from each snake segment\n    for (let i = 0; i < this.currentState.snake.length; i++) {\n      const seg = this.currentState.snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const segHue = (this.hueOffset + i * 15) % 360;\n\n      // Create debris particles per segment (limit total)\n      const debrisPerSeg = Math.min(3, Math.floor(MAX_DEATH_DEBRIS / this.currentState.snake.length));\n      for (let j = 0; j < debrisPerSeg; j++) {\n        if (this.deathDebris.length >= MAX_DEATH_DEBRIS) break;\n\n        const angle = Math.random() * Math.PI * 2;\n        const speed = 2 + Math.random() * 4;\n        const types: ('shard' | 'spark' | 'ember')[] = ['shard', 'spark', 'ember'];\n\n        this.deathDebris.push({\n          x: cx + (Math.random() - 0.5) * 8,\n          y: cy + (Math.random() - 0.5) * 8,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed - 1,\n          size: 3 + Math.random() * 5,\n          hue: segHue + (Math.random() - 0.5) * 40,\n          rotation: Math.random() * Math.PI * 2,\n          rotationSpeed: (Math.random() - 0.5) * 0.4,\n          life: 1,\n          type: types[Math.floor(Math.random() * types.length)],\n        });\n      }\n    }\n  }\n\n  private updateDeathDebris(): void {\n    // Decay explosion phase\n    if (this.deathExplosionPhase > 0) {\n      this.deathExplosionPhase *= 0.95;\n      if (this.deathExplosionPhase < 0.01) this.deathExplosionPhase = 0;\n    }\n\n    for (let i = this.deathDebris.length - 1; i >= 0; i--) {\n      const d = this.deathDebris[i];\n\n      // Update position with gravity\n      d.x += d.vx;\n      d.y += d.vy;\n      d.vy += 0.08; // gravity\n      d.vx *= 0.99; // air resistance\n\n      // Update rotation\n      d.rotation += d.rotationSpeed;\n\n      // Decay life\n      d.life -= 0.015;\n\n      if (d.life <= 0) {\n        this.deathDebris.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnFoodParticles(foodX: number, foodY: number): void {\n    if (this.foodParticles.length < MAX_FOOD_PARTICLES && Math.random() < 0.15) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.3 + Math.random() * 0.5;\n      this.foodParticles.push({\n        x: foodX,\n        y: foodY,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 0.5,\n        life: 1,\n        maxLife: 40 + Math.random() * 20,\n        size: 1 + Math.random() * 2,\n      });\n    }\n  }\n\n  private updateParticles(): void {\n    for (let i = this.foodParticles.length - 1; i >= 0; i--) {\n      const p = this.foodParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy += 0.02;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.foodParticles.splice(i, 1);\n      }\n    }\n    // Update trail particles\n    for (let i = this.trailParticles.length - 1; i >= 0; i--) {\n      const p = this.trailParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.trailParticles.splice(i, 1);\n      }\n    }\n    // Update shockwaves\n    for (let i = this.shockWaves.length - 1; i >= 0; i--) {\n      const sw = this.shockWaves[i];\n      sw.radius += 3;\n      sw.life -= 0.04;\n      if (sw.life <= 0 || sw.radius >= sw.maxRadius) {\n        this.shockWaves.splice(i, 1);\n      }\n    }\n    // Update lightning bolts\n    for (let i = this.lightningBolts.length - 1; i >= 0; i--) {\n      const bolt = this.lightningBolts[i];\n      bolt.life -= 1 / bolt.maxLife;\n      if (bolt.life <= 0) {\n        this.lightningBolts.splice(i, 1);\n      }\n    }\n    // Update afterimages\n    for (let i = this.snakeAfterimages.length - 1; i >= 0; i--) {\n      const ai = this.snakeAfterimages[i];\n      ai.life -= 1 / ai.maxLife;\n      if (ai.life <= 0) {\n        this.snakeAfterimages.splice(i, 1);\n      }\n    }\n    // Decay screen flash\n    if (this.screenFlashAlpha > 0) {\n      this.screenFlashAlpha -= 0.08;\n      if (this.screenFlashAlpha < 0) this.screenFlashAlpha = 0;\n    }\n\n    // Update screen shake\n    if (this.screenShakeIntensity > 0) {\n      this.screenShakeX = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeY = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeIntensity *= 0.9;\n      if (this.screenShakeIntensity < 0.5) {\n        this.screenShakeIntensity = 0;\n        this.screenShakeX = 0;\n        this.screenShakeY = 0;\n      }\n    }\n\n    // Decay chromatic aberration\n    if (this.chromaticIntensity > 0) {\n      this.chromaticIntensity *= 0.92;\n      if (this.chromaticIntensity < 0.05) this.chromaticIntensity = 0;\n    }\n\n    // Decay energy field pulse\n    if (this.energyFieldPulse > 0) {\n      this.energyFieldPulse *= 0.95;\n      if (this.energyFieldPulse < 0.05) this.energyFieldPulse = 0;\n    }\n\n    // Update food burst particles\n    for (let i = this.foodBurstParticles.length - 1; i >= 0; i--) {\n      const p = this.foodBurstParticles[i];\n      // Store trail position\n      p.trail.unshift({ x: p.x, y: p.y });\n      if (p.trail.length > 6) p.trail.pop();\n      // Update position\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vx *= 0.96;\n      p.vy *= 0.96;\n      p.life -= 0.025;\n      if (p.life <= 0) {\n        this.foodBurstParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnTrailParticles(x: number, y: number): void {\n    if (this.trailParticles.length >= MAX_TRAIL_PARTICLES) return;\n    // Spawn 2-3 particles per movement\n    const count = 2 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < count; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.2 + Math.random() * 0.4;\n      this.trailParticles.push({\n        x: x + (Math.random() - 0.5) * 8,\n        y: y + (Math.random() - 0.5) * 8,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        maxLife: 25 + Math.random() * 15,\n        size: 2 + Math.random() * 3,\n        hue: this.hueOffset + Math.random() * 30,\n      });\n    }\n  }\n\n  updateGameState(state: GameState): void {\n    // Detect food eaten - snake got longer\n    if (this.currentState && state.snake.length > this.lastSnakeLength) {\n      const head = state.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n      this.spawnShockWave(headX, headY);\n      this.spawnLightningBurst(headX, headY);\n      this.spawnFoodBurst(headX, headY);\n      this.spawnChaosExplosion(headX, headY); // Armageddon chaos explosion\n      this.screenFlashAlpha = 0.8; // More intense flash for armageddon\n      this.chromaticIntensity = 1.5; // Stronger chromatic aberration\n      this.energyFieldPulse = 1.0; // Trigger energy field expansion\n    }\n    this.lastSnakeLength = state.snake.length;\n\n    // Detect food position change - trigger thrown food animation\n    const newFood = state.food;\n    if (this.lastFoodPos && (newFood.x !== this.lastFoodPos.x || newFood.y !== this.lastFoodPos.y)) {\n      this.spawnThrownFood(newFood.x, newFood.y);\n    } else if (!this.lastFoodPos && !state.gameOver) {\n      // First food spawn\n      this.spawnThrownFood(newFood.x, newFood.y);\n    }\n    this.lastFoodPos = { x: newFood.x, y: newFood.y };\n\n    // Create afterimage when snake moves\n    if (this.currentState && state.snake.length > 0) {\n      const oldHead = this.currentState.snake[0];\n      const newHead = state.snake[0];\n      if (oldHead && newHead && (oldHead.x !== newHead.x || oldHead.y !== newHead.y)) {\n        this.spawnAfterimage(this.currentState.snake);\n      }\n    }\n\n    // Detect game over transition - ARMAGEDDON CHAOS death sequence\n    if (state.gameOver && this.currentState && !this.currentState.gameOver) {\n      this.screenShakeIntensity = 25; // Massive screen shake on death\n      this.chromaticIntensity = 3.0; // Maximum chromatic aberration on death\n      this.chaosIntensity = 1.0; // Full chaos overlay\n      this.spawnDeathExplosion(); // Dramatic death explosion\n      // Spawn chaos explosions across the snake body\n      for (let i = 0; i < Math.min(3, state.snake.length); i++) {\n        const seg = state.snake[Math.floor(i * state.snake.length / 3)];\n        setTimeout(() => {\n          this.spawnChaosExplosion(\n            seg.x * CELL_SIZE + CELL_SIZE / 2,\n            seg.y * CELL_SIZE + CELL_SIZE / 2\n          );\n        }, i * 50);\n      }\n    }\n\n    this.currentState = state;\n    this.needsRedraw = true;\n    if (!state.gameOver) {\n      this.gameOverAlpha = 0;\n      this.gameOverGlitchOffset = 0;\n      this.screenShakeIntensity = 0;\n    }\n  }\n\n  private spawnShockWave(x: number, y: number): void {\n    if (this.shockWaves.length >= MAX_SHOCKWAVES) {\n      this.shockWaves.shift();\n    }\n    this.shockWaves.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: CELL_SIZE * 3,\n      life: 1,\n    });\n  }\n\n  private spawnAfterimage(snake: Position[]): void {\n    if (this.snakeAfterimages.length >= MAX_AFTERIMAGES) {\n      this.snakeAfterimages.shift();\n    }\n    this.snakeAfterimages.push({\n      segments: snake.map(s => ({ x: s.x, y: s.y })),\n      life: 1,\n      maxLife: 12,\n      hueOffset: this.hueOffset,\n    });\n  }\n\n  private spawnLightningBurst(x: number, y: number): void {\n    const numBolts = 3 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < numBolts; i++) {\n      if (this.lightningBolts.length >= MAX_LIGHTNING_BOLTS) {\n        this.lightningBolts.shift();\n      }\n      const angle = (Math.PI * 2 * i) / numBolts + Math.random() * 0.5;\n      const length = 30 + Math.random() * 40;\n      const endX = x + Math.cos(angle) * length;\n      const endY = y + Math.sin(angle) * length;\n      this.lightningBolts.push({\n        points: this.generateLightningPath(x, y, endX, endY),\n        life: 1,\n        maxLife: 15 + Math.random() * 10,\n        hue: this.hueOffset + Math.random() * 60,\n      });\n    }\n  }\n\n  private generateLightningPath(x1: number, y1: number, x2: number, y2: number): { x: number; y: number }[] {\n    const points: { x: number; y: number }[] = [{ x: x1, y: y1 }];\n    const segments = 4 + Math.floor(Math.random() * 3);\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n\n    for (let i = 1; i < segments; i++) {\n      const jitter = 8;\n      points.push({\n        x: x1 + dx * i + (Math.random() - 0.5) * jitter,\n        y: y1 + dy * i + (Math.random() - 0.5) * jitter,\n      });\n    }\n    points.push({ x: x2, y: y2 });\n    return points;\n  }\n\n  private spawnFoodBurst(x: number, y: number): void {\n    // Clear old particles and spawn new dramatic burst\n    this.foodBurstParticles = [];\n    const numParticles = MAX_BURST_PARTICLES;\n    for (let i = 0; i < numParticles; i++) {\n      const angle = (i / numParticles) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 4;\n      this.foodBurstParticles.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        size: 3 + Math.random() * 4,\n        hue: this.hueOffset + Math.random() * 60,\n        trail: [],\n      });\n    }\n  }\n\n  private spawnThrownFood(targetGridX: number, targetGridY: number): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const targetX = targetGridX * CELL_SIZE + CELL_SIZE / 2;\n    const targetY = targetGridY * CELL_SIZE + CELL_SIZE / 2;\n\n    // Choose random edge to throw from\n    const edge = Math.floor(Math.random() * 4);\n    let startX: number, startY: number;\n\n    switch (edge) {\n      case 0: // top\n        startX = Math.random() * width;\n        startY = -40;\n        break;\n      case 1: // right\n        startX = width + 40;\n        startY = Math.random() * height;\n        break;\n      case 2: // bottom\n        startX = Math.random() * width;\n        startY = height + 40;\n        break;\n      default: // left\n        startX = -40;\n        startY = Math.random() * height;\n        break;\n    }\n\n    this.thrownFood = {\n      startX,\n      startY,\n      targetX,\n      targetY,\n      x: startX,\n      y: startY,\n      progress: 0,\n      rotation: 0,\n      rotationSpeed: (Math.random() - 0.5) * 0.6,\n      trail: [],\n      landed: false,\n      landingParticles: [],\n      impactRings: [],\n    };\n  }\n\n  private updateThrownFood(): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    if (!tf.landed) {\n      // Update progress\n      tf.progress += 0.04;\n\n      // Store trail\n      if (this.frameCount % 2 === 0) {\n        tf.trail.unshift({ x: tf.x, y: tf.y, alpha: 1, rotation: tf.rotation });\n        if (tf.trail.length > 12) tf.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.85;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Calculate position with parabolic arc\n      const t = tf.progress;\n      const arcHeight = 80;\n      const arc = 4 * arcHeight * t * (1 - t);\n      tf.x = tf.startX + (tf.targetX - tf.startX) * t;\n      tf.y = tf.startY + (tf.targetY - tf.startY) * t - arc;\n\n      // Rotation\n      tf.rotation += tf.rotationSpeed;\n\n      // Check if landed\n      if (tf.progress >= 1) {\n        tf.landed = true;\n        tf.x = tf.targetX;\n        tf.y = tf.targetY;\n\n        // Spawn landing effects\n        this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 6);\n\n        // Impact rings\n        tf.impactRings = [\n          { radius: 5, alpha: 1 },\n          { radius: 3, alpha: 0.8 },\n        ];\n\n        // Landing particles\n        for (let i = 0; i < 10; i++) {\n          const angle = (i / 10) * Math.PI * 2 + Math.random() * 0.3;\n          const speed = 2 + Math.random() * 3;\n          tf.landingParticles.push({\n            x: tf.targetX,\n            y: tf.targetY,\n            vx: Math.cos(angle) * speed,\n            vy: Math.sin(angle) * speed - 1,\n            life: 1,\n            size: 2 + Math.random() * 3,\n          });\n        }\n      }\n    } else {\n      // Update landing effects\n      for (const ring of tf.impactRings) {\n        ring.radius += 3;\n        ring.alpha *= 0.9;\n      }\n      tf.impactRings = tf.impactRings.filter(r => r.alpha > 0.05);\n\n      for (let i = tf.landingParticles.length - 1; i >= 0; i--) {\n        const p = tf.landingParticles[i];\n        p.x += p.vx;\n        p.y += p.vy;\n        p.vy += 0.15;\n        p.vx *= 0.98;\n        p.life -= 0.04;\n        if (p.life <= 0) {\n          tf.landingParticles.splice(i, 1);\n        }\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.8;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Clear thrown food when effects are done\n      if (tf.impactRings.length === 0 && tf.landingParticles.length === 0 && tf.trail.length === 0) {\n        this.thrownFood = null;\n      }\n    }\n  }\n\n  private drawThrownFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    // Draw trail\n    for (let i = 0; i < tf.trail.length; i++) {\n      const t = tf.trail[i];\n      const trailProgress = i / tf.trail.length;\n      const trailSize = (CELL_SIZE / 2) * (1 - trailProgress * 0.5) * t.alpha;\n\n      // Trail glow\n      g.fillStyle(COLORS.foodGlow, t.alpha * 0.3);\n      g.fillCircle(t.x, t.y, trailSize * 1.5);\n\n      // Trail core\n      g.fillStyle(COLORS.food, t.alpha * 0.6);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    // Draw impact rings\n    for (const ring of tf.impactRings) {\n      g.lineStyle(3, COLORS.foodGlow, ring.alpha * 0.5);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n      g.lineStyle(1.5, COLORS.noirWhite, ring.alpha * 0.7);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n    }\n\n    // Draw landing particles\n    for (const p of tf.landingParticles) {\n      g.fillStyle(COLORS.foodGlow, p.life * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Draw the flying food if not landed\n    if (!tf.landed) {\n      const scale = 0.8 + tf.progress * 0.4;\n      const foodSize = (CELL_SIZE / 2) * scale;\n\n      // Motion blur glow\n      g.fillStyle(COLORS.foodGlow, 0.3);\n      g.fillCircle(tf.x, tf.y, foodSize * 2);\n\n      // Outer glow\n      g.fillStyle(COLORS.noirWhite, 0.4);\n      g.fillCircle(tf.x, tf.y, foodSize * 1.5);\n\n      // Main food body\n      g.fillStyle(COLORS.food, 0.95);\n      g.fillCircle(tf.x, tf.y, foodSize);\n\n      // Spinning highlight\n      const highlightAngle = tf.rotation;\n      const highlightX = tf.x + Math.cos(highlightAngle) * foodSize * 0.3;\n      const highlightY = tf.y + Math.sin(highlightAngle) * foodSize * 0.3;\n      g.fillStyle(0xffffff, 0.9);\n      g.fillCircle(highlightX, highlightY, foodSize * 0.25);\n\n      // Secondary sparkle\n      const sparkleAngle = tf.rotation + Math.PI * 0.7;\n      const sparkleX = tf.x + Math.cos(sparkleAngle) * foodSize * 0.4;\n      const sparkleY = tf.y + Math.sin(sparkleAngle) * foodSize * 0.4;\n      g.fillStyle(0xffffff, 0.6);\n      g.fillCircle(sparkleX, sparkleY, foodSize * 0.15);\n    }\n  }\n\n  update(): void {\n    this.frameCount++;\n    this.cleanEffects.frameCount = this.frameCount;\n\n    const width = this.scale.width;\n    const height = this.scale.height;\n\n    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n    updateTears(this.cleanEffects, height);\n    updateBlood(this.cleanEffects, height);\n\n    if (this.currentState && this.currentState.snake.length > 0) {\n      const head = this.currentState.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n        updateGlowTrail(this.cleanEffects, headX, headY);\n      }\n      this.lastHeadPos = { x: head.x, y: head.y };\n\n      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n        const food = this.currentState.food;\n        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnRipple(this.cleanEffects, foodX, foodY);\n      }\n      this.lastSnakeLength = this.currentState.snake.length;\n    }\n\n    const g = this.graphics;\n    g.clear();\n    g.setPosition(0, 0);\n\n    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n\n    if (!this.currentState) return;\n\n    drawGlowTrail(g, this.cleanEffects);\n    drawRipples(g, this.cleanEffects);\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n\n    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawTears(g, this.cleanEffects);\n    drawBlood(g, this.cleanEffects);\n\n    drawCleanVignette(g, width, height);\n\n    const score = this.currentState.score || 0;\n    const snakeLength = this.currentState.snake.length;\n    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n\n    if (this.currentState.gameOver) {\n      this.drawGameOver(g, width, height);\n      this.drawScoreboard(g, width, height);\n    }\n\n    this.checkAndSaveHighScore();\n    this.needsRedraw = false;\n  }\n\n  private drawStars(g: Phaser.GameObjects.Graphics): void {\n    // In film noir mode, stars are subtle distant lights\n    for (const star of this.stars) {\n      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n      const alpha = star.brightness * twinkle * 0.25;\n      g.fillStyle(COLORS.star, alpha);\n      g.fillCircle(star.x, star.y, star.size * 0.7);\n    }\n  }\n\n  private updateSmokeParticles(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (const smoke of this.smokeParticles) {\n      smoke.x += smoke.vx;\n      smoke.y += smoke.vy;\n      smoke.life -= 0.002;\n      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n        smoke.x = Math.random() * width;\n        smoke.y = height + smoke.size;\n        smoke.life = 1;\n        smoke.size = 30 + Math.random() * 50;\n        smoke.alpha = 0.02 + Math.random() * 0.03;\n      }\n      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n    }\n  }\n\n  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Create dramatic spotlight effect centered on snake\n    const cx = this.spotlightX || width / 2;\n    const cy = this.spotlightY || height / 2;\n    const pulse = 0.9 + Math.sin(this.frameCount * 0.03) * 0.1;\n\n    // Outer darkness vignette\n    g.fillStyle(0x000000, 0.6);\n    g.fillRect(0, 0, width, height);\n\n    // Spotlight cone - multiple layers for smooth falloff\n    const layers = 4;\n    for (let i = layers; i > 0; i--) {\n      const layerRadius = (width * 0.4 + i * 30) * pulse;\n      const layerAlpha = 0.15 * (1 - i / (layers + 1));\n      g.fillStyle(COLORS.spotlight, layerAlpha);\n      g.fillCircle(cx, cy, layerRadius);\n    }\n\n    // Bright center\n    g.fillStyle(COLORS.noirWhite, 0.08 * pulse);\n    g.fillCircle(cx, cy, width * 0.25);\n  }\n\n  private drawVenetianBlinds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Horizontal light streaks simulating light through venetian blinds\n    const blindSpacing = 25;\n    const blindWidth = 8;\n    const waveOffset = Math.sin(this.venetianPhase) * 10;\n\n    for (let y = waveOffset; y < height; y += blindSpacing) {\n      const brightness = 0.03 + Math.sin(y * 0.02 + this.venetianPhase * 2) * 0.015;\n      g.fillStyle(COLORS.noirWhite, brightness);\n      g.fillRect(0, y, width, blindWidth);\n    }\n\n    // Diagonal shadow bars from window frame\n    const diagonalAlpha = 0.04 + Math.sin(this.frameCount * 0.02) * 0.01;\n    g.fillStyle(0x000000, diagonalAlpha);\n    for (let i = -2; i < 6; i++) {\n      const x1 = i * 100 + Math.sin(this.venetianPhase) * 20;\n      g.beginPath();\n      g.moveTo(x1, 0);\n      g.lineTo(x1 + 40, 0);\n      g.lineTo(x1 + 40 + height * 0.3, height);\n      g.lineTo(x1 + height * 0.3, height);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawSmoke(g: Phaser.GameObjects.Graphics): void {\n    for (const smoke of this.smokeParticles) {\n      const alpha = smoke.alpha * smoke.life;\n      g.fillStyle(COLORS.noirGray, alpha);\n      g.fillCircle(smoke.x, smoke.y, smoke.size);\n      g.fillStyle(COLORS.noirWhite, alpha * 0.3);\n      g.fillCircle(smoke.x, smoke.y, smoke.size * 0.5);\n    }\n  }\n\n  private spawnFlameParticle(x: number, y: number, intensity: number): void {\n    if (this.flameParticles.length >= MAX_FLAME_PARTICLES) {\n      this.flameParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.6;\n    const life = 0.5 + Math.random() * 0.5;\n\n    this.flameParticles.push({\n      x: x + (Math.random() - 0.5) * 6,\n      y: y + (Math.random() - 0.5) * 6,\n      vx: Math.cos(angle) * speed * 0.3,\n      vy: -0.5 - Math.random() * 1.5 * intensity,\n      size: 3 + Math.random() * 4 * intensity,\n      life,\n      maxLife: life,\n      hue: 10 + Math.random() * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n    });\n  }\n\n  private updateFlameParticles(): void {\n    for (let i = this.flameParticles.length - 1; i >= 0; i--) {\n      const p = this.flameParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.02;\n      p.vx *= 0.98;\n      p.size *= 0.97;\n      p.life -= 0.025;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.flameParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private drawFlameParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.flameParticles) {\n      const lifeRatio = p.life / p.maxLife;\n\n      // Hue shifts from yellow-orange (high life) to red (low life)\n      const hue = p.hue - (1 - lifeRatio) * 15;\n      const outerColor = this.hslToRgb(hue / 360, 1, 0.3 + lifeRatio * 0.2);\n      const midColor = this.hslToRgb(hue / 360, 1, 0.5 + lifeRatio * 0.2);\n      const coreColor = this.hslToRgb((hue + 20) / 360, 0.7, 0.7 + lifeRatio * 0.2);\n\n      // Outer glow\n      g.fillStyle(outerColor, lifeRatio * 0.3);\n      g.fillCircle(p.x, p.y, p.size * 2);\n\n      // Mid flame\n      g.fillStyle(midColor, lifeRatio * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3);\n\n      // Core (bright yellow/white)\n      g.fillStyle(coreColor, lifeRatio * 0.8);\n      g.fillCircle(p.x, p.y, p.size * 0.6);\n    }\n  }\n\n  private spawnFlamesAlongSnake(): void {\n    if (!this.currentState || this.currentState.gameOver) return;\n\n    const snake = this.currentState.snake;\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const segX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const segY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const intensity = 1 - (i / snake.length) * 0.6;\n      if (Math.random() < 0.4 * intensity) {\n        this.spawnFlameParticle(segX, segY, intensity);\n      }\n    }\n  }\n\n  private drawMeteors(g: Phaser.GameObjects.Graphics): void {\n    for (const m of this.meteors) {\n      const meteorColor = this.hslToRgb(m.hue / 360, 0.9, 0.6);\n      const coreColor = this.hslToRgb(m.hue / 360, 0.6, 0.9);\n\n      // Draw trail (oldest to newest for proper layering)\n      for (let i = m.trail.length - 1; i >= 0; i--) {\n        const t = m.trail[i];\n        const trailProgress = 1 - i / m.trail.length;\n        const trailAlpha = t.alpha * trailProgress * 0.4;\n        const trailSize = m.size * trailProgress * 0.6;\n\n        g.fillStyle(meteorColor, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      g.fillStyle(meteorColor, m.alpha * 0.3);\n      g.fillCircle(m.x, m.y, m.size * 2);\n\n      // Main meteor body\n      g.fillStyle(meteorColor, m.alpha * 0.8);\n      g.fillCircle(m.x, m.y, m.size);\n\n      // Bright core\n      g.fillStyle(coreColor, m.alpha);\n      g.fillCircle(m.x, m.y, m.size * 0.5);\n    }\n  }\n\n  private drawDeathDebris(g: Phaser.GameObjects.Graphics): void {\n    // Draw explosion flash at the beginning\n    if (this.deathExplosionPhase > 0.7) {\n      const flashAlpha = (this.deathExplosionPhase - 0.7) * 2;\n      g.fillStyle(0xffffff, flashAlpha * 0.5);\n      g.fillRect(0, 0, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);\n    }\n\n    for (const d of this.deathDebris) {\n      // Film noir: grayscale debris\n      const brightness = 0.4 + (d.hue % 60) / 100;\n      const color = this.hslToRgb(0, 0, brightness);\n      const alpha = d.life * 0.9;\n\n      g.save();\n\n      if (d.type === 'shard') {\n        // Draw triangular shards\n        const cx = d.x;\n        const cy = d.y;\n        const size = d.size * d.life;\n\n        // Calculate rotated triangle points\n        const cos = Math.cos(d.rotation);\n        const sin = Math.sin(d.rotation);\n\n        const p1x = cx + cos * size;\n        const p1y = cy + sin * size;\n        const p2x = cx + cos * (-size * 0.5) - sin * (size * 0.7);\n        const p2y = cy + sin * (-size * 0.5) + cos * (size * 0.7);\n        const p3x = cx + cos * (-size * 0.5) - sin * (-size * 0.7);\n        const p3y = cy + sin * (-size * 0.5) + cos * (-size * 0.7);\n\n        // Glow\n        g.fillStyle(color, alpha * 0.4);\n        g.fillCircle(cx, cy, size * 1.5);\n\n        // Shard body\n        g.fillStyle(color, alpha);\n        g.fillTriangle(p1x, p1y, p2x, p2y, p3x, p3y);\n\n        // Highlight edge\n        g.lineStyle(1, 0xffffff, alpha * 0.6);\n        g.lineBetween(p1x, p1y, p2x, p2y);\n\n      } else if (d.type === 'spark') {\n        // Draw elongated spark\n        const sparkLength = d.size * 2 * d.life;\n        const sparkWidth = d.size * 0.3 * d.life;\n\n        // Direction based on velocity\n        const vLen = Math.sqrt(d.vx * d.vx + d.vy * d.vy);\n        const nx = vLen > 0 ? d.vx / vLen : 1;\n        const ny = vLen > 0 ? d.vy / vLen : 0;\n\n        // Glow\n        g.fillStyle(color, alpha * 0.3);\n        g.fillCircle(d.x, d.y, sparkLength * 0.8);\n\n        // Spark line\n        g.lineStyle(sparkWidth * 2, color, alpha * 0.6);\n        g.lineBetween(d.x - nx * sparkLength, d.y - ny * sparkLength, d.x, d.y);\n\n        // Bright tip\n        g.lineStyle(sparkWidth, 0xffffff, alpha);\n        g.lineBetween(d.x - nx * sparkLength * 0.3, d.y - ny * sparkLength * 0.3, d.x, d.y);\n\n      } else {\n        // Ember - glowing circle\n        const emberSize = d.size * d.life;\n\n        // Outer glow\n        g.fillStyle(color, alpha * 0.2);\n        g.fillCircle(d.x, d.y, emberSize * 2);\n\n        // Mid glow\n        g.fillStyle(color, alpha * 0.5);\n        g.fillCircle(d.x, d.y, emberSize * 1.3);\n\n        // Core\n        g.fillStyle(color, alpha);\n        g.fillCircle(d.x, d.y, emberSize);\n\n        // Hot center\n        g.fillStyle(0xffffff, alpha * 0.7);\n        g.fillCircle(d.x, d.y, emberSize * 0.4);\n      }\n\n      g.restore();\n    }\n  }\n\n  private drawNebulaClouds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const cloud of this.nebulaClouds) {\n      // Update cloud position (slow drift)\n      cloud.x += cloud.driftX;\n      cloud.y += cloud.driftY;\n      cloud.pulsePhase += cloud.pulseSpeed;\n\n      // Wrap around edges\n      if (cloud.x < -cloud.radius) cloud.x = width + cloud.radius;\n      if (cloud.x > width + cloud.radius) cloud.x = -cloud.radius;\n      if (cloud.y < -cloud.radius) cloud.y = height + cloud.radius;\n      if (cloud.y > height + cloud.radius) cloud.y = -cloud.radius;\n\n      // Pulsing alpha\n      const pulseAlpha = cloud.alpha * (0.7 + Math.sin(cloud.pulsePhase) * 0.3);\n      const color = this.hslToRgb(cloud.hue / 360, 0.6, 0.3);\n\n      // Draw multiple concentric layers for soft cloud effect\n      const layers = 4;\n      for (let i = layers; i > 0; i--) {\n        const layerRadius = cloud.radius * (i / layers);\n        const layerAlpha = pulseAlpha * (1 - i / (layers + 1)) * 0.6;\n        g.fillStyle(color, layerAlpha);\n        g.fillCircle(cloud.x, cloud.y, layerRadius);\n      }\n\n      // Core glow\n      const coreColor = this.hslToRgb(cloud.hue / 360, 0.8, 0.5);\n      g.fillStyle(coreColor, pulseAlpha * 0.4);\n      g.fillCircle(cloud.x, cloud.y, cloud.radius * 0.3);\n    }\n  }\n\n  private drawVortex(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Update vortex pulse\n    this.vortexPulse += 0.03;\n    const globalPulse = 0.8 + Math.sin(this.vortexPulse) * 0.2;\n\n    // Draw outer glow/halo\n    const outerGlowColor = this.hslToRgb(280 / 360, 0.7, 0.3);\n    g.fillStyle(outerGlowColor, 0.08 * globalPulse);\n    g.fillCircle(centerX, centerY, 120);\n    g.fillStyle(outerGlowColor, 0.05 * globalPulse);\n    g.fillCircle(centerX, centerY, 140);\n\n    // Draw orbiting particles (behind rings)\n    for (const particle of this.vortexParticles) {\n      // Update particle position - spiral inward slightly then reset\n      particle.angle += particle.speed;\n      particle.radius = particle.baseRadius + Math.sin(particle.angle * 3) * 8;\n\n      const px = centerX + Math.cos(particle.angle) * particle.radius;\n      const py = centerY + Math.sin(particle.angle) * particle.radius;\n\n      // Particle hue shifts over time\n      particle.hue = (particle.hue + 0.5) % 360;\n      const particleColor = this.hslToRgb(particle.hue / 360, 0.8, 0.6);\n\n      // Draw particle with trail\n      const trailAngle = particle.angle - 0.3;\n      const trailX = centerX + Math.cos(trailAngle) * particle.radius;\n      const trailY = centerY + Math.sin(trailAngle) * particle.radius;\n\n      g.lineStyle(particle.size * 0.8, particleColor, particle.alpha * 0.3 * globalPulse);\n      g.lineBetween(trailX, trailY, px, py);\n\n      g.fillStyle(particleColor, particle.alpha * globalPulse);\n      g.fillCircle(px, py, particle.size);\n\n      // Bright core\n      g.fillStyle(0xffffff, particle.alpha * 0.5 * globalPulse);\n      g.fillCircle(px, py, particle.size * 0.4);\n    }\n\n    // Draw rotating rings\n    for (const ring of this.vortexRings) {\n      ring.rotationOffset += ring.rotationSpeed;\n      ring.pulsePhase += 0.02;\n\n      const ringPulse = 0.7 + Math.sin(ring.pulsePhase) * 0.3;\n      const adjustedRadius = ring.baseRadius * (0.95 + ringPulse * 0.1);\n\n      const ringColor = this.hslToRgb(ring.hue / 360, 0.8, 0.5);\n\n      // Draw ring as series of arc segments with gaps\n      const segments = 6;\n      const arcLength = (Math.PI * 2) / segments * 0.7;\n\n      for (let i = 0; i < segments; i++) {\n        const startAngle = ring.rotationOffset + (i * Math.PI * 2) / segments;\n        const endAngle = startAngle + arcLength;\n\n        // Calculate alpha based on segment position for 3D effect\n        const segmentAlpha = 0.15 + Math.sin(startAngle + this.frameCount * 0.02) * 0.1;\n\n        g.lineStyle(ring.thickness, ringColor, segmentAlpha * ringPulse * globalPulse);\n        g.beginPath();\n        g.arc(centerX, centerY, adjustedRadius, startAngle, endAngle, false);\n        g.strokePath();\n      }\n\n      // Inner glow line\n      g.lineStyle(ring.thickness * 0.5, 0xffffff, 0.1 * ringPulse * globalPulse);\n      g.beginPath();\n      g.arc(centerX, centerY, adjustedRadius - 1, ring.rotationOffset, ring.rotationOffset + Math.PI, false);\n      g.strokePath();\n    }\n\n    // Central dark core (event horizon)\n    g.fillStyle(0x000000, 0.9);\n    g.fillCircle(centerX, centerY, 12);\n    g.fillStyle(0x000000, 0.7);\n    g.fillCircle(centerX, centerY, 18);\n    g.fillStyle(0x000000, 0.4);\n    g.fillCircle(centerX, centerY, 25);\n\n    // Bright accretion ring at edge of event horizon\n    const accretionHue = (this.frameCount * 2) % 360;\n    const accretionColor = this.hslToRgb(accretionHue / 360, 1, 0.6);\n    g.lineStyle(2, accretionColor, 0.4 * globalPulse);\n    g.strokeCircle(centerX, centerY, 14);\n    g.lineStyle(1, 0xffffff, 0.3 * globalPulse);\n    g.strokeCircle(centerX, centerY, 13);\n\n    // Gravitational lensing effect - distorted light streaks\n    const numStreaks = 4;\n    for (let i = 0; i < numStreaks; i++) {\n      const streakAngle = (i * Math.PI * 2) / numStreaks + this.frameCount * 0.01;\n      const streakHue = (accretionHue + i * 60) % 360;\n      const streakColor = this.hslToRgb(streakHue / 360, 0.9, 0.7);\n\n      const innerRadius = 20;\n      const outerRadius = 35 + Math.sin(this.frameCount * 0.05 + i) * 10;\n\n      const x1 = centerX + Math.cos(streakAngle) * innerRadius;\n      const y1 = centerY + Math.sin(streakAngle) * innerRadius;\n      const x2 = centerX + Math.cos(streakAngle + 0.2) * outerRadius;\n      const y2 = centerY + Math.sin(streakAngle + 0.2) * outerRadius;\n\n      g.lineStyle(3, streakColor, 0.15 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n      g.lineStyle(1.5, 0xffffff, 0.2 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n    }\n  }\n\n  private drawAuroraWaves(g: Phaser.GameObjects.Graphics, width: number): void {\n    for (const aurora of this.auroraWaves) {\n      aurora.phase += aurora.speed;\n\n      // Draw multiple ribbon layers for each aurora\n      const ribbonLayers = 3;\n      for (let layer = 0; layer < ribbonLayers; layer++) {\n        const layerOffset = layer * 5;\n        const layerAlpha = 0.06 - layer * 0.015;\n\n        // Calculate shifting hue for color variation\n        const shiftedHue = (aurora.hue + Math.sin(aurora.phase * 0.5) * 20) % 360;\n        const color = this.hslToRgb(shiftedHue / 360, 0.7, 0.5);\n\n        // Draw aurora as a series of connected curves\n        g.fillStyle(color, layerAlpha);\n        const step = 4;\n        for (let x = 0; x < width; x += step) {\n          // Multiple sine waves combined for organic movement\n          const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n          const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n          const wave3 = Math.sin(x * 0.01 + aurora.phase * 0.7) * aurora.amplitude * 0.3;\n          const yOffset = wave1 + wave2 + wave3;\n\n          const segmentY = aurora.y + yOffset + layerOffset;\n          const thickness = aurora.thickness * (0.7 + Math.sin(x * 0.05 + aurora.phase) * 0.3);\n\n          g.fillRect(x, segmentY - thickness / 2, step + 1, thickness);\n        }\n      }\n\n      // Add bright core line\n      const coreHue = (aurora.hue + 40) % 360;\n      const coreColor = this.hslToRgb(coreHue / 360, 0.9, 0.7);\n      g.lineStyle(1.5, coreColor, 0.15);\n      g.beginPath();\n      for (let x = 0; x < width; x += 3) {\n        const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n        const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n        const y = aurora.y + wave1 + wave2;\n        if (x === 0) {\n          g.moveTo(x, y);\n        } else {\n          g.lineTo(x, y);\n        }\n      }\n      g.strokePath();\n    }\n  }\n\n  private drawPlasmaWaves(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const wave of this.plasmaWaves) {\n      wave.phase += wave.speed;\n      const color = this.hslToRgb(wave.hue / 360, 0.7, 0.4);\n\n      // Draw flowing plasma lines\n      for (let y = 0; y < height; y += 8) {\n        const waveOffset = Math.sin(y / wave.wavelength + wave.phase) * wave.amplitude;\n        const intensity = 0.03 + Math.sin(wave.phase + y * 0.01) * 0.02;\n\n        g.fillStyle(color, intensity);\n        const x1 = width / 2 + waveOffset - 40;\n        const x2 = width / 2 + waveOffset + 40;\n        g.fillRect(x1, y, x2 - x1, 2);\n      }\n    }\n  }\n\n  private drawSnakeAfterimages(g: Phaser.GameObjects.Graphics): void {\n    for (const ai of this.snakeAfterimages) {\n      const alpha = ai.life * 0.25;\n      for (let i = 0; i < ai.segments.length; i++) {\n        const seg = ai.segments[i];\n        const centerX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n        const centerY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n        const t = ai.segments.length > 1 ? i / (ai.segments.length - 1) : 1;\n        const radius = (CELL_SIZE / 2 - 2) * (0.7 + t * 0.2);\n\n        const segmentHue = (ai.hueOffset + i * 15) % 360;\n        const color = this.hslToRgb(segmentHue / 360, 0.6, 0.4);\n\n        g.fillStyle(color, alpha * t);\n        g.fillCircle(centerX, centerY, radius);\n      }\n    }\n  }\n\n  private drawTrailParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.trailParticles) {\n      // Film noir: grayscale trail\n      g.fillStyle(COLORS.noirGray, p.life * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 1.5 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.5);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n  }\n\n  // Update comet trail - add new segments and fade old ones\n  private updateCometTrail(): void {\n    if (!this.currentState || this.currentState.gameOver) {\n      // Fade out trail on game over\n      for (const seg of this.cometTrail) {\n        seg.alpha *= 0.9;\n      }\n      this.cometTrail = this.cometTrail.filter(s => s.alpha > 0.01);\n      return;\n    }\n\n    const snake = this.currentState.snake;\n    if (snake.length === 0) return;\n\n    const head = snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Track head history for smooth interpolation\n    this.headHistory.unshift({ x: headX, y: headY, time: this.frameCount });\n    if (this.headHistory.length > 10) this.headHistory.pop();\n\n    // Add new trail segment at head position\n    if (this.frameCount % 2 === 0) {\n      const hue = 270 + Math.sin(this.frameCount * 0.05) * 20;\n      this.cometTrail.unshift({\n        x: headX,\n        y: headY,\n        alpha: 1,\n        size: CELL_SIZE / 2 + 2,\n        hue,\n      });\n\n      // Spawn ethereal particles from trail\n      if (Math.random() < 0.6) {\n        this.spawnEtherealParticle(headX, headY, hue);\n      }\n    }\n\n    // Limit trail length and fade segments\n    while (this.cometTrail.length > MAX_COMET_TRAIL_LENGTH) {\n      this.cometTrail.pop();\n    }\n\n    // Fade all segments\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const fadeRate = 0.06 + (i / this.cometTrail.length) * 0.04;\n      this.cometTrail[i].alpha -= fadeRate;\n      this.cometTrail[i].size *= 0.97;\n    }\n\n    // Remove fully faded segments\n    this.cometTrail = this.cometTrail.filter(s => s.alpha > 0);\n  }\n\n  // Spawn an ethereal particle that drifts away from the trail\n  private spawnEtherealParticle(x: number, y: number, hue: number): void {\n    if (this.etherealParticles.length >= MAX_ETHEREAL_PARTICLES) {\n      this.etherealParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.5;\n    const life = 0.8 + Math.random() * 0.4;\n\n    this.etherealParticles.push({\n      x: x + (Math.random() - 0.5) * 10,\n      y: y + (Math.random() - 0.5) * 10,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 0.3,\n      size: 3 + Math.random() * 4,\n      life,\n      maxLife: life,\n      hue: hue + (Math.random() - 0.5) * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n\n  // Update ethereal particles\n  private updateEtherealParticles(): void {\n    for (let i = this.etherealParticles.length - 1; i >= 0; i--) {\n      const p = this.etherealParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.015; // Slight upward drift\n      p.vx *= 0.98;\n      p.size *= 0.985;\n      p.life -= 0.02;\n      p.pulsePhase += 0.15;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.etherealParticles.splice(i, 1);\n      }\n    }\n  }\n\n  // Draw the comet trail - smooth glowing ribbon\n  private drawCometTrail(g: Phaser.GameObjects.Graphics): void {\n    if (this.cometTrail.length < 2) return;\n\n    // Draw outer glow layer\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.05) continue;\n\n      const progress = i / this.cometTrail.length;\n      const glowSize = seg.size * (1.5 + progress * 0.5);\n      const glowAlpha = seg.alpha * 0.15 * (1 - progress * 0.5);\n\n      // Outer ethereal glow\n      const outerColor = this.hslToRgb(seg.hue / 360, 0.6, 0.4);\n      g.fillStyle(outerColor, glowAlpha);\n      g.fillCircle(seg.x, seg.y, glowSize * 1.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(seg.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, glowAlpha * 1.5);\n      g.fillCircle(seg.x, seg.y, glowSize);\n    }\n\n    // Draw connecting ribbon between segments\n    if (this.cometTrail.length >= 2) {\n      for (let i = 0; i < this.cometTrail.length - 1; i++) {\n        const seg1 = this.cometTrail[i];\n        const seg2 = this.cometTrail[i + 1];\n        if (seg1.alpha < 0.1 || seg2.alpha < 0.1) continue;\n\n        const progress = i / this.cometTrail.length;\n        const ribbonAlpha = Math.min(seg1.alpha, seg2.alpha) * 0.4 * (1 - progress * 0.5);\n        const ribbonWidth = (seg1.size + seg2.size) / 2 * 0.6;\n\n        // Ribbon core\n        const ribbonColor = this.hslToRgb(seg1.hue / 360, 0.8, 0.6);\n        g.lineStyle(ribbonWidth, ribbonColor, ribbonAlpha);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n\n        // Bright inner ribbon\n        g.lineStyle(ribbonWidth * 0.4, 0xffffff, ribbonAlpha * 0.6);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n      }\n    }\n\n    // Draw core particles at each segment\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.1) continue;\n\n      const progress = i / this.cometTrail.length;\n      const coreAlpha = seg.alpha * 0.6 * (1 - progress * 0.7);\n      const coreSize = seg.size * 0.5 * (1 - progress * 0.3);\n\n      // Core glow\n      const coreColor = this.hslToRgb(seg.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, coreAlpha);\n      g.fillCircle(seg.x, seg.y, coreSize);\n\n      // Bright white center\n      g.fillStyle(0xffffff, coreAlpha * 0.5);\n      g.fillCircle(seg.x, seg.y, coreSize * 0.4);\n    }\n  }\n\n  // Draw ethereal particles - luminous drifting particles\n  private drawEtherealParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.etherealParticles) {\n      const lifeRatio = p.life / p.maxLife;\n      const pulse = 0.7 + Math.sin(p.pulsePhase) * 0.3;\n      const alpha = lifeRatio * pulse;\n\n      // Outer glow\n      const glowColor = this.hslToRgb(p.hue / 360, 0.5, 0.3);\n      g.fillStyle(glowColor, alpha * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 2.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(p.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      // Core\n      const coreColor = this.hslToRgb(p.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, alpha * 0.7);\n      g.fillCircle(p.x, p.y, p.size);\n\n      // Bright center\n      g.fillStyle(0xffffff, alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawShockWaves(g: Phaser.GameObjects.Graphics): void {\n    for (const sw of this.shockWaves) {\n      const alpha = sw.life * 0.6;\n      // Outer ring\n      g.lineStyle(3, 0xffffff, alpha * 0.3);\n      g.strokeCircle(sw.x, sw.y, sw.radius);\n      // Inner bright ring\n      g.lineStyle(2, 0x00ffff, alpha * 0.7);\n      g.strokeCircle(sw.x, sw.y, sw.radius * 0.8);\n      // Core flash\n      if (sw.life > 0.8) {\n        g.fillStyle(0xffffff, (sw.life - 0.8) * 3);\n        g.fillCircle(sw.x, sw.y, sw.radius * 0.3);\n      }\n    }\n  }\n\n  private drawLightningBolts(g: Phaser.GameObjects.Graphics): void {\n    for (const bolt of this.lightningBolts) {\n      const alpha = bolt.life;\n\n      // Film noir: white lightning\n      g.lineStyle(4, COLORS.noirGray, alpha * 0.3);\n      this.drawLightningPath(g, bolt.points);\n\n      g.lineStyle(2, 0xffffff, alpha * 0.8);\n      this.drawLightningPath(g, bolt.points);\n    }\n  }\n\n  private drawLightningPath(g: Phaser.GameObjects.Graphics, points: { x: number; y: number }[]): void {\n    if (points.length < 2) return;\n    g.beginPath();\n    g.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      g.lineTo(points[i].x, points[i].y);\n    }\n    g.strokePath();\n  }\n\n  private drawSnakeElectricity(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n    const snake = this.currentState.snake;\n    if (snake.length < 2) return;\n\n    // Draw electric arcs between segments every few frames\n    if (this.frameCount % 3 !== 0) return;\n\n    for (let i = 0; i < snake.length - 1; i++) {\n      if (Math.random() > 0.4) continue;\n\n      const seg1 = snake[i];\n      const seg2 = snake[i + 1];\n      const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n      const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n      const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n      const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const arcPoints = this.generateLightningPath(x1, y1, x2, y2);\n\n      // Film noir: grayscale arcs\n      g.lineStyle(3, COLORS.noirGray, 0.3);\n      this.drawLightningPath(g, arcPoints);\n      g.lineStyle(1, 0xffffff, 0.7);\n      this.drawLightningPath(g, arcPoints);\n    }\n  }\n\n  private hslToRgb(h: number, s: number, l: number): number {\n    let r: number, g: number, b: number;\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return (Math.round(r * 255) << 16) | (Math.round(g * 255) << 8) | Math.round(b * 255);\n  }\n\n  private loadHighScores(): HighScoreEntry[] {\n    if (this.highScoresLoaded && this.highScores.length > 0) {\n      return this.highScores;\n    }\n    try {\n      const stored = localStorage.getItem('snake_high_scores');\n      if (stored) {\n        const parsed = JSON.parse(stored) as HighScoreEntry[];\n        this.highScores = parsed.slice(0, MAX_HIGH_SCORES);\n        this.highScoresLoaded = true;\n        return this.highScores;\n      }\n    } catch {\n      // localStorage not available\n    }\n    this.highScores = [];\n    this.highScoresLoaded = true;\n    return this.highScores;\n  }\n\n  private saveHighScore(score: number): number {\n    const highScores = this.loadHighScores();\n    const newEntry: HighScoreEntry = { score, date: Date.now(), rank: 0 };\n\n    let insertIndex = highScores.findIndex(entry => score > entry.score);\n    if (insertIndex === -1) insertIndex = highScores.length;\n\n    if (insertIndex < MAX_HIGH_SCORES && score > 0) {\n      highScores.splice(insertIndex, 0, newEntry);\n      highScores.forEach((entry, i) => { entry.rank = i + 1; });\n      this.highScores = highScores.slice(0, MAX_HIGH_SCORES);\n\n      try {\n        localStorage.setItem('snake_high_scores', JSON.stringify(this.highScores));\n      } catch {\n        // localStorage not available\n      }\n      return insertIndex + 1;\n    }\n    return -1;\n  }\n\n  private checkAndSaveHighScore(): void {\n    if (!this.currentState) return;\n\n    if (this.currentState.gameOver && !this.lastGameOverState) {\n      const score = this.currentState.score || 0;\n      const rank = this.saveHighScore(score);\n      this.newHighScoreRank = rank > 0 ? rank : -1;\n      this.scoreboardRevealProgress = 0;\n\n      const head = this.currentState.snake[0];\n      if (head) {\n        const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnBlood(this.cleanEffects, headX, headY, 15);\n        spawnTears(this.cleanEffects, headX, headY - 10, 6);\n      }\n    }\n    this.lastGameOverState = this.currentState.gameOver;\n\n    if (this.currentState.gameStarted && !this.currentState.gameOver) {\n      this.newHighScoreRank = -1;\n    }\n  }\n\n  private drawHUD(g: Phaser.GameObjects.Graphics, width: number): void {\n    if (!this.currentState || !this.currentState.gameStarted) return;\n\n    this.hudPulsePhase += 0.08;\n    const score = this.currentState.score || 0;\n\n    if (score > this.lastHudScore) {\n      this.scoreFlashIntensity = 1;\n    }\n    this.lastHudScore = score;\n    this.scoreFlashIntensity *= 0.92;\n\n    const padding = 12;\n    const scorePanelWidth = 120;\n    const scorePanelHeight = 50;\n\n    // Score panel background - volcanic lava theme\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Glowing border\n    const borderGlow = 0.6 + this.scoreFlashIntensity * 0.4;\n    g.lineStyle(2, COLORS.snakeGlow, borderGlow);\n    g.strokeRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Score label\n    this.drawText(g, 'SCORE', padding + 10, padding + 12, 10, COLORS.snakeBody, 0.9);\n\n    // Score value with flash effect\n    const scoreColor = this.scoreFlashIntensity > 0.5 ? 0xffffff : COLORS.snakeHead;\n    this.drawText(g, String(score).padStart(5, '0'), padding + 10, padding + 32, 18, scoreColor, 1);\n\n    // Outer glow on score when flashing\n    if (this.scoreFlashIntensity > 0.1) {\n      g.fillStyle(COLORS.snakeGlow, this.scoreFlashIntensity * 0.3);\n      g.fillRoundedRect(padding + 5, padding + 20, 100, 28, 4);\n    }\n\n    // Length panel on the right\n    const lengthPanelWidth = 80;\n    const lengthPanelHeight = 50;\n    const lengthX = width - padding - lengthPanelWidth;\n\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    g.lineStyle(2, COLORS.foodGlow, 0.6);\n    g.strokeRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    this.drawText(g, 'LENGTH', lengthX + 10, padding + 12, 10, COLORS.food, 0.9);\n    this.drawText(g, String(this.currentState.snake.length), lengthX + 10, padding + 32, 18, COLORS.foodCore, 1);\n  }\n\n  private drawText(\n    g: Phaser.GameObjects.Graphics,\n    text: string,\n    x: number,\n    y: number,\n    size: number,\n    color: number,\n    alpha: number\n  ): void {\n    // Use simple block characters for text rendering\n    const charWidth = size * 0.6;\n    const charHeight = size;\n\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const cx = x + i * charWidth;\n\n      g.fillStyle(color, alpha);\n\n      // Simple pixel-style character rendering\n      if (char >= '0' && char <= '9') {\n        this.drawDigit(g, char, cx, y, size);\n      } else {\n        this.drawLetter(g, char, cx, y, size);\n      }\n    }\n  }\n\n  private drawDigit(g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15; // thickness\n\n    // 7-segment style digits\n    const segments: Record<string, number[]> = {\n      '0': [1, 1, 1, 0, 1, 1, 1],\n      '1': [0, 0, 1, 0, 0, 1, 0],\n      '2': [1, 0, 1, 1, 1, 0, 1],\n      '3': [1, 0, 1, 1, 0, 1, 1],\n      '4': [0, 1, 1, 1, 0, 1, 0],\n      '5': [1, 1, 0, 1, 0, 1, 1],\n      '6': [1, 1, 0, 1, 1, 1, 1],\n      '7': [1, 0, 1, 0, 0, 1, 0],\n      '8': [1, 1, 1, 1, 1, 1, 1],\n      '9': [1, 1, 1, 1, 0, 1, 1],\n    };\n\n    const seg = segments[digit] || segments['0'];\n\n    // Top horizontal\n    if (seg[0]) g.fillRect(x, y - h / 2, w, t);\n    // Top-left vertical\n    if (seg[1]) g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n    // Top-right vertical\n    if (seg[2]) g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n    // Middle horizontal\n    if (seg[3]) g.fillRect(x, y - t / 2, w, t);\n    // Bottom-left vertical\n    if (seg[4]) g.fillRect(x - t / 2, y, t, h / 2);\n    // Bottom-right vertical\n    if (seg[5]) g.fillRect(x + w - t / 2, y, t, h / 2);\n    // Bottom horizontal\n    if (seg[6]) g.fillRect(x, y + h / 2 - t, w, t);\n  }\n\n  private drawLetter(g: Phaser.GameObjects.Graphics, letter: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15;\n\n    // Simple block letters\n    switch (letter.toUpperCase()) {\n      case 'S':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'C':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'O':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'R':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w / 2, y, t, h / 2);\n        break;\n      case 'E':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w * 0.7, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'L':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'N':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - h / 2 + t, w, t);\n        break;\n      case 'G':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x + w / 2, y - t / 2, w / 2, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'T':\n        g.fillRect(x - t, y - h / 2, w + t * 2, t);\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'H':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n      case 'I':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'Y':\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        break;\n      case 'U':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'W':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case '!':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h * 0.6);\n        g.fillRect(x + w / 2 - t / 2, y + h / 2 - t * 2, t, t);\n        break;\n      case ' ':\n        break;\n      default:\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n    }\n  }\n\n  private drawScoreboard(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (!this.currentState || !this.currentState.gameOver) return;\n\n    this.scoreboardAnimPhase += 0.06;\n    this.scoreboardRevealProgress = Math.min(1, this.scoreboardRevealProgress + 0.02);\n\n    const highScores = this.loadHighScores();\n    const centerX = width / 2;\n    const baseY = height * 0.18;\n    const panelWidth = 180;\n    const panelHeight = 170;\n    const panelX = centerX - panelWidth / 2;\n    const panelY = baseY;\n    const slideOffset = (1 - this.scoreboardRevealProgress) * 50;\n    const alphaMultiplier = this.scoreboardRevealProgress;\n\n    // Panel background - volcanic lava glow\n    g.fillStyle(0x150510, 0.95 * alphaMultiplier);\n    g.fillRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Glowing border - animated\n    const borderHue = this.newHighScoreRank > 0 ? 45 : 0;\n    const borderPulse = 0.6 + Math.sin(this.scoreboardAnimPhase) * 0.2;\n    const borderColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    g.lineStyle(3, borderColor, borderPulse * alphaMultiplier);\n    g.strokeRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Title\n    const titleY = panelY - slideOffset + 22;\n    this.drawText(g, 'HIGH SCORES', centerX - 55, titleY, 10, COLORS.foodCore, alphaMultiplier);\n\n    // Divider line\n    g.lineStyle(1, COLORS.snakeGlow, 0.5 * alphaMultiplier);\n    g.lineBetween(panelX + 20, titleY + 8, panelX + panelWidth - 20, titleY + 8);\n\n    const entryStartY = titleY + 25;\n    const entryHeight = 22;\n\n    if (highScores.length === 0) {\n      this.drawText(g, 'NO SCORES YET', centerX - 50, entryStartY + 30, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n    } else {\n      for (let i = 0; i < Math.min(highScores.length, 5); i++) {\n        const entry = highScores[i];\n        const entryY = entryStartY + i * entryHeight;\n        const isNewScore = this.newHighScoreRank === i + 1;\n        const entryDelay = i * 0.15;\n        const entryProgress = Math.max(0, Math.min(1, (this.scoreboardRevealProgress - entryDelay) * 2));\n        if (entryProgress <= 0) continue;\n\n        const entryAlpha = alphaMultiplier * entryProgress;\n\n        // Highlight new high score row\n        if (isNewScore) {\n          const flashIntensity = 0.3 + Math.sin(this.scoreboardAnimPhase * 3) * 0.2;\n          g.fillStyle(0xffcc00, flashIntensity * entryAlpha);\n          g.fillRoundedRect(panelX + 8, entryY - slideOffset - 8, panelWidth - 16, entryHeight - 2, 4);\n        }\n\n        // Rank colors: gold, silver, bronze, then volcanic colors\n        const rankColors = [0xffd700, 0xc0c0c0, 0xcd7f32, COLORS.snakeGlow, COLORS.foodGlow];\n        const rankColor = rankColors[i] || 0x888888;\n\n        // Rank number\n        this.drawText(g, `${i + 1}`, panelX + 18, entryY - slideOffset, 10, rankColor, entryAlpha);\n\n        // Score value\n        const scoreColor = isNewScore ? 0xffffff : COLORS.foodCore;\n        this.drawText(g, String(entry.score).padStart(5, '0'), panelX + panelWidth - 70, entryY - slideOffset, 10, scoreColor, entryAlpha);\n\n        // NEW! label\n        if (isNewScore) {\n          const newAlpha = 0.8 + Math.sin(this.scoreboardAnimPhase * 4) * 0.2;\n          this.drawText(g, 'NEW', panelX + 50, entryY - slideOffset, 7, 0xffcc00, newAlpha * entryAlpha);\n        }\n      }\n    }\n\n    // Current score at bottom\n    const currentScoreY = panelY - slideOffset + panelHeight - 30;\n    this.drawText(g, 'YOUR SCORE', centerX - 40, currentScoreY - 10, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n\n    const currentScore = this.currentState.score || 0;\n    const scoreColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    this.drawText(g, String(currentScore).padStart(5, '0'), centerX - 25, currentScoreY + 8, 14, scoreColor, alphaMultiplier);\n  }\n\n  private drawGrid(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir grid: subtle, dark lines suggesting tile floor or city grid\n    g.lineStyle(1, COLORS.gridLine, 0.08);\n    for (let i = 0; i <= GRID_SIZE; i++) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Accent lines every 5 cells - subtle gray\n    const accentPulse = 0.12 + Math.sin(this.frameCount * 0.03) * 0.04;\n    g.lineStyle(1, COLORS.gridAccent, accentPulse);\n    for (let i = 0; i <= GRID_SIZE; i += 5) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Heavy vignette for dramatic noir look\n    this.drawVignette(g, width, height);\n  }\n\n  private drawVignette(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Multiple layers of vignette for smooth falloff\n    const layers = 5;\n    for (let i = 0; i < layers; i++) {\n      const inset = i * 30;\n      const alpha = 0.15 * (1 - i / layers);\n      g.lineStyle(60, 0x000000, alpha);\n      g.strokeRect(inset - 30, inset - 30, width - inset * 2 + 60, height - inset * 2 + 60);\n    }\n  }\n\n  private drawFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    // Don't draw food if it's still being thrown\n    if (this.thrownFood && !this.thrownFood.landed) return;\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    const pulseScale = 1 + Math.sin(this.frameCount * 0.15) * 0.08;\n    const glowPulse = 0.4 + Math.sin(this.frameCount * 0.1) * 0.2;\n\n    // Spawn particles (orange/yellow for Halloween)\n    this.spawnFoodParticles(foodX, foodY);\n\n    // Draw particles\n    for (const p of this.foodParticles) {\n      g.fillStyle(COLORS.pumpkinOrange, p.life * 0.4);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Halloween pumpkin!\n    const pumpkinSize = (CELL_SIZE / 2) * pulseScale;\n\n    // Shadow underneath\n    g.fillStyle(0x000000, 0.5);\n    g.fillEllipse(foodX + 2, foodY + pumpkinSize * 0.8, pumpkinSize * 1.2, pumpkinSize * 0.4);\n\n    // Outer orange glow (candlelight effect)\n    g.fillStyle(COLORS.pumpkinOrange, glowPulse * 0.15);\n    g.fillCircle(foodX, foodY, pumpkinSize + 12);\n    g.fillStyle(COLORS.candyCorn1, glowPulse * 0.2);\n    g.fillCircle(foodX, foodY, pumpkinSize + 6);\n\n    // Pumpkin body (slightly squashed circle)\n    g.fillStyle(COLORS.pumpkinOrange, 0.95);\n    g.fillEllipse(foodX, foodY, pumpkinSize * 1.1, pumpkinSize * 0.9);\n\n    // Pumpkin segments (darker lines)\n    g.lineStyle(2, 0xcc4400, 0.5);\n    g.lineBetween(foodX, foodY - pumpkinSize * 0.8, foodX, foodY + pumpkinSize * 0.7);\n    g.lineStyle(1.5, 0xcc4400, 0.3);\n    g.lineBetween(foodX - pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX - pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n    g.lineBetween(foodX + pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX + pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n\n    // Pumpkin stem\n    g.fillStyle(0x228822, 0.9);\n    g.fillRect(foodX - 2, foodY - pumpkinSize * 0.9 - 4, 4, 6);\n\n    // Jack-o-lantern face - glowing eyes and mouth\n    const faceGlow = 0.8 + Math.sin(this.frameCount * 0.12) * 0.2;\n    g.fillStyle(COLORS.candyCorn1, faceGlow);\n\n    // Eyes (triangles)\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n\n    // Mouth (jagged smile)\n    g.fillStyle(COLORS.candyCorn1, faceGlow * 0.9);\n    g.fillRect(foodX - pumpkinSize * 0.35, foodY + pumpkinSize * 0.15, pumpkinSize * 0.7, pumpkinSize * 0.25);\n\n    // Teeth (dark gaps in mouth)\n    g.fillStyle(COLORS.pumpkinOrange, 1);\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX, foodY + pumpkinSize * 0.15,\n      foodX - pumpkinSize * 0.075, foodY + pumpkinSize * 0.3\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.3, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.225, foodY + pumpkinSize * 0.3\n    );\n  }\n\n  private drawEnergyTendrils(g: Phaser.GameObjects.Graphics, foodX: number, foodY: number): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const head = this.currentState.snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Calculate distance to snake head\n    const dx = headX - foodX;\n    const dy = headY - foodY;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    // Only draw tendrils when snake is somewhat close\n    if (dist > CELL_SIZE * 6) return;\n\n    // Intensity increases as snake gets closer\n    const intensity = 1 - dist / (CELL_SIZE * 6);\n    const numTendrils = 2 + Math.floor(intensity * 2);\n\n    for (let i = 0; i < numTendrils; i++) {\n      // Tendril reaches partway toward the snake\n      const reach = 0.3 + intensity * 0.4;\n      const targetX = foodX + dx * reach;\n      const targetY = foodY + dy * reach;\n\n      // Add some wave offset for each tendril\n      const waveOffset = Math.sin(this.frameCount * 0.15 + i * 2) * 10;\n      const perpX = -dy / dist;\n      const perpY = dx / dist;\n      const wavyTargetX = targetX + perpX * waveOffset * (1 - reach);\n      const wavyTargetY = targetY + perpY * waveOffset * (1 - reach);\n\n      // Generate tendril path\n      const points = this.generateLightningPath(foodX, foodY, wavyTargetX, wavyTargetY);\n\n      // Draw tendril with glow\n      g.lineStyle(3, COLORS.foodGlow, intensity * 0.3);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1.5, COLORS.food, intensity * 0.7);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1, 0xffffff, intensity * 0.5);\n      this.drawLightningPath(g, points);\n    }\n  }\n\n  private drawSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const snakeLen = snake.length;\n\n    // Spooky shadow under snake\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const shadowRadius = (CELL_SIZE / 2) * (0.9 + t * 0.1);\n      g.fillStyle(0x000000, 0.5 * t);\n      g.fillCircle(centerX, centerY, shadowRadius);\n    }\n\n    // Draw trailing glow (ghostly green)\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const glowAlpha = 0.2 * t;\n      const glowSize = (CELL_SIZE / 2 + 4) * (0.5 + t * 0.5);\n\n      g.fillStyle(COLORS.snakeGlow, glowAlpha);\n      g.fillCircle(centerX, centerY, glowSize);\n    }\n\n    // Draw snake segments from tail to head with green gradient\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n\n      // Green gradient from tail (dark) to head (bright)\n      const brightness = 0.3 + t * 0.4;\n      const segmentColor = this.hslToRgb(0.4, 0.9, brightness);\n\n      if (i === 0) {\n        // Head: brightest green with eerie glow\n        g.fillStyle(COLORS.snakeGlow, 0.4);\n        g.fillCircle(centerX, centerY, radius + 8);\n\n        g.fillStyle(COLORS.snakeHead, 1);\n        g.fillCircle(centerX, centerY, radius + 1);\n\n        // Slimy highlight\n        g.fillStyle(0xaaffcc, 0.6);\n        g.fillCircle(centerX - 2, centerY - 2, radius * 0.35);\n\n        this.drawSnakeHead(g, segment, snake[1]);\n      } else {\n        // Body segment with green tones\n        g.fillStyle(COLORS.snakeGlow, 0.15);\n        g.fillCircle(centerX, centerY, radius + 2);\n\n        g.fillStyle(segmentColor, 1);\n        g.fillCircle(centerX, centerY, radius);\n\n        // Slimy specular highlight\n        g.fillStyle(0xaaffcc, 0.15 * t);\n        g.fillCircle(centerX - 1, centerY - 1, radius * 0.25);\n      }\n    }\n  }\n\n  private drawFoodBurst(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.foodBurstParticles) {\n      // Halloween: orange pumpkin burst\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailAlpha = p.life * 0.4 * (1 - i / p.trail.length);\n        const trailSize = p.size * p.life * (1 - i / p.trail.length);\n        g.fillStyle(COLORS.pumpkinOrange, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      g.fillStyle(COLORS.candyCorn1, p.life * 0.7);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n      g.fillStyle(COLORS.candyCorn3, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life * 0.4);\n    }\n  }\n\n  private drawEnergyField(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const snake = this.currentState.snake;\n    const baseIntensity = 0.06 + this.energyFieldPulse * 0.2;\n    const pulseOffset = Math.sin(this.frameCount * 0.1) * 0.02;\n    const alpha = Math.min(0.3, baseIntensity + pulseOffset);\n\n    // Halloween: ghostly green energy field\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const fieldRadius = CELL_SIZE * (0.8 + this.energyFieldPulse * 0.5) + Math.sin(this.frameCount * 0.15 + i * 0.5) * 2;\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.2);\n      g.fillCircle(cx, cy, fieldRadius + 4);\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.35);\n      g.fillCircle(cx, cy, fieldRadius);\n    }\n\n    // Connecting lines when pulse is active\n    if (this.energyFieldPulse > 0.3 && snake.length > 1) {\n      for (let i = 0; i < snake.length - 1; i++) {\n        const seg1 = snake[i];\n        const seg2 = snake[i + 1];\n        const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n        const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n        const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n        const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n        g.lineStyle(3, COLORS.noirGray, this.energyFieldPulse * 0.3);\n        g.lineBetween(x1, y1, x2, y2);\n        g.lineStyle(1.5, 0xffffff, this.energyFieldPulse * 0.5);\n        g.lineBetween(x1, y1, x2, y2);\n      }\n    }\n  }\n\n  private drawChromaticAberration(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const offset = this.chromaticIntensity * 3;\n\n    // Film noir: grayscale ghosting effect instead of color split\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snake.length > 1 ? i / (snake.length - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n      const alpha = this.chromaticIntensity * 0.3 * (i === 0 ? 1 : 0.5);\n\n      // Light ghost - offset left\n      g.fillStyle(0xffffff, alpha);\n      g.fillCircle(cx - offset, cy, radius);\n\n      // Dark ghost - offset right\n      g.fillStyle(0x404040, alpha);\n      g.fillCircle(cx + offset, cy, radius);\n    }\n  }\n\n  private drawGameOver(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir game over: dramatic fade to black with spotlight\n    if (this.gameOverAlpha < 0.85) {\n      this.gameOverAlpha += 0.03;\n    }\n\n    // Heavy dark overlay\n    g.fillStyle(COLORS.gameOverOverlay, this.gameOverAlpha);\n    g.fillRect(0, 0, width, height);\n\n    // Film grain effect (subtle noise lines)\n    for (let y = 0; y < height; y += 3) {\n      const grainAlpha = 0.05 + Math.random() * 0.05;\n      g.fillStyle(Math.random() > 0.5 ? 0xffffff : 0x000000, grainAlpha);\n      g.fillRect(0, y, width, 1);\n    }\n\n    // Dramatic spotlight in center\n    const spotPulse = 0.15 + Math.sin(this.frameCount * 0.05) * 0.05;\n    g.fillStyle(COLORS.noirWhite, spotPulse);\n    g.fillCircle(width / 2, height / 2, 80);\n    g.fillStyle(COLORS.noirWhite, spotPulse * 0.5);\n    g.fillCircle(width / 2, height / 2, 120);\n\n    // Noir border: thick black frame\n    const borderSize = 8;\n    g.fillStyle(0x000000, 0.8);\n    g.fillRect(0, 0, width, borderSize);\n    g.fillRect(0, height - borderSize, width, borderSize);\n    g.fillRect(0, 0, borderSize, height);\n    g.fillRect(width - borderSize, 0, borderSize, height);\n\n    // White inner border\n    const innerBorder = 2;\n    const innerOffset = borderSize;\n    g.fillStyle(COLORS.noirWhite, 0.3);\n    g.fillRect(innerOffset, innerOffset, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, height - innerOffset - innerBorder, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, innerOffset, innerBorder, height - innerOffset * 2);\n    g.fillRect(width - innerOffset - innerBorder, innerOffset, innerBorder, height - innerOffset * 2);\n  }\n\n  private drawSnakeHead(\n    g: Phaser.GameObjects.Graphics,\n    head: Position,\n    nextSegment: Position | undefined\n  ): void {\n    const centerX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const centerY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Determine direction for eye placement\n    let dx = 1, dy = 0;\n    if (nextSegment) {\n      dx = head.x - nextSegment.x;\n      dy = head.y - nextSegment.y;\n      // Normalize\n      const len = Math.sqrt(dx * dx + dy * dy);\n      if (len > 0) {\n        dx /= len;\n        dy /= len;\n      }\n    }\n\n    // Perpendicular for eye offset\n    const perpX = -dy;\n    const perpY = dx;\n\n    const eyeOffset = 4;\n    const eyeForward = 3;\n    const eyeRadius = 3;\n    const pupilRadius = 1.5;\n\n    // Left eye\n    const leftEyeX = centerX + perpX * eyeOffset + dx * eyeForward;\n    const leftEyeY = centerY + perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(leftEyeX, leftEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(leftEyeX + dx * 1, leftEyeY + dy * 1, pupilRadius);\n\n    // Right eye\n    const rightEyeX = centerX - perpX * eyeOffset + dx * eyeForward;\n    const rightEyeY = centerY - perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(rightEyeX, rightEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(rightEyeX + dx * 1, rightEyeY + dy * 1, pupilRadius);\n\n    // Draw the royal crown\n    this.drawCrown(g, centerX, centerY, dx, dy, perpX, perpY);\n  }\n\n  private drawCrown(\n    g: Phaser.GameObjects.Graphics,\n    headX: number,\n    headY: number,\n    dx: number,\n    dy: number,\n    perpX: number,\n    perpY: number\n  ): void {\n    // Volcanic crown: molten gold with ruby gems\n    const crownOffset = -8;\n    const crownBaseX = headX - dx * crownOffset;\n    const crownBaseY = headY - dy * crownOffset;\n\n    const crownWidth = 14;\n    const crownHeight = 10;\n    const halfWidth = crownWidth / 2;\n\n    const sparkle = 0.7 + Math.sin(this.frameCount * 0.15) * 0.3;\n\n    const baseLeft = {\n      x: crownBaseX + perpX * halfWidth,\n      y: crownBaseY + perpY * halfWidth\n    };\n    const baseRight = {\n      x: crownBaseX - perpX * halfWidth,\n      y: crownBaseY - perpY * halfWidth\n    };\n\n    const pointOffset = -dx * crownHeight;\n    const pointOffsetY = -dy * crownHeight;\n\n    const crownPoints = [\n      baseLeft,\n      { x: baseLeft.x + pointOffset * 0.4, y: baseLeft.y + pointOffsetY * 0.4 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: crownBaseX + perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY + perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY },\n      { x: crownBaseX - perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY - perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: baseRight.x + pointOffset * 0.4, y: baseRight.y + pointOffsetY * 0.4 },\n      baseRight\n    ];\n\n    // Crown glow (molten orange/red aura)\n    g.fillStyle(COLORS.noirWhite, 0.25 * sparkle);\n    g.fillCircle(crownBaseX + pointOffset * 0.5, crownBaseY + pointOffsetY * 0.5, crownHeight + 4);\n\n    // Crown base (molten gold)\n    g.fillStyle(0xffa500, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.fillPath();\n\n    // Crown outline (dark crimson)\n    g.lineStyle(1.5, 0x801010, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.strokePath();\n\n    // Crown band\n    const bandY1 = {\n      x: baseLeft.x + pointOffset * 0.15,\n      y: baseLeft.y + pointOffsetY * 0.15\n    };\n    const bandY2 = {\n      x: baseRight.x + pointOffset * 0.15,\n      y: baseRight.y + pointOffsetY * 0.15\n    };\n    g.lineStyle(3, 0xcc6600, 1);\n    g.lineBetween(bandY1.x, bandY1.y, bandY2.x, bandY2.y);\n\n    // Ruby jewels: glowing red gems\n    const jewelPositions = [\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY, size: 2.5 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n    ];\n\n    for (const jewel of jewelPositions) {\n      g.fillStyle(0xff4020, 0.5 * sparkle);\n      g.fillCircle(jewel.x, jewel.y, jewel.size + 2);\n\n      g.fillStyle(0xff2000, 1);\n      g.fillCircle(jewel.x, jewel.y, jewel.size);\n\n      g.fillStyle(0xffff80, 0.9 * sparkle);\n      g.fillCircle(jewel.x - 0.5, jewel.y - 0.5, jewel.size * 0.4);\n    }\n\n    // Crown highlight (golden gleam)\n    g.fillStyle(0xffff80, 0.6 * sparkle);\n    g.fillCircle(crownBaseX + perpX * 3 + pointOffset * 0.3, crownBaseY + perpY * 3 + pointOffsetY * 0.3, 2);\n  }\n}\n","structuredPatch":[{"oldStart":2394,"oldLines":6,"newStart":2394,"newLines":7,"lines":["     const height = this.scale.height;"," ","     updateMotes(this.cleanEffects, width, height);","+    updateSnowflakes(this.cleanEffects, width, height);","     updateRipples(this.cleanEffects);","     updateTears(this.cleanEffects, height);","     updateBlood(this.cleanEffects, height);"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016u8thLzeKG1Gt2UiEPaN2h","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to find where drawMotes is called to add drawSnowflakes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":343,"cache_read_input_tokens":42802,"cache_creation":{"ephemeral_5m_input_tokens":343,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"1ce79621-209c-4680-b0c0-5f9c053ee8d3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016u8thLzeKG1Gt2UiEPaN2h","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MaPmtz43whcEfZA46q3RJs","name":"Grep","input":{"pattern":"drawMotes","path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","output_mode":"content","-n":true,"-C":3},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":343,"cache_read_input_tokens":42802,"cache_creation":{"ephemeral_5m_input_tokens":343,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"ba89445c-d3b3-4f6f-b29e-8aae464e2674"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MaPmtz43whcEfZA46q3RJs","type":"tool_result","content":"15-  drawSnowflakes,\n16-  drawCleanBackground,\n17-  drawCleanGrid,\n18:  drawMotes,\n19-  drawRipples,\n20-  drawGlowTrail,\n21-  drawCleanFood,\n--\n2424-\n2425-    drawCleanBackground(g, width, height, this.frameCount);\n2426-    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n2427:    drawMotes(g, this.cleanEffects);\n2428-\n2429-    if (!this.currentState) return;\n2430-"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"f971bc26-3a29-4457-a419-54c61a444237","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"15-  drawSnowflakes,\n16-  drawCleanBackground,\n17-  drawCleanGrid,\n18:  drawMotes,\n19-  drawRipples,\n20-  drawGlowTrail,\n21-  drawCleanFood,\n--\n2424-\n2425-    drawCleanBackground(g, width, height, this.frameCount);\n2426-    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n2427:    drawMotes(g, this.cleanEffects);\n2428-\n2429-    if (!this.currentState) return;\n2430-","numLines":15}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01U64cd1agRpomYHtb6qbm4S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QWCUXsCSdFvMSiUFXgiMh7","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","old_string":"    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n\n    if (!this.currentState) return;","new_string":"    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n    drawSnowflakes(g, this.cleanEffects);\n\n    if (!this.currentState) return;"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":377,"cache_read_input_tokens":43145,"cache_creation":{"ephemeral_5m_input_tokens":377,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"7e455a89-92e5-4e66-929b-c097fee7b885"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QWCUXsCSdFvMSiUFXgiMh7","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"309ae627-77a5-401c-aaad-b0bd923ae516","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","oldString":"    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n\n    if (!this.currentState) return;","newString":"    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n    drawSnowflakes(g, this.cleanEffects);\n\n    if (!this.currentState) return;","originalFile":"import Phaser from 'phaser';\nimport {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  initSnowflakes,\n  updateSnowflakes,\n  drawSnowflakes,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface GameState {\n  snake: Position[];\n  food: Position;\n  gameOver: boolean;\n  gameStarted?: boolean;\n  score?: number;\n}\n\ninterface Star {\n  x: number;\n  y: number;\n  size: number;\n  speed: number;\n  brightness: number;\n}\n\ninterface PlasmaWave {\n  phase: number;\n  speed: number;\n  amplitude: number;\n  wavelength: number;\n  hue: number;\n}\n\ninterface AuroraWave {\n  y: number;\n  phase: number;\n  speed: number;\n  hue: number;\n  thickness: number;\n  amplitude: number;\n}\n\ninterface NebulaCloud {\n  x: number;\n  y: number;\n  radius: number;\n  hue: number;\n  alpha: number;\n  driftX: number;\n  driftY: number;\n  pulsePhase: number;\n  pulseSpeed: number;\n}\n\ninterface VortexRing {\n  radius: number;\n  baseRadius: number;\n  rotationOffset: number;\n  rotationSpeed: number;\n  thickness: number;\n  hue: number;\n  pulsePhase: number;\n}\n\ninterface VortexParticle {\n  angle: number;\n  radius: number;\n  baseRadius: number;\n  speed: number;\n  size: number;\n  hue: number;\n  alpha: number;\n}\n\ninterface SnakeAfterimage {\n  segments: Position[];\n  life: number;\n  maxLife: number;\n  hueOffset: number;\n}\n\ninterface FoodParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n}\n\ninterface SnakeTrailParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n  hue: number;\n}\n\ninterface ShockWave {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n}\n\ninterface LightningBolt {\n  points: { x: number; y: number }[];\n  life: number;\n  maxLife: number;\n  hue: number;\n}\n\nconst CELL_SIZE = 20;\nconst GRID_SIZE = 20;\nconst NUM_STARS = 30;\nconst MAX_FOOD_PARTICLES = 8;\nconst MAX_TRAIL_PARTICLES = 40;\nconst MAX_SHOCKWAVES = 3;\nconst MAX_LIGHTNING_BOLTS = 5;\nconst MAX_BURST_PARTICLES = 12;\nconst NUM_PLASMA_WAVES = 3;\nconst MAX_AFTERIMAGES = 4;\nconst NUM_AURORA_WAVES = 5;\nconst NUM_NEBULA_CLOUDS = 6;\nconst NUM_VORTEX_RINGS = 5;\nconst NUM_VORTEX_PARTICLES = 20;\nconst NUM_METEORS = 8;\nconst MAX_DEATH_DEBRIS = 24;\nconst NUM_SPIRITS_PER_EDGE = 2;\nconst MAX_FLAME_PARTICLES = 60;\nconst MAX_COMET_TRAIL_LENGTH = 30;\nconst MAX_ETHEREAL_PARTICLES = 50;\nconst NUM_BEES = 8;\nconst BEE_SPAWN_CHANCE = 0.02;\n\n// Comet trail segment - stores historical snake positions for smooth trail rendering\ninterface CometTrailSegment {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n  hue: number;\n}\n\n// Ethereal trail particle - luminous particles that drift away from trail\ninterface EtherealParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n  pulsePhase: number;\n}\n\n// Thrown food animation - food launched onto screen with arc trajectory\ninterface ThrownFood {\n  startX: number;\n  startY: number;\n  targetX: number;\n  targetY: number;\n  x: number;\n  y: number;\n  progress: number; // 0 to 1\n  rotation: number;\n  rotationSpeed: number;\n  trail: { x: number; y: number; alpha: number; rotation: number }[];\n  landed: boolean;\n  landingParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number }[];\n  impactRings: { radius: number; alpha: number }[];\n}\n\n// Meteor shower types\ninterface Meteor {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  alpha: number;\n  trail: { x: number; y: number; alpha: number }[];\n  life: number;\n}\n\n// Death debris particle\ninterface DeathDebris {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  rotation: number;\n  rotationSpeed: number;\n  life: number;\n  type: 'shard' | 'spark' | 'ember';\n}\n\n// Guardian spirit - ethereal protectors at edges\ninterface GuardianSpirit {\n  x: number;\n  y: number;\n  baseX: number;\n  baseY: number;\n  size: number;\n  phase: number;\n  speed: number;\n  haloPhase: number;\n  orbPhase: number;\n  edge: 'top' | 'bottom' | 'left' | 'right';\n  targetAlpha: number;\n  currentAlpha: number;\n  hue: number;\n  orbs: { angle: number; distance: number; size: number; speed: number }[];\n}\n\n// Flame particle for burning effect\ninterface FlameParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n}\n\n// Mystical bee - glowing magical creatures that swarm around food\ninterface MysticalBee {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  targetX: number;\n  targetY: number;\n  wingPhase: number;\n  wingSpeed: number;\n  size: number;\n  hue: number;\n  glowIntensity: number;\n  bobPhase: number;\n  bobSpeed: number;\n  trail: { x: number; y: number; alpha: number }[];\n  state: 'flying' | 'hovering' | 'attracted';\n  sparkleTimer: number;\n}\n\n// Rival snake - spectral AI nemesis that competes for food\ninterface RivalSnake {\n  segments: { x: number; y: number }[];\n  direction: { dx: number; dy: number };\n  targetX: number;\n  targetY: number;\n  moveTimer: number;\n  moveInterval: number;\n  pulsePhase: number;\n  glowIntensity: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n  energyTrail: { x: number; y: number; alpha: number; size: number }[];\n  state: 'hunting' | 'fleeing' | 'circling';\n  aggression: number;\n  nearMissTimer: number;\n  electricArcs: { x1: number; y1: number; x2: number; y2: number; life: number }[];\n}\n\nconst RIVAL_SNAKE_LENGTH = 10;\nconst RIVAL_MOVE_INTERVAL = 8;\n\n// Armageddon Chaos effect types\ninterface GroundFissure {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  width: number;\n  glowIntensity: number;\n  pulsePhase: number;\n}\n\ninterface FireRainParticle {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n}\n\ninterface ChaosExplosion {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n  rings: { radius: number; alpha: number }[];\n  debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[];\n}\n\ninterface ApocalypticSkull {\n  x: number;\n  y: number;\n  size: number;\n  alpha: number;\n  rotation: number;\n  pulsePhase: number;\n}\n\nconst NUM_FISSURES = 6;\nconst MAX_FIRE_RAIN = 30;\nconst MAX_CHAOS_EXPLOSIONS = 3;\nconst NUM_SKULLS = 4;\n\n// High score entry for scoreboard\ninterface HighScoreEntry {\n  score: number;\n  date: number;\n  rank: number;\n}\n\nconst MAX_HIGH_SCORES = 5;\n\n// Color palette - HALLOWEEN theme: spooky purple/orange, ghostly greens, pumpkin glow\nconst COLORS = {\n  bgDark: 0x0a0012,\n  bgMid: 0x150825,\n  gridLine: 0x2a1540,\n  gridAccent: 0x401860,\n  snakeHead: 0x00ff66,\n  snakeBody: 0x00cc55,\n  snakeTail: 0x009944,\n  snakeHighlight: 0x66ffaa,\n  snakeScale: 0x00aa44,\n  snakeEye: 0xff0000,\n  snakePupil: 0x000000,\n  snakeGlow: 0x00ff80,\n  food: 0xff6600,\n  foodCore: 0xffcc00,\n  foodGlow: 0xff8800,\n  foodParticle: 0xffaa00,\n  star: 0x8844ff,\n  gameOverOverlay: 0x0a0015,\n  gameOverText: 0xff6600,\n  plasma1: 0x9933ff,\n  plasma2: 0xbb55ff,\n  plasma3: 0x7722cc,\n  screenFlash: 0xff6600,\n  // Halloween specific colors\n  noirWhite: 0xeeddff,\n  noirGray: 0x8866aa,\n  noirDark: 0x2a1540,\n  spotlight: 0xff8800,\n  // Halloween additions\n  chaosRed: 0x9933ff,\n  chaosOrange: 0xff6600,\n  chaosYellow: 0xffcc00,\n  lavaGlow: 0x9944ff,\n  ashGray: 0x554466,\n  bloodRed: 0x660088,\n  hellfire: 0xff6600,\n  // New Halloween colors\n  pumpkinOrange: 0xff6600,\n  ghostWhite: 0xeeffee,\n  witchPurple: 0x9933ff,\n  spiderBlack: 0x111122,\n  candyCorn1: 0xffcc00,\n  candyCorn2: 0xff8800,\n  candyCorn3: 0xffffff,\n};\n\nexport class SnakeScene extends Phaser.Scene {\n  private graphics!: Phaser.GameObjects.Graphics;\n  private currentState: GameState | null = null;\n  private needsRedraw = false;\n  private frameCount = 0;\n  private stars: Star[] = [];\n  private foodParticles: FoodParticle[] = [];\n  private trailParticles: SnakeTrailParticle[] = [];\n  private shockWaves: ShockWave[] = [];\n  private lightningBolts: LightningBolt[] = [];\n  private plasmaWaves: PlasmaWave[] = [];\n  private snakeAfterimages: SnakeAfterimage[] = [];\n  private auroraWaves: AuroraWave[] = [];\n  private nebulaClouds: NebulaCloud[] = [];\n  private vortexRings: VortexRing[] = [];\n  private vortexParticles: VortexParticle[] = [];\n  private vortexPulse = 0;\n  private meteors: Meteor[] = [];\n  private deathDebris: DeathDebris[] = [];\n  private deathExplosionPhase = 0;\n  private gameOverAlpha = 0;\n  private lastHeadPos: Position | null = null;\n  private lastSnakeLength = 0;\n  private hueOffset = 0;\n  private screenFlashAlpha = 0;\n  private gameOverGlitchOffset = 0;\n  private screenShakeX = 0;\n  private screenShakeY = 0;\n  private screenShakeIntensity = 0;\n  private energyFieldPulse = 0;\n  private foodBurstParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number; hue: number; trail: { x: number; y: number }[] }[] = [];\n  private chromaticIntensity = 0;\n  // Film noir effects\n  private venetianPhase = 0;\n  private spotlightX = 0;\n  private spotlightY = 0;\n  private smokeParticles: { x: number; y: number; vx: number; vy: number; size: number; alpha: number; life: number }[] = [];\n  private guardianSpirits: GuardianSpirit[] = [];\n  // Burning flame particles trailing behind snake\n  private flameParticles: FlameParticle[] = [];\n  // Comet trail system - historical positions for smooth ribbon trail\n  private cometTrail: CometTrailSegment[] = [];\n  // Ethereal particles that drift away from the trail\n  private etherealParticles: EtherealParticle[] = [];\n  // Track last few head positions for smooth interpolation\n  private headHistory: { x: number; y: number; time: number }[] = [];\n  // Thrown food animation system\n  private thrownFood: ThrownFood | null = null;\n  private lastFoodPos: Position | null = null;\n  // Mystical bees swarming around\n  private bees: MysticalBee[] = [];\n  // Rival snake - spectral AI nemesis\n  private rivalSnake: RivalSnake | null = null;\n  // Scoreboard system\n  private highScores: HighScoreEntry[] = [];\n  private highScoresLoaded = false;\n  private newHighScoreRank = -1;\n  private scoreboardAnimPhase = 0;\n  private scoreboardRevealProgress = 0;\n  private lastGameOverState = false;\n  private hudPulsePhase = 0;\n  private lastHudScore = 0;\n  private scoreFlashIntensity = 0;\n  // Armageddon Chaos effects\n  private groundFissures: GroundFissure[] = [];\n  private fireRainParticles: FireRainParticle[] = [];\n  private chaosExplosions: ChaosExplosion[] = [];\n  private apocalypticSkulls: ApocalypticSkull[] = [];\n  private armageddonPulse = 0;\n  private chaosIntensity = 0;\n  private cleanEffects: CleanEffectsState = createCleanEffectsState();\n\n  constructor() {\n    super({ key: 'SnakeScene' });\n  }\n\n  create(): void {\n    this.graphics = this.add.graphics();\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    initMotes(this.cleanEffects, width, height);\n    initSnowflakes(this.cleanEffects, width, height);\n\n    if (this.currentState) {\n      this.needsRedraw = true;\n    }\n  }\n\n  private initArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Initialize ground fissures - cracks in the earth with lava\n    this.groundFissures = [];\n    for (let i = 0; i < NUM_FISSURES; i++) {\n      const startX = Math.random() * width;\n      const startY = Math.random() * height;\n      const angle = Math.random() * Math.PI;\n      const length = 40 + Math.random() * 80;\n      this.groundFissures.push({\n        x1: startX,\n        y1: startY,\n        x2: startX + Math.cos(angle) * length,\n        y2: startY + Math.sin(angle) * length,\n        width: 2 + Math.random() * 4,\n        glowIntensity: 0.5 + Math.random() * 0.5,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n\n    // Initialize fire rain\n    this.fireRainParticles = [];\n\n    // Initialize chaos explosions\n    this.chaosExplosions = [];\n\n    // Initialize apocalyptic skulls floating in background\n    this.apocalypticSkulls = [];\n    for (let i = 0; i < NUM_SKULLS; i++) {\n      this.apocalypticSkulls.push({\n        x: 30 + Math.random() * (width - 60),\n        y: 30 + Math.random() * (height - 60),\n        size: 15 + Math.random() * 10,\n        alpha: 0.03 + Math.random() * 0.04,\n        rotation: Math.random() * Math.PI * 2,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n  }\n\n  private initSmokeParticles(): void {\n    this.smokeParticles = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < 12; i++) {\n      this.smokeParticles.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        vx: (Math.random() - 0.5) * 0.3,\n        vy: -0.1 - Math.random() * 0.2,\n        size: 30 + Math.random() * 50,\n        alpha: 0.02 + Math.random() * 0.03,\n        life: Math.random(),\n      });\n    }\n  }\n\n  private updateArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    this.armageddonPulse += 0.04;\n\n    // Update ground fissures - pulsing lava glow\n    for (const fissure of this.groundFissures) {\n      fissure.pulsePhase += 0.06;\n      fissure.glowIntensity = 0.5 + Math.sin(fissure.pulsePhase) * 0.3;\n    }\n\n    // Spawn fire rain particles\n    if (this.fireRainParticles.length < MAX_FIRE_RAIN && Math.random() < 0.3) {\n      const hueVariation = Math.random();\n      this.fireRainParticles.push({\n        x: Math.random() * width,\n        y: -20,\n        vy: 2 + Math.random() * 3,\n        size: 2 + Math.random() * 4,\n        alpha: 0.6 + Math.random() * 0.4,\n        hue: hueVariation < 0.6 ? 0 : (hueVariation < 0.85 ? 20 : 40), // Red, orange, yellow\n        trail: [],\n      });\n    }\n\n    // Update fire rain\n    for (let i = this.fireRainParticles.length - 1; i >= 0; i--) {\n      const p = this.fireRainParticles[i];\n      p.trail.unshift({ x: p.x, y: p.y, alpha: p.alpha });\n      if (p.trail.length > 6) p.trail.pop();\n      for (const t of p.trail) { t.alpha *= 0.7; }\n\n      p.y += p.vy;\n      p.x += Math.sin(this.armageddonPulse + p.y * 0.05) * 0.3;\n      p.alpha *= 0.995;\n\n      if (p.y > height + 20 || p.alpha < 0.05) {\n        this.fireRainParticles.splice(i, 1);\n      }\n    }\n\n    // Update chaos explosions\n    for (let i = this.chaosExplosions.length - 1; i >= 0; i--) {\n      const exp = this.chaosExplosions[i];\n      exp.radius += 4;\n      exp.life -= 0.03;\n\n      for (const ring of exp.rings) {\n        ring.radius += 3;\n        ring.alpha *= 0.92;\n      }\n      exp.rings = exp.rings.filter(r => r.alpha > 0.02);\n\n      for (const d of exp.debris) {\n        d.x += d.vx;\n        d.y += d.vy;\n        d.vy += 0.1;\n        d.alpha *= 0.96;\n      }\n      exp.debris = exp.debris.filter(d => d.alpha > 0.02);\n\n      if (exp.life <= 0 && exp.rings.length === 0 && exp.debris.length === 0) {\n        this.chaosExplosions.splice(i, 1);\n      }\n    }\n\n    // Update apocalyptic skulls - slow drift and pulse\n    for (const skull of this.apocalypticSkulls) {\n      skull.pulsePhase += 0.02;\n      skull.rotation += 0.002;\n      skull.x += Math.sin(skull.pulsePhase * 0.5) * 0.1;\n      skull.y += Math.cos(skull.pulsePhase * 0.3) * 0.1;\n\n      // Keep in bounds\n      if (skull.x < 20) skull.x = 20;\n      if (skull.x > width - 20) skull.x = width - 20;\n      if (skull.y < 20) skull.y = 20;\n      if (skull.y > height - 20) skull.y = height - 20;\n    }\n\n    // Chaos intensity increases when snake eats or dies\n    this.chaosIntensity *= 0.97;\n  }\n\n  private spawnChaosExplosion(x: number, y: number): void {\n    if (this.chaosExplosions.length >= MAX_CHAOS_EXPLOSIONS) {\n      this.chaosExplosions.shift();\n    }\n\n    const debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[] = [];\n    for (let i = 0; i < 12; i++) {\n      const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 5;\n      debris.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 2,\n        size: 2 + Math.random() * 4,\n        alpha: 1,\n      });\n    }\n\n    this.chaosExplosions.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: 80,\n      life: 1,\n      rings: [\n        { radius: 10, alpha: 1 },\n        { radius: 5, alpha: 0.8 },\n        { radius: 15, alpha: 0.6 },\n      ],\n      debris,\n    });\n\n    this.chaosIntensity = Math.min(1, this.chaosIntensity + 0.5);\n    this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 12);\n  }\n\n  private drawArmageddonBackground(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Spooky Halloween night sky\n    const skyPulse = 0.8 + Math.sin(this.armageddonPulse * 0.5) * 0.2;\n\n    // Layer 1: Deep purple-black night base\n    g.fillStyle(0x0a0018, 1);\n    g.fillRect(0, 0, width, height);\n\n    // Layer 2: Eerie purple glow from below (like fog)\n    g.fillStyle(0x200840, 0.3 * skyPulse);\n    g.fillRect(0, height * 0.7, width, height * 0.3);\n\n    // Layer 3: Misty purple clouds\n    for (let i = 0; i < 4; i++) {\n      const cloudY = i * 30 + Math.sin(this.armageddonPulse + i) * 10;\n      const cloudAlpha = 0.1 - i * 0.02;\n      g.fillStyle(0x301040, cloudAlpha * skyPulse);\n      g.fillRect(0, cloudY, width, 40);\n    }\n\n    // Draw haunted moon\n    this.drawHauntedMoon(g, width);\n\n    // Draw flying bats in background\n    this.drawFlyingBats(g, width, height);\n\n    // Draw apocalyptic skulls (very faint, background layer)\n    this.drawApocalypticSkulls(g);\n  }\n\n  private drawHauntedMoon(g: Phaser.GameObjects.Graphics, width: number): void {\n    const moonX = width * 0.8;\n    const moonY = 60;\n    const moonRadius = 35;\n    const moonPulse = 0.9 + Math.sin(this.frameCount * 0.02) * 0.1;\n\n    // Moon glow\n    g.fillStyle(0xff8800, 0.1 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 2);\n    g.fillStyle(0xffaa00, 0.15 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 1.5);\n\n    // Main moon (orange harvest moon)\n    g.fillStyle(0xffaa33, 0.9);\n    g.fillCircle(moonX, moonY, moonRadius);\n\n    // Moon craters\n    g.fillStyle(0xcc8822, 0.4);\n    g.fillCircle(moonX - 10, moonY - 5, 8);\n    g.fillCircle(moonX + 12, moonY + 8, 6);\n    g.fillCircle(moonX - 5, moonY + 12, 5);\n  }\n\n  private drawFlyingBats(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const batCount = 6;\n    for (let i = 0; i < batCount; i++) {\n      const phase = this.frameCount * 0.03 + i * 1.5;\n      const batX = ((i * 127 + this.frameCount * 0.5) % (width + 100)) - 50;\n      const batY = 40 + i * 20 + Math.sin(phase) * 15;\n      const wingPhase = Math.sin(this.frameCount * 0.15 + i * 2);\n\n      // Bat body\n      g.fillStyle(0x111122, 0.8);\n      g.fillCircle(batX, batY, 4);\n\n      // Bat wings (flapping)\n      const wingSpread = 8 + wingPhase * 4;\n      g.fillStyle(0x111122, 0.7);\n\n      // Left wing\n      g.beginPath();\n      g.moveTo(batX - 2, batY);\n      g.lineTo(batX - wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX - wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n\n      // Right wing\n      g.beginPath();\n      g.moveTo(batX + 2, batY);\n      g.lineTo(batX + wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX + wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawGroundFissures(g: Phaser.GameObjects.Graphics): void {\n    for (const fissure of this.groundFissures) {\n      const pulse = fissure.glowIntensity;\n\n      // Ghostly purple glow underneath\n      g.lineStyle(fissure.width * 3, COLORS.lavaGlow, 0.12 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Crack edges (dark purple)\n      g.lineStyle(fissure.width + 2, 0x200030, 0.4);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ethereal core (bright purple)\n      g.lineStyle(fissure.width, COLORS.witchPurple, 0.3 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ghostly white center\n      g.lineStyle(fissure.width * 0.3, COLORS.ghostWhite, 0.2 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n    }\n  }\n\n  private drawFireRain(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.fireRainParticles) {\n      // Draw ghostly trail\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailSize = p.size * (1 - i / p.trail.length) * 0.6;\n        // Ghostly purple/green trail\n        const ghostHue = 0.75 + (p.hue % 60) / 360;\n        const trailColor = this.hslToRgb(ghostHue, 0.6, 0.6);\n        g.fillStyle(trailColor, t.alpha * 0.3);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Main spirit particle (ghostly appearance)\n      const outerColor = this.hslToRgb(0.8, 0.5, 0.5);\n      const coreColor = this.hslToRgb(0.85, 0.3, 0.8);\n\n      g.fillStyle(outerColor, p.alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      g.fillStyle(coreColor, p.alpha * 0.6);\n      g.fillCircle(p.x, p.y, p.size);\n\n      g.fillStyle(COLORS.ghostWhite, p.alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawChaosExplosions(g: Phaser.GameObjects.Graphics): void {\n    for (const exp of this.chaosExplosions) {\n      // Central flash\n      if (exp.life > 0.7) {\n        const flashAlpha = (exp.life - 0.7) * 3;\n        g.fillStyle(0xffffff, flashAlpha * 0.5);\n        g.fillCircle(exp.x, exp.y, exp.radius * 0.5);\n        g.fillStyle(COLORS.chaosYellow, flashAlpha * 0.4);\n        g.fillCircle(exp.x, exp.y, exp.radius);\n      }\n\n      // Expanding rings\n      for (const ring of exp.rings) {\n        g.lineStyle(4, COLORS.chaosRed, ring.alpha * 0.5);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(2, COLORS.chaosOrange, ring.alpha * 0.7);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(1, 0xffffff, ring.alpha * 0.4);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n      }\n\n      // Flying debris\n      for (const d of exp.debris) {\n        g.fillStyle(COLORS.chaosOrange, d.alpha * 0.6);\n        g.fillCircle(d.x, d.y, d.size * 1.3);\n        g.fillStyle(COLORS.chaosYellow, d.alpha * 0.9);\n        g.fillCircle(d.x, d.y, d.size);\n      }\n    }\n  }\n\n  private drawApocalypticSkulls(g: Phaser.GameObjects.Graphics): void {\n    for (const skull of this.apocalypticSkulls) {\n      const pulse = 0.7 + Math.sin(skull.pulsePhase) * 0.3;\n      const alpha = skull.alpha * pulse;\n      const s = skull.size;\n\n      // Ghostly purple glow\n      g.fillStyle(COLORS.witchPurple, alpha * 0.2);\n      g.fillCircle(skull.x, skull.y, s * 1.5);\n\n      // Skull outline (bone white)\n      g.fillStyle(0xcccccc, alpha * 0.8);\n      // Cranium\n      g.fillCircle(skull.x, skull.y - s * 0.1, s * 0.8);\n      // Jaw\n      g.fillRect(skull.x - s * 0.4, skull.y + s * 0.3, s * 0.8, s * 0.4);\n\n      // Eye sockets (glowing green - spooky!)\n      g.fillStyle(COLORS.snakeHead, alpha * 1.2);\n      g.fillCircle(skull.x - s * 0.25, skull.y - s * 0.1, s * 0.2);\n      g.fillCircle(skull.x + s * 0.25, skull.y - s * 0.1, s * 0.2);\n\n      // Nose hole\n      g.fillStyle(0x000000, alpha);\n      g.fillTriangle(\n        skull.x, skull.y + s * 0.1,\n        skull.x - s * 0.1, skull.y + s * 0.25,\n        skull.x + s * 0.1, skull.y + s * 0.25\n      );\n    }\n  }\n\n  private drawChaosOverlay(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (this.chaosIntensity <= 0) return;\n\n    // Purple tint overlay when chaos is active\n    g.fillStyle(COLORS.witchPurple, this.chaosIntensity * 0.1);\n    g.fillRect(0, 0, width, height);\n\n    // Pulsing purple vignette edges\n    const vignetteAlpha = this.chaosIntensity * 0.25;\n    g.lineStyle(80, COLORS.bloodRed, vignetteAlpha);\n    g.strokeRect(-40, -40, width + 80, height + 80);\n  }\n\n  private initGuardianSpirits(): void {\n    this.guardianSpirits = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const spiritHues = [180, 220, 280, 320];\n\n    const edges: ('top' | 'bottom' | 'left' | 'right')[] = ['top', 'bottom', 'left', 'right'];\n    for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      const edge = edges[edgeIndex];\n      for (let i = 0; i < NUM_SPIRITS_PER_EDGE; i++) {\n        let x = 0, y = 0;\n        const offset = (i + 0.5) / NUM_SPIRITS_PER_EDGE;\n\n        switch (edge) {\n          case 'top':\n            x = width * offset;\n            y = -15;\n            break;\n          case 'bottom':\n            x = width * offset;\n            y = height + 15;\n            break;\n          case 'left':\n            x = -15;\n            y = height * offset;\n            break;\n          case 'right':\n            x = width + 15;\n            y = height * offset;\n            break;\n        }\n\n        const orbs: { angle: number; distance: number; size: number; speed: number }[] = [];\n        const numOrbs = 3;\n        for (let o = 0; o < numOrbs; o++) {\n          orbs.push({\n            angle: (o / numOrbs) * Math.PI * 2,\n            distance: 15 + Math.random() * 10,\n            size: 3 + Math.random() * 2,\n            speed: 0.03 + Math.random() * 0.02,\n          });\n        }\n\n        this.guardianSpirits.push({\n          x,\n          y,\n          baseX: x,\n          baseY: y,\n          size: 20 + Math.random() * 10,\n          phase: Math.random() * Math.PI * 2,\n          speed: 0.015 + Math.random() * 0.01,\n          haloPhase: Math.random() * Math.PI * 2,\n          orbPhase: Math.random() * Math.PI * 2,\n          edge,\n          targetAlpha: 0.4 + Math.random() * 0.2,\n          currentAlpha: 0,\n          hue: spiritHues[edgeIndex % spiritHues.length] + Math.random() * 30 - 15,\n          orbs,\n        });\n      }\n    }\n  }\n\n  private initBees(): void {\n    this.bees = [];\n  }\n\n  private initRivalSnake(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    const startX = width - 50 - Math.random() * 50;\n    const startY = height - 50 - Math.random() * 50;\n\n    const segments: { x: number; y: number }[] = [];\n    for (let i = 0; i < RIVAL_SNAKE_LENGTH; i++) {\n      segments.push({\n        x: startX + i * CELL_SIZE * 0.6,\n        y: startY,\n      });\n    }\n\n    this.rivalSnake = {\n      segments,\n      direction: { dx: -1, dy: 0 },\n      targetX: width / 2,\n      targetY: height / 2,\n      moveTimer: 0,\n      moveInterval: RIVAL_MOVE_INTERVAL,\n      pulsePhase: 0,\n      glowIntensity: 0.8,\n      hue: 200,\n      trail: [],\n      energyTrail: [],\n      state: 'hunting',\n      aggression: 0.5,\n      nearMissTimer: 0,\n      electricArcs: [],\n    };\n  }\n\n  private updateRivalSnake(): void {\n    if (!this.rivalSnake || !this.currentState) return;\n\n    const rs = this.rivalSnake;\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    rs.pulsePhase += 0.1;\n    rs.glowIntensity = 0.6 + Math.sin(rs.pulsePhase) * 0.3;\n\n    if (rs.segments.length > 0) {\n      rs.trail.unshift({ x: rs.segments[0].x, y: rs.segments[0].y, alpha: 0.7 });\n      if (rs.trail.length > 20) rs.trail.pop();\n\n      rs.energyTrail.unshift({\n        x: rs.segments[0].x + (Math.random() - 0.5) * 8,\n        y: rs.segments[0].y + (Math.random() - 0.5) * 8,\n        alpha: 0.8,\n        size: 3 + Math.random() * 4\n      });\n      if (rs.energyTrail.length > 30) rs.energyTrail.pop();\n    }\n\n    for (const t of rs.trail) {\n      t.alpha *= 0.92;\n    }\n    rs.trail = rs.trail.filter(t => t.alpha > 0.02);\n\n    for (const e of rs.energyTrail) {\n      e.alpha *= 0.88;\n      e.size *= 0.95;\n    }\n    rs.energyTrail = rs.energyTrail.filter(e => e.alpha > 0.02);\n\n    rs.electricArcs = rs.electricArcs.filter(arc => {\n      arc.life -= 0.15;\n      return arc.life > 0;\n    });\n\n    if (rs.nearMissTimer > 0) rs.nearMissTimer--;\n\n    const playerHead = this.currentState.snake[0];\n    const playerX = playerHead.x * CELL_SIZE + CELL_SIZE / 2;\n    const playerY = playerHead.y * CELL_SIZE + CELL_SIZE / 2;\n    const rivalHead = rs.segments[0];\n    const distToPlayer = Math.sqrt(\n      Math.pow(playerX - rivalHead.x, 2) + Math.pow(playerY - rivalHead.y, 2)\n    );\n\n    if (distToPlayer < 60 && rs.nearMissTimer === 0) {\n      rs.nearMissTimer = 30;\n      rs.electricArcs.push({\n        x1: rivalHead.x,\n        y1: rivalHead.y,\n        x2: playerX,\n        y2: playerY,\n        life: 1.0\n      });\n      rs.aggression = Math.min(1.0, rs.aggression + 0.1);\n    }\n\n    rs.moveTimer++;\n    if (rs.moveTimer >= rs.moveInterval) {\n      rs.moveTimer = 0;\n\n      const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n      const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n      const distToFood = Math.sqrt(\n        Math.pow(foodX - rivalHead.x, 2) + Math.pow(foodY - rivalHead.y, 2)\n      );\n\n      if (distToPlayer < 80) {\n        rs.state = 'fleeing';\n        const fleeAngle = Math.atan2(rivalHead.y - playerY, rivalHead.x - playerX);\n        rs.targetX = rivalHead.x + Math.cos(fleeAngle) * 100;\n        rs.targetY = rivalHead.y + Math.sin(fleeAngle) * 100;\n      } else if (distToFood < 150 || rs.aggression > 0.7) {\n        rs.state = 'hunting';\n        rs.targetX = foodX;\n        rs.targetY = foodY;\n      } else {\n        rs.state = 'circling';\n        const circleAngle = rs.pulsePhase * 0.3;\n        rs.targetX = width / 2 + Math.cos(circleAngle) * 120;\n        rs.targetY = height / 2 + Math.sin(circleAngle) * 120;\n      }\n\n      rs.targetX = Math.max(30, Math.min(width - 30, rs.targetX));\n      rs.targetY = Math.max(30, Math.min(height - 30, rs.targetY));\n\n      const dx = rs.targetX - rivalHead.x;\n      const dy = rs.targetY - rivalHead.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 5) {\n        const targetDx = dx / dist;\n        const targetDy = dy / dist;\n        const turnSpeed = rs.state === 'fleeing' ? 0.5 : 0.35;\n\n        rs.direction.dx = rs.direction.dx * (1 - turnSpeed) + targetDx * turnSpeed;\n        rs.direction.dy = rs.direction.dy * (1 - turnSpeed) + targetDy * turnSpeed;\n\n        const len = Math.sqrt(rs.direction.dx * rs.direction.dx + rs.direction.dy * rs.direction.dy);\n        if (len > 0) {\n          rs.direction.dx /= len;\n          rs.direction.dy /= len;\n        }\n      }\n\n      const moveSpeed = rs.state === 'fleeing' ? CELL_SIZE * 0.7 : CELL_SIZE * 0.55;\n      const newHead = {\n        x: rivalHead.x + rs.direction.dx * moveSpeed,\n        y: rivalHead.y + rs.direction.dy * moveSpeed,\n      };\n\n      if (newHead.x < 10) newHead.x = width - 10;\n      if (newHead.x > width - 10) newHead.x = 10;\n      if (newHead.y < 10) newHead.y = height - 10;\n      if (newHead.y > height - 10) newHead.y = 10;\n\n      rs.segments.unshift(newHead);\n      rs.segments.pop();\n    } else {\n      const head = rs.segments[0];\n      const moveSpeed = CELL_SIZE * 0.5;\n\n      head.x += rs.direction.dx * moveSpeed * 0.06;\n      head.y += rs.direction.dy * moveSpeed * 0.06;\n\n      for (let i = 1; i < rs.segments.length; i++) {\n        const seg = rs.segments[i];\n        const prev = rs.segments[i - 1];\n        const pullStrength = 0.18;\n        seg.x += (prev.x - seg.x) * pullStrength;\n        seg.y += (prev.y - seg.y) * pullStrength;\n      }\n    }\n\n    if (this.currentState.gameOver) {\n      rs.hue = 180;\n      rs.glowIntensity *= 0.95;\n      rs.state = 'circling';\n    } else {\n      rs.hue = rs.state === 'hunting' ? 190 : (rs.state === 'fleeing' ? 220 : 200);\n      rs.hue += Math.sin(rs.pulsePhase * 0.5) * 10;\n    }\n\n    rs.aggression *= 0.998;\n  }\n\n  private drawRivalSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.rivalSnake || this.rivalSnake.segments.length === 0) return;\n\n    const rs = this.rivalSnake;\n    const pulse = rs.glowIntensity;\n\n    for (const arc of rs.electricArcs) {\n      this.drawElectricArc(g, arc.x1, arc.y1, arc.x2, arc.y2, arc.life);\n    }\n\n    for (const e of rs.energyTrail) {\n      g.fillStyle(this.hslToHex(rs.hue + 20, 80, 70), e.alpha * 0.6);\n      g.fillCircle(e.x, e.y, e.size);\n      g.fillStyle(this.hslToHex(rs.hue, 90, 85), e.alpha * 0.3);\n      g.fillCircle(e.x, e.y, e.size * 0.5);\n    }\n\n    for (let i = 0; i < rs.trail.length; i++) {\n      const t = rs.trail[i];\n      const trailSize = 5 * (1 - i / rs.trail.length);\n      g.fillStyle(this.hslToHex(rs.hue, 80, 55), t.alpha * 0.4);\n      g.fillCircle(t.x, t.y, trailSize * 2);\n      g.fillStyle(this.hslToHex(rs.hue + 30, 70, 70), t.alpha * 0.2);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    g.lineStyle(14, this.hslToHex(rs.hue, 70, 40), 0.2 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    g.lineStyle(8, this.hslToHex(rs.hue, 80, 55), 0.35 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    for (let i = rs.segments.length - 1; i >= 0; i--) {\n      const seg = rs.segments[i];\n      const t = rs.segments.length > 1 ? i / (rs.segments.length - 1) : 1;\n      const segmentPulse = pulse * (0.8 + Math.sin(rs.pulsePhase + i * 0.4) * 0.2);\n\n      const baseSize = 7 + t * 5;\n      const size = baseSize * (0.9 + segmentPulse * 0.15);\n\n      g.fillStyle(this.hslToHex(rs.hue - 10, 60, 35), 0.15 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 2.8);\n\n      g.fillStyle(this.hslToHex(rs.hue, 75, 50), 0.3 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 1.6);\n\n      g.fillStyle(this.hslToHex(rs.hue + 10, 85, 65), 0.6 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size);\n\n      g.fillStyle(this.hslToHex(rs.hue + 40, 60, 90), 0.5 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 0.35);\n\n      if (i === 0) {\n        const dx = rs.direction.dx;\n        const dy = rs.direction.dy;\n        const perpX = -dy;\n        const perpY = dx;\n\n        g.fillStyle(this.hslToHex(rs.hue, 90, 70), 0.3);\n        g.fillCircle(seg.x - dx * 3, seg.y - dy * 3, size * 1.8);\n\n        const eyeOffset = 4;\n        const eyeForward = 5;\n        const leftEyeX = seg.x + perpX * eyeOffset + dx * eyeForward;\n        const leftEyeY = seg.y + perpY * eyeOffset + dy * eyeForward;\n        const rightEyeX = seg.x - perpX * eyeOffset + dx * eyeForward;\n        const rightEyeY = seg.y - perpY * eyeOffset + dy * eyeForward;\n\n        const eyeColor = rs.state === 'hunting' ? 0xff4444 :\n                         rs.state === 'fleeing' ? 0xffff44 : 0x44ffff;\n\n        g.fillStyle(0x000000, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 4);\n        g.fillCircle(rightEyeX, rightEyeY, 4);\n\n        g.fillStyle(eyeColor, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 3);\n        g.fillCircle(rightEyeX, rightEyeY, 3);\n\n        g.fillStyle(0xffffff, 0.95 * segmentPulse);\n        g.fillCircle(leftEyeX + dx, leftEyeY + dy, 1.2);\n        g.fillCircle(rightEyeX + dx, rightEyeY + dy, 1.2);\n\n        const hornLength = 8;\n        const hornAngle = 0.4;\n        g.lineStyle(3, this.hslToHex(rs.hue - 20, 70, 45), 0.8 * segmentPulse);\n        g.beginPath();\n        g.moveTo(seg.x + perpX * 5, seg.y + perpY * 5);\n        g.lineTo(\n          seg.x + perpX * 5 + Math.cos(Math.atan2(dy, dx) - hornAngle) * hornLength,\n          seg.y + perpY * 5 + Math.sin(Math.atan2(dy, dx) - hornAngle) * hornLength\n        );\n        g.strokePath();\n        g.beginPath();\n        g.moveTo(seg.x - perpX * 5, seg.y - perpY * 5);\n        g.lineTo(\n          seg.x - perpX * 5 + Math.cos(Math.atan2(dy, dx) + hornAngle) * hornLength,\n          seg.y - perpY * 5 + Math.sin(Math.atan2(dy, dx) + hornAngle) * hornLength\n        );\n        g.strokePath();\n      }\n    }\n  }\n\n  private drawElectricArc(g: Phaser.GameObjects.Graphics, x1: number, y1: number, x2: number, y2: number, life: number): void {\n    const segments = 6;\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n    const jitter = 15 * life;\n\n    g.lineStyle(4, 0x00ffff, 0.2 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter;\n      const jy = (Math.random() - 0.5) * jitter;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(2, 0x88ffff, 0.5 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter * 0.5;\n      const jy = (Math.random() - 0.5) * jitter * 0.5;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(1, 0xffffff, 0.8 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    g.lineTo(x2, y2);\n    g.strokePath();\n  }\n\n  private spawnBee(): void {\n    if (this.bees.length >= NUM_BEES) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Spawn from random edge\n    const edge = Math.floor(Math.random() * 4);\n    let x: number, y: number;\n\n    switch (edge) {\n      case 0: // top\n        x = Math.random() * width;\n        y = -20;\n        break;\n      case 1: // right\n        x = width + 20;\n        y = Math.random() * height;\n        break;\n      case 2: // bottom\n        x = Math.random() * width;\n        y = height + 20;\n        break;\n      default: // left\n        x = -20;\n        y = Math.random() * height;\n        break;\n    }\n\n    // Random target inside the play area\n    const targetX = 50 + Math.random() * (width - 100);\n    const targetY = 50 + Math.random() * (height - 100);\n\n    this.bees.push({\n      x,\n      y,\n      vx: 0,\n      vy: 0,\n      targetX,\n      targetY,\n      wingPhase: Math.random() * Math.PI * 2,\n      wingSpeed: 0.4 + Math.random() * 0.2,\n      size: 6 + Math.random() * 3,\n      hue: 0 + Math.random() * 20, // Crimson/red volcanic color\n      glowIntensity: 0.5 + Math.random() * 0.5,\n      bobPhase: Math.random() * Math.PI * 2,\n      bobSpeed: 0.08 + Math.random() * 0.04,\n      trail: [],\n      state: 'flying',\n      sparkleTimer: 0,\n    });\n  }\n\n  private updateBees(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n    const gameOver = this.currentState.gameOver;\n\n    // Randomly spawn new bees\n    if (!gameOver && Math.random() < BEE_SPAWN_CHANCE && this.bees.length < NUM_BEES) {\n      this.spawnBee();\n    }\n\n    for (let i = this.bees.length - 1; i >= 0; i--) {\n      const bee = this.bees[i];\n\n      // Update wing animation\n      bee.wingPhase += bee.wingSpeed;\n      bee.bobPhase += bee.bobSpeed;\n      bee.sparkleTimer += 0.1;\n\n      // Store trail position\n      if (this.frameCount % 2 === 0) {\n        bee.trail.unshift({ x: bee.x, y: bee.y, alpha: 0.6 });\n        if (bee.trail.length > 8) bee.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of bee.trail) {\n        t.alpha *= 0.85;\n      }\n      bee.trail = bee.trail.filter(t => t.alpha > 0.05);\n\n      // Bees are attracted to food\n      const dxFood = foodX - bee.x;\n      const dyFood = foodY - bee.y;\n      const distFood = Math.sqrt(dxFood * dxFood + dyFood * dyFood);\n\n      // Determine behavior based on distance to food\n      if (distFood < 80) {\n        bee.state = 'attracted';\n        bee.targetX = foodX + Math.cos(bee.bobPhase * 3) * 30;\n        bee.targetY = foodY + Math.sin(bee.bobPhase * 3) * 30;\n      } else if (distFood < 150) {\n        bee.state = 'hovering';\n        // Circle around food loosely\n        const angle = Math.atan2(dyFood, dxFood) + Math.sin(bee.bobPhase) * 0.5;\n        bee.targetX = foodX - Math.cos(angle) * 60;\n        bee.targetY = foodY - Math.sin(angle) * 60;\n      } else {\n        bee.state = 'flying';\n        // Wander towards food with some randomness\n        if (Math.random() < 0.02) {\n          bee.targetX = foodX + (Math.random() - 0.5) * 200;\n          bee.targetY = foodY + (Math.random() - 0.5) * 200;\n        }\n      }\n\n      // Move towards target with smooth steering\n      const dx = bee.targetX - bee.x;\n      const dy = bee.targetY - bee.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 1) {\n        const speed = bee.state === 'attracted' ? 2.5 : (bee.state === 'hovering' ? 1.5 : 2);\n        const ax = (dx / dist) * speed * 0.1;\n        const ay = (dy / dist) * speed * 0.1;\n\n        bee.vx += ax;\n        bee.vy += ay;\n\n        // Add bobbing motion\n        bee.vy += Math.sin(bee.bobPhase) * 0.05;\n      }\n\n      // Limit velocity\n      const maxSpeed = bee.state === 'attracted' ? 3 : 2;\n      const currentSpeed = Math.sqrt(bee.vx * bee.vx + bee.vy * bee.vy);\n      if (currentSpeed > maxSpeed) {\n        bee.vx = (bee.vx / currentSpeed) * maxSpeed;\n        bee.vy = (bee.vy / currentSpeed) * maxSpeed;\n      }\n\n      // Apply velocity with damping\n      bee.x += bee.vx;\n      bee.y += bee.vy;\n      bee.vx *= 0.95;\n      bee.vy *= 0.95;\n\n      // Pulsing glow when near food\n      if (bee.state === 'attracted') {\n        bee.glowIntensity = 0.7 + Math.sin(bee.bobPhase * 4) * 0.3;\n      } else {\n        bee.glowIntensity = 0.5 + Math.sin(bee.bobPhase * 2) * 0.2;\n      }\n\n      // Remove bees that fly too far off screen\n      if (bee.x < -100 || bee.x > width + 100 || bee.y < -100 || bee.y > height + 100) {\n        this.bees.splice(i, 1);\n      }\n\n      // Scatter bees on game over\n      if (gameOver) {\n        bee.targetX = bee.x + (Math.random() - 0.5) * 400;\n        bee.targetY = bee.y - 200 - Math.random() * 200;\n        bee.vx += (Math.random() - 0.5) * 2;\n        bee.vy -= 1 + Math.random();\n      }\n    }\n  }\n\n  private drawBees(g: Phaser.GameObjects.Graphics): void {\n    for (const bee of this.bees) {\n      const { x, y, size, wingPhase, hue, glowIntensity, trail, state, sparkleTimer } = bee;\n\n      // Draw trail\n      for (let i = 0; i < trail.length; i++) {\n        const t = trail[i];\n        const trailSize = size * 0.4 * (1 - i / trail.length);\n        g.fillStyle(this.hslToHex(hue, 80, 60), t.alpha * 0.4);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      const glowSize = size * 2 * glowIntensity;\n      g.fillStyle(this.hslToHex(hue, 90, 50), 0.2 * glowIntensity);\n      g.fillCircle(x, y, glowSize);\n\n      // Mid glow\n      g.fillStyle(this.hslToHex(hue, 85, 60), 0.3 * glowIntensity);\n      g.fillCircle(x, y, glowSize * 0.6);\n\n      // Bee body - striped pattern\n      const bodyLength = size * 1.2;\n      const bodyWidth = size * 0.7;\n\n      // Body shadow/glow\n      g.fillStyle(this.hslToHex(hue, 70, 30), 0.5);\n      g.fillEllipse(x, y, bodyLength + 2, bodyWidth + 2);\n\n      // Main body (amber/golden)\n      g.fillStyle(this.hslToHex(hue, 90, 55), 1);\n      g.fillEllipse(x, y, bodyLength, bodyWidth);\n\n      // Dark stripes\n      g.fillStyle(0x1a1a1a, 0.8);\n      g.fillRect(x - bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n      g.fillRect(x + bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n\n      // Head\n      g.fillStyle(this.hslToHex(hue - 10, 80, 40), 1);\n      g.fillCircle(x - bodyLength * 0.4, y, size * 0.4);\n\n      // Wings - animated flutter\n      const wingAngle = Math.sin(wingPhase) * 0.8;\n      const wingSize = size * 0.9;\n\n      // Wing glow (ethereal effect)\n      g.fillStyle(0xffffff, 0.2 + Math.abs(Math.sin(wingPhase)) * 0.2);\n      g.fillEllipse(x + Math.cos(wingAngle + 0.5) * wingSize * 0.3, y - wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n      g.fillEllipse(x + Math.cos(-wingAngle + 0.5) * wingSize * 0.3, y + wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n\n      // Wing bodies\n      g.fillStyle(0xffffff, 0.5 + Math.abs(Math.sin(wingPhase)) * 0.3);\n      g.fillEllipse(x + Math.cos(wingAngle) * wingSize * 0.2, y - wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n      g.fillEllipse(x + Math.cos(-wingAngle) * wingSize * 0.2, y + wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n\n      // Eyes\n      g.fillStyle(0x000000, 1);\n      g.fillCircle(x - bodyLength * 0.45, y - size * 0.12, size * 0.12);\n      g.fillCircle(x - bodyLength * 0.45, y + size * 0.12, size * 0.12);\n\n      // Sparkles when attracted to food\n      if (state === 'attracted' && Math.sin(sparkleTimer * 3) > 0.7) {\n        const sparkleAngle = sparkleTimer * 2;\n        const sparkleDist = size * 1.5;\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n\n        g.fillStyle(0xffffff, 0.8);\n        g.fillCircle(sparkleX, sparkleY, 2);\n        g.fillStyle(this.hslToHex(hue, 100, 80), 0.6);\n        g.fillCircle(sparkleX, sparkleY, 3);\n      }\n    }\n  }\n\n  // Helper to convert HSL to hex for Phaser\n  private hslToHex(h: number, s: number, l: number): number {\n    h = h / 360;\n    s = s / 100;\n    l = l / 100;\n\n    let r: number, g: number, b: number;\n\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    return (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255);\n  }\n\n  private updateGuardianSpirits(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const gameOver = this.currentState.gameOver;\n    const snakeHead = this.currentState.snake.length > 0 ? this.currentState.snake[0] : null;\n\n    for (const spirit of this.guardianSpirits) {\n      spirit.phase += spirit.speed;\n      spirit.haloPhase += 0.04;\n      spirit.orbPhase += 0.02;\n\n      for (const orb of spirit.orbs) {\n        orb.angle += orb.speed;\n      }\n\n      const floatAmount = gameOver ? 20 : 12;\n      const waveAmount = 5;\n      const wave = Math.sin(spirit.phase) * waveAmount;\n\n      let targetX = spirit.baseX;\n      let targetY = spirit.baseY;\n\n      switch (spirit.edge) {\n        case 'top':\n          targetY = spirit.baseY + floatAmount + wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'bottom':\n          targetY = spirit.baseY - floatAmount - wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'left':\n          targetX = spirit.baseX + floatAmount + wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'right':\n          targetX = spirit.baseX - floatAmount - wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n      }\n\n      if (snakeHead && !gameOver) {\n        const headX = snakeHead.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = snakeHead.y * CELL_SIZE + CELL_SIZE / 2;\n        const dx = spirit.x - headX;\n        const dy = spirit.y - headY;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        if (dist < 120) {\n          const attraction = (120 - dist) / 120 * 15;\n          targetX += (dx / dist) * attraction;\n          targetY += (dy / dist) * attraction;\n        }\n      }\n\n      spirit.x += (targetX - spirit.x) * 0.04;\n      spirit.y += (targetY - spirit.y) * 0.04;\n      spirit.x = Math.max(-50, Math.min(width + 50, spirit.x));\n      spirit.y = Math.max(-50, Math.min(height + 50, spirit.y));\n\n      const baseAlpha = gameOver ? 0.8 : spirit.targetAlpha;\n      spirit.currentAlpha += (baseAlpha - spirit.currentAlpha) * 0.05;\n    }\n  }\n\n  private drawGuardianSpirits(g: Phaser.GameObjects.Graphics): void {\n    for (const spirit of this.guardianSpirits) {\n      if (spirit.currentAlpha < 0.01) continue;\n\n      const { x, y, size, phase, haloPhase, currentAlpha, hue, orbs } = spirit;\n      const breathPulse = 1 + Math.sin(phase * 2) * 0.15;\n      const coreSize = size * breathPulse;\n\n      const spiritColor = this.hslToHex(hue, 0.7, 0.6);\n      const glowColor = this.hslToHex(hue, 0.5, 0.8);\n      const haloColor = this.hslToHex(hue, 0.3, 0.9);\n\n      g.fillStyle(glowColor, currentAlpha * 0.1);\n      g.fillCircle(x, y, coreSize * 2.5);\n\n      g.fillStyle(glowColor, currentAlpha * 0.15);\n      g.fillCircle(x, y, coreSize * 1.8);\n\n      const haloRadius = coreSize * 1.4 + Math.sin(haloPhase) * 3;\n      g.lineStyle(2, haloColor, currentAlpha * 0.4);\n      g.strokeCircle(x, y, haloRadius);\n\n      const innerHaloRadius = coreSize * 1.1 + Math.sin(haloPhase + 1) * 2;\n      g.lineStyle(1.5, haloColor, currentAlpha * 0.3);\n      g.strokeCircle(x, y, innerHaloRadius);\n\n      for (const orb of orbs) {\n        const orbX = x + Math.cos(orb.angle) * orb.distance;\n        const orbY = y + Math.sin(orb.angle) * orb.distance;\n        const orbPulse = 1 + Math.sin(phase + orb.angle) * 0.3;\n\n        g.fillStyle(glowColor, currentAlpha * 0.3);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse * 1.5);\n\n        g.fillStyle(spiritColor, currentAlpha * 0.8);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse);\n      }\n\n      g.fillStyle(spiritColor, currentAlpha * 0.9);\n      g.fillCircle(x, y, coreSize * 0.5);\n\n      g.fillStyle(0xffffff, currentAlpha * 0.7);\n      g.fillCircle(x, y, coreSize * 0.25);\n\n      const sparkleCount = 4;\n      for (let i = 0; i < sparkleCount; i++) {\n        const sparkleAngle = (i / sparkleCount) * Math.PI * 2 + phase * 0.5;\n        const sparkleDist = coreSize * (0.8 + Math.sin(phase * 2 + i) * 0.3);\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n        const sparkleSize = 1.5 + Math.sin(phase * 3 + i * 2) * 0.5;\n\n        g.fillStyle(0xffffff, currentAlpha * (0.4 + Math.sin(phase * 2 + i) * 0.3));\n        g.fillCircle(sparkleX, sparkleY, sparkleSize);\n      }\n    }\n  }\n\n  private initStars(): void {\n    this.stars = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_STARS; i++) {\n      this.stars.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: 0.5 + Math.random() * 1.5,\n        speed: 0.02 + Math.random() * 0.03,\n        brightness: 0.3 + Math.random() * 0.7,\n      });\n    }\n  }\n\n  private initPlasmaWaves(): void {\n    this.plasmaWaves = [];\n    const hues = [0, 15, 30]; // Red/orange volcanic variations\n    for (let i = 0; i < NUM_PLASMA_WAVES; i++) {\n      this.plasmaWaves.push({\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.015 + Math.random() * 0.01,\n        amplitude: 30 + Math.random() * 20,\n        wavelength: 80 + Math.random() * 40,\n        hue: hues[i % hues.length],\n      });\n    }\n  }\n\n  private initAuroraWaves(): void {\n    this.auroraWaves = [];\n    const height = GRID_SIZE * CELL_SIZE;\n    // Aurora hues: volcanic reds, oranges, crimsons\n    const auroraHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_AURORA_WAVES; i++) {\n      this.auroraWaves.push({\n        y: height * 0.2 + (height * 0.6 * i) / NUM_AURORA_WAVES,\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.008 + Math.random() * 0.006,\n        hue: auroraHues[i % auroraHues.length],\n        thickness: 25 + Math.random() * 20,\n        amplitude: 15 + Math.random() * 25,\n      });\n    }\n  }\n\n  private initNebulaClouds(): void {\n    this.nebulaClouds = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    // Volcanic smoke and lava glow colors: reds, oranges, crimsons\n    const nebulaHues = [0, 10, 20, 30, 350, 340];\n    for (let i = 0; i < NUM_NEBULA_CLOUDS; i++) {\n      this.nebulaClouds.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        radius: 40 + Math.random() * 60,\n        hue: nebulaHues[i % nebulaHues.length],\n        alpha: 0.04 + Math.random() * 0.04,\n        driftX: (Math.random() - 0.5) * 0.15,\n        driftY: (Math.random() - 0.5) * 0.15,\n        pulsePhase: Math.random() * Math.PI * 2,\n        pulseSpeed: 0.01 + Math.random() * 0.01,\n      });\n    }\n  }\n\n  private initVortex(): void {\n    this.vortexRings = [];\n    this.vortexParticles = [];\n\n    // Create concentric rings with different properties\n    const ringHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_VORTEX_RINGS; i++) {\n      const baseRadius = 25 + i * 18;\n      this.vortexRings.push({\n        radius: baseRadius,\n        baseRadius,\n        rotationOffset: (i * Math.PI * 2) / NUM_VORTEX_RINGS,\n        rotationSpeed: 0.02 - i * 0.003,\n        thickness: 2 + (NUM_VORTEX_RINGS - i) * 0.5,\n        hue: ringHues[i % ringHues.length],\n        pulsePhase: i * 0.5,\n      });\n    }\n\n    // Create orbiting particles\n    for (let i = 0; i < NUM_VORTEX_PARTICLES; i++) {\n      const baseRadius = 20 + Math.random() * 80;\n      this.vortexParticles.push({\n        angle: Math.random() * Math.PI * 2,\n        radius: baseRadius,\n        baseRadius,\n        speed: 0.02 + Math.random() * 0.03,\n        size: 1 + Math.random() * 2,\n        hue: Math.random() * 360,\n        alpha: 0.3 + Math.random() * 0.5,\n      });\n    }\n  }\n\n  private initMeteors(): void {\n    this.meteors = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_METEORS; i++) {\n      this.spawnMeteor(width, height, true);\n    }\n  }\n\n  private spawnMeteor(width: number, height: number, initial = false): void {\n    if (this.meteors.length >= NUM_METEORS) return;\n\n    // Meteors come from top-right and travel to bottom-left\n    const startX = initial ? Math.random() * width * 1.5 : width + 20 + Math.random() * 40;\n    const startY = initial ? Math.random() * height * 0.5 - height * 0.25 : -20 - Math.random() * 40;\n\n    // Random angle variation (mostly diagonal)\n    const angle = Math.PI * 0.65 + (Math.random() - 0.5) * 0.4;\n    const speed = 1.5 + Math.random() * 2;\n\n    this.meteors.push({\n      x: startX,\n      y: startY,\n      vx: -Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed,\n      size: 2 + Math.random() * 3,\n      hue: Math.random() < 0.3 ? 0 + Math.random() * 30 : 20 + Math.random() * 40, // Red or orange volcanic\n      alpha: 0.6 + Math.random() * 0.4,\n      trail: [],\n      life: 1,\n    });\n  }\n\n  private updateMeteors(width: number, height: number): void {\n    for (let i = this.meteors.length - 1; i >= 0; i--) {\n      const m = this.meteors[i];\n\n      // Store trail position\n      m.trail.unshift({ x: m.x, y: m.y, alpha: m.alpha });\n      if (m.trail.length > 12) m.trail.pop();\n\n      // Update position\n      m.x += m.vx;\n      m.y += m.vy;\n\n      // Check if meteor is out of bounds\n      if (m.x < -50 || m.y > height + 50) {\n        this.meteors.splice(i, 1);\n        // Spawn a new one\n        this.spawnMeteor(width, height, false);\n      }\n    }\n  }\n\n  private spawnDeathExplosion(): void {\n    if (!this.currentState) return;\n\n    this.deathDebris = [];\n    this.deathExplosionPhase = 1;\n\n    // Spawn debris from each snake segment\n    for (let i = 0; i < this.currentState.snake.length; i++) {\n      const seg = this.currentState.snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const segHue = (this.hueOffset + i * 15) % 360;\n\n      // Create debris particles per segment (limit total)\n      const debrisPerSeg = Math.min(3, Math.floor(MAX_DEATH_DEBRIS / this.currentState.snake.length));\n      for (let j = 0; j < debrisPerSeg; j++) {\n        if (this.deathDebris.length >= MAX_DEATH_DEBRIS) break;\n\n        const angle = Math.random() * Math.PI * 2;\n        const speed = 2 + Math.random() * 4;\n        const types: ('shard' | 'spark' | 'ember')[] = ['shard', 'spark', 'ember'];\n\n        this.deathDebris.push({\n          x: cx + (Math.random() - 0.5) * 8,\n          y: cy + (Math.random() - 0.5) * 8,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed - 1,\n          size: 3 + Math.random() * 5,\n          hue: segHue + (Math.random() - 0.5) * 40,\n          rotation: Math.random() * Math.PI * 2,\n          rotationSpeed: (Math.random() - 0.5) * 0.4,\n          life: 1,\n          type: types[Math.floor(Math.random() * types.length)],\n        });\n      }\n    }\n  }\n\n  private updateDeathDebris(): void {\n    // Decay explosion phase\n    if (this.deathExplosionPhase > 0) {\n      this.deathExplosionPhase *= 0.95;\n      if (this.deathExplosionPhase < 0.01) this.deathExplosionPhase = 0;\n    }\n\n    for (let i = this.deathDebris.length - 1; i >= 0; i--) {\n      const d = this.deathDebris[i];\n\n      // Update position with gravity\n      d.x += d.vx;\n      d.y += d.vy;\n      d.vy += 0.08; // gravity\n      d.vx *= 0.99; // air resistance\n\n      // Update rotation\n      d.rotation += d.rotationSpeed;\n\n      // Decay life\n      d.life -= 0.015;\n\n      if (d.life <= 0) {\n        this.deathDebris.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnFoodParticles(foodX: number, foodY: number): void {\n    if (this.foodParticles.length < MAX_FOOD_PARTICLES && Math.random() < 0.15) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.3 + Math.random() * 0.5;\n      this.foodParticles.push({\n        x: foodX,\n        y: foodY,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 0.5,\n        life: 1,\n        maxLife: 40 + Math.random() * 20,\n        size: 1 + Math.random() * 2,\n      });\n    }\n  }\n\n  private updateParticles(): void {\n    for (let i = this.foodParticles.length - 1; i >= 0; i--) {\n      const p = this.foodParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy += 0.02;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.foodParticles.splice(i, 1);\n      }\n    }\n    // Update trail particles\n    for (let i = this.trailParticles.length - 1; i >= 0; i--) {\n      const p = this.trailParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.trailParticles.splice(i, 1);\n      }\n    }\n    // Update shockwaves\n    for (let i = this.shockWaves.length - 1; i >= 0; i--) {\n      const sw = this.shockWaves[i];\n      sw.radius += 3;\n      sw.life -= 0.04;\n      if (sw.life <= 0 || sw.radius >= sw.maxRadius) {\n        this.shockWaves.splice(i, 1);\n      }\n    }\n    // Update lightning bolts\n    for (let i = this.lightningBolts.length - 1; i >= 0; i--) {\n      const bolt = this.lightningBolts[i];\n      bolt.life -= 1 / bolt.maxLife;\n      if (bolt.life <= 0) {\n        this.lightningBolts.splice(i, 1);\n      }\n    }\n    // Update afterimages\n    for (let i = this.snakeAfterimages.length - 1; i >= 0; i--) {\n      const ai = this.snakeAfterimages[i];\n      ai.life -= 1 / ai.maxLife;\n      if (ai.life <= 0) {\n        this.snakeAfterimages.splice(i, 1);\n      }\n    }\n    // Decay screen flash\n    if (this.screenFlashAlpha > 0) {\n      this.screenFlashAlpha -= 0.08;\n      if (this.screenFlashAlpha < 0) this.screenFlashAlpha = 0;\n    }\n\n    // Update screen shake\n    if (this.screenShakeIntensity > 0) {\n      this.screenShakeX = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeY = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeIntensity *= 0.9;\n      if (this.screenShakeIntensity < 0.5) {\n        this.screenShakeIntensity = 0;\n        this.screenShakeX = 0;\n        this.screenShakeY = 0;\n      }\n    }\n\n    // Decay chromatic aberration\n    if (this.chromaticIntensity > 0) {\n      this.chromaticIntensity *= 0.92;\n      if (this.chromaticIntensity < 0.05) this.chromaticIntensity = 0;\n    }\n\n    // Decay energy field pulse\n    if (this.energyFieldPulse > 0) {\n      this.energyFieldPulse *= 0.95;\n      if (this.energyFieldPulse < 0.05) this.energyFieldPulse = 0;\n    }\n\n    // Update food burst particles\n    for (let i = this.foodBurstParticles.length - 1; i >= 0; i--) {\n      const p = this.foodBurstParticles[i];\n      // Store trail position\n      p.trail.unshift({ x: p.x, y: p.y });\n      if (p.trail.length > 6) p.trail.pop();\n      // Update position\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vx *= 0.96;\n      p.vy *= 0.96;\n      p.life -= 0.025;\n      if (p.life <= 0) {\n        this.foodBurstParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnTrailParticles(x: number, y: number): void {\n    if (this.trailParticles.length >= MAX_TRAIL_PARTICLES) return;\n    // Spawn 2-3 particles per movement\n    const count = 2 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < count; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.2 + Math.random() * 0.4;\n      this.trailParticles.push({\n        x: x + (Math.random() - 0.5) * 8,\n        y: y + (Math.random() - 0.5) * 8,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        maxLife: 25 + Math.random() * 15,\n        size: 2 + Math.random() * 3,\n        hue: this.hueOffset + Math.random() * 30,\n      });\n    }\n  }\n\n  updateGameState(state: GameState): void {\n    // Detect food eaten - snake got longer\n    if (this.currentState && state.snake.length > this.lastSnakeLength) {\n      const head = state.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n      this.spawnShockWave(headX, headY);\n      this.spawnLightningBurst(headX, headY);\n      this.spawnFoodBurst(headX, headY);\n      this.spawnChaosExplosion(headX, headY); // Armageddon chaos explosion\n      this.screenFlashAlpha = 0.8; // More intense flash for armageddon\n      this.chromaticIntensity = 1.5; // Stronger chromatic aberration\n      this.energyFieldPulse = 1.0; // Trigger energy field expansion\n    }\n    this.lastSnakeLength = state.snake.length;\n\n    // Detect food position change - trigger thrown food animation\n    const newFood = state.food;\n    if (this.lastFoodPos && (newFood.x !== this.lastFoodPos.x || newFood.y !== this.lastFoodPos.y)) {\n      this.spawnThrownFood(newFood.x, newFood.y);\n    } else if (!this.lastFoodPos && !state.gameOver) {\n      // First food spawn\n      this.spawnThrownFood(newFood.x, newFood.y);\n    }\n    this.lastFoodPos = { x: newFood.x, y: newFood.y };\n\n    // Create afterimage when snake moves\n    if (this.currentState && state.snake.length > 0) {\n      const oldHead = this.currentState.snake[0];\n      const newHead = state.snake[0];\n      if (oldHead && newHead && (oldHead.x !== newHead.x || oldHead.y !== newHead.y)) {\n        this.spawnAfterimage(this.currentState.snake);\n      }\n    }\n\n    // Detect game over transition - ARMAGEDDON CHAOS death sequence\n    if (state.gameOver && this.currentState && !this.currentState.gameOver) {\n      this.screenShakeIntensity = 25; // Massive screen shake on death\n      this.chromaticIntensity = 3.0; // Maximum chromatic aberration on death\n      this.chaosIntensity = 1.0; // Full chaos overlay\n      this.spawnDeathExplosion(); // Dramatic death explosion\n      // Spawn chaos explosions across the snake body\n      for (let i = 0; i < Math.min(3, state.snake.length); i++) {\n        const seg = state.snake[Math.floor(i * state.snake.length / 3)];\n        setTimeout(() => {\n          this.spawnChaosExplosion(\n            seg.x * CELL_SIZE + CELL_SIZE / 2,\n            seg.y * CELL_SIZE + CELL_SIZE / 2\n          );\n        }, i * 50);\n      }\n    }\n\n    this.currentState = state;\n    this.needsRedraw = true;\n    if (!state.gameOver) {\n      this.gameOverAlpha = 0;\n      this.gameOverGlitchOffset = 0;\n      this.screenShakeIntensity = 0;\n    }\n  }\n\n  private spawnShockWave(x: number, y: number): void {\n    if (this.shockWaves.length >= MAX_SHOCKWAVES) {\n      this.shockWaves.shift();\n    }\n    this.shockWaves.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: CELL_SIZE * 3,\n      life: 1,\n    });\n  }\n\n  private spawnAfterimage(snake: Position[]): void {\n    if (this.snakeAfterimages.length >= MAX_AFTERIMAGES) {\n      this.snakeAfterimages.shift();\n    }\n    this.snakeAfterimages.push({\n      segments: snake.map(s => ({ x: s.x, y: s.y })),\n      life: 1,\n      maxLife: 12,\n      hueOffset: this.hueOffset,\n    });\n  }\n\n  private spawnLightningBurst(x: number, y: number): void {\n    const numBolts = 3 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < numBolts; i++) {\n      if (this.lightningBolts.length >= MAX_LIGHTNING_BOLTS) {\n        this.lightningBolts.shift();\n      }\n      const angle = (Math.PI * 2 * i) / numBolts + Math.random() * 0.5;\n      const length = 30 + Math.random() * 40;\n      const endX = x + Math.cos(angle) * length;\n      const endY = y + Math.sin(angle) * length;\n      this.lightningBolts.push({\n        points: this.generateLightningPath(x, y, endX, endY),\n        life: 1,\n        maxLife: 15 + Math.random() * 10,\n        hue: this.hueOffset + Math.random() * 60,\n      });\n    }\n  }\n\n  private generateLightningPath(x1: number, y1: number, x2: number, y2: number): { x: number; y: number }[] {\n    const points: { x: number; y: number }[] = [{ x: x1, y: y1 }];\n    const segments = 4 + Math.floor(Math.random() * 3);\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n\n    for (let i = 1; i < segments; i++) {\n      const jitter = 8;\n      points.push({\n        x: x1 + dx * i + (Math.random() - 0.5) * jitter,\n        y: y1 + dy * i + (Math.random() - 0.5) * jitter,\n      });\n    }\n    points.push({ x: x2, y: y2 });\n    return points;\n  }\n\n  private spawnFoodBurst(x: number, y: number): void {\n    // Clear old particles and spawn new dramatic burst\n    this.foodBurstParticles = [];\n    const numParticles = MAX_BURST_PARTICLES;\n    for (let i = 0; i < numParticles; i++) {\n      const angle = (i / numParticles) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 4;\n      this.foodBurstParticles.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        size: 3 + Math.random() * 4,\n        hue: this.hueOffset + Math.random() * 60,\n        trail: [],\n      });\n    }\n  }\n\n  private spawnThrownFood(targetGridX: number, targetGridY: number): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const targetX = targetGridX * CELL_SIZE + CELL_SIZE / 2;\n    const targetY = targetGridY * CELL_SIZE + CELL_SIZE / 2;\n\n    // Choose random edge to throw from\n    const edge = Math.floor(Math.random() * 4);\n    let startX: number, startY: number;\n\n    switch (edge) {\n      case 0: // top\n        startX = Math.random() * width;\n        startY = -40;\n        break;\n      case 1: // right\n        startX = width + 40;\n        startY = Math.random() * height;\n        break;\n      case 2: // bottom\n        startX = Math.random() * width;\n        startY = height + 40;\n        break;\n      default: // left\n        startX = -40;\n        startY = Math.random() * height;\n        break;\n    }\n\n    this.thrownFood = {\n      startX,\n      startY,\n      targetX,\n      targetY,\n      x: startX,\n      y: startY,\n      progress: 0,\n      rotation: 0,\n      rotationSpeed: (Math.random() - 0.5) * 0.6,\n      trail: [],\n      landed: false,\n      landingParticles: [],\n      impactRings: [],\n    };\n  }\n\n  private updateThrownFood(): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    if (!tf.landed) {\n      // Update progress\n      tf.progress += 0.04;\n\n      // Store trail\n      if (this.frameCount % 2 === 0) {\n        tf.trail.unshift({ x: tf.x, y: tf.y, alpha: 1, rotation: tf.rotation });\n        if (tf.trail.length > 12) tf.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.85;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Calculate position with parabolic arc\n      const t = tf.progress;\n      const arcHeight = 80;\n      const arc = 4 * arcHeight * t * (1 - t);\n      tf.x = tf.startX + (tf.targetX - tf.startX) * t;\n      tf.y = tf.startY + (tf.targetY - tf.startY) * t - arc;\n\n      // Rotation\n      tf.rotation += tf.rotationSpeed;\n\n      // Check if landed\n      if (tf.progress >= 1) {\n        tf.landed = true;\n        tf.x = tf.targetX;\n        tf.y = tf.targetY;\n\n        // Spawn landing effects\n        this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 6);\n\n        // Impact rings\n        tf.impactRings = [\n          { radius: 5, alpha: 1 },\n          { radius: 3, alpha: 0.8 },\n        ];\n\n        // Landing particles\n        for (let i = 0; i < 10; i++) {\n          const angle = (i / 10) * Math.PI * 2 + Math.random() * 0.3;\n          const speed = 2 + Math.random() * 3;\n          tf.landingParticles.push({\n            x: tf.targetX,\n            y: tf.targetY,\n            vx: Math.cos(angle) * speed,\n            vy: Math.sin(angle) * speed - 1,\n            life: 1,\n            size: 2 + Math.random() * 3,\n          });\n        }\n      }\n    } else {\n      // Update landing effects\n      for (const ring of tf.impactRings) {\n        ring.radius += 3;\n        ring.alpha *= 0.9;\n      }\n      tf.impactRings = tf.impactRings.filter(r => r.alpha > 0.05);\n\n      for (let i = tf.landingParticles.length - 1; i >= 0; i--) {\n        const p = tf.landingParticles[i];\n        p.x += p.vx;\n        p.y += p.vy;\n        p.vy += 0.15;\n        p.vx *= 0.98;\n        p.life -= 0.04;\n        if (p.life <= 0) {\n          tf.landingParticles.splice(i, 1);\n        }\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.8;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Clear thrown food when effects are done\n      if (tf.impactRings.length === 0 && tf.landingParticles.length === 0 && tf.trail.length === 0) {\n        this.thrownFood = null;\n      }\n    }\n  }\n\n  private drawThrownFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    // Draw trail\n    for (let i = 0; i < tf.trail.length; i++) {\n      const t = tf.trail[i];\n      const trailProgress = i / tf.trail.length;\n      const trailSize = (CELL_SIZE / 2) * (1 - trailProgress * 0.5) * t.alpha;\n\n      // Trail glow\n      g.fillStyle(COLORS.foodGlow, t.alpha * 0.3);\n      g.fillCircle(t.x, t.y, trailSize * 1.5);\n\n      // Trail core\n      g.fillStyle(COLORS.food, t.alpha * 0.6);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    // Draw impact rings\n    for (const ring of tf.impactRings) {\n      g.lineStyle(3, COLORS.foodGlow, ring.alpha * 0.5);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n      g.lineStyle(1.5, COLORS.noirWhite, ring.alpha * 0.7);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n    }\n\n    // Draw landing particles\n    for (const p of tf.landingParticles) {\n      g.fillStyle(COLORS.foodGlow, p.life * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Draw the flying food if not landed\n    if (!tf.landed) {\n      const scale = 0.8 + tf.progress * 0.4;\n      const foodSize = (CELL_SIZE / 2) * scale;\n\n      // Motion blur glow\n      g.fillStyle(COLORS.foodGlow, 0.3);\n      g.fillCircle(tf.x, tf.y, foodSize * 2);\n\n      // Outer glow\n      g.fillStyle(COLORS.noirWhite, 0.4);\n      g.fillCircle(tf.x, tf.y, foodSize * 1.5);\n\n      // Main food body\n      g.fillStyle(COLORS.food, 0.95);\n      g.fillCircle(tf.x, tf.y, foodSize);\n\n      // Spinning highlight\n      const highlightAngle = tf.rotation;\n      const highlightX = tf.x + Math.cos(highlightAngle) * foodSize * 0.3;\n      const highlightY = tf.y + Math.sin(highlightAngle) * foodSize * 0.3;\n      g.fillStyle(0xffffff, 0.9);\n      g.fillCircle(highlightX, highlightY, foodSize * 0.25);\n\n      // Secondary sparkle\n      const sparkleAngle = tf.rotation + Math.PI * 0.7;\n      const sparkleX = tf.x + Math.cos(sparkleAngle) * foodSize * 0.4;\n      const sparkleY = tf.y + Math.sin(sparkleAngle) * foodSize * 0.4;\n      g.fillStyle(0xffffff, 0.6);\n      g.fillCircle(sparkleX, sparkleY, foodSize * 0.15);\n    }\n  }\n\n  update(): void {\n    this.frameCount++;\n    this.cleanEffects.frameCount = this.frameCount;\n\n    const width = this.scale.width;\n    const height = this.scale.height;\n\n    updateMotes(this.cleanEffects, width, height);\n    updateSnowflakes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n    updateTears(this.cleanEffects, height);\n    updateBlood(this.cleanEffects, height);\n\n    if (this.currentState && this.currentState.snake.length > 0) {\n      const head = this.currentState.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n        updateGlowTrail(this.cleanEffects, headX, headY);\n      }\n      this.lastHeadPos = { x: head.x, y: head.y };\n\n      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n        const food = this.currentState.food;\n        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnRipple(this.cleanEffects, foodX, foodY);\n      }\n      this.lastSnakeLength = this.currentState.snake.length;\n    }\n\n    const g = this.graphics;\n    g.clear();\n    g.setPosition(0, 0);\n\n    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n\n    if (!this.currentState) return;\n\n    drawGlowTrail(g, this.cleanEffects);\n    drawRipples(g, this.cleanEffects);\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n\n    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawTears(g, this.cleanEffects);\n    drawBlood(g, this.cleanEffects);\n\n    drawCleanVignette(g, width, height);\n\n    const score = this.currentState.score || 0;\n    const snakeLength = this.currentState.snake.length;\n    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n\n    if (this.currentState.gameOver) {\n      this.drawGameOver(g, width, height);\n      this.drawScoreboard(g, width, height);\n    }\n\n    this.checkAndSaveHighScore();\n    this.needsRedraw = false;\n  }\n\n  private drawStars(g: Phaser.GameObjects.Graphics): void {\n    // In film noir mode, stars are subtle distant lights\n    for (const star of this.stars) {\n      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n      const alpha = star.brightness * twinkle * 0.25;\n      g.fillStyle(COLORS.star, alpha);\n      g.fillCircle(star.x, star.y, star.size * 0.7);\n    }\n  }\n\n  private updateSmokeParticles(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (const smoke of this.smokeParticles) {\n      smoke.x += smoke.vx;\n      smoke.y += smoke.vy;\n      smoke.life -= 0.002;\n      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n        smoke.x = Math.random() * width;\n        smoke.y = height + smoke.size;\n        smoke.life = 1;\n        smoke.size = 30 + Math.random() * 50;\n        smoke.alpha = 0.02 + Math.random() * 0.03;\n      }\n      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n    }\n  }\n\n  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Create dramatic spotlight effect centered on snake\n    const cx = this.spotlightX || width / 2;\n    const cy = this.spotlightY || height / 2;\n    const pulse = 0.9 + Math.sin(this.frameCount * 0.03) * 0.1;\n\n    // Outer darkness vignette\n    g.fillStyle(0x000000, 0.6);\n    g.fillRect(0, 0, width, height);\n\n    // Spotlight cone - multiple layers for smooth falloff\n    const layers = 4;\n    for (let i = layers; i > 0; i--) {\n      const layerRadius = (width * 0.4 + i * 30) * pulse;\n      const layerAlpha = 0.15 * (1 - i / (layers + 1));\n      g.fillStyle(COLORS.spotlight, layerAlpha);\n      g.fillCircle(cx, cy, layerRadius);\n    }\n\n    // Bright center\n    g.fillStyle(COLORS.noirWhite, 0.08 * pulse);\n    g.fillCircle(cx, cy, width * 0.25);\n  }\n\n  private drawVenetianBlinds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Horizontal light streaks simulating light through venetian blinds\n    const blindSpacing = 25;\n    const blindWidth = 8;\n    const waveOffset = Math.sin(this.venetianPhase) * 10;\n\n    for (let y = waveOffset; y < height; y += blindSpacing) {\n      const brightness = 0.03 + Math.sin(y * 0.02 + this.venetianPhase * 2) * 0.015;\n      g.fillStyle(COLORS.noirWhite, brightness);\n      g.fillRect(0, y, width, blindWidth);\n    }\n\n    // Diagonal shadow bars from window frame\n    const diagonalAlpha = 0.04 + Math.sin(this.frameCount * 0.02) * 0.01;\n    g.fillStyle(0x000000, diagonalAlpha);\n    for (let i = -2; i < 6; i++) {\n      const x1 = i * 100 + Math.sin(this.venetianPhase) * 20;\n      g.beginPath();\n      g.moveTo(x1, 0);\n      g.lineTo(x1 + 40, 0);\n      g.lineTo(x1 + 40 + height * 0.3, height);\n      g.lineTo(x1 + height * 0.3, height);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawSmoke(g: Phaser.GameObjects.Graphics): void {\n    for (const smoke of this.smokeParticles) {\n      const alpha = smoke.alpha * smoke.life;\n      g.fillStyle(COLORS.noirGray, alpha);\n      g.fillCircle(smoke.x, smoke.y, smoke.size);\n      g.fillStyle(COLORS.noirWhite, alpha * 0.3);\n      g.fillCircle(smoke.x, smoke.y, smoke.size * 0.5);\n    }\n  }\n\n  private spawnFlameParticle(x: number, y: number, intensity: number): void {\n    if (this.flameParticles.length >= MAX_FLAME_PARTICLES) {\n      this.flameParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.6;\n    const life = 0.5 + Math.random() * 0.5;\n\n    this.flameParticles.push({\n      x: x + (Math.random() - 0.5) * 6,\n      y: y + (Math.random() - 0.5) * 6,\n      vx: Math.cos(angle) * speed * 0.3,\n      vy: -0.5 - Math.random() * 1.5 * intensity,\n      size: 3 + Math.random() * 4 * intensity,\n      life,\n      maxLife: life,\n      hue: 10 + Math.random() * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n    });\n  }\n\n  private updateFlameParticles(): void {\n    for (let i = this.flameParticles.length - 1; i >= 0; i--) {\n      const p = this.flameParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.02;\n      p.vx *= 0.98;\n      p.size *= 0.97;\n      p.life -= 0.025;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.flameParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private drawFlameParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.flameParticles) {\n      const lifeRatio = p.life / p.maxLife;\n\n      // Hue shifts from yellow-orange (high life) to red (low life)\n      const hue = p.hue - (1 - lifeRatio) * 15;\n      const outerColor = this.hslToRgb(hue / 360, 1, 0.3 + lifeRatio * 0.2);\n      const midColor = this.hslToRgb(hue / 360, 1, 0.5 + lifeRatio * 0.2);\n      const coreColor = this.hslToRgb((hue + 20) / 360, 0.7, 0.7 + lifeRatio * 0.2);\n\n      // Outer glow\n      g.fillStyle(outerColor, lifeRatio * 0.3);\n      g.fillCircle(p.x, p.y, p.size * 2);\n\n      // Mid flame\n      g.fillStyle(midColor, lifeRatio * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3);\n\n      // Core (bright yellow/white)\n      g.fillStyle(coreColor, lifeRatio * 0.8);\n      g.fillCircle(p.x, p.y, p.size * 0.6);\n    }\n  }\n\n  private spawnFlamesAlongSnake(): void {\n    if (!this.currentState || this.currentState.gameOver) return;\n\n    const snake = this.currentState.snake;\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const segX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const segY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const intensity = 1 - (i / snake.length) * 0.6;\n      if (Math.random() < 0.4 * intensity) {\n        this.spawnFlameParticle(segX, segY, intensity);\n      }\n    }\n  }\n\n  private drawMeteors(g: Phaser.GameObjects.Graphics): void {\n    for (const m of this.meteors) {\n      const meteorColor = this.hslToRgb(m.hue / 360, 0.9, 0.6);\n      const coreColor = this.hslToRgb(m.hue / 360, 0.6, 0.9);\n\n      // Draw trail (oldest to newest for proper layering)\n      for (let i = m.trail.length - 1; i >= 0; i--) {\n        const t = m.trail[i];\n        const trailProgress = 1 - i / m.trail.length;\n        const trailAlpha = t.alpha * trailProgress * 0.4;\n        const trailSize = m.size * trailProgress * 0.6;\n\n        g.fillStyle(meteorColor, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      g.fillStyle(meteorColor, m.alpha * 0.3);\n      g.fillCircle(m.x, m.y, m.size * 2);\n\n      // Main meteor body\n      g.fillStyle(meteorColor, m.alpha * 0.8);\n      g.fillCircle(m.x, m.y, m.size);\n\n      // Bright core\n      g.fillStyle(coreColor, m.alpha);\n      g.fillCircle(m.x, m.y, m.size * 0.5);\n    }\n  }\n\n  private drawDeathDebris(g: Phaser.GameObjects.Graphics): void {\n    // Draw explosion flash at the beginning\n    if (this.deathExplosionPhase > 0.7) {\n      const flashAlpha = (this.deathExplosionPhase - 0.7) * 2;\n      g.fillStyle(0xffffff, flashAlpha * 0.5);\n      g.fillRect(0, 0, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);\n    }\n\n    for (const d of this.deathDebris) {\n      // Film noir: grayscale debris\n      const brightness = 0.4 + (d.hue % 60) / 100;\n      const color = this.hslToRgb(0, 0, brightness);\n      const alpha = d.life * 0.9;\n\n      g.save();\n\n      if (d.type === 'shard') {\n        // Draw triangular shards\n        const cx = d.x;\n        const cy = d.y;\n        const size = d.size * d.life;\n\n        // Calculate rotated triangle points\n        const cos = Math.cos(d.rotation);\n        const sin = Math.sin(d.rotation);\n\n        const p1x = cx + cos * size;\n        const p1y = cy + sin * size;\n        const p2x = cx + cos * (-size * 0.5) - sin * (size * 0.7);\n        const p2y = cy + sin * (-size * 0.5) + cos * (size * 0.7);\n        const p3x = cx + cos * (-size * 0.5) - sin * (-size * 0.7);\n        const p3y = cy + sin * (-size * 0.5) + cos * (-size * 0.7);\n\n        // Glow\n        g.fillStyle(color, alpha * 0.4);\n        g.fillCircle(cx, cy, size * 1.5);\n\n        // Shard body\n        g.fillStyle(color, alpha);\n        g.fillTriangle(p1x, p1y, p2x, p2y, p3x, p3y);\n\n        // Highlight edge\n        g.lineStyle(1, 0xffffff, alpha * 0.6);\n        g.lineBetween(p1x, p1y, p2x, p2y);\n\n      } else if (d.type === 'spark') {\n        // Draw elongated spark\n        const sparkLength = d.size * 2 * d.life;\n        const sparkWidth = d.size * 0.3 * d.life;\n\n        // Direction based on velocity\n        const vLen = Math.sqrt(d.vx * d.vx + d.vy * d.vy);\n        const nx = vLen > 0 ? d.vx / vLen : 1;\n        const ny = vLen > 0 ? d.vy / vLen : 0;\n\n        // Glow\n        g.fillStyle(color, alpha * 0.3);\n        g.fillCircle(d.x, d.y, sparkLength * 0.8);\n\n        // Spark line\n        g.lineStyle(sparkWidth * 2, color, alpha * 0.6);\n        g.lineBetween(d.x - nx * sparkLength, d.y - ny * sparkLength, d.x, d.y);\n\n        // Bright tip\n        g.lineStyle(sparkWidth, 0xffffff, alpha);\n        g.lineBetween(d.x - nx * sparkLength * 0.3, d.y - ny * sparkLength * 0.3, d.x, d.y);\n\n      } else {\n        // Ember - glowing circle\n        const emberSize = d.size * d.life;\n\n        // Outer glow\n        g.fillStyle(color, alpha * 0.2);\n        g.fillCircle(d.x, d.y, emberSize * 2);\n\n        // Mid glow\n        g.fillStyle(color, alpha * 0.5);\n        g.fillCircle(d.x, d.y, emberSize * 1.3);\n\n        // Core\n        g.fillStyle(color, alpha);\n        g.fillCircle(d.x, d.y, emberSize);\n\n        // Hot center\n        g.fillStyle(0xffffff, alpha * 0.7);\n        g.fillCircle(d.x, d.y, emberSize * 0.4);\n      }\n\n      g.restore();\n    }\n  }\n\n  private drawNebulaClouds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const cloud of this.nebulaClouds) {\n      // Update cloud position (slow drift)\n      cloud.x += cloud.driftX;\n      cloud.y += cloud.driftY;\n      cloud.pulsePhase += cloud.pulseSpeed;\n\n      // Wrap around edges\n      if (cloud.x < -cloud.radius) cloud.x = width + cloud.radius;\n      if (cloud.x > width + cloud.radius) cloud.x = -cloud.radius;\n      if (cloud.y < -cloud.radius) cloud.y = height + cloud.radius;\n      if (cloud.y > height + cloud.radius) cloud.y = -cloud.radius;\n\n      // Pulsing alpha\n      const pulseAlpha = cloud.alpha * (0.7 + Math.sin(cloud.pulsePhase) * 0.3);\n      const color = this.hslToRgb(cloud.hue / 360, 0.6, 0.3);\n\n      // Draw multiple concentric layers for soft cloud effect\n      const layers = 4;\n      for (let i = layers; i > 0; i--) {\n        const layerRadius = cloud.radius * (i / layers);\n        const layerAlpha = pulseAlpha * (1 - i / (layers + 1)) * 0.6;\n        g.fillStyle(color, layerAlpha);\n        g.fillCircle(cloud.x, cloud.y, layerRadius);\n      }\n\n      // Core glow\n      const coreColor = this.hslToRgb(cloud.hue / 360, 0.8, 0.5);\n      g.fillStyle(coreColor, pulseAlpha * 0.4);\n      g.fillCircle(cloud.x, cloud.y, cloud.radius * 0.3);\n    }\n  }\n\n  private drawVortex(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Update vortex pulse\n    this.vortexPulse += 0.03;\n    const globalPulse = 0.8 + Math.sin(this.vortexPulse) * 0.2;\n\n    // Draw outer glow/halo\n    const outerGlowColor = this.hslToRgb(280 / 360, 0.7, 0.3);\n    g.fillStyle(outerGlowColor, 0.08 * globalPulse);\n    g.fillCircle(centerX, centerY, 120);\n    g.fillStyle(outerGlowColor, 0.05 * globalPulse);\n    g.fillCircle(centerX, centerY, 140);\n\n    // Draw orbiting particles (behind rings)\n    for (const particle of this.vortexParticles) {\n      // Update particle position - spiral inward slightly then reset\n      particle.angle += particle.speed;\n      particle.radius = particle.baseRadius + Math.sin(particle.angle * 3) * 8;\n\n      const px = centerX + Math.cos(particle.angle) * particle.radius;\n      const py = centerY + Math.sin(particle.angle) * particle.radius;\n\n      // Particle hue shifts over time\n      particle.hue = (particle.hue + 0.5) % 360;\n      const particleColor = this.hslToRgb(particle.hue / 360, 0.8, 0.6);\n\n      // Draw particle with trail\n      const trailAngle = particle.angle - 0.3;\n      const trailX = centerX + Math.cos(trailAngle) * particle.radius;\n      const trailY = centerY + Math.sin(trailAngle) * particle.radius;\n\n      g.lineStyle(particle.size * 0.8, particleColor, particle.alpha * 0.3 * globalPulse);\n      g.lineBetween(trailX, trailY, px, py);\n\n      g.fillStyle(particleColor, particle.alpha * globalPulse);\n      g.fillCircle(px, py, particle.size);\n\n      // Bright core\n      g.fillStyle(0xffffff, particle.alpha * 0.5 * globalPulse);\n      g.fillCircle(px, py, particle.size * 0.4);\n    }\n\n    // Draw rotating rings\n    for (const ring of this.vortexRings) {\n      ring.rotationOffset += ring.rotationSpeed;\n      ring.pulsePhase += 0.02;\n\n      const ringPulse = 0.7 + Math.sin(ring.pulsePhase) * 0.3;\n      const adjustedRadius = ring.baseRadius * (0.95 + ringPulse * 0.1);\n\n      const ringColor = this.hslToRgb(ring.hue / 360, 0.8, 0.5);\n\n      // Draw ring as series of arc segments with gaps\n      const segments = 6;\n      const arcLength = (Math.PI * 2) / segments * 0.7;\n\n      for (let i = 0; i < segments; i++) {\n        const startAngle = ring.rotationOffset + (i * Math.PI * 2) / segments;\n        const endAngle = startAngle + arcLength;\n\n        // Calculate alpha based on segment position for 3D effect\n        const segmentAlpha = 0.15 + Math.sin(startAngle + this.frameCount * 0.02) * 0.1;\n\n        g.lineStyle(ring.thickness, ringColor, segmentAlpha * ringPulse * globalPulse);\n        g.beginPath();\n        g.arc(centerX, centerY, adjustedRadius, startAngle, endAngle, false);\n        g.strokePath();\n      }\n\n      // Inner glow line\n      g.lineStyle(ring.thickness * 0.5, 0xffffff, 0.1 * ringPulse * globalPulse);\n      g.beginPath();\n      g.arc(centerX, centerY, adjustedRadius - 1, ring.rotationOffset, ring.rotationOffset + Math.PI, false);\n      g.strokePath();\n    }\n\n    // Central dark core (event horizon)\n    g.fillStyle(0x000000, 0.9);\n    g.fillCircle(centerX, centerY, 12);\n    g.fillStyle(0x000000, 0.7);\n    g.fillCircle(centerX, centerY, 18);\n    g.fillStyle(0x000000, 0.4);\n    g.fillCircle(centerX, centerY, 25);\n\n    // Bright accretion ring at edge of event horizon\n    const accretionHue = (this.frameCount * 2) % 360;\n    const accretionColor = this.hslToRgb(accretionHue / 360, 1, 0.6);\n    g.lineStyle(2, accretionColor, 0.4 * globalPulse);\n    g.strokeCircle(centerX, centerY, 14);\n    g.lineStyle(1, 0xffffff, 0.3 * globalPulse);\n    g.strokeCircle(centerX, centerY, 13);\n\n    // Gravitational lensing effect - distorted light streaks\n    const numStreaks = 4;\n    for (let i = 0; i < numStreaks; i++) {\n      const streakAngle = (i * Math.PI * 2) / numStreaks + this.frameCount * 0.01;\n      const streakHue = (accretionHue + i * 60) % 360;\n      const streakColor = this.hslToRgb(streakHue / 360, 0.9, 0.7);\n\n      const innerRadius = 20;\n      const outerRadius = 35 + Math.sin(this.frameCount * 0.05 + i) * 10;\n\n      const x1 = centerX + Math.cos(streakAngle) * innerRadius;\n      const y1 = centerY + Math.sin(streakAngle) * innerRadius;\n      const x2 = centerX + Math.cos(streakAngle + 0.2) * outerRadius;\n      const y2 = centerY + Math.sin(streakAngle + 0.2) * outerRadius;\n\n      g.lineStyle(3, streakColor, 0.15 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n      g.lineStyle(1.5, 0xffffff, 0.2 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n    }\n  }\n\n  private drawAuroraWaves(g: Phaser.GameObjects.Graphics, width: number): void {\n    for (const aurora of this.auroraWaves) {\n      aurora.phase += aurora.speed;\n\n      // Draw multiple ribbon layers for each aurora\n      const ribbonLayers = 3;\n      for (let layer = 0; layer < ribbonLayers; layer++) {\n        const layerOffset = layer * 5;\n        const layerAlpha = 0.06 - layer * 0.015;\n\n        // Calculate shifting hue for color variation\n        const shiftedHue = (aurora.hue + Math.sin(aurora.phase * 0.5) * 20) % 360;\n        const color = this.hslToRgb(shiftedHue / 360, 0.7, 0.5);\n\n        // Draw aurora as a series of connected curves\n        g.fillStyle(color, layerAlpha);\n        const step = 4;\n        for (let x = 0; x < width; x += step) {\n          // Multiple sine waves combined for organic movement\n          const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n          const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n          const wave3 = Math.sin(x * 0.01 + aurora.phase * 0.7) * aurora.amplitude * 0.3;\n          const yOffset = wave1 + wave2 + wave3;\n\n          const segmentY = aurora.y + yOffset + layerOffset;\n          const thickness = aurora.thickness * (0.7 + Math.sin(x * 0.05 + aurora.phase) * 0.3);\n\n          g.fillRect(x, segmentY - thickness / 2, step + 1, thickness);\n        }\n      }\n\n      // Add bright core line\n      const coreHue = (aurora.hue + 40) % 360;\n      const coreColor = this.hslToRgb(coreHue / 360, 0.9, 0.7);\n      g.lineStyle(1.5, coreColor, 0.15);\n      g.beginPath();\n      for (let x = 0; x < width; x += 3) {\n        const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n        const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n        const y = aurora.y + wave1 + wave2;\n        if (x === 0) {\n          g.moveTo(x, y);\n        } else {\n          g.lineTo(x, y);\n        }\n      }\n      g.strokePath();\n    }\n  }\n\n  private drawPlasmaWaves(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const wave of this.plasmaWaves) {\n      wave.phase += wave.speed;\n      const color = this.hslToRgb(wave.hue / 360, 0.7, 0.4);\n\n      // Draw flowing plasma lines\n      for (let y = 0; y < height; y += 8) {\n        const waveOffset = Math.sin(y / wave.wavelength + wave.phase) * wave.amplitude;\n        const intensity = 0.03 + Math.sin(wave.phase + y * 0.01) * 0.02;\n\n        g.fillStyle(color, intensity);\n        const x1 = width / 2 + waveOffset - 40;\n        const x2 = width / 2 + waveOffset + 40;\n        g.fillRect(x1, y, x2 - x1, 2);\n      }\n    }\n  }\n\n  private drawSnakeAfterimages(g: Phaser.GameObjects.Graphics): void {\n    for (const ai of this.snakeAfterimages) {\n      const alpha = ai.life * 0.25;\n      for (let i = 0; i < ai.segments.length; i++) {\n        const seg = ai.segments[i];\n        const centerX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n        const centerY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n        const t = ai.segments.length > 1 ? i / (ai.segments.length - 1) : 1;\n        const radius = (CELL_SIZE / 2 - 2) * (0.7 + t * 0.2);\n\n        const segmentHue = (ai.hueOffset + i * 15) % 360;\n        const color = this.hslToRgb(segmentHue / 360, 0.6, 0.4);\n\n        g.fillStyle(color, alpha * t);\n        g.fillCircle(centerX, centerY, radius);\n      }\n    }\n  }\n\n  private drawTrailParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.trailParticles) {\n      // Film noir: grayscale trail\n      g.fillStyle(COLORS.noirGray, p.life * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 1.5 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.5);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n  }\n\n  // Update comet trail - add new segments and fade old ones\n  private updateCometTrail(): void {\n    if (!this.currentState || this.currentState.gameOver) {\n      // Fade out trail on game over\n      for (const seg of this.cometTrail) {\n        seg.alpha *= 0.9;\n      }\n      this.cometTrail = this.cometTrail.filter(s => s.alpha > 0.01);\n      return;\n    }\n\n    const snake = this.currentState.snake;\n    if (snake.length === 0) return;\n\n    const head = snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Track head history for smooth interpolation\n    this.headHistory.unshift({ x: headX, y: headY, time: this.frameCount });\n    if (this.headHistory.length > 10) this.headHistory.pop();\n\n    // Add new trail segment at head position\n    if (this.frameCount % 2 === 0) {\n      const hue = 270 + Math.sin(this.frameCount * 0.05) * 20;\n      this.cometTrail.unshift({\n        x: headX,\n        y: headY,\n        alpha: 1,\n        size: CELL_SIZE / 2 + 2,\n        hue,\n      });\n\n      // Spawn ethereal particles from trail\n      if (Math.random() < 0.6) {\n        this.spawnEtherealParticle(headX, headY, hue);\n      }\n    }\n\n    // Limit trail length and fade segments\n    while (this.cometTrail.length > MAX_COMET_TRAIL_LENGTH) {\n      this.cometTrail.pop();\n    }\n\n    // Fade all segments\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const fadeRate = 0.06 + (i / this.cometTrail.length) * 0.04;\n      this.cometTrail[i].alpha -= fadeRate;\n      this.cometTrail[i].size *= 0.97;\n    }\n\n    // Remove fully faded segments\n    this.cometTrail = this.cometTrail.filter(s => s.alpha > 0);\n  }\n\n  // Spawn an ethereal particle that drifts away from the trail\n  private spawnEtherealParticle(x: number, y: number, hue: number): void {\n    if (this.etherealParticles.length >= MAX_ETHEREAL_PARTICLES) {\n      this.etherealParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.5;\n    const life = 0.8 + Math.random() * 0.4;\n\n    this.etherealParticles.push({\n      x: x + (Math.random() - 0.5) * 10,\n      y: y + (Math.random() - 0.5) * 10,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 0.3,\n      size: 3 + Math.random() * 4,\n      life,\n      maxLife: life,\n      hue: hue + (Math.random() - 0.5) * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n\n  // Update ethereal particles\n  private updateEtherealParticles(): void {\n    for (let i = this.etherealParticles.length - 1; i >= 0; i--) {\n      const p = this.etherealParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.015; // Slight upward drift\n      p.vx *= 0.98;\n      p.size *= 0.985;\n      p.life -= 0.02;\n      p.pulsePhase += 0.15;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.etherealParticles.splice(i, 1);\n      }\n    }\n  }\n\n  // Draw the comet trail - smooth glowing ribbon\n  private drawCometTrail(g: Phaser.GameObjects.Graphics): void {\n    if (this.cometTrail.length < 2) return;\n\n    // Draw outer glow layer\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.05) continue;\n\n      const progress = i / this.cometTrail.length;\n      const glowSize = seg.size * (1.5 + progress * 0.5);\n      const glowAlpha = seg.alpha * 0.15 * (1 - progress * 0.5);\n\n      // Outer ethereal glow\n      const outerColor = this.hslToRgb(seg.hue / 360, 0.6, 0.4);\n      g.fillStyle(outerColor, glowAlpha);\n      g.fillCircle(seg.x, seg.y, glowSize * 1.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(seg.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, glowAlpha * 1.5);\n      g.fillCircle(seg.x, seg.y, glowSize);\n    }\n\n    // Draw connecting ribbon between segments\n    if (this.cometTrail.length >= 2) {\n      for (let i = 0; i < this.cometTrail.length - 1; i++) {\n        const seg1 = this.cometTrail[i];\n        const seg2 = this.cometTrail[i + 1];\n        if (seg1.alpha < 0.1 || seg2.alpha < 0.1) continue;\n\n        const progress = i / this.cometTrail.length;\n        const ribbonAlpha = Math.min(seg1.alpha, seg2.alpha) * 0.4 * (1 - progress * 0.5);\n        const ribbonWidth = (seg1.size + seg2.size) / 2 * 0.6;\n\n        // Ribbon core\n        const ribbonColor = this.hslToRgb(seg1.hue / 360, 0.8, 0.6);\n        g.lineStyle(ribbonWidth, ribbonColor, ribbonAlpha);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n\n        // Bright inner ribbon\n        g.lineStyle(ribbonWidth * 0.4, 0xffffff, ribbonAlpha * 0.6);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n      }\n    }\n\n    // Draw core particles at each segment\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.1) continue;\n\n      const progress = i / this.cometTrail.length;\n      const coreAlpha = seg.alpha * 0.6 * (1 - progress * 0.7);\n      const coreSize = seg.size * 0.5 * (1 - progress * 0.3);\n\n      // Core glow\n      const coreColor = this.hslToRgb(seg.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, coreAlpha);\n      g.fillCircle(seg.x, seg.y, coreSize);\n\n      // Bright white center\n      g.fillStyle(0xffffff, coreAlpha * 0.5);\n      g.fillCircle(seg.x, seg.y, coreSize * 0.4);\n    }\n  }\n\n  // Draw ethereal particles - luminous drifting particles\n  private drawEtherealParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.etherealParticles) {\n      const lifeRatio = p.life / p.maxLife;\n      const pulse = 0.7 + Math.sin(p.pulsePhase) * 0.3;\n      const alpha = lifeRatio * pulse;\n\n      // Outer glow\n      const glowColor = this.hslToRgb(p.hue / 360, 0.5, 0.3);\n      g.fillStyle(glowColor, alpha * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 2.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(p.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      // Core\n      const coreColor = this.hslToRgb(p.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, alpha * 0.7);\n      g.fillCircle(p.x, p.y, p.size);\n\n      // Bright center\n      g.fillStyle(0xffffff, alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawShockWaves(g: Phaser.GameObjects.Graphics): void {\n    for (const sw of this.shockWaves) {\n      const alpha = sw.life * 0.6;\n      // Outer ring\n      g.lineStyle(3, 0xffffff, alpha * 0.3);\n      g.strokeCircle(sw.x, sw.y, sw.radius);\n      // Inner bright ring\n      g.lineStyle(2, 0x00ffff, alpha * 0.7);\n      g.strokeCircle(sw.x, sw.y, sw.radius * 0.8);\n      // Core flash\n      if (sw.life > 0.8) {\n        g.fillStyle(0xffffff, (sw.life - 0.8) * 3);\n        g.fillCircle(sw.x, sw.y, sw.radius * 0.3);\n      }\n    }\n  }\n\n  private drawLightningBolts(g: Phaser.GameObjects.Graphics): void {\n    for (const bolt of this.lightningBolts) {\n      const alpha = bolt.life;\n\n      // Film noir: white lightning\n      g.lineStyle(4, COLORS.noirGray, alpha * 0.3);\n      this.drawLightningPath(g, bolt.points);\n\n      g.lineStyle(2, 0xffffff, alpha * 0.8);\n      this.drawLightningPath(g, bolt.points);\n    }\n  }\n\n  private drawLightningPath(g: Phaser.GameObjects.Graphics, points: { x: number; y: number }[]): void {\n    if (points.length < 2) return;\n    g.beginPath();\n    g.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      g.lineTo(points[i].x, points[i].y);\n    }\n    g.strokePath();\n  }\n\n  private drawSnakeElectricity(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n    const snake = this.currentState.snake;\n    if (snake.length < 2) return;\n\n    // Draw electric arcs between segments every few frames\n    if (this.frameCount % 3 !== 0) return;\n\n    for (let i = 0; i < snake.length - 1; i++) {\n      if (Math.random() > 0.4) continue;\n\n      const seg1 = snake[i];\n      const seg2 = snake[i + 1];\n      const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n      const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n      const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n      const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const arcPoints = this.generateLightningPath(x1, y1, x2, y2);\n\n      // Film noir: grayscale arcs\n      g.lineStyle(3, COLORS.noirGray, 0.3);\n      this.drawLightningPath(g, arcPoints);\n      g.lineStyle(1, 0xffffff, 0.7);\n      this.drawLightningPath(g, arcPoints);\n    }\n  }\n\n  private hslToRgb(h: number, s: number, l: number): number {\n    let r: number, g: number, b: number;\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return (Math.round(r * 255) << 16) | (Math.round(g * 255) << 8) | Math.round(b * 255);\n  }\n\n  private loadHighScores(): HighScoreEntry[] {\n    if (this.highScoresLoaded && this.highScores.length > 0) {\n      return this.highScores;\n    }\n    try {\n      const stored = localStorage.getItem('snake_high_scores');\n      if (stored) {\n        const parsed = JSON.parse(stored) as HighScoreEntry[];\n        this.highScores = parsed.slice(0, MAX_HIGH_SCORES);\n        this.highScoresLoaded = true;\n        return this.highScores;\n      }\n    } catch {\n      // localStorage not available\n    }\n    this.highScores = [];\n    this.highScoresLoaded = true;\n    return this.highScores;\n  }\n\n  private saveHighScore(score: number): number {\n    const highScores = this.loadHighScores();\n    const newEntry: HighScoreEntry = { score, date: Date.now(), rank: 0 };\n\n    let insertIndex = highScores.findIndex(entry => score > entry.score);\n    if (insertIndex === -1) insertIndex = highScores.length;\n\n    if (insertIndex < MAX_HIGH_SCORES && score > 0) {\n      highScores.splice(insertIndex, 0, newEntry);\n      highScores.forEach((entry, i) => { entry.rank = i + 1; });\n      this.highScores = highScores.slice(0, MAX_HIGH_SCORES);\n\n      try {\n        localStorage.setItem('snake_high_scores', JSON.stringify(this.highScores));\n      } catch {\n        // localStorage not available\n      }\n      return insertIndex + 1;\n    }\n    return -1;\n  }\n\n  private checkAndSaveHighScore(): void {\n    if (!this.currentState) return;\n\n    if (this.currentState.gameOver && !this.lastGameOverState) {\n      const score = this.currentState.score || 0;\n      const rank = this.saveHighScore(score);\n      this.newHighScoreRank = rank > 0 ? rank : -1;\n      this.scoreboardRevealProgress = 0;\n\n      const head = this.currentState.snake[0];\n      if (head) {\n        const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnBlood(this.cleanEffects, headX, headY, 15);\n        spawnTears(this.cleanEffects, headX, headY - 10, 6);\n      }\n    }\n    this.lastGameOverState = this.currentState.gameOver;\n\n    if (this.currentState.gameStarted && !this.currentState.gameOver) {\n      this.newHighScoreRank = -1;\n    }\n  }\n\n  private drawHUD(g: Phaser.GameObjects.Graphics, width: number): void {\n    if (!this.currentState || !this.currentState.gameStarted) return;\n\n    this.hudPulsePhase += 0.08;\n    const score = this.currentState.score || 0;\n\n    if (score > this.lastHudScore) {\n      this.scoreFlashIntensity = 1;\n    }\n    this.lastHudScore = score;\n    this.scoreFlashIntensity *= 0.92;\n\n    const padding = 12;\n    const scorePanelWidth = 120;\n    const scorePanelHeight = 50;\n\n    // Score panel background - volcanic lava theme\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Glowing border\n    const borderGlow = 0.6 + this.scoreFlashIntensity * 0.4;\n    g.lineStyle(2, COLORS.snakeGlow, borderGlow);\n    g.strokeRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Score label\n    this.drawText(g, 'SCORE', padding + 10, padding + 12, 10, COLORS.snakeBody, 0.9);\n\n    // Score value with flash effect\n    const scoreColor = this.scoreFlashIntensity > 0.5 ? 0xffffff : COLORS.snakeHead;\n    this.drawText(g, String(score).padStart(5, '0'), padding + 10, padding + 32, 18, scoreColor, 1);\n\n    // Outer glow on score when flashing\n    if (this.scoreFlashIntensity > 0.1) {\n      g.fillStyle(COLORS.snakeGlow, this.scoreFlashIntensity * 0.3);\n      g.fillRoundedRect(padding + 5, padding + 20, 100, 28, 4);\n    }\n\n    // Length panel on the right\n    const lengthPanelWidth = 80;\n    const lengthPanelHeight = 50;\n    const lengthX = width - padding - lengthPanelWidth;\n\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    g.lineStyle(2, COLORS.foodGlow, 0.6);\n    g.strokeRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    this.drawText(g, 'LENGTH', lengthX + 10, padding + 12, 10, COLORS.food, 0.9);\n    this.drawText(g, String(this.currentState.snake.length), lengthX + 10, padding + 32, 18, COLORS.foodCore, 1);\n  }\n\n  private drawText(\n    g: Phaser.GameObjects.Graphics,\n    text: string,\n    x: number,\n    y: number,\n    size: number,\n    color: number,\n    alpha: number\n  ): void {\n    // Use simple block characters for text rendering\n    const charWidth = size * 0.6;\n    const charHeight = size;\n\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const cx = x + i * charWidth;\n\n      g.fillStyle(color, alpha);\n\n      // Simple pixel-style character rendering\n      if (char >= '0' && char <= '9') {\n        this.drawDigit(g, char, cx, y, size);\n      } else {\n        this.drawLetter(g, char, cx, y, size);\n      }\n    }\n  }\n\n  private drawDigit(g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15; // thickness\n\n    // 7-segment style digits\n    const segments: Record<string, number[]> = {\n      '0': [1, 1, 1, 0, 1, 1, 1],\n      '1': [0, 0, 1, 0, 0, 1, 0],\n      '2': [1, 0, 1, 1, 1, 0, 1],\n      '3': [1, 0, 1, 1, 0, 1, 1],\n      '4': [0, 1, 1, 1, 0, 1, 0],\n      '5': [1, 1, 0, 1, 0, 1, 1],\n      '6': [1, 1, 0, 1, 1, 1, 1],\n      '7': [1, 0, 1, 0, 0, 1, 0],\n      '8': [1, 1, 1, 1, 1, 1, 1],\n      '9': [1, 1, 1, 1, 0, 1, 1],\n    };\n\n    const seg = segments[digit] || segments['0'];\n\n    // Top horizontal\n    if (seg[0]) g.fillRect(x, y - h / 2, w, t);\n    // Top-left vertical\n    if (seg[1]) g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n    // Top-right vertical\n    if (seg[2]) g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n    // Middle horizontal\n    if (seg[3]) g.fillRect(x, y - t / 2, w, t);\n    // Bottom-left vertical\n    if (seg[4]) g.fillRect(x - t / 2, y, t, h / 2);\n    // Bottom-right vertical\n    if (seg[5]) g.fillRect(x + w - t / 2, y, t, h / 2);\n    // Bottom horizontal\n    if (seg[6]) g.fillRect(x, y + h / 2 - t, w, t);\n  }\n\n  private drawLetter(g: Phaser.GameObjects.Graphics, letter: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15;\n\n    // Simple block letters\n    switch (letter.toUpperCase()) {\n      case 'S':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'C':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'O':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'R':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w / 2, y, t, h / 2);\n        break;\n      case 'E':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w * 0.7, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'L':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'N':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - h / 2 + t, w, t);\n        break;\n      case 'G':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x + w / 2, y - t / 2, w / 2, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'T':\n        g.fillRect(x - t, y - h / 2, w + t * 2, t);\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'H':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n      case 'I':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'Y':\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        break;\n      case 'U':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'W':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case '!':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h * 0.6);\n        g.fillRect(x + w / 2 - t / 2, y + h / 2 - t * 2, t, t);\n        break;\n      case ' ':\n        break;\n      default:\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n    }\n  }\n\n  private drawScoreboard(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (!this.currentState || !this.currentState.gameOver) return;\n\n    this.scoreboardAnimPhase += 0.06;\n    this.scoreboardRevealProgress = Math.min(1, this.scoreboardRevealProgress + 0.02);\n\n    const highScores = this.loadHighScores();\n    const centerX = width / 2;\n    const baseY = height * 0.18;\n    const panelWidth = 180;\n    const panelHeight = 170;\n    const panelX = centerX - panelWidth / 2;\n    const panelY = baseY;\n    const slideOffset = (1 - this.scoreboardRevealProgress) * 50;\n    const alphaMultiplier = this.scoreboardRevealProgress;\n\n    // Panel background - volcanic lava glow\n    g.fillStyle(0x150510, 0.95 * alphaMultiplier);\n    g.fillRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Glowing border - animated\n    const borderHue = this.newHighScoreRank > 0 ? 45 : 0;\n    const borderPulse = 0.6 + Math.sin(this.scoreboardAnimPhase) * 0.2;\n    const borderColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    g.lineStyle(3, borderColor, borderPulse * alphaMultiplier);\n    g.strokeRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Title\n    const titleY = panelY - slideOffset + 22;\n    this.drawText(g, 'HIGH SCORES', centerX - 55, titleY, 10, COLORS.foodCore, alphaMultiplier);\n\n    // Divider line\n    g.lineStyle(1, COLORS.snakeGlow, 0.5 * alphaMultiplier);\n    g.lineBetween(panelX + 20, titleY + 8, panelX + panelWidth - 20, titleY + 8);\n\n    const entryStartY = titleY + 25;\n    const entryHeight = 22;\n\n    if (highScores.length === 0) {\n      this.drawText(g, 'NO SCORES YET', centerX - 50, entryStartY + 30, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n    } else {\n      for (let i = 0; i < Math.min(highScores.length, 5); i++) {\n        const entry = highScores[i];\n        const entryY = entryStartY + i * entryHeight;\n        const isNewScore = this.newHighScoreRank === i + 1;\n        const entryDelay = i * 0.15;\n        const entryProgress = Math.max(0, Math.min(1, (this.scoreboardRevealProgress - entryDelay) * 2));\n        if (entryProgress <= 0) continue;\n\n        const entryAlpha = alphaMultiplier * entryProgress;\n\n        // Highlight new high score row\n        if (isNewScore) {\n          const flashIntensity = 0.3 + Math.sin(this.scoreboardAnimPhase * 3) * 0.2;\n          g.fillStyle(0xffcc00, flashIntensity * entryAlpha);\n          g.fillRoundedRect(panelX + 8, entryY - slideOffset - 8, panelWidth - 16, entryHeight - 2, 4);\n        }\n\n        // Rank colors: gold, silver, bronze, then volcanic colors\n        const rankColors = [0xffd700, 0xc0c0c0, 0xcd7f32, COLORS.snakeGlow, COLORS.foodGlow];\n        const rankColor = rankColors[i] || 0x888888;\n\n        // Rank number\n        this.drawText(g, `${i + 1}`, panelX + 18, entryY - slideOffset, 10, rankColor, entryAlpha);\n\n        // Score value\n        const scoreColor = isNewScore ? 0xffffff : COLORS.foodCore;\n        this.drawText(g, String(entry.score).padStart(5, '0'), panelX + panelWidth - 70, entryY - slideOffset, 10, scoreColor, entryAlpha);\n\n        // NEW! label\n        if (isNewScore) {\n          const newAlpha = 0.8 + Math.sin(this.scoreboardAnimPhase * 4) * 0.2;\n          this.drawText(g, 'NEW', panelX + 50, entryY - slideOffset, 7, 0xffcc00, newAlpha * entryAlpha);\n        }\n      }\n    }\n\n    // Current score at bottom\n    const currentScoreY = panelY - slideOffset + panelHeight - 30;\n    this.drawText(g, 'YOUR SCORE', centerX - 40, currentScoreY - 10, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n\n    const currentScore = this.currentState.score || 0;\n    const scoreColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    this.drawText(g, String(currentScore).padStart(5, '0'), centerX - 25, currentScoreY + 8, 14, scoreColor, alphaMultiplier);\n  }\n\n  private drawGrid(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir grid: subtle, dark lines suggesting tile floor or city grid\n    g.lineStyle(1, COLORS.gridLine, 0.08);\n    for (let i = 0; i <= GRID_SIZE; i++) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Accent lines every 5 cells - subtle gray\n    const accentPulse = 0.12 + Math.sin(this.frameCount * 0.03) * 0.04;\n    g.lineStyle(1, COLORS.gridAccent, accentPulse);\n    for (let i = 0; i <= GRID_SIZE; i += 5) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Heavy vignette for dramatic noir look\n    this.drawVignette(g, width, height);\n  }\n\n  private drawVignette(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Multiple layers of vignette for smooth falloff\n    const layers = 5;\n    for (let i = 0; i < layers; i++) {\n      const inset = i * 30;\n      const alpha = 0.15 * (1 - i / layers);\n      g.lineStyle(60, 0x000000, alpha);\n      g.strokeRect(inset - 30, inset - 30, width - inset * 2 + 60, height - inset * 2 + 60);\n    }\n  }\n\n  private drawFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    // Don't draw food if it's still being thrown\n    if (this.thrownFood && !this.thrownFood.landed) return;\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    const pulseScale = 1 + Math.sin(this.frameCount * 0.15) * 0.08;\n    const glowPulse = 0.4 + Math.sin(this.frameCount * 0.1) * 0.2;\n\n    // Spawn particles (orange/yellow for Halloween)\n    this.spawnFoodParticles(foodX, foodY);\n\n    // Draw particles\n    for (const p of this.foodParticles) {\n      g.fillStyle(COLORS.pumpkinOrange, p.life * 0.4);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Halloween pumpkin!\n    const pumpkinSize = (CELL_SIZE / 2) * pulseScale;\n\n    // Shadow underneath\n    g.fillStyle(0x000000, 0.5);\n    g.fillEllipse(foodX + 2, foodY + pumpkinSize * 0.8, pumpkinSize * 1.2, pumpkinSize * 0.4);\n\n    // Outer orange glow (candlelight effect)\n    g.fillStyle(COLORS.pumpkinOrange, glowPulse * 0.15);\n    g.fillCircle(foodX, foodY, pumpkinSize + 12);\n    g.fillStyle(COLORS.candyCorn1, glowPulse * 0.2);\n    g.fillCircle(foodX, foodY, pumpkinSize + 6);\n\n    // Pumpkin body (slightly squashed circle)\n    g.fillStyle(COLORS.pumpkinOrange, 0.95);\n    g.fillEllipse(foodX, foodY, pumpkinSize * 1.1, pumpkinSize * 0.9);\n\n    // Pumpkin segments (darker lines)\n    g.lineStyle(2, 0xcc4400, 0.5);\n    g.lineBetween(foodX, foodY - pumpkinSize * 0.8, foodX, foodY + pumpkinSize * 0.7);\n    g.lineStyle(1.5, 0xcc4400, 0.3);\n    g.lineBetween(foodX - pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX - pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n    g.lineBetween(foodX + pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX + pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n\n    // Pumpkin stem\n    g.fillStyle(0x228822, 0.9);\n    g.fillRect(foodX - 2, foodY - pumpkinSize * 0.9 - 4, 4, 6);\n\n    // Jack-o-lantern face - glowing eyes and mouth\n    const faceGlow = 0.8 + Math.sin(this.frameCount * 0.12) * 0.2;\n    g.fillStyle(COLORS.candyCorn1, faceGlow);\n\n    // Eyes (triangles)\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n\n    // Mouth (jagged smile)\n    g.fillStyle(COLORS.candyCorn1, faceGlow * 0.9);\n    g.fillRect(foodX - pumpkinSize * 0.35, foodY + pumpkinSize * 0.15, pumpkinSize * 0.7, pumpkinSize * 0.25);\n\n    // Teeth (dark gaps in mouth)\n    g.fillStyle(COLORS.pumpkinOrange, 1);\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX, foodY + pumpkinSize * 0.15,\n      foodX - pumpkinSize * 0.075, foodY + pumpkinSize * 0.3\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.3, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.225, foodY + pumpkinSize * 0.3\n    );\n  }\n\n  private drawEnergyTendrils(g: Phaser.GameObjects.Graphics, foodX: number, foodY: number): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const head = this.currentState.snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Calculate distance to snake head\n    const dx = headX - foodX;\n    const dy = headY - foodY;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    // Only draw tendrils when snake is somewhat close\n    if (dist > CELL_SIZE * 6) return;\n\n    // Intensity increases as snake gets closer\n    const intensity = 1 - dist / (CELL_SIZE * 6);\n    const numTendrils = 2 + Math.floor(intensity * 2);\n\n    for (let i = 0; i < numTendrils; i++) {\n      // Tendril reaches partway toward the snake\n      const reach = 0.3 + intensity * 0.4;\n      const targetX = foodX + dx * reach;\n      const targetY = foodY + dy * reach;\n\n      // Add some wave offset for each tendril\n      const waveOffset = Math.sin(this.frameCount * 0.15 + i * 2) * 10;\n      const perpX = -dy / dist;\n      const perpY = dx / dist;\n      const wavyTargetX = targetX + perpX * waveOffset * (1 - reach);\n      const wavyTargetY = targetY + perpY * waveOffset * (1 - reach);\n\n      // Generate tendril path\n      const points = this.generateLightningPath(foodX, foodY, wavyTargetX, wavyTargetY);\n\n      // Draw tendril with glow\n      g.lineStyle(3, COLORS.foodGlow, intensity * 0.3);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1.5, COLORS.food, intensity * 0.7);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1, 0xffffff, intensity * 0.5);\n      this.drawLightningPath(g, points);\n    }\n  }\n\n  private drawSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const snakeLen = snake.length;\n\n    // Spooky shadow under snake\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const shadowRadius = (CELL_SIZE / 2) * (0.9 + t * 0.1);\n      g.fillStyle(0x000000, 0.5 * t);\n      g.fillCircle(centerX, centerY, shadowRadius);\n    }\n\n    // Draw trailing glow (ghostly green)\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const glowAlpha = 0.2 * t;\n      const glowSize = (CELL_SIZE / 2 + 4) * (0.5 + t * 0.5);\n\n      g.fillStyle(COLORS.snakeGlow, glowAlpha);\n      g.fillCircle(centerX, centerY, glowSize);\n    }\n\n    // Draw snake segments from tail to head with green gradient\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n\n      // Green gradient from tail (dark) to head (bright)\n      const brightness = 0.3 + t * 0.4;\n      const segmentColor = this.hslToRgb(0.4, 0.9, brightness);\n\n      if (i === 0) {\n        // Head: brightest green with eerie glow\n        g.fillStyle(COLORS.snakeGlow, 0.4);\n        g.fillCircle(centerX, centerY, radius + 8);\n\n        g.fillStyle(COLORS.snakeHead, 1);\n        g.fillCircle(centerX, centerY, radius + 1);\n\n        // Slimy highlight\n        g.fillStyle(0xaaffcc, 0.6);\n        g.fillCircle(centerX - 2, centerY - 2, radius * 0.35);\n\n        this.drawSnakeHead(g, segment, snake[1]);\n      } else {\n        // Body segment with green tones\n        g.fillStyle(COLORS.snakeGlow, 0.15);\n        g.fillCircle(centerX, centerY, radius + 2);\n\n        g.fillStyle(segmentColor, 1);\n        g.fillCircle(centerX, centerY, radius);\n\n        // Slimy specular highlight\n        g.fillStyle(0xaaffcc, 0.15 * t);\n        g.fillCircle(centerX - 1, centerY - 1, radius * 0.25);\n      }\n    }\n  }\n\n  private drawFoodBurst(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.foodBurstParticles) {\n      // Halloween: orange pumpkin burst\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailAlpha = p.life * 0.4 * (1 - i / p.trail.length);\n        const trailSize = p.size * p.life * (1 - i / p.trail.length);\n        g.fillStyle(COLORS.pumpkinOrange, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      g.fillStyle(COLORS.candyCorn1, p.life * 0.7);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n      g.fillStyle(COLORS.candyCorn3, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life * 0.4);\n    }\n  }\n\n  private drawEnergyField(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const snake = this.currentState.snake;\n    const baseIntensity = 0.06 + this.energyFieldPulse * 0.2;\n    const pulseOffset = Math.sin(this.frameCount * 0.1) * 0.02;\n    const alpha = Math.min(0.3, baseIntensity + pulseOffset);\n\n    // Halloween: ghostly green energy field\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const fieldRadius = CELL_SIZE * (0.8 + this.energyFieldPulse * 0.5) + Math.sin(this.frameCount * 0.15 + i * 0.5) * 2;\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.2);\n      g.fillCircle(cx, cy, fieldRadius + 4);\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.35);\n      g.fillCircle(cx, cy, fieldRadius);\n    }\n\n    // Connecting lines when pulse is active\n    if (this.energyFieldPulse > 0.3 && snake.length > 1) {\n      for (let i = 0; i < snake.length - 1; i++) {\n        const seg1 = snake[i];\n        const seg2 = snake[i + 1];\n        const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n        const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n        const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n        const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n        g.lineStyle(3, COLORS.noirGray, this.energyFieldPulse * 0.3);\n        g.lineBetween(x1, y1, x2, y2);\n        g.lineStyle(1.5, 0xffffff, this.energyFieldPulse * 0.5);\n        g.lineBetween(x1, y1, x2, y2);\n      }\n    }\n  }\n\n  private drawChromaticAberration(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const offset = this.chromaticIntensity * 3;\n\n    // Film noir: grayscale ghosting effect instead of color split\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snake.length > 1 ? i / (snake.length - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n      const alpha = this.chromaticIntensity * 0.3 * (i === 0 ? 1 : 0.5);\n\n      // Light ghost - offset left\n      g.fillStyle(0xffffff, alpha);\n      g.fillCircle(cx - offset, cy, radius);\n\n      // Dark ghost - offset right\n      g.fillStyle(0x404040, alpha);\n      g.fillCircle(cx + offset, cy, radius);\n    }\n  }\n\n  private drawGameOver(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir game over: dramatic fade to black with spotlight\n    if (this.gameOverAlpha < 0.85) {\n      this.gameOverAlpha += 0.03;\n    }\n\n    // Heavy dark overlay\n    g.fillStyle(COLORS.gameOverOverlay, this.gameOverAlpha);\n    g.fillRect(0, 0, width, height);\n\n    // Film grain effect (subtle noise lines)\n    for (let y = 0; y < height; y += 3) {\n      const grainAlpha = 0.05 + Math.random() * 0.05;\n      g.fillStyle(Math.random() > 0.5 ? 0xffffff : 0x000000, grainAlpha);\n      g.fillRect(0, y, width, 1);\n    }\n\n    // Dramatic spotlight in center\n    const spotPulse = 0.15 + Math.sin(this.frameCount * 0.05) * 0.05;\n    g.fillStyle(COLORS.noirWhite, spotPulse);\n    g.fillCircle(width / 2, height / 2, 80);\n    g.fillStyle(COLORS.noirWhite, spotPulse * 0.5);\n    g.fillCircle(width / 2, height / 2, 120);\n\n    // Noir border: thick black frame\n    const borderSize = 8;\n    g.fillStyle(0x000000, 0.8);\n    g.fillRect(0, 0, width, borderSize);\n    g.fillRect(0, height - borderSize, width, borderSize);\n    g.fillRect(0, 0, borderSize, height);\n    g.fillRect(width - borderSize, 0, borderSize, height);\n\n    // White inner border\n    const innerBorder = 2;\n    const innerOffset = borderSize;\n    g.fillStyle(COLORS.noirWhite, 0.3);\n    g.fillRect(innerOffset, innerOffset, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, height - innerOffset - innerBorder, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, innerOffset, innerBorder, height - innerOffset * 2);\n    g.fillRect(width - innerOffset - innerBorder, innerOffset, innerBorder, height - innerOffset * 2);\n  }\n\n  private drawSnakeHead(\n    g: Phaser.GameObjects.Graphics,\n    head: Position,\n    nextSegment: Position | undefined\n  ): void {\n    const centerX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const centerY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Determine direction for eye placement\n    let dx = 1, dy = 0;\n    if (nextSegment) {\n      dx = head.x - nextSegment.x;\n      dy = head.y - nextSegment.y;\n      // Normalize\n      const len = Math.sqrt(dx * dx + dy * dy);\n      if (len > 0) {\n        dx /= len;\n        dy /= len;\n      }\n    }\n\n    // Perpendicular for eye offset\n    const perpX = -dy;\n    const perpY = dx;\n\n    const eyeOffset = 4;\n    const eyeForward = 3;\n    const eyeRadius = 3;\n    const pupilRadius = 1.5;\n\n    // Left eye\n    const leftEyeX = centerX + perpX * eyeOffset + dx * eyeForward;\n    const leftEyeY = centerY + perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(leftEyeX, leftEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(leftEyeX + dx * 1, leftEyeY + dy * 1, pupilRadius);\n\n    // Right eye\n    const rightEyeX = centerX - perpX * eyeOffset + dx * eyeForward;\n    const rightEyeY = centerY - perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(rightEyeX, rightEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(rightEyeX + dx * 1, rightEyeY + dy * 1, pupilRadius);\n\n    // Draw the royal crown\n    this.drawCrown(g, centerX, centerY, dx, dy, perpX, perpY);\n  }\n\n  private drawCrown(\n    g: Phaser.GameObjects.Graphics,\n    headX: number,\n    headY: number,\n    dx: number,\n    dy: number,\n    perpX: number,\n    perpY: number\n  ): void {\n    // Volcanic crown: molten gold with ruby gems\n    const crownOffset = -8;\n    const crownBaseX = headX - dx * crownOffset;\n    const crownBaseY = headY - dy * crownOffset;\n\n    const crownWidth = 14;\n    const crownHeight = 10;\n    const halfWidth = crownWidth / 2;\n\n    const sparkle = 0.7 + Math.sin(this.frameCount * 0.15) * 0.3;\n\n    const baseLeft = {\n      x: crownBaseX + perpX * halfWidth,\n      y: crownBaseY + perpY * halfWidth\n    };\n    const baseRight = {\n      x: crownBaseX - perpX * halfWidth,\n      y: crownBaseY - perpY * halfWidth\n    };\n\n    const pointOffset = -dx * crownHeight;\n    const pointOffsetY = -dy * crownHeight;\n\n    const crownPoints = [\n      baseLeft,\n      { x: baseLeft.x + pointOffset * 0.4, y: baseLeft.y + pointOffsetY * 0.4 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: crownBaseX + perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY + perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY },\n      { x: crownBaseX - perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY - perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: baseRight.x + pointOffset * 0.4, y: baseRight.y + pointOffsetY * 0.4 },\n      baseRight\n    ];\n\n    // Crown glow (molten orange/red aura)\n    g.fillStyle(COLORS.noirWhite, 0.25 * sparkle);\n    g.fillCircle(crownBaseX + pointOffset * 0.5, crownBaseY + pointOffsetY * 0.5, crownHeight + 4);\n\n    // Crown base (molten gold)\n    g.fillStyle(0xffa500, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.fillPath();\n\n    // Crown outline (dark crimson)\n    g.lineStyle(1.5, 0x801010, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.strokePath();\n\n    // Crown band\n    const bandY1 = {\n      x: baseLeft.x + pointOffset * 0.15,\n      y: baseLeft.y + pointOffsetY * 0.15\n    };\n    const bandY2 = {\n      x: baseRight.x + pointOffset * 0.15,\n      y: baseRight.y + pointOffsetY * 0.15\n    };\n    g.lineStyle(3, 0xcc6600, 1);\n    g.lineBetween(bandY1.x, bandY1.y, bandY2.x, bandY2.y);\n\n    // Ruby jewels: glowing red gems\n    const jewelPositions = [\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY, size: 2.5 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n    ];\n\n    for (const jewel of jewelPositions) {\n      g.fillStyle(0xff4020, 0.5 * sparkle);\n      g.fillCircle(jewel.x, jewel.y, jewel.size + 2);\n\n      g.fillStyle(0xff2000, 1);\n      g.fillCircle(jewel.x, jewel.y, jewel.size);\n\n      g.fillStyle(0xffff80, 0.9 * sparkle);\n      g.fillCircle(jewel.x - 0.5, jewel.y - 0.5, jewel.size * 0.4);\n    }\n\n    // Crown highlight (golden gleam)\n    g.fillStyle(0xffff80, 0.6 * sparkle);\n    g.fillCircle(crownBaseX + perpX * 3 + pointOffset * 0.3, crownBaseY + perpY * 3 + pointOffsetY * 0.3, 2);\n  }\n}\n","structuredPatch":[{"oldStart":2425,"oldLines":6,"newStart":2425,"newLines":7,"lines":["     drawCleanBackground(g, width, height, this.frameCount);","     drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);","     drawMotes(g, this.cleanEffects);","+    drawSnowflakes(g, this.cleanEffects);"," ","     if (!this.currentState) return;"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VuUYGGZHtRWLxWQ8CrLExQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017ozAbBxNJFoWae9WBA9Lr3","name":"TodoWrite","input":{"todos":[{"content":"Add snowflake particle interface and state to cleanEffects.ts","status":"completed","activeForm":"Adding snowflake particle interface and state"},{"content":"Create snowflake update and draw functions","status":"completed","activeForm":"Creating snowflake update and draw functions"},{"content":"Update Christmas color palette for food and snake","status":"completed","activeForm":"Updating Christmas color palette"},{"content":"Import and integrate snowflakes in SnakeScene.ts","status":"completed","activeForm":"Importing and integrating snowflakes"},{"content":"Run npm test and npm run build","status":"in_progress","activeForm":"Running tests and build"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":367,"cache_read_input_tokens":43522,"cache_creation":{"ephemeral_5m_input_tokens":367,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"7a4d42a2-16bd-4093-a45b-0be0153591f6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017ozAbBxNJFoWae9WBA9Lr3","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"e71cd267-fceb-45a6-95c3-f6e275df4b59","tool_use_result":{"oldTodos":[{"content":"Add snowflake particle interface and state to cleanEffects.ts","status":"completed","activeForm":"Adding snowflake particle interface and state"},{"content":"Create snowflake update and draw functions","status":"completed","activeForm":"Creating snowflake update and draw functions"},{"content":"Update Christmas color palette for food and snake","status":"completed","activeForm":"Updating Christmas color palette"},{"content":"Import and integrate snowflakes in SnakeScene.ts","status":"in_progress","activeForm":"Importing and integrating snowflakes"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}],"newTodos":[{"content":"Add snowflake particle interface and state to cleanEffects.ts","status":"completed","activeForm":"Adding snowflake particle interface and state"},{"content":"Create snowflake update and draw functions","status":"completed","activeForm":"Creating snowflake update and draw functions"},{"content":"Update Christmas color palette for food and snake","status":"completed","activeForm":"Updating Christmas color palette"},{"content":"Import and integrate snowflakes in SnakeScene.ts","status":"completed","activeForm":"Importing and integrating snowflakes"},{"content":"Run npm test and npm run build","status":"in_progress","activeForm":"Running tests and build"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014HaNiaXWGoPANTV6iS1UQ2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YC7ozQepw2vwUk6qjJEPU3","name":"Bash","input":{"command":"npm test 2>&1","description":"Running npm test for the game","timeout":120000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":333,"cache_read_input_tokens":43889,"cache_creation":{"ephemeral_5m_input_tokens":333,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"04b210d5-8f89-4021-9438-4282414beb1c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YC7ozQepw2vwUk6qjJEPU3","type":"tool_result","content":"> the-perfect-snake@0.0.0 test\n> vitest run\n\n\n\u001b[7m\u001b[1m\u001b[36m RUN \u001b[39m\u001b[22m\u001b[27m \u001b[36mv1.6.1\u001b[39m \u001b[90m/__w/perfect-snake-platform/perfect-snake-platform/game\u001b[39m\n\n \u001b[32m✓\u001b[39m src/__tests__/visual-safety.test.tsx \u001b[2m (\u001b[22m\u001b[2m15 tests\u001b[22m\u001b[2m)\u001b[22m\u001b[33m 472\u001b[2mms\u001b[22m\u001b[39m\n\u001b[90mstderr\u001b[2m | VirtualConsole.<anonymous> (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/virtual-console.js:29:45)\u001b[22m\u001b[39m\nError: Not implemented: HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\n    at module.exports (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/browser/not-implemented.js:9:17)\n    at HTMLCanvasElementImpl.getContext (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/living/nodes/HTMLCanvasElement-impl.js:42:5)\n    at HTMLCanvasElement.getContext (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/living/generated/HTMLCanvasElement.js:131:58)\n    at checkInverseAlpha (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:72:26)\n    at init (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:106:46)\n    at Object.<anonymous> (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:112:18)\n    at Module._compile (node:internal/modules/cjs/loader:1521:14)\n    at Object..js (node:internal/modules/cjs/loader:1623:10)\n    at Module.load (node:internal/modules/cjs/loader:1266:32)\n    at Function._load (node:internal/modules/cjs/loader:1091:12) undefined\n\n \u001b[32m✓\u001b[39m src/__tests__/postMessage.test.ts \u001b[2m (\u001b[22m\u001b[2m10 tests\u001b[22m\u001b[2m)\u001b[22m\u001b[90m 33\u001b[2mms\u001b[22m\u001b[39m\n \u001b[32m✓\u001b[39m src/components/GameBoard.test.tsx \u001b[2m (\u001b[22m\u001b[2m1 test\u001b[22m\u001b[2m)\u001b[22m\u001b[90m 21\u001b[2mms\u001b[22m\u001b[39m\n\u001b[90mstderr\u001b[2m | VirtualConsole.<anonymous> (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/virtual-console.js:29:45)\u001b[22m\u001b[39m\nError: Not implemented: HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\n    at module.exports (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/browser/not-implemented.js:9:17)\n    at HTMLCanvasElementImpl.getContext (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/living/nodes/HTMLCanvasElement-impl.js:42:5)\n    at HTMLCanvasElement.getContext (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/living/generated/HTMLCanvasElement.js:131:58)\n    at checkInverseAlpha (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:72:26)\n    at init (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:106:46)\n    at Object.<anonymous> (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:112:18)\n    at Module._compile (node:internal/modules/cjs/loader:1521:14)\n    at Object..js (node:internal/modules/cjs/loader:1623:10)\n    at Module.load (node:internal/modules/cjs/loader:1266:32)\n    at Function._load (node:internal/modules/cjs/loader:1091:12) undefined\n\n\n\u001b[2m Test Files \u001b[22m \u001b[1m\u001b[32m3 passed\u001b[39m\u001b[22m\u001b[90m (3)\u001b[39m\n\u001b[2m      Tests \u001b[22m \u001b[1m\u001b[32m26 passed\u001b[39m\u001b[22m\u001b[90m (26)\u001b[39m\n\u001b[2m   Start at \u001b[22m 21:59:56\n\u001b[2m   Duration \u001b[22m 3.37s\u001b[2m (transform 241ms, setup 437ms, collect 276ms, tests 526ms, environment 1.37s, prepare 308ms)\u001b[22m","is_error":false}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"6cc4ff5b-e6e6-41c6-b30a-7d3098889169","tool_use_result":{"stdout":"> the-perfect-snake@0.0.0 test\n> vitest run\n\n\n\u001b[7m\u001b[1m\u001b[36m RUN \u001b[39m\u001b[22m\u001b[27m \u001b[36mv1.6.1\u001b[39m \u001b[90m/__w/perfect-snake-platform/perfect-snake-platform/game\u001b[39m\n\n \u001b[32m✓\u001b[39m src/__tests__/visual-safety.test.tsx \u001b[2m (\u001b[22m\u001b[2m15 tests\u001b[22m\u001b[2m)\u001b[22m\u001b[33m 472\u001b[2mms\u001b[22m\u001b[39m\n\u001b[90mstderr\u001b[2m | VirtualConsole.<anonymous> (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/virtual-console.js:29:45)\u001b[22m\u001b[39m\nError: Not implemented: HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\n    at module.exports (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/browser/not-implemented.js:9:17)\n    at HTMLCanvasElementImpl.getContext (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/living/nodes/HTMLCanvasElement-impl.js:42:5)\n    at HTMLCanvasElement.getContext (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/living/generated/HTMLCanvasElement.js:131:58)\n    at checkInverseAlpha (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:72:26)\n    at init (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:106:46)\n    at Object.<anonymous> (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:112:18)\n    at Module._compile (node:internal/modules/cjs/loader:1521:14)\n    at Object..js (node:internal/modules/cjs/loader:1623:10)\n    at Module.load (node:internal/modules/cjs/loader:1266:32)\n    at Function._load (node:internal/modules/cjs/loader:1091:12) undefined\n\n \u001b[32m✓\u001b[39m src/__tests__/postMessage.test.ts \u001b[2m (\u001b[22m\u001b[2m10 tests\u001b[22m\u001b[2m)\u001b[22m\u001b[90m 33\u001b[2mms\u001b[22m\u001b[39m\n \u001b[32m✓\u001b[39m src/components/GameBoard.test.tsx \u001b[2m (\u001b[22m\u001b[2m1 test\u001b[22m\u001b[2m)\u001b[22m\u001b[90m 21\u001b[2mms\u001b[22m\u001b[39m\n\u001b[90mstderr\u001b[2m | VirtualConsole.<anonymous> (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/virtual-console.js:29:45)\u001b[22m\u001b[39m\nError: Not implemented: HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\n    at module.exports (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/browser/not-implemented.js:9:17)\n    at HTMLCanvasElementImpl.getContext (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/living/nodes/HTMLCanvasElement-impl.js:42:5)\n    at HTMLCanvasElement.getContext (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/living/generated/HTMLCanvasElement.js:131:58)\n    at checkInverseAlpha (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:72:26)\n    at init (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:106:46)\n    at Object.<anonymous> (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:112:18)\n    at Module._compile (node:internal/modules/cjs/loader:1521:14)\n    at Object..js (node:internal/modules/cjs/loader:1623:10)\n    at Module.load (node:internal/modules/cjs/loader:1266:32)\n    at Function._load (node:internal/modules/cjs/loader:1091:12) undefined\n\n\n\u001b[2m Test Files \u001b[22m \u001b[1m\u001b[32m3 passed\u001b[39m\u001b[22m\u001b[90m (3)\u001b[39m\n\u001b[2m      Tests \u001b[22m \u001b[1m\u001b[32m26 passed\u001b[39m\u001b[22m\u001b[90m (26)\u001b[39m\n\u001b[2m   Start at \u001b[22m 21:59:56\n\u001b[2m   Duration \u001b[22m 3.37s\u001b[2m (transform 241ms, setup 437ms, collect 276ms, tests 526ms, environment 1.37s, prepare 308ms)\u001b[22m","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019DvjRHseZagvzAXPh2qK2N","type":"message","role":"assistant","content":[{"type":"text","text":"Tests pass. Now let me run the build."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1480,"cache_read_input_tokens":44222,"cache_creation":{"ephemeral_5m_input_tokens":1480,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"fd03c63b-35c1-4781-8a84-afa2f90d7c38"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019DvjRHseZagvzAXPh2qK2N","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0179XHPtbGZb5P5j8b7uHucA","name":"Bash","input":{"command":"npm run build 2>&1","description":"Running npm run build","timeout":120000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1480,"cache_read_input_tokens":44222,"cache_creation":{"ephemeral_5m_input_tokens":1480,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"e3ae1bdd-8309-41b7-b7a2-a98329a0fcb1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0179XHPtbGZb5P5j8b7uHucA","type":"tool_result","content":"> the-perfect-snake@0.0.0 build\n> tsc && vite build\n\n\u001b[36mvite v5.4.21 \u001b[32mbuilding for production...\u001b[36m\u001b[39m\ntransforming...\n\u001b[32m✓\u001b[39m 47 modules transformed.\nrendering chunks...\ncomputing gzip size...\n\u001b[2mdist/\u001b[22m\u001b[32mindex.html                     \u001b[39m\u001b[1m\u001b[2m    0.47 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m │ gzip:   0.30 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[35mindex-lEa4aZZ6.css      \u001b[39m\u001b[1m\u001b[2m    3.29 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m │ gzip:   0.97 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[36mSnakeScene-z6sFSMe4.js  \u001b[39m\u001b[1m\u001b[2m   65.24 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m │ gzip:  17.92 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[36mindex-XAV4dw72.js       \u001b[39m\u001b[1m\u001b[2m  165.37 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m │ gzip:  53.85 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[36mphaser-DYmWhAWu.js      \u001b[39m\u001b[1m\u001b[33m1,478.82 kB\u001b[39m\u001b[22m\u001b[2m │ gzip: 339.81 kB\u001b[22m\n\u001b[33m\n(!) Some chunks are larger than 500 kB after minification. Consider:\n- Using dynamic import() to code-split the application\n- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks\n- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.\u001b[39m\n\u001b[32m✓ built in 7.68s\u001b[39m","is_error":false}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"715c28c3-3f39-425d-90cb-82629c913d51","tool_use_result":{"stdout":"> the-perfect-snake@0.0.0 build\n> tsc && vite build\n\n\u001b[36mvite v5.4.21 \u001b[32mbuilding for production...\u001b[36m\u001b[39m\ntransforming...\n\u001b[32m✓\u001b[39m 47 modules transformed.\nrendering chunks...\ncomputing gzip size...\n\u001b[2mdist/\u001b[22m\u001b[32mindex.html                     \u001b[39m\u001b[1m\u001b[2m    0.47 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m │ gzip:   0.30 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[35mindex-lEa4aZZ6.css      \u001b[39m\u001b[1m\u001b[2m    3.29 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m │ gzip:   0.97 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[36mSnakeScene-z6sFSMe4.js  \u001b[39m\u001b[1m\u001b[2m   65.24 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m │ gzip:  17.92 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[36mindex-XAV4dw72.js       \u001b[39m\u001b[1m\u001b[2m  165.37 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m │ gzip:  53.85 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[36mphaser-DYmWhAWu.js      \u001b[39m\u001b[1m\u001b[33m1,478.82 kB\u001b[39m\u001b[22m\u001b[2m │ gzip: 339.81 kB\u001b[22m\n\u001b[33m\n(!) Some chunks are larger than 500 kB after minification. Consider:\n- Using dynamic import() to code-split the application\n- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks\n- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.\u001b[39m\n\u001b[32m✓ built in 7.68s\u001b[39m","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UeLF8j743taMBSiKsaNKUu","type":"message","role":"assistant","content":[{"type":"text","text":"Build passes. Now let me run the performance test."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":704,"cache_read_input_tokens":45702,"cache_creation":{"ephemeral_5m_input_tokens":704,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"9f2f50d7-c5de-4a46-9848-6cbdc8815ae8"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UeLF8j743taMBSiKsaNKUu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016U4kiC6nSJBp9dzpZ7DWcD","name":"Bash","input":{"command":"npm run test:perf 2>&1","description":"Running performance test","timeout":180000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":704,"cache_read_input_tokens":45702,"cache_creation":{"ephemeral_5m_input_tokens":704,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"cdfb23c7-5c5a-4d56-a2f0-e9c61cad4297"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016U4kiC6nSJBp9dzpZ7DWcD","type":"tool_result","content":"> the-perfect-snake@0.0.0 test:perf\n> npx playwright test\n\n[WebServer] \u001b[33m\n[WebServer] (!) Some chunks are larger than 500 kB after minification. Consider:\n[WebServer] - Using dynamic import() to code-split the application\n[WebServer] - Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks\n[WebServer] - Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.\u001b[39m\n\nRunning 1 test using 1 worker\nFrames collected: 181\nAverage frame delta: 16.67 ms\nAverage FPS: 60.0\n·\n  1 passed (17.7s)","is_error":false}]},"parent_tool_use_id":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","uuid":"9328ee3a-2460-44e8-aedd-575a06b37057","tool_use_result":{"stdout":"> the-perfect-snake@0.0.0 test:perf\n> npx playwright test\n\n[WebServer] \u001b[33m\n[WebServer] (!) Some chunks are larger than 500 kB after minification. Consider:\n[WebServer] - Using dynamic import() to code-split the application\n[WebServer] - Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks\n[WebServer] - Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.\u001b[39m\n\nRunning 1 test using 1 worker\nFrames collected: 181\nAverage frame delta: 16.67 ms\nAverage FPS: 60.0\n·\n  1 passed (17.7s)","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false}}
{"type":"result","subtype":"error_max_turns","duration_ms":204832,"duration_api_ms":181624,"is_error":false,"num_turns":26,"stop_reason":null,"session_id":"8f593ad2-dbdd-4309-babf-41c9133237f8","total_cost_usd":0.9883624,"usage":{"input_tokens":29,"cache_creation_input_tokens":31122,"cache_read_input_tokens":927682,"output_tokens":7002,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":31122},"inference_geo":"","iterations":[],"speed":"standard"},"modelUsage":{"claude-haiku-4-5-20251001":{"inputTokens":9652,"outputTokens":6083,"cacheReadInputTokens":582869,"cacheCreationInputTokens":45168,"webSearchRequests":0,"costUSD":0.1548139,"contextWindow":200000,"maxOutputTokens":64000},"claude-opus-4-5-20251101":{"inputTokens":29,"outputTokens":7002,"cacheReadInputTokens":927682,"cacheCreationInputTokens":31122,"webSearchRequests":0,"costUSD":0.8335485,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"f7f917b5-1e32-460f-8657-4f720fa84c5b","errors":[]}
