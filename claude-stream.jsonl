{"type":"system","subtype":"init","cwd":"/__w/perfect-snake-platform/perfect-snake-platform/game","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","ToolSearch"],"mcp_servers":[],"model":"claude-opus-4-5-20251101","permissionMode":"default","slash_commands":["debug","compact","context","cost","init","pr-comments","release-notes","review","security-review","insights"],"apiKeySource":"ANTHROPIC_API_KEY","claude_code_version":"2.1.41","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan"],"skills":["debug"],"plugins":[],"uuid":"dc5daab3-6198-4662-8813-197a2924046b","fast_mode_state":"off"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NLjERDVPUFGiPJ6qEi7E8u","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","name":"Task","input":{"description":"Explore snake game codebase","prompt":"Explore the game codebase to understand its structure. I need to understand:\n1. The main game files and their organization\n2. The Phaser rendering code (where visual changes should be made)\n3. The current visual style and effects\n4. Any existing particle systems or visual effects\n\nLook at the src directory structure and read the key files to understand how the game renders and what visual systems are already in place. Focus on files related to rendering, effects, and the snake appearance.","subagent_type":"Explore"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":6586,"cache_read_input_tokens":13693,"cache_creation":{"ephemeral_5m_input_tokens":6586,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"40db660c-d8e9-4e5e-b44e-ccf20cd20cfc"}
{"type":"user","message":{"role":"user","content":[{"type":"text","text":"Explore the game codebase to understand its structure. I need to understand:\n1. The main game files and their organization\n2. The Phaser rendering code (where visual changes should be made)\n3. The current visual style and effects\n4. Any existing particle systems or visual effects\n\nLook at the src directory structure and read the key files to understand how the game renders and what visual systems are already in place. Focus on files related to rendering, effects, and the snake appearance."}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"4fa3ff01-674a-49d1-bad8-d2166f1b6af6"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01WJH5u9E3LkZqu3khtupj1w","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Kj4GgUgkcstcx3MP1iApR9","name":"Bash","input":{"command":"find /__w/perfect-snake-platform/perfect-snake-platform/game -type f -name \"*.ts\" -o -name \"*.tsx\" -o -name \"*.js\" -o -name \"*.json\" | head -30"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":11649,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":11649,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"b2d69dd7-9bdf-444c-8760-1e4e37ae3411"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Kj4GgUgkcstcx3MP1iApR9","type":"tool_result","content":"/__w/perfect-snake-platform/perfect-snake-platform/game/tsconfig.node.json\n/__w/perfect-snake-platform/perfect-snake-platform/game/e2e/perf.spec.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/.baseline/SnakeScene.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/.baseline/GameBoard.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/scripts/upload-version.js\n/__w/perfect-snake-platform/perfect-snake-platform/game/playwright.config.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/package-lock.json\n/__w/perfect-snake-platform/perfect-snake-platform/game/test-results/.last-run.json\n/__w/perfect-snake-platform/perfect-snake-platform/game/public/versions.json\n/__w/perfect-snake-platform/perfect-snake-platform/game/public/deployment-metadata.json\n/__w/perfect-snake-platform/perfect-snake-platform/game/package.json\n/__w/perfect-snake-platform/perfect-snake-platform/game/vitest.config.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/vite.config.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/tsconfig.json\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/useDirectionQueue.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/logic.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/usePostMessage.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/index.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/useSnakeGame.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/useKeyboard.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/useTouch.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/types.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/constants.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.test.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/vite-env.d.ts\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/main.tsx\n/__w/perfect-snake-platform/perfect-snake-platform/game/src/__tests__/postMessage.test.ts","is_error":false}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"9a688719-506a-4ba4-a381-a5fa2de1fc26"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RWEYZXwyACbtdSD36WHF6i","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VeYJahoRo8fjE3CLWncUuZ","name":"Bash","input":{"command":"ls -la /__w/perfect-snake-platform/perfect-snake-platform/game/src/"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":939,"cache_read_input_tokens":11649,"cache_creation":{"ephemeral_5m_input_tokens":939,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"4b673cb1-872f-4985-9f12-007d45291136"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VeYJahoRo8fjE3CLWncUuZ","type":"tool_result","content":"total 36\ndrwxr-xr-x  5 root root 4096 Feb 24 21:49 .\ndrwxr-xr-x 11 root root 4096 Feb 24 21:50 ..\n-rw-r--r--  1 root root 3484 Feb 24 21:49 App.css\n-rw-r--r--  1 root root 2591 Feb 24 21:49 App.tsx\ndrwxr-xr-x  2 root root 4096 Feb 24 21:49 __tests__\ndrwxr-xr-x  2 root root 4096 Feb 24 21:49 components\ndrwxr-xr-x  2 root root 4096 Feb 24 21:49 game\n-rw-r--r--  1 root root  215 Feb 24 21:49 main.tsx\n-rw-r--r--  1 root root  164 Feb 24 21:49 vite-env.d.ts","is_error":false}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"32a352f7-4536-41ac-a355-7588ecf8c40c"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GzpHkjgRCKRRPrFofqqNqL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018kZ1iWgM9usuvdtj8Sp8ec","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":396,"cache_read_input_tokens":12588,"cache_creation":{"ephemeral_5m_input_tokens":396,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"b7d256d9-4b29-4717-83b6-1f15ffc6d0be"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"EISDIR: illegal operation on a directory, read '/__w/perfect-snake-platform/perfect-snake-platform/game/src/components'","is_error":true,"tool_use_id":"toolu_018kZ1iWgM9usuvdtj8Sp8ec"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"e5a01140-8862-422a-a96e-c9fb27b7a7b8","tool_use_result":"Error: EISDIR: illegal operation on a directory, read '/__w/perfect-snake-platform/perfect-snake-platform/game/src/components'"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GzpHkjgRCKRRPrFofqqNqL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HtdyS31M3eRnrNhPeLjhb8","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/game"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":396,"cache_read_input_tokens":12588,"cache_creation":{"ephemeral_5m_input_tokens":396,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"0e7f4ef5-b296-41d9-a871-4b3046847405"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>Sibling tool call errored</tool_use_error>","is_error":true,"tool_use_id":"toolu_01HtdyS31M3eRnrNhPeLjhb8"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"ff600d63-5edb-4efe-a4a1-092f9f2dd450","tool_use_result":"Sibling tool call errored"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0119HQNfcBJcKo36HbSScBNL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MqyxmxhAendbDWmMYaJSpZ","name":"Bash","input":{"command":"ls -la /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/ && echo \"---\" && ls -la /__w/perfect-snake-platform/perfect-snake-platform/game/src/game/"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":295,"cache_read_input_tokens":12984,"cache_creation":{"ephemeral_5m_input_tokens":295,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"b01c0718-b416-48b3-af1d-f89e3a98a3bb"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Command contains quoted characters in flag names","is_error":true,"tool_use_id":"toolu_01MqyxmxhAendbDWmMYaJSpZ"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"d6d323cc-4a03-4a60-aed7-1963e0b8aae4","tool_use_result":"Error: Command contains quoted characters in flag names"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UenpViEi4L5GuLdCJBwyYT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LrGxzLiDYYDdF4xU9k94qz","name":"Bash","input":{"command":"ls -la /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":179,"cache_read_input_tokens":13279,"cache_creation":{"ephemeral_5m_input_tokens":179,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"6b723049-ad9c-4fdc-af83-a2b362a7fc45"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LrGxzLiDYYDdF4xU9k94qz","type":"tool_result","content":"total 204\ndrwxr-xr-x 2 root root   4096 Feb 24 21:49 .\ndrwxr-xr-x 5 root root   4096 Feb 24 21:49 ..\n-rw-r--r-- 1 root root   1310 Feb 24 21:49 GameBoard.css\n-rw-r--r-- 1 root root    746 Feb 24 21:49 GameBoard.test.tsx\n-rw-r--r-- 1 root root     71 Feb 24 21:49 GameBoard.test.tsx.bak\n-rw-r--r-- 1 root root  33454 Feb 24 21:49 GameBoard.tsx\n-rw-r--r-- 1 root root 135172 Feb 24 21:49 SnakeScene.ts\n-rw-r--r-- 1 root root   9362 Feb 24 21:49 cleanEffects.ts","is_error":false}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"814fc741-0865-4c60-8414-d951dcb6235f"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UenpViEi4L5GuLdCJBwyYT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016h3hghJaHnY6FDPo7nQdp8","name":"Bash","input":{"command":"ls -la /__w/perfect-snake-platform/perfect-snake-platform/game/src/game/"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":179,"cache_read_input_tokens":13279,"cache_creation":{"ephemeral_5m_input_tokens":179,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"e928d942-bfb8-46db-9ce5-a71792a6a3ac"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016h3hghJaHnY6FDPo7nQdp8","type":"tool_result","content":"total 48\ndrwxr-xr-x 2 root root 4096 Feb 24 21:49 .\ndrwxr-xr-x 5 root root 4096 Feb 24 21:49 ..\n-rw-r--r-- 1 root root 1166 Feb 24 21:49 constants.ts\n-rw-r--r-- 1 root root  194 Feb 24 21:49 index.ts\n-rw-r--r-- 1 root root 5933 Feb 24 21:49 logic.ts\n-rw-r--r-- 1 root root  830 Feb 24 21:49 types.ts\n-rw-r--r-- 1 root root 1929 Feb 24 21:49 useDirectionQueue.ts\n-rw-r--r-- 1 root root 1291 Feb 24 21:49 useKeyboard.ts\n-rw-r--r-- 1 root root 3181 Feb 24 21:49 usePostMessage.ts\n-rw-r--r-- 1 root root 3200 Feb 24 21:49 useSnakeGame.ts\n-rw-r--r-- 1 root root 1743 Feb 24 21:49 useTouch.ts","is_error":false}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"0eedb9fa-4882-4e5e-b1f8-1fabd0def5ce"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01PgakSQnTckk6PWUCAJ7fDA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JGbEpGpkMrxnCNa1u89Wvm","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","limit":200},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":912,"cache_read_input_tokens":13458,"cache_creation":{"ephemeral_5m_input_tokens":912,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"b26cc2d9-e2c9-4d79-a684-1a95b0529413"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JGbEpGpkMrxnCNa1u89Wvm","type":"tool_result","content":"     1â†’import Phaser from 'phaser';\n     2â†’import {\n     3â†’  createCleanEffectsState,\n     4â†’  initMotes,\n     5â†’  updateMotes,\n     6â†’  updateRipples,\n     7â†’  updateGlowTrail,\n     8â†’  spawnRipple,\n     9â†’  drawCleanBackground,\n    10â†’  drawCleanGrid,\n    11â†’  drawMotes,\n    12â†’  drawRipples,\n    13â†’  drawGlowTrail,\n    14â†’  drawCleanFood,\n    15â†’  drawCleanSnake,\n    16â†’  drawCleanVignette,\n    17â†’  drawCleanHUD,\n    18â†’  CLEAN_COLORS,\n    19â†’  CleanEffectsState,\n    20â†’} from './cleanEffects';\n    21â†’\n    22â†’interface Position {\n    23â†’  x: number;\n    24â†’  y: number;\n    25â†’}\n    26â†’\n    27â†’interface GameState {\n    28â†’  snake: Position[];\n    29â†’  food: Position;\n    30â†’  gameOver: boolean;\n    31â†’  gameStarted?: boolean;\n    32â†’  score?: number;\n    33â†’}\n    34â†’\n    35â†’interface Star {\n    36â†’  x: number;\n    37â†’  y: number;\n    38â†’  size: number;\n    39â†’  speed: number;\n    40â†’  brightness: number;\n    41â†’}\n    42â†’\n    43â†’interface PlasmaWave {\n    44â†’  phase: number;\n    45â†’  speed: number;\n    46â†’  amplitude: number;\n    47â†’  wavelength: number;\n    48â†’  hue: number;\n    49â†’}\n    50â†’\n    51â†’interface AuroraWave {\n    52â†’  y: number;\n    53â†’  phase: number;\n    54â†’  speed: number;\n    55â†’  hue: number;\n    56â†’  thickness: number;\n    57â†’  amplitude: number;\n    58â†’}\n    59â†’\n    60â†’interface NebulaCloud {\n    61â†’  x: number;\n    62â†’  y: number;\n    63â†’  radius: number;\n    64â†’  hue: number;\n    65â†’  alpha: number;\n    66â†’  driftX: number;\n    67â†’  driftY: number;\n    68â†’  pulsePhase: number;\n    69â†’  pulseSpeed: number;\n    70â†’}\n    71â†’\n    72â†’interface VortexRing {\n    73â†’  radius: number;\n    74â†’  baseRadius: number;\n    75â†’  rotationOffset: number;\n    76â†’  rotationSpeed: number;\n    77â†’  thickness: number;\n    78â†’  hue: number;\n    79â†’  pulsePhase: number;\n    80â†’}\n    81â†’\n    82â†’interface VortexParticle {\n    83â†’  angle: number;\n    84â†’  radius: number;\n    85â†’  baseRadius: number;\n    86â†’  speed: number;\n    87â†’  size: number;\n    88â†’  hue: number;\n    89â†’  alpha: number;\n    90â†’}\n    91â†’\n    92â†’interface SnakeAfterimage {\n    93â†’  segments: Position[];\n    94â†’  life: number;\n    95â†’  maxLife: number;\n    96â†’  hueOffset: number;\n    97â†’}\n    98â†’\n    99â†’interface FoodParticle {\n   100â†’  x: number;\n   101â†’  y: number;\n   102â†’  vx: number;\n   103â†’  vy: number;\n   104â†’  life: number;\n   105â†’  maxLife: number;\n   106â†’  size: number;\n   107â†’}\n   108â†’\n   109â†’interface SnakeTrailParticle {\n   110â†’  x: number;\n   111â†’  y: number;\n   112â†’  vx: number;\n   113â†’  vy: number;\n   114â†’  life: number;\n   115â†’  maxLife: number;\n   116â†’  size: number;\n   117â†’  hue: number;\n   118â†’}\n   119â†’\n   120â†’interface ShockWave {\n   121â†’  x: number;\n   122â†’  y: number;\n   123â†’  radius: number;\n   124â†’  maxRadius: number;\n   125â†’  life: number;\n   126â†’}\n   127â†’\n   128â†’interface LightningBolt {\n   129â†’  points: { x: number; y: number }[];\n   130â†’  life: number;\n   131â†’  maxLife: number;\n   132â†’  hue: number;\n   133â†’}\n   134â†’\n   135â†’const CELL_SIZE = 20;\n   136â†’const GRID_SIZE = 20;\n   137â†’const NUM_STARS = 30;\n   138â†’const MAX_FOOD_PARTICLES = 8;\n   139â†’const MAX_TRAIL_PARTICLES = 40;\n   140â†’const MAX_SHOCKWAVES = 3;\n   141â†’const MAX_LIGHTNING_BOLTS = 5;\n   142â†’const MAX_BURST_PARTICLES = 12;\n   143â†’const NUM_PLASMA_WAVES = 3;\n   144â†’const MAX_AFTERIMAGES = 4;\n   145â†’const NUM_AURORA_WAVES = 5;\n   146â†’const NUM_NEBULA_CLOUDS = 6;\n   147â†’const NUM_VORTEX_RINGS = 5;\n   148â†’const NUM_VORTEX_PARTICLES = 20;\n   149â†’const NUM_METEORS = 8;\n   150â†’const MAX_DEATH_DEBRIS = 24;\n   151â†’const NUM_SPIRITS_PER_EDGE = 2;\n   152â†’const MAX_FLAME_PARTICLES = 60;\n   153â†’const MAX_COMET_TRAIL_LENGTH = 30;\n   154â†’const MAX_ETHEREAL_PARTICLES = 50;\n   155â†’const NUM_BEES = 8;\n   156â†’const BEE_SPAWN_CHANCE = 0.02;\n   157â†’\n   158â†’// Comet trail segment - stores historical snake positions for smooth trail rendering\n   159â†’interface CometTrailSegment {\n   160â†’  x: number;\n   161â†’  y: number;\n   162â†’  alpha: number;\n   163â†’  size: number;\n   164â†’  hue: number;\n   165â†’}\n   166â†’\n   167â†’// Ethereal trail particle - luminous particles that drift away from trail\n   168â†’interface EtherealParticle {\n   169â†’  x: number;\n   170â†’  y: number;\n   171â†’  vx: number;\n   172â†’  vy: number;\n   173â†’  size: number;\n   174â†’  life: number;\n   175â†’  maxLife: number;\n   176â†’  hue: number;\n   177â†’  brightness: number;\n   178â†’  pulsePhase: number;\n   179â†’}\n   180â†’\n   181â†’// Thrown food animation - food launched onto screen with arc trajectory\n   182â†’interface ThrownFood {\n   183â†’  startX: number;\n   184â†’  startY: number;\n   185â†’  targetX: number;\n   186â†’  targetY: number;\n   187â†’  x: number;\n   188â†’  y: number;\n   189â†’  progress: number; // 0 to 1\n   190â†’  rotation: number;\n   191â†’  rotationSpeed: number;\n   192â†’  trail: { x: number; y: number; alpha: number; rotation: number }[];\n   193â†’  landed: boolean;\n   194â†’  landingParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number }[];\n   195â†’  impactRings: { radius: number; alpha: number }[];\n   196â†’}\n   197â†’\n   198â†’// Meteor shower types\n   199â†’interface Meteor {\n   200â†’  x: number;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"1a0c5d56-04d4-4b98-8337-f9a0a2289d9d"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01PgakSQnTckk6PWUCAJ7fDA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JAfjWEGW7eSKVUwvZBdMBu","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":912,"cache_read_input_tokens":13458,"cache_creation":{"ephemeral_5m_input_tokens":912,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"32240035-242f-43c9-a307-7abbef310768"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JAfjWEGW7eSKVUwvZBdMBu","type":"tool_result","content":"     1â†’export interface CleanRipple {\n     2â†’  x: number;\n     3â†’  y: number;\n     4â†’  radius: number;\n     5â†’  maxRadius: number;\n     6â†’  alpha: number;\n     7â†’  thickness: number;\n     8â†’}\n     9â†’\n    10â†’export interface FloatingMote {\n    11â†’  x: number;\n    12â†’  y: number;\n    13â†’  vx: number;\n    14â†’  vy: number;\n    15â†’  size: number;\n    16â†’  alpha: number;\n    17â†’  pulsePhase: number;\n    18â†’}\n    19â†’\n    20â†’export interface SnakeGlowTrail {\n    21â†’  x: number;\n    22â†’  y: number;\n    23â†’  alpha: number;\n    24â†’  size: number;\n    25â†’}\n    26â†’\n    27â†’export const CLEAN_COLORS = {\n    28â†’  bgDark: 0x0a1628,\n    29â†’  bgMid: 0x0f1d32,\n    30â†’  bgLight: 0x14253e,\n    31â†’\n    32â†’  gridLine: 0x1a3050,\n    33â†’  gridAccent: 0x254060,\n    34â†’\n    35â†’  snakeHead: 0x4fd1c5,\n    36â†’  snakeBody: 0x38b2ac,\n    37â†’  snakeTail: 0x2c9a94,\n    38â†’  snakeGlow: 0x81e6d9,\n    39â†’\n    40â†’  food: 0xe2e8f0,\n    41â†’  foodCore: 0xffffff,\n    42â†’  foodGlow: 0xcbd5e1,\n    43â†’\n    44â†’  ripple: 0x81e6d9,\n    45â†’  mote: 0x4fd1c5,\n    46â†’\n    47â†’  text: 0xe2e8f0,\n    48â†’  textDim: 0x94a3b8,\n    49â†’};\n    50â†’\n    51â†’const MAX_RIPPLES = 5;\n    52â†’const MAX_MOTES = 20;\n    53â†’const MAX_TRAIL_LENGTH = 15;\n    54â†’\n    55â†’export function createCleanEffectsState() {\n    56â†’  return {\n    57â†’    ripples: [] as CleanRipple[],\n    58â†’    motes: [] as FloatingMote[],\n    59â†’    glowTrail: [] as SnakeGlowTrail[],\n    60â†’    frameCount: 0,\n    61â†’  };\n    62â†’}\n    63â†’\n    64â†’export type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n    65â†’\n    66â†’export function initMotes(state: CleanEffectsState, width: number, height: number): void {\n    67â†’  state.motes = [];\n    68â†’  for (let i = 0; i < MAX_MOTES; i++) {\n    69â†’    state.motes.push({\n    70â†’      x: Math.random() * width,\n    71â†’      y: Math.random() * height,\n    72â†’      vx: (Math.random() - 0.5) * 0.3,\n    73â†’      vy: (Math.random() - 0.5) * 0.3,\n    74â†’      size: 1 + Math.random() * 2,\n    75â†’      alpha: 0.1 + Math.random() * 0.2,\n    76â†’      pulsePhase: Math.random() * Math.PI * 2,\n    77â†’    });\n    78â†’  }\n    79â†’}\n    80â†’\n    81â†’export function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n    82â†’  for (const mote of state.motes) {\n    83â†’    mote.x += mote.vx;\n    84â†’    mote.y += mote.vy;\n    85â†’    mote.pulsePhase += 0.02;\n    86â†’\n    87â†’    if (mote.x < 0) mote.x = width;\n    88â†’    if (mote.x > width) mote.x = 0;\n    89â†’    if (mote.y < 0) mote.y = height;\n    90â†’    if (mote.y > height) mote.y = 0;\n    91â†’  }\n    92â†’}\n    93â†’\n    94â†’export function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n    95â†’  if (state.ripples.length >= MAX_RIPPLES) {\n    96â†’    state.ripples.shift();\n    97â†’  }\n    98â†’\n    99â†’  state.ripples.push({\n   100â†’    x,\n   101â†’    y,\n   102â†’    radius: 5,\n   103â†’    maxRadius: 60,\n   104â†’    alpha: 0.6,\n   105â†’    thickness: 2,\n   106â†’  });\n   107â†’}\n   108â†’\n   109â†’export function updateRipples(state: CleanEffectsState): void {\n   110â†’  for (let i = state.ripples.length - 1; i >= 0; i--) {\n   111â†’    const ripple = state.ripples[i];\n   112â†’    ripple.radius += 2;\n   113â†’    ripple.alpha *= 0.94;\n   114â†’    ripple.thickness *= 0.98;\n   115â†’\n   116â†’    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n   117â†’      state.ripples.splice(i, 1);\n   118â†’    }\n   119â†’  }\n   120â†’}\n   121â†’\n   122â†’export function updateGlowTrail(\n   123â†’  state: CleanEffectsState,\n   124â†’  headX: number,\n   125â†’  headY: number\n   126â†’): void {\n   127â†’  state.glowTrail.unshift({\n   128â†’    x: headX,\n   129â†’    y: headY,\n   130â†’    alpha: 0.5,\n   131â†’    size: 12,\n   132â†’  });\n   133â†’\n   134â†’  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n   135â†’    state.glowTrail.pop();\n   136â†’  }\n   137â†’\n   138â†’  for (let i = 0; i < state.glowTrail.length; i++) {\n   139â†’    const t = state.glowTrail[i];\n   140â†’    t.alpha *= 0.85;\n   141â†’    t.size *= 0.95;\n   142â†’  }\n   143â†’\n   144â†’  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n   145â†’}\n   146â†’\n   147â†’export function drawCleanBackground(\n   148â†’  g: Phaser.GameObjects.Graphics,\n   149â†’  width: number,\n   150â†’  height: number,\n   151â†’  frameCount: number\n   152â†’): void {\n   153â†’  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n   154â†’  g.fillRect(0, 0, width, height);\n   155â†’\n   156â†’  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n   157â†’  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n   158â†’  g.fillCircle(width / 2, height / 2, width * 0.6);\n   159â†’  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n   160â†’  g.fillCircle(width / 2, height / 2, width * 0.3);\n   161â†’}\n   162â†’\n   163â†’export function drawCleanGrid(\n   164â†’  g: Phaser.GameObjects.Graphics,\n   165â†’  width: number,\n   166â†’  height: number,\n   167â†’  cellSize: number,\n   168â†’  gridSize: number,\n   169â†’  frameCount: number\n   170â†’): void {\n   171â†’  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n   172â†’  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n   173â†’\n   174â†’  for (let i = 0; i <= gridSize; i++) {\n   175â†’    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n   176â†’    g.lineBetween(0, i * cellSize, width, i * cellSize);\n   177â†’  }\n   178â†’\n   179â†’  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n   180â†’  for (let i = 0; i <= gridSize; i += 5) {\n   181â†’    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n   182â†’    g.lineBetween(0, i * cellSize, width, i * cellSize);\n   183â†’  }\n   184â†’}\n   185â†’\n   186â†’export function drawMotes(\n   187â†’  g: Phaser.GameObjects.Graphics,\n   188â†’  state: CleanEffectsState\n   189â†’): void {\n   190â†’  for (const mote of state.motes) {\n   191â†’    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n   192â†’    const alpha = mote.alpha * pulse;\n   193â†’\n   194â†’    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n   195â†’    g.fillCircle(mote.x, mote.y, mote.size * 2);\n   196â†’    g.fillStyle(CLEAN_COLORS.mote, alpha);\n   197â†’    g.fillCircle(mote.x, mote.y, mote.size);\n   198â†’  }\n   199â†’}\n   200â†’\n   201â†’export function drawRipples(\n   202â†’  g: Phaser.GameObjects.Graphics,\n   203â†’  state: CleanEffectsState\n   204â†’): void {\n   205â†’  for (const ripple of state.ripples) {\n   206â†’    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n   207â†’    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n   208â†’\n   209â†’    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n   210â†’    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n   211â†’  }\n   212â†’}\n   213â†’\n   214â†’export function drawGlowTrail(\n   215â†’  g: Phaser.GameObjects.Graphics,\n   216â†’  state: CleanEffectsState\n   217â†’): void {\n   218â†’  for (const trail of state.glowTrail) {\n   219â†’    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n   220â†’    g.fillCircle(trail.x, trail.y, trail.size);\n   221â†’  }\n   222â†’}\n   223â†’\n   224â†’export function drawCleanFood(\n   225â†’  g: Phaser.GameObjects.Graphics,\n   226â†’  foodX: number,\n   227â†’  foodY: number,\n   228â†’  cellSize: number,\n   229â†’  frameCount: number\n   230â†’): void {\n   231â†’  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n   232â†’  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n   233â†’  const foodSize = (cellSize / 2 - 2) * pulseScale;\n   234â†’\n   235â†’  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n   236â†’  g.fillCircle(foodX, foodY, foodSize + 12);\n   237â†’  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n   238â†’  g.fillCircle(foodX, foodY, foodSize + 6);\n   239â†’\n   240â†’  g.fillStyle(CLEAN_COLORS.food, 0.9);\n   241â†’  g.fillCircle(foodX, foodY, foodSize);\n   242â†’  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n   243â†’  g.fillCircle(foodX, foodY, foodSize * 0.5);\n   244â†’\n   245â†’  g.fillStyle(0xffffff, 0.6);\n   246â†’  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n   247â†’}\n   248â†’\n   249â†’export function drawCleanSnake(\n   250â†’  g: Phaser.GameObjects.Graphics,\n   251â†’  snake: { x: number; y: number }[],\n   252â†’  cellSize: number,\n   253â†’  frameCount: number\n   254â†’): void {\n   255â†’  const snakeLen = snake.length;\n   256â†’  if (snakeLen === 0) return;\n   257â†’\n   258â†’  for (let i = snakeLen - 1; i >= 0; i--) {\n   259â†’    const segment = snake[i];\n   260â†’    const centerX = segment.x * cellSize + cellSize / 2;\n   261â†’    const centerY = segment.y * cellSize + cellSize / 2;\n   262â†’    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n   263â†’\n   264â†’    const glowAlpha = 0.15 * (1 - t * 0.5);\n   265â†’    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n   266â†’    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n   267â†’    g.fillCircle(centerX, centerY, glowSize);\n   268â†’  }\n   269â†’\n   270â†’  for (let i = snakeLen - 1; i >= 0; i--) {\n   271â†’    const segment = snake[i];\n   272â†’    const centerX = segment.x * cellSize + cellSize / 2;\n   273â†’    const centerY = segment.y * cellSize + cellSize / 2;\n   274â†’    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n   275â†’    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n   276â†’\n   277â†’    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n   278â†’    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n   279â†’    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n   280â†’    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n   281â†’    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n   282â†’    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n   283â†’\n   284â†’    const r = Math.round(r1 + (r2 - r1) * t);\n   285â†’    const gVal = Math.round(g1 + (g2 - g1) * t);\n   286â†’    const b = Math.round(b1 + (b2 - b1) * t);\n   287â†’    const color = (r << 16) | (gVal << 8) | b;\n   288â†’\n   289â†’    g.fillStyle(color, 0.95);\n   290â†’    g.fillCircle(centerX, centerY, radius);\n   291â†’\n   292â†’    if (i === 0) {\n   293â†’      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n   294â†’      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n   295â†’      g.fillCircle(centerX, centerY, radius + 4);\n   296â†’\n   297â†’      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n   298â†’      g.fillCircle(centerX, centerY, radius);\n   299â†’\n   300â†’      g.fillStyle(0xffffff, 0.7);\n   301â†’      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n   302â†’    }\n   303â†’  }\n   304â†’}\n   305â†’\n   306â†’export function drawCleanVignette(\n   307â†’  g: Phaser.GameObjects.Graphics,\n   308â†’  width: number,\n   309â†’  height: number\n   310â†’): void {\n   311â†’  const layers = 4;\n   312â†’  for (let i = 0; i < layers; i++) {\n   313â†’    const inset = i * 25;\n   314â†’    const alpha = 0.08 * (1 - i / layers);\n   315â†’    g.lineStyle(50, 0x000000, alpha);\n   316â†’    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n   317â†’  }\n   318â†’}\n   319â†’\n   320â†’export function drawCleanHUD(\n   321â†’  g: Phaser.GameObjects.Graphics,\n   322â†’  score: number,\n   323â†’  snakeLength: number,\n   324â†’  width: number,\n   325â†’  frameCount: number,\n   326â†’  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n   327â†’): void {\n   328â†’  const padding = 15;\n   329â†’  const digitSize = 12;\n   330â†’  const digitSpacing = digitSize * 0.6;\n   331â†’\n   332â†’  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n   333â†’\n   334â†’  const scoreStr = String(score).padStart(4, '0');\n   335â†’  let xPos = padding;\n   336â†’\n   337â†’  for (let i = 0; i < scoreStr.length; i++) {\n   338â†’    const digit = scoreStr[i];\n   339â†’    g.fillStyle(CLEAN_COLORS.text, pulse);\n   340â†’    drawDigit(g, digit, xPos, padding, digitSize);\n   341â†’    xPos += digitSpacing;\n   342â†’  }\n   343â†’\n   344â†’  const lengthStr = String(snakeLength);\n   345â†’  xPos = width - padding - lengthStr.length * digitSpacing;\n   346â†’\n   347â†’  for (let i = 0; i < lengthStr.length; i++) {\n   348â†’    const digit = lengthStr[i];\n   349â†’    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n   350â†’    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n   351â†’    xPos += digitSpacing * 0.9;\n   352â†’  }\n   353â†’}\n   354â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"d23a94b4-9af8-4f4a-a896-cb1382162594"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01PgakSQnTckk6PWUCAJ7fDA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HMNUhyWUwAcdbTTHCCykEW","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.tsx","limit":100},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":912,"cache_read_input_tokens":13458,"cache_creation":{"ephemeral_5m_input_tokens":912,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"2347207b-aae6-427b-a503-2e65c2d55add"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HMNUhyWUwAcdbTTHCCykEW","type":"tool_result","content":"     1â†’import { useEffect, useRef, useCallback } from 'react';\n     2â†’import './GameBoard.css';\n     3â†’import type { SnakeScene } from './SnakeScene';\n     4â†’\n     5â†’interface Position {\n     6â†’  x: number;\n     7â†’  y: number;\n     8â†’}\n     9â†’\n    10â†’type PowerUpType = 'SPEED_BOOST' | 'INVINCIBILITY' | 'SCORE_MULTIPLIER' | 'MAGNET';\n    11â†’\n    12â†’interface PowerUp {\n    13â†’  position: Position;\n    14â†’  type: PowerUpType;\n    15â†’  spawnTime: number;\n    16â†’  duration: number;\n    17â†’}\n    18â†’\n    19â†’interface ActivePowerUp {\n    20â†’  type: PowerUpType;\n    21â†’  endTime: number;\n    22â†’}\n    23â†’\n    24â†’interface GameState {\n    25â†’  snake: Position[];\n    26â†’  food: Position;\n    27â†’  gameOver: boolean;\n    28â†’  gameStarted: boolean;\n    29â†’  score: number;\n    30â†’  powerUp?: PowerUp | null;\n    31â†’  activePowerUps?: ActivePowerUp[];\n    32â†’  tickCount?: number;\n    33â†’}\n    34â†’\n    35â†’interface GameBoardProps {\n    36â†’  gameState: GameState;\n    37â†’  gridSize: number;\n    38â†’}\n    39â†’\n    40â†’const CELL_SIZE = 20;\n    41â†’const GRID_SIZE = 20;\n    42â†’\n    43â†’// Deep Ocean Bioluminescent Theme Colors\n    44â†’const COLORS = {\n    45â†’  // Ocean depths background\n    46â†’  oceanDeep: '#020812',\n    47â†’  oceanMid: '#041525',\n    48â†’  oceanLight: '#082040',\n    49â†’\n    50â†’  // Bioluminescent snake\n    51â†’  snakeGlow: '#00ffaa',\n    52â†’  snakeCore: '#40ffc0',\n    53â†’  snakeHead: '#80ffdd',\n    54â†’  snakeEye: '#ffffff',\n    55â†’\n    56â†’  // Food - jellyfish orb\n    57â†’  foodGlow: '#ff6090',\n    58â†’  foodCore: '#ffaacc',\n    59â†’  foodPulse: '#ff80b0',\n    60â†’\n    61â†’  // Ambient particles\n    62â†’  planktonBlue: '#4080ff',\n    63â†’  planktonCyan: '#00e0ff',\n    64â†’  planktonGreen: '#40ff80',\n    65â†’\n    66â†’  // Game over\n    67â†’  gameOverOverlay: 'rgba(2, 8, 18, 0.92)',\n    68â†’\n    69â†’  // Power-up colors\n    70â†’  powerUpSpeed: '#ffff00',\n    71â†’  powerUpSpeedGlow: '#ff8800',\n    72â†’  powerUpInvincibility: '#00ffff',\n    73â†’  powerUpInvincibilityGlow: '#0088ff',\n    74â†’  powerUpMultiplier: '#ff00ff',\n    75â†’  powerUpMultiplierGlow: '#aa00ff',\n    76â†’  powerUpMagnet: '#00ff88',\n    77â†’  powerUpMagnetGlow: '#00ff44',\n    78â†’};\n    79â†’\n    80â†’const POWERUP_COLORS: Record<PowerUpType, { main: string; glow: string; symbol: string }> = {\n    81â†’  SPEED_BOOST: { main: '#ffff00', glow: '#ffa500', symbol: 'âš¡' },\n    82â†’  INVINCIBILITY: { main: '#00ffff', glow: '#0088ff', symbol: 'ðŸ›¡' },\n    83â†’  SCORE_MULTIPLIER: { main: '#ff00ff', glow: '#8800ff', symbol: 'Ã—3' },\n    84â†’  MAGNET: { main: '#00ff88', glow: '#00ff00', symbol: 'â—Ž' },\n    85â†’};\n    86â†’\n    87â†’// Animation frame counter\n    88â†’let frameCount = 0;\n    89â†’\n    90â†’// Floating plankton particles\n    91â†’interface PlanktonParticle {\n    92â†’  x: number;\n    93â†’  y: number;\n    94â†’  vx: number;\n    95â†’  vy: number;\n    96â†’  size: number;\n    97â†’  hue: number;\n    98â†’  alpha: number;\n    99â†’  pulsePhase: number;\n   100â†’  pulseSpeed: number;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"ed1e9965-7cce-427b-ba43-813ed24025f2"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01MCNm2wLZLFMrZnsXfSpJkF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KFffTDj39XDx3dK2xoyf9c","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":200,"limit":300},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":8959,"cache_read_input_tokens":14370,"cache_creation":{"ephemeral_5m_input_tokens":8959,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"d7607d77-3cb1-4f6c-8cf4-fb771fa0e0cb"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KFffTDj39XDx3dK2xoyf9c","type":"tool_result","content":"   200â†’  x: number;\n   201â†’  y: number;\n   202â†’  vx: number;\n   203â†’  vy: number;\n   204â†’  size: number;\n   205â†’  hue: number;\n   206â†’  alpha: number;\n   207â†’  trail: { x: number; y: number; alpha: number }[];\n   208â†’  life: number;\n   209â†’}\n   210â†’\n   211â†’// Death debris particle\n   212â†’interface DeathDebris {\n   213â†’  x: number;\n   214â†’  y: number;\n   215â†’  vx: number;\n   216â†’  vy: number;\n   217â†’  size: number;\n   218â†’  hue: number;\n   219â†’  rotation: number;\n   220â†’  rotationSpeed: number;\n   221â†’  life: number;\n   222â†’  type: 'shard' | 'spark' | 'ember';\n   223â†’}\n   224â†’\n   225â†’// Guardian spirit - ethereal protectors at edges\n   226â†’interface GuardianSpirit {\n   227â†’  x: number;\n   228â†’  y: number;\n   229â†’  baseX: number;\n   230â†’  baseY: number;\n   231â†’  size: number;\n   232â†’  phase: number;\n   233â†’  speed: number;\n   234â†’  haloPhase: number;\n   235â†’  orbPhase: number;\n   236â†’  edge: 'top' | 'bottom' | 'left' | 'right';\n   237â†’  targetAlpha: number;\n   238â†’  currentAlpha: number;\n   239â†’  hue: number;\n   240â†’  orbs: { angle: number; distance: number; size: number; speed: number }[];\n   241â†’}\n   242â†’\n   243â†’// Flame particle for burning effect\n   244â†’interface FlameParticle {\n   245â†’  x: number;\n   246â†’  y: number;\n   247â†’  vx: number;\n   248â†’  vy: number;\n   249â†’  size: number;\n   250â†’  life: number;\n   251â†’  maxLife: number;\n   252â†’  hue: number;\n   253â†’  brightness: number;\n   254â†’}\n   255â†’\n   256â†’// Mystical bee - glowing magical creatures that swarm around food\n   257â†’interface MysticalBee {\n   258â†’  x: number;\n   259â†’  y: number;\n   260â†’  vx: number;\n   261â†’  vy: number;\n   262â†’  targetX: number;\n   263â†’  targetY: number;\n   264â†’  wingPhase: number;\n   265â†’  wingSpeed: number;\n   266â†’  size: number;\n   267â†’  hue: number;\n   268â†’  glowIntensity: number;\n   269â†’  bobPhase: number;\n   270â†’  bobSpeed: number;\n   271â†’  trail: { x: number; y: number; alpha: number }[];\n   272â†’  state: 'flying' | 'hovering' | 'attracted';\n   273â†’  sparkleTimer: number;\n   274â†’}\n   275â†’\n   276â†’// Rival snake - spectral AI nemesis that competes for food\n   277â†’interface RivalSnake {\n   278â†’  segments: { x: number; y: number }[];\n   279â†’  direction: { dx: number; dy: number };\n   280â†’  targetX: number;\n   281â†’  targetY: number;\n   282â†’  moveTimer: number;\n   283â†’  moveInterval: number;\n   284â†’  pulsePhase: number;\n   285â†’  glowIntensity: number;\n   286â†’  hue: number;\n   287â†’  trail: { x: number; y: number; alpha: number }[];\n   288â†’  energyTrail: { x: number; y: number; alpha: number; size: number }[];\n   289â†’  state: 'hunting' | 'fleeing' | 'circling';\n   290â†’  aggression: number;\n   291â†’  nearMissTimer: number;\n   292â†’  electricArcs: { x1: number; y1: number; x2: number; y2: number; life: number }[];\n   293â†’}\n   294â†’\n   295â†’const RIVAL_SNAKE_LENGTH = 10;\n   296â†’const RIVAL_MOVE_INTERVAL = 8;\n   297â†’\n   298â†’// Armageddon Chaos effect types\n   299â†’interface GroundFissure {\n   300â†’  x1: number;\n   301â†’  y1: number;\n   302â†’  x2: number;\n   303â†’  y2: number;\n   304â†’  width: number;\n   305â†’  glowIntensity: number;\n   306â†’  pulsePhase: number;\n   307â†’}\n   308â†’\n   309â†’interface FireRainParticle {\n   310â†’  x: number;\n   311â†’  y: number;\n   312â†’  vy: number;\n   313â†’  size: number;\n   314â†’  alpha: number;\n   315â†’  hue: number;\n   316â†’  trail: { x: number; y: number; alpha: number }[];\n   317â†’}\n   318â†’\n   319â†’interface ChaosExplosion {\n   320â†’  x: number;\n   321â†’  y: number;\n   322â†’  radius: number;\n   323â†’  maxRadius: number;\n   324â†’  life: number;\n   325â†’  rings: { radius: number; alpha: number }[];\n   326â†’  debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[];\n   327â†’}\n   328â†’\n   329â†’interface ApocalypticSkull {\n   330â†’  x: number;\n   331â†’  y: number;\n   332â†’  size: number;\n   333â†’  alpha: number;\n   334â†’  rotation: number;\n   335â†’  pulsePhase: number;\n   336â†’}\n   337â†’\n   338â†’const NUM_FISSURES = 6;\n   339â†’const MAX_FIRE_RAIN = 30;\n   340â†’const MAX_CHAOS_EXPLOSIONS = 3;\n   341â†’const NUM_SKULLS = 4;\n   342â†’\n   343â†’// High score entry for scoreboard\n   344â†’interface HighScoreEntry {\n   345â†’  score: number;\n   346â†’  date: number;\n   347â†’  rank: number;\n   348â†’}\n   349â†’\n   350â†’const MAX_HIGH_SCORES = 5;\n   351â†’\n   352â†’// Color palette - HALLOWEEN theme: spooky purple/orange, ghostly greens, pumpkin glow\n   353â†’const COLORS = {\n   354â†’  bgDark: 0x0a0012,\n   355â†’  bgMid: 0x150825,\n   356â†’  gridLine: 0x2a1540,\n   357â†’  gridAccent: 0x401860,\n   358â†’  snakeHead: 0x00ff66,\n   359â†’  snakeBody: 0x00cc55,\n   360â†’  snakeTail: 0x009944,\n   361â†’  snakeHighlight: 0x66ffaa,\n   362â†’  snakeScale: 0x00aa44,\n   363â†’  snakeEye: 0xff0000,\n   364â†’  snakePupil: 0x000000,\n   365â†’  snakeGlow: 0x00ff80,\n   366â†’  food: 0xff6600,\n   367â†’  foodCore: 0xffcc00,\n   368â†’  foodGlow: 0xff8800,\n   369â†’  foodParticle: 0xffaa00,\n   370â†’  star: 0x8844ff,\n   371â†’  gameOverOverlay: 0x0a0015,\n   372â†’  gameOverText: 0xff6600,\n   373â†’  plasma1: 0x9933ff,\n   374â†’  plasma2: 0xbb55ff,\n   375â†’  plasma3: 0x7722cc,\n   376â†’  screenFlash: 0xff6600,\n   377â†’  // Halloween specific colors\n   378â†’  noirWhite: 0xeeddff,\n   379â†’  noirGray: 0x8866aa,\n   380â†’  noirDark: 0x2a1540,\n   381â†’  spotlight: 0xff8800,\n   382â†’  // Halloween additions\n   383â†’  chaosRed: 0x9933ff,\n   384â†’  chaosOrange: 0xff6600,\n   385â†’  chaosYellow: 0xffcc00,\n   386â†’  lavaGlow: 0x9944ff,\n   387â†’  ashGray: 0x554466,\n   388â†’  bloodRed: 0x660088,\n   389â†’  hellfire: 0xff6600,\n   390â†’  // New Halloween colors\n   391â†’  pumpkinOrange: 0xff6600,\n   392â†’  ghostWhite: 0xeeffee,\n   393â†’  witchPurple: 0x9933ff,\n   394â†’  spiderBlack: 0x111122,\n   395â†’  candyCorn1: 0xffcc00,\n   396â†’  candyCorn2: 0xff8800,\n   397â†’  candyCorn3: 0xffffff,\n   398â†’};\n   399â†’\n   400â†’export class SnakeScene extends Phaser.Scene {\n   401â†’  private graphics!: Phaser.GameObjects.Graphics;\n   402â†’  private currentState: GameState | null = null;\n   403â†’  private needsRedraw = false;\n   404â†’  private frameCount = 0;\n   405â†’  private stars: Star[] = [];\n   406â†’  private foodParticles: FoodParticle[] = [];\n   407â†’  private trailParticles: SnakeTrailParticle[] = [];\n   408â†’  private shockWaves: ShockWave[] = [];\n   409â†’  private lightningBolts: LightningBolt[] = [];\n   410â†’  private plasmaWaves: PlasmaWave[] = [];\n   411â†’  private snakeAfterimages: SnakeAfterimage[] = [];\n   412â†’  private auroraWaves: AuroraWave[] = [];\n   413â†’  private nebulaClouds: NebulaCloud[] = [];\n   414â†’  private vortexRings: VortexRing[] = [];\n   415â†’  private vortexParticles: VortexParticle[] = [];\n   416â†’  private vortexPulse = 0;\n   417â†’  private meteors: Meteor[] = [];\n   418â†’  private deathDebris: DeathDebris[] = [];\n   419â†’  private deathExplosionPhase = 0;\n   420â†’  private gameOverAlpha = 0;\n   421â†’  private lastHeadPos: Position | null = null;\n   422â†’  private lastSnakeLength = 0;\n   423â†’  private hueOffset = 0;\n   424â†’  private screenFlashAlpha = 0;\n   425â†’  private gameOverGlitchOffset = 0;\n   426â†’  private screenShakeX = 0;\n   427â†’  private screenShakeY = 0;\n   428â†’  private screenShakeIntensity = 0;\n   429â†’  private energyFieldPulse = 0;\n   430â†’  private foodBurstParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number; hue: number; trail: { x: number; y: number }[] }[] = [];\n   431â†’  private chromaticIntensity = 0;\n   432â†’  // Film noir effects\n   433â†’  private venetianPhase = 0;\n   434â†’  private spotlightX = 0;\n   435â†’  private spotlightY = 0;\n   436â†’  private smokeParticles: { x: number; y: number; vx: number; vy: number; size: number; alpha: number; life: number }[] = [];\n   437â†’  private guardianSpirits: GuardianSpirit[] = [];\n   438â†’  // Burning flame particles trailing behind snake\n   439â†’  private flameParticles: FlameParticle[] = [];\n   440â†’  // Comet trail system - historical positions for smooth ribbon trail\n   441â†’  private cometTrail: CometTrailSegment[] = [];\n   442â†’  // Ethereal particles that drift away from the trail\n   443â†’  private etherealParticles: EtherealParticle[] = [];\n   444â†’  // Track last few head positions for smooth interpolation\n   445â†’  private headHistory: { x: number; y: number; time: number }[] = [];\n   446â†’  // Thrown food animation system\n   447â†’  private thrownFood: ThrownFood | null = null;\n   448â†’  private lastFoodPos: Position | null = null;\n   449â†’  // Mystical bees swarming around\n   450â†’  private bees: MysticalBee[] = [];\n   451â†’  // Rival snake - spectral AI nemesis\n   452â†’  private rivalSnake: RivalSnake | null = null;\n   453â†’  // Scoreboard system\n   454â†’  private highScores: HighScoreEntry[] = [];\n   455â†’  private highScoresLoaded = false;\n   456â†’  private newHighScoreRank = -1;\n   457â†’  private scoreboardAnimPhase = 0;\n   458â†’  private scoreboardRevealProgress = 0;\n   459â†’  private lastGameOverState = false;\n   460â†’  private hudPulsePhase = 0;\n   461â†’  private lastHudScore = 0;\n   462â†’  private scoreFlashIntensity = 0;\n   463â†’  // Armageddon Chaos effects\n   464â†’  private groundFissures: GroundFissure[] = [];\n   465â†’  private fireRainParticles: FireRainParticle[] = [];\n   466â†’  private chaosExplosions: ChaosExplosion[] = [];\n   467â†’  private apocalypticSkulls: ApocalypticSkull[] = [];\n   468â†’  private armageddonPulse = 0;\n   469â†’  private chaosIntensity = 0;\n   470â†’  private cleanEffects: CleanEffectsState = createCleanEffectsState();\n   471â†’\n   472â†’  constructor() {\n   473â†’    super({ key: 'SnakeScene' });\n   474â†’  }\n   475â†’\n   476â†’  create(): void {\n   477â†’    this.graphics = this.add.graphics();\n   478â†’    const width = GRID_SIZE * CELL_SIZE;\n   479â†’    const height = GRID_SIZE * CELL_SIZE;\n   480â†’    initMotes(this.cleanEffects, width, height);\n   481â†’\n   482â†’    if (this.currentState) {\n   483â†’      this.needsRedraw = true;\n   484â†’    }\n   485â†’  }\n   486â†’\n   487â†’  private initArmageddonEffects(): void {\n   488â†’    const width = GRID_SIZE * CELL_SIZE;\n   489â†’    const height = GRID_SIZE * CELL_SIZE;\n   490â†’\n   491â†’    // Initialize ground fissures - cracks in the earth with lava\n   492â†’    this.groundFissures = [];\n   493â†’    for (let i = 0; i < NUM_FISSURES; i++) {\n   494â†’      const startX = Math.random() * width;\n   495â†’      const startY = Math.random() * height;\n   496â†’      const angle = Math.random() * Math.PI;\n   497â†’      const length = 40 + Math.random() * 80;\n   498â†’      this.groundFissures.push({\n   499â†’        x1: startX,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"d8c33c26-4e07-42d6-9d43-a23de609d308"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01MCNm2wLZLFMrZnsXfSpJkF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BNKwaZg4Ye29VEhCfTzakq","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/logic.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":8959,"cache_read_input_tokens":14370,"cache_creation":{"ephemeral_5m_input_tokens":8959,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"c36bbff9-f68e-460b-a631-8fa87ffc806e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BNKwaZg4Ye29VEhCfTzakq","type":"tool_result","content":"     1â†’/**\n     2â†’ * Pure game logic functions - no React, no side effects\n     3â†’ * Easy to test, easy to reason about\n     4â†’ */\n     5â†’\n     6â†’import { Position, Direction, GameState, OPPOSITE_DIRECTIONS, PowerUp, PowerUpType, ActivePowerUp } from './types';\n     7â†’import { GRID_SIZE, POINTS_PER_FOOD, POWERUP_SPAWN_CHANCE, POWERUP_DESPAWN_TICKS, POWERUP_DURATIONS, POWERUP_TYPES, SCORE_MULTIPLIER_VALUE } from './constants';\n     8â†’\n     9â†’/** Check if two positions are equal */\n    10â†’export const positionsEqual = (a: Position, b: Position): boolean =>\n    11â†’  a.x === b.x && a.y === b.y;\n    12â†’\n    13â†’/** Check if position is within grid bounds */\n    14â†’export const isInBounds = (pos: Position): boolean =>\n    15â†’  pos.x >= 0 && pos.x < GRID_SIZE && pos.y >= 0 && pos.y < GRID_SIZE;\n    16â†’\n    17â†’/** Check if position collides with snake body */\n    18â†’export const collidesWithSnake = (pos: Position, snake: Position[]): boolean =>\n    19â†’  snake.some(segment => positionsEqual(pos, segment));\n    20â†’\n    21â†’/** Check if move would cause collision (wall or self) */\n    22â†’export const wouldCollide = (head: Position, snake: Position[]): boolean =>\n    23â†’  !isInBounds(head) || collidesWithSnake(head, snake);\n    24â†’\n    25â†’/** Get next head position based on direction */\n    26â†’export const getNextHead = (head: Position, direction: Direction): Position => {\n    27â†’  const moves: Record<Direction, Position> = {\n    28â†’    UP: { x: head.x, y: head.y - 1 },\n    29â†’    DOWN: { x: head.x, y: head.y + 1 },\n    30â†’    LEFT: { x: head.x - 1, y: head.y },\n    31â†’    RIGHT: { x: head.x + 1, y: head.y }\n    32â†’  };\n    33â†’  return moves[direction];\n    34â†’};\n    35â†’\n    36â†’/** Check if direction change is valid (not 180-degree turn) */\n    37â†’export const isValidDirectionChange = (\n    38â†’  newDirection: Direction,\n    39â†’  currentDirection: Direction\n    40â†’): boolean => OPPOSITE_DIRECTIONS[newDirection] !== currentDirection;\n    41â†’\n    42â†’/** Generate random food position not on snake */\n    43â†’export const generateFood = (snake: Position[], excludePos?: Position): Position => {\n    44â†’  let food: Position;\n    45â†’  do {\n    46â†’    food = {\n    47â†’      x: Math.floor(Math.random() * GRID_SIZE),\n    48â†’      y: Math.floor(Math.random() * GRID_SIZE)\n    49â†’    };\n    50â†’  } while (collidesWithSnake(food, snake) || (excludePos && positionsEqual(food, excludePos)));\n    51â†’  return food;\n    52â†’};\n    53â†’\n    54â†’/** Generate a power-up at a random position */\n    55â†’export const generatePowerUp = (snake: Position[], food: Position, tickCount: number): PowerUp => {\n    56â†’  const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];\n    57â†’  let pos: Position;\n    58â†’  do {\n    59â†’    pos = {\n    60â†’      x: Math.floor(Math.random() * GRID_SIZE),\n    61â†’      y: Math.floor(Math.random() * GRID_SIZE)\n    62â†’    };\n    63â†’  } while (collidesWithSnake(pos, snake) || positionsEqual(pos, food));\n    64â†’\n    65â†’  return {\n    66â†’    position: pos,\n    67â†’    type,\n    68â†’    spawnTime: tickCount,\n    69â†’    duration: POWERUP_DURATIONS[type],\n    70â†’  };\n    71â†’};\n    72â†’\n    73â†’/** Check if a power-up type is active */\n    74â†’export const hasPowerUp = (activePowerUps: ActivePowerUp[], type: PowerUpType): boolean => {\n    75â†’  return activePowerUps.some(p => p.type === type);\n    76â†’};\n    77â†’\n    78â†’/** Update active power-ups, removing expired ones */\n    79â†’export const updateActivePowerUps = (activePowerUps: ActivePowerUp[], tickCount: number): ActivePowerUp[] => {\n    80â†’  return activePowerUps.filter(p => p.endTime > tickCount);\n    81â†’};\n    82â†’\n    83â†’/** Activate a power-up */\n    84â†’export const activatePowerUp = (activePowerUps: ActivePowerUp[], type: PowerUpType, tickCount: number): ActivePowerUp[] => {\n    85â†’  const existing = activePowerUps.find(p => p.type === type);\n    86â†’  const duration = POWERUP_DURATIONS[type];\n    87â†’\n    88â†’  if (existing) {\n    89â†’    return activePowerUps.map(p =>\n    90â†’      p.type === type ? { ...p, endTime: tickCount + duration } : p\n    91â†’    );\n    92â†’  }\n    93â†’\n    94â†’  return [...activePowerUps, { type, endTime: tickCount + duration }];\n    95â†’};\n    96â†’\n    97â†’/** Calculate next game state after one tick */\n    98â†’export const tick = (state: GameState, direction: Direction): GameState => {\n    99â†’  if (state.gameOver || !state.gameStarted) {\n   100â†’    return state;\n   101â†’  }\n   102â†’\n   103â†’  const tickCount = state.tickCount + 1;\n   104â†’  const head = state.snake[0];\n   105â†’  const newHead = getNextHead(head, direction);\n   106â†’\n   107â†’  // Check collision - invincibility protects against self-collision only\n   108â†’  const isInvincible = hasPowerUp(state.activePowerUps, 'INVINCIBILITY');\n   109â†’  const hitWall = !isInBounds(newHead);\n   110â†’  const hitSelf = collidesWithSnake(newHead, state.snake);\n   111â†’\n   112â†’  if (hitWall || (hitSelf && !isInvincible)) {\n   113â†’    return { ...state, gameOver: true, tickCount };\n   114â†’  }\n   115â†’\n   116â†’  const newSnake = [newHead, ...state.snake];\n   117â†’  const ateFood = positionsEqual(newHead, state.food);\n   118â†’\n   119â†’  // Check power-up collection\n   120â†’  let newPowerUp = state.powerUp;\n   121â†’  let newActivePowerUps = updateActivePowerUps(state.activePowerUps, tickCount);\n   122â†’\n   123â†’  if (state.powerUp && positionsEqual(newHead, state.powerUp.position)) {\n   124â†’    newActivePowerUps = activatePowerUp(newActivePowerUps, state.powerUp.type, tickCount);\n   125â†’    newPowerUp = null;\n   126â†’  }\n   127â†’\n   128â†’  // Despawn power-up after time limit\n   129â†’  if (newPowerUp && (tickCount - newPowerUp.spawnTime) > POWERUP_DESPAWN_TICKS) {\n   130â†’    newPowerUp = null;\n   131â†’  }\n   132â†’\n   133â†’  // Maybe spawn a new power-up\n   134â†’  if (!newPowerUp && Math.random() < POWERUP_SPAWN_CHANCE) {\n   135â†’    newPowerUp = generatePowerUp(newSnake, state.food, tickCount);\n   136â†’  }\n   137â†’\n   138â†’  // Calculate score with multiplier\n   139â†’  const hasMultiplier = hasPowerUp(newActivePowerUps, 'SCORE_MULTIPLIER');\n   140â†’  const scoreGain = ateFood ? (hasMultiplier ? POINTS_PER_FOOD * SCORE_MULTIPLIER_VALUE : POINTS_PER_FOOD) : 0;\n   141â†’\n   142â†’  if (ateFood) {\n   143â†’    return {\n   144â†’      ...state,\n   145â†’      snake: newSnake,\n   146â†’      food: generateFood(newSnake, newPowerUp?.position),\n   147â†’      score: state.score + scoreGain,\n   148â†’      direction,\n   149â†’      powerUp: newPowerUp,\n   150â†’      activePowerUps: newActivePowerUps,\n   151â†’      tickCount,\n   152â†’    };\n   153â†’  }\n   154â†’\n   155â†’  newSnake.pop();\n   156â†’  return {\n   157â†’    ...state,\n   158â†’    snake: newSnake,\n   159â†’    direction,\n   160â†’    powerUp: newPowerUp,\n   161â†’    activePowerUps: newActivePowerUps,\n   162â†’    tickCount,\n   163â†’  };\n   164â†’};\n   165â†’\n   166â†’/** Create a fresh game state for starting/restarting */\n   167â†’export const createNewGame = (initialSnake: Position[]): GameState => ({\n   168â†’  snake: [...initialSnake],\n   169â†’  food: generateFood(initialSnake),\n   170â†’  direction: 'RIGHT',\n   171â†’  gameOver: false,\n   172â†’  gameStarted: true,\n   173â†’  score: 0,\n   174â†’  powerUp: null,\n   175â†’  activePowerUps: [],\n   176â†’  tickCount: 0,\n   177â†’});\n   178â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"e8083112-c2b9-406b-8893-f9a4eff3003b"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01MCNm2wLZLFMrZnsXfSpJkF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017yYmCX5ihVXLiVHoGAybQx","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/types.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":8959,"cache_read_input_tokens":14370,"cache_creation":{"ephemeral_5m_input_tokens":8959,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"aff2d22c-375a-4b43-9184-97ab238d004f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017yYmCX5ihVXLiVHoGAybQx","type":"tool_result","content":"     1â†’/**\n     2â†’ * Core game types - shared across all game modules\n     3â†’ */\n     4â†’\n     5â†’export interface Position {\n     6â†’  x: number;\n     7â†’  y: number;\n     8â†’}\n     9â†’\n    10â†’export type PowerUpType = 'SPEED_BOOST' | 'INVINCIBILITY' | 'SCORE_MULTIPLIER' | 'MAGNET';\n    11â†’\n    12â†’export interface PowerUp {\n    13â†’  position: Position;\n    14â†’  type: PowerUpType;\n    15â†’  spawnTime: number;\n    16â†’  duration: number;\n    17â†’}\n    18â†’\n    19â†’export interface ActivePowerUp {\n    20â†’  type: PowerUpType;\n    21â†’  endTime: number;\n    22â†’}\n    23â†’\n    24â†’export interface GameState {\n    25â†’  snake: Position[];\n    26â†’  food: Position;\n    27â†’  direction: Direction;\n    28â†’  gameOver: boolean;\n    29â†’  gameStarted: boolean;\n    30â†’  score: number;\n    31â†’  powerUp: PowerUp | null;\n    32â†’  activePowerUps: ActivePowerUp[];\n    33â†’  tickCount: number;\n    34â†’}\n    35â†’\n    36â†’export type Direction = 'UP' | 'DOWN' | 'LEFT' | 'RIGHT';\n    37â†’\n    38â†’export const OPPOSITE_DIRECTIONS: Record<Direction, Direction> = {\n    39â†’  UP: 'DOWN',\n    40â†’  DOWN: 'UP',\n    41â†’  LEFT: 'RIGHT',\n    42â†’  RIGHT: 'LEFT'\n    43â†’};\n    44â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"65c091f0-ca0b-40cf-a9b5-9e2d41106768"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016aXBbsKUx8wZriU196sWEY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011uxynw4YQ7cD3RTapsLhy6","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":500,"limit":300},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":7580,"cache_read_input_tokens":23329,"cache_creation":{"ephemeral_5m_input_tokens":7580,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"8052cb7e-2144-480c-a5b9-a287e5e819f8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011uxynw4YQ7cD3RTapsLhy6","type":"tool_result","content":"   500â†’        y1: startY,\n   501â†’        x2: startX + Math.cos(angle) * length,\n   502â†’        y2: startY + Math.sin(angle) * length,\n   503â†’        width: 2 + Math.random() * 4,\n   504â†’        glowIntensity: 0.5 + Math.random() * 0.5,\n   505â†’        pulsePhase: Math.random() * Math.PI * 2,\n   506â†’      });\n   507â†’    }\n   508â†’\n   509â†’    // Initialize fire rain\n   510â†’    this.fireRainParticles = [];\n   511â†’\n   512â†’    // Initialize chaos explosions\n   513â†’    this.chaosExplosions = [];\n   514â†’\n   515â†’    // Initialize apocalyptic skulls floating in background\n   516â†’    this.apocalypticSkulls = [];\n   517â†’    for (let i = 0; i < NUM_SKULLS; i++) {\n   518â†’      this.apocalypticSkulls.push({\n   519â†’        x: 30 + Math.random() * (width - 60),\n   520â†’        y: 30 + Math.random() * (height - 60),\n   521â†’        size: 15 + Math.random() * 10,\n   522â†’        alpha: 0.03 + Math.random() * 0.04,\n   523â†’        rotation: Math.random() * Math.PI * 2,\n   524â†’        pulsePhase: Math.random() * Math.PI * 2,\n   525â†’      });\n   526â†’    }\n   527â†’  }\n   528â†’\n   529â†’  private initSmokeParticles(): void {\n   530â†’    this.smokeParticles = [];\n   531â†’    const width = GRID_SIZE * CELL_SIZE;\n   532â†’    const height = GRID_SIZE * CELL_SIZE;\n   533â†’    for (let i = 0; i < 12; i++) {\n   534â†’      this.smokeParticles.push({\n   535â†’        x: Math.random() * width,\n   536â†’        y: Math.random() * height,\n   537â†’        vx: (Math.random() - 0.5) * 0.3,\n   538â†’        vy: -0.1 - Math.random() * 0.2,\n   539â†’        size: 30 + Math.random() * 50,\n   540â†’        alpha: 0.02 + Math.random() * 0.03,\n   541â†’        life: Math.random(),\n   542â†’      });\n   543â†’    }\n   544â†’  }\n   545â†’\n   546â†’  private updateArmageddonEffects(): void {\n   547â†’    const width = GRID_SIZE * CELL_SIZE;\n   548â†’    const height = GRID_SIZE * CELL_SIZE;\n   549â†’\n   550â†’    this.armageddonPulse += 0.04;\n   551â†’\n   552â†’    // Update ground fissures - pulsing lava glow\n   553â†’    for (const fissure of this.groundFissures) {\n   554â†’      fissure.pulsePhase += 0.06;\n   555â†’      fissure.glowIntensity = 0.5 + Math.sin(fissure.pulsePhase) * 0.3;\n   556â†’    }\n   557â†’\n   558â†’    // Spawn fire rain particles\n   559â†’    if (this.fireRainParticles.length < MAX_FIRE_RAIN && Math.random() < 0.3) {\n   560â†’      const hueVariation = Math.random();\n   561â†’      this.fireRainParticles.push({\n   562â†’        x: Math.random() * width,\n   563â†’        y: -20,\n   564â†’        vy: 2 + Math.random() * 3,\n   565â†’        size: 2 + Math.random() * 4,\n   566â†’        alpha: 0.6 + Math.random() * 0.4,\n   567â†’        hue: hueVariation < 0.6 ? 0 : (hueVariation < 0.85 ? 20 : 40), // Red, orange, yellow\n   568â†’        trail: [],\n   569â†’      });\n   570â†’    }\n   571â†’\n   572â†’    // Update fire rain\n   573â†’    for (let i = this.fireRainParticles.length - 1; i >= 0; i--) {\n   574â†’      const p = this.fireRainParticles[i];\n   575â†’      p.trail.unshift({ x: p.x, y: p.y, alpha: p.alpha });\n   576â†’      if (p.trail.length > 6) p.trail.pop();\n   577â†’      for (const t of p.trail) { t.alpha *= 0.7; }\n   578â†’\n   579â†’      p.y += p.vy;\n   580â†’      p.x += Math.sin(this.armageddonPulse + p.y * 0.05) * 0.3;\n   581â†’      p.alpha *= 0.995;\n   582â†’\n   583â†’      if (p.y > height + 20 || p.alpha < 0.05) {\n   584â†’        this.fireRainParticles.splice(i, 1);\n   585â†’      }\n   586â†’    }\n   587â†’\n   588â†’    // Update chaos explosions\n   589â†’    for (let i = this.chaosExplosions.length - 1; i >= 0; i--) {\n   590â†’      const exp = this.chaosExplosions[i];\n   591â†’      exp.radius += 4;\n   592â†’      exp.life -= 0.03;\n   593â†’\n   594â†’      for (const ring of exp.rings) {\n   595â†’        ring.radius += 3;\n   596â†’        ring.alpha *= 0.92;\n   597â†’      }\n   598â†’      exp.rings = exp.rings.filter(r => r.alpha > 0.02);\n   599â†’\n   600â†’      for (const d of exp.debris) {\n   601â†’        d.x += d.vx;\n   602â†’        d.y += d.vy;\n   603â†’        d.vy += 0.1;\n   604â†’        d.alpha *= 0.96;\n   605â†’      }\n   606â†’      exp.debris = exp.debris.filter(d => d.alpha > 0.02);\n   607â†’\n   608â†’      if (exp.life <= 0 && exp.rings.length === 0 && exp.debris.length === 0) {\n   609â†’        this.chaosExplosions.splice(i, 1);\n   610â†’      }\n   611â†’    }\n   612â†’\n   613â†’    // Update apocalyptic skulls - slow drift and pulse\n   614â†’    for (const skull of this.apocalypticSkulls) {\n   615â†’      skull.pulsePhase += 0.02;\n   616â†’      skull.rotation += 0.002;\n   617â†’      skull.x += Math.sin(skull.pulsePhase * 0.5) * 0.1;\n   618â†’      skull.y += Math.cos(skull.pulsePhase * 0.3) * 0.1;\n   619â†’\n   620â†’      // Keep in bounds\n   621â†’      if (skull.x < 20) skull.x = 20;\n   622â†’      if (skull.x > width - 20) skull.x = width - 20;\n   623â†’      if (skull.y < 20) skull.y = 20;\n   624â†’      if (skull.y > height - 20) skull.y = height - 20;\n   625â†’    }\n   626â†’\n   627â†’    // Chaos intensity increases when snake eats or dies\n   628â†’    this.chaosIntensity *= 0.97;\n   629â†’  }\n   630â†’\n   631â†’  private spawnChaosExplosion(x: number, y: number): void {\n   632â†’    if (this.chaosExplosions.length >= MAX_CHAOS_EXPLOSIONS) {\n   633â†’      this.chaosExplosions.shift();\n   634â†’    }\n   635â†’\n   636â†’    const debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[] = [];\n   637â†’    for (let i = 0; i < 12; i++) {\n   638â†’      const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.3;\n   639â†’      const speed = 3 + Math.random() * 5;\n   640â†’      debris.push({\n   641â†’        x,\n   642â†’        y,\n   643â†’        vx: Math.cos(angle) * speed,\n   644â†’        vy: Math.sin(angle) * speed - 2,\n   645â†’        size: 2 + Math.random() * 4,\n   646â†’        alpha: 1,\n   647â†’      });\n   648â†’    }\n   649â†’\n   650â†’    this.chaosExplosions.push({\n   651â†’      x,\n   652â†’      y,\n   653â†’      radius: 5,\n   654â†’      maxRadius: 80,\n   655â†’      life: 1,\n   656â†’      rings: [\n   657â†’        { radius: 10, alpha: 1 },\n   658â†’        { radius: 5, alpha: 0.8 },\n   659â†’        { radius: 15, alpha: 0.6 },\n   660â†’      ],\n   661â†’      debris,\n   662â†’    });\n   663â†’\n   664â†’    this.chaosIntensity = Math.min(1, this.chaosIntensity + 0.5);\n   665â†’    this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 12);\n   666â†’  }\n   667â†’\n   668â†’  private drawArmageddonBackground(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n   669â†’    // Spooky Halloween night sky\n   670â†’    const skyPulse = 0.8 + Math.sin(this.armageddonPulse * 0.5) * 0.2;\n   671â†’\n   672â†’    // Layer 1: Deep purple-black night base\n   673â†’    g.fillStyle(0x0a0018, 1);\n   674â†’    g.fillRect(0, 0, width, height);\n   675â†’\n   676â†’    // Layer 2: Eerie purple glow from below (like fog)\n   677â†’    g.fillStyle(0x200840, 0.3 * skyPulse);\n   678â†’    g.fillRect(0, height * 0.7, width, height * 0.3);\n   679â†’\n   680â†’    // Layer 3: Misty purple clouds\n   681â†’    for (let i = 0; i < 4; i++) {\n   682â†’      const cloudY = i * 30 + Math.sin(this.armageddonPulse + i) * 10;\n   683â†’      const cloudAlpha = 0.1 - i * 0.02;\n   684â†’      g.fillStyle(0x301040, cloudAlpha * skyPulse);\n   685â†’      g.fillRect(0, cloudY, width, 40);\n   686â†’    }\n   687â†’\n   688â†’    // Draw haunted moon\n   689â†’    this.drawHauntedMoon(g, width);\n   690â†’\n   691â†’    // Draw flying bats in background\n   692â†’    this.drawFlyingBats(g, width, height);\n   693â†’\n   694â†’    // Draw apocalyptic skulls (very faint, background layer)\n   695â†’    this.drawApocalypticSkulls(g);\n   696â†’  }\n   697â†’\n   698â†’  private drawHauntedMoon(g: Phaser.GameObjects.Graphics, width: number): void {\n   699â†’    const moonX = width * 0.8;\n   700â†’    const moonY = 60;\n   701â†’    const moonRadius = 35;\n   702â†’    const moonPulse = 0.9 + Math.sin(this.frameCount * 0.02) * 0.1;\n   703â†’\n   704â†’    // Moon glow\n   705â†’    g.fillStyle(0xff8800, 0.1 * moonPulse);\n   706â†’    g.fillCircle(moonX, moonY, moonRadius * 2);\n   707â†’    g.fillStyle(0xffaa00, 0.15 * moonPulse);\n   708â†’    g.fillCircle(moonX, moonY, moonRadius * 1.5);\n   709â†’\n   710â†’    // Main moon (orange harvest moon)\n   711â†’    g.fillStyle(0xffaa33, 0.9);\n   712â†’    g.fillCircle(moonX, moonY, moonRadius);\n   713â†’\n   714â†’    // Moon craters\n   715â†’    g.fillStyle(0xcc8822, 0.4);\n   716â†’    g.fillCircle(moonX - 10, moonY - 5, 8);\n   717â†’    g.fillCircle(moonX + 12, moonY + 8, 6);\n   718â†’    g.fillCircle(moonX - 5, moonY + 12, 5);\n   719â†’  }\n   720â†’\n   721â†’  private drawFlyingBats(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n   722â†’    const batCount = 6;\n   723â†’    for (let i = 0; i < batCount; i++) {\n   724â†’      const phase = this.frameCount * 0.03 + i * 1.5;\n   725â†’      const batX = ((i * 127 + this.frameCount * 0.5) % (width + 100)) - 50;\n   726â†’      const batY = 40 + i * 20 + Math.sin(phase) * 15;\n   727â†’      const wingPhase = Math.sin(this.frameCount * 0.15 + i * 2);\n   728â†’\n   729â†’      // Bat body\n   730â†’      g.fillStyle(0x111122, 0.8);\n   731â†’      g.fillCircle(batX, batY, 4);\n   732â†’\n   733â†’      // Bat wings (flapping)\n   734â†’      const wingSpread = 8 + wingPhase * 4;\n   735â†’      g.fillStyle(0x111122, 0.7);\n   736â†’\n   737â†’      // Left wing\n   738â†’      g.beginPath();\n   739â†’      g.moveTo(batX - 2, batY);\n   740â†’      g.lineTo(batX - wingSpread, batY - wingPhase * 3);\n   741â†’      g.lineTo(batX - wingSpread * 0.6, batY + 2);\n   742â†’      g.closePath();\n   743â†’      g.fillPath();\n   744â†’\n   745â†’      // Right wing\n   746â†’      g.beginPath();\n   747â†’      g.moveTo(batX + 2, batY);\n   748â†’      g.lineTo(batX + wingSpread, batY - wingPhase * 3);\n   749â†’      g.lineTo(batX + wingSpread * 0.6, batY + 2);\n   750â†’      g.closePath();\n   751â†’      g.fillPath();\n   752â†’    }\n   753â†’  }\n   754â†’\n   755â†’  private drawGroundFissures(g: Phaser.GameObjects.Graphics): void {\n   756â†’    for (const fissure of this.groundFissures) {\n   757â†’      const pulse = fissure.glowIntensity;\n   758â†’\n   759â†’      // Ghostly purple glow underneath\n   760â†’      g.lineStyle(fissure.width * 3, COLORS.lavaGlow, 0.12 * pulse);\n   761â†’      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n   762â†’\n   763â†’      // Crack edges (dark purple)\n   764â†’      g.lineStyle(fissure.width + 2, 0x200030, 0.4);\n   765â†’      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n   766â†’\n   767â†’      // Ethereal core (bright purple)\n   768â†’      g.lineStyle(fissure.width, COLORS.witchPurple, 0.3 * pulse);\n   769â†’      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n   770â†’\n   771â†’      // Ghostly white center\n   772â†’      g.lineStyle(fissure.width * 0.3, COLORS.ghostWhite, 0.2 * pulse);\n   773â†’      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n   774â†’    }\n   775â†’  }\n   776â†’\n   777â†’  private drawFireRain(g: Phaser.GameObjects.Graphics): void {\n   778â†’    for (const p of this.fireRainParticles) {\n   779â†’      // Draw ghostly trail\n   780â†’      for (let i = 0; i < p.trail.length; i++) {\n   781â†’        const t = p.trail[i];\n   782â†’        const trailSize = p.size * (1 - i / p.trail.length) * 0.6;\n   783â†’        // Ghostly purple/green trail\n   784â†’        const ghostHue = 0.75 + (p.hue % 60) / 360;\n   785â†’        const trailColor = this.hslToRgb(ghostHue, 0.6, 0.6);\n   786â†’        g.fillStyle(trailColor, t.alpha * 0.3);\n   787â†’        g.fillCircle(t.x, t.y, trailSize);\n   788â†’      }\n   789â†’\n   790â†’      // Main spirit particle (ghostly appearance)\n   791â†’      const outerColor = this.hslToRgb(0.8, 0.5, 0.5);\n   792â†’      const coreColor = this.hslToRgb(0.85, 0.3, 0.8);\n   793â†’\n   794â†’      g.fillStyle(outerColor, p.alpha * 0.4);\n   795â†’      g.fillCircle(p.x, p.y, p.size * 1.5);\n   796â†’\n   797â†’      g.fillStyle(coreColor, p.alpha * 0.6);\n   798â†’      g.fillCircle(p.x, p.y, p.size);\n   799â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"37ef9618-ab5e-421f-8086-683b93f2f938"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016aXBbsKUx8wZriU196sWEY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01M35VpPPBeHiQisjXgrCQKL","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":800,"limit":300},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":7580,"cache_read_input_tokens":23329,"cache_creation":{"ephemeral_5m_input_tokens":7580,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"4a8d61ea-c4f1-4e76-a479-bf44e44f23e5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M35VpPPBeHiQisjXgrCQKL","type":"tool_result","content":"   800â†’      g.fillStyle(COLORS.ghostWhite, p.alpha * 0.5);\n   801â†’      g.fillCircle(p.x, p.y, p.size * 0.3);\n   802â†’    }\n   803â†’  }\n   804â†’\n   805â†’  private drawChaosExplosions(g: Phaser.GameObjects.Graphics): void {\n   806â†’    for (const exp of this.chaosExplosions) {\n   807â†’      // Central flash\n   808â†’      if (exp.life > 0.7) {\n   809â†’        const flashAlpha = (exp.life - 0.7) * 3;\n   810â†’        g.fillStyle(0xffffff, flashAlpha * 0.5);\n   811â†’        g.fillCircle(exp.x, exp.y, exp.radius * 0.5);\n   812â†’        g.fillStyle(COLORS.chaosYellow, flashAlpha * 0.4);\n   813â†’        g.fillCircle(exp.x, exp.y, exp.radius);\n   814â†’      }\n   815â†’\n   816â†’      // Expanding rings\n   817â†’      for (const ring of exp.rings) {\n   818â†’        g.lineStyle(4, COLORS.chaosRed, ring.alpha * 0.5);\n   819â†’        g.strokeCircle(exp.x, exp.y, ring.radius);\n   820â†’        g.lineStyle(2, COLORS.chaosOrange, ring.alpha * 0.7);\n   821â†’        g.strokeCircle(exp.x, exp.y, ring.radius);\n   822â†’        g.lineStyle(1, 0xffffff, ring.alpha * 0.4);\n   823â†’        g.strokeCircle(exp.x, exp.y, ring.radius);\n   824â†’      }\n   825â†’\n   826â†’      // Flying debris\n   827â†’      for (const d of exp.debris) {\n   828â†’        g.fillStyle(COLORS.chaosOrange, d.alpha * 0.6);\n   829â†’        g.fillCircle(d.x, d.y, d.size * 1.3);\n   830â†’        g.fillStyle(COLORS.chaosYellow, d.alpha * 0.9);\n   831â†’        g.fillCircle(d.x, d.y, d.size);\n   832â†’      }\n   833â†’    }\n   834â†’  }\n   835â†’\n   836â†’  private drawApocalypticSkulls(g: Phaser.GameObjects.Graphics): void {\n   837â†’    for (const skull of this.apocalypticSkulls) {\n   838â†’      const pulse = 0.7 + Math.sin(skull.pulsePhase) * 0.3;\n   839â†’      const alpha = skull.alpha * pulse;\n   840â†’      const s = skull.size;\n   841â†’\n   842â†’      // Ghostly purple glow\n   843â†’      g.fillStyle(COLORS.witchPurple, alpha * 0.2);\n   844â†’      g.fillCircle(skull.x, skull.y, s * 1.5);\n   845â†’\n   846â†’      // Skull outline (bone white)\n   847â†’      g.fillStyle(0xcccccc, alpha * 0.8);\n   848â†’      // Cranium\n   849â†’      g.fillCircle(skull.x, skull.y - s * 0.1, s * 0.8);\n   850â†’      // Jaw\n   851â†’      g.fillRect(skull.x - s * 0.4, skull.y + s * 0.3, s * 0.8, s * 0.4);\n   852â†’\n   853â†’      // Eye sockets (glowing green - spooky!)\n   854â†’      g.fillStyle(COLORS.snakeHead, alpha * 1.2);\n   855â†’      g.fillCircle(skull.x - s * 0.25, skull.y - s * 0.1, s * 0.2);\n   856â†’      g.fillCircle(skull.x + s * 0.25, skull.y - s * 0.1, s * 0.2);\n   857â†’\n   858â†’      // Nose hole\n   859â†’      g.fillStyle(0x000000, alpha);\n   860â†’      g.fillTriangle(\n   861â†’        skull.x, skull.y + s * 0.1,\n   862â†’        skull.x - s * 0.1, skull.y + s * 0.25,\n   863â†’        skull.x + s * 0.1, skull.y + s * 0.25\n   864â†’      );\n   865â†’    }\n   866â†’  }\n   867â†’\n   868â†’  private drawChaosOverlay(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n   869â†’    if (this.chaosIntensity <= 0) return;\n   870â†’\n   871â†’    // Purple tint overlay when chaos is active\n   872â†’    g.fillStyle(COLORS.witchPurple, this.chaosIntensity * 0.1);\n   873â†’    g.fillRect(0, 0, width, height);\n   874â†’\n   875â†’    // Pulsing purple vignette edges\n   876â†’    const vignetteAlpha = this.chaosIntensity * 0.25;\n   877â†’    g.lineStyle(80, COLORS.bloodRed, vignetteAlpha);\n   878â†’    g.strokeRect(-40, -40, width + 80, height + 80);\n   879â†’  }\n   880â†’\n   881â†’  private initGuardianSpirits(): void {\n   882â†’    this.guardianSpirits = [];\n   883â†’    const width = GRID_SIZE * CELL_SIZE;\n   884â†’    const height = GRID_SIZE * CELL_SIZE;\n   885â†’    const spiritHues = [180, 220, 280, 320];\n   886â†’\n   887â†’    const edges: ('top' | 'bottom' | 'left' | 'right')[] = ['top', 'bottom', 'left', 'right'];\n   888â†’    for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n   889â†’      const edge = edges[edgeIndex];\n   890â†’      for (let i = 0; i < NUM_SPIRITS_PER_EDGE; i++) {\n   891â†’        let x = 0, y = 0;\n   892â†’        const offset = (i + 0.5) / NUM_SPIRITS_PER_EDGE;\n   893â†’\n   894â†’        switch (edge) {\n   895â†’          case 'top':\n   896â†’            x = width * offset;\n   897â†’            y = -15;\n   898â†’            break;\n   899â†’          case 'bottom':\n   900â†’            x = width * offset;\n   901â†’            y = height + 15;\n   902â†’            break;\n   903â†’          case 'left':\n   904â†’            x = -15;\n   905â†’            y = height * offset;\n   906â†’            break;\n   907â†’          case 'right':\n   908â†’            x = width + 15;\n   909â†’            y = height * offset;\n   910â†’            break;\n   911â†’        }\n   912â†’\n   913â†’        const orbs: { angle: number; distance: number; size: number; speed: number }[] = [];\n   914â†’        const numOrbs = 3;\n   915â†’        for (let o = 0; o < numOrbs; o++) {\n   916â†’          orbs.push({\n   917â†’            angle: (o / numOrbs) * Math.PI * 2,\n   918â†’            distance: 15 + Math.random() * 10,\n   919â†’            size: 3 + Math.random() * 2,\n   920â†’            speed: 0.03 + Math.random() * 0.02,\n   921â†’          });\n   922â†’        }\n   923â†’\n   924â†’        this.guardianSpirits.push({\n   925â†’          x,\n   926â†’          y,\n   927â†’          baseX: x,\n   928â†’          baseY: y,\n   929â†’          size: 20 + Math.random() * 10,\n   930â†’          phase: Math.random() * Math.PI * 2,\n   931â†’          speed: 0.015 + Math.random() * 0.01,\n   932â†’          haloPhase: Math.random() * Math.PI * 2,\n   933â†’          orbPhase: Math.random() * Math.PI * 2,\n   934â†’          edge,\n   935â†’          targetAlpha: 0.4 + Math.random() * 0.2,\n   936â†’          currentAlpha: 0,\n   937â†’          hue: spiritHues[edgeIndex % spiritHues.length] + Math.random() * 30 - 15,\n   938â†’          orbs,\n   939â†’        });\n   940â†’      }\n   941â†’    }\n   942â†’  }\n   943â†’\n   944â†’  private initBees(): void {\n   945â†’    this.bees = [];\n   946â†’  }\n   947â†’\n   948â†’  private initRivalSnake(): void {\n   949â†’    const width = GRID_SIZE * CELL_SIZE;\n   950â†’    const height = GRID_SIZE * CELL_SIZE;\n   951â†’\n   952â†’    const startX = width - 50 - Math.random() * 50;\n   953â†’    const startY = height - 50 - Math.random() * 50;\n   954â†’\n   955â†’    const segments: { x: number; y: number }[] = [];\n   956â†’    for (let i = 0; i < RIVAL_SNAKE_LENGTH; i++) {\n   957â†’      segments.push({\n   958â†’        x: startX + i * CELL_SIZE * 0.6,\n   959â†’        y: startY,\n   960â†’      });\n   961â†’    }\n   962â†’\n   963â†’    this.rivalSnake = {\n   964â†’      segments,\n   965â†’      direction: { dx: -1, dy: 0 },\n   966â†’      targetX: width / 2,\n   967â†’      targetY: height / 2,\n   968â†’      moveTimer: 0,\n   969â†’      moveInterval: RIVAL_MOVE_INTERVAL,\n   970â†’      pulsePhase: 0,\n   971â†’      glowIntensity: 0.8,\n   972â†’      hue: 200,\n   973â†’      trail: [],\n   974â†’      energyTrail: [],\n   975â†’      state: 'hunting',\n   976â†’      aggression: 0.5,\n   977â†’      nearMissTimer: 0,\n   978â†’      electricArcs: [],\n   979â†’    };\n   980â†’  }\n   981â†’\n   982â†’  private updateRivalSnake(): void {\n   983â†’    if (!this.rivalSnake || !this.currentState) return;\n   984â†’\n   985â†’    const rs = this.rivalSnake;\n   986â†’    const width = GRID_SIZE * CELL_SIZE;\n   987â†’    const height = GRID_SIZE * CELL_SIZE;\n   988â†’\n   989â†’    rs.pulsePhase += 0.1;\n   990â†’    rs.glowIntensity = 0.6 + Math.sin(rs.pulsePhase) * 0.3;\n   991â†’\n   992â†’    if (rs.segments.length > 0) {\n   993â†’      rs.trail.unshift({ x: rs.segments[0].x, y: rs.segments[0].y, alpha: 0.7 });\n   994â†’      if (rs.trail.length > 20) rs.trail.pop();\n   995â†’\n   996â†’      rs.energyTrail.unshift({\n   997â†’        x: rs.segments[0].x + (Math.random() - 0.5) * 8,\n   998â†’        y: rs.segments[0].y + (Math.random() - 0.5) * 8,\n   999â†’        alpha: 0.8,\n  1000â†’        size: 3 + Math.random() * 4\n  1001â†’      });\n  1002â†’      if (rs.energyTrail.length > 30) rs.energyTrail.pop();\n  1003â†’    }\n  1004â†’\n  1005â†’    for (const t of rs.trail) {\n  1006â†’      t.alpha *= 0.92;\n  1007â†’    }\n  1008â†’    rs.trail = rs.trail.filter(t => t.alpha > 0.02);\n  1009â†’\n  1010â†’    for (const e of rs.energyTrail) {\n  1011â†’      e.alpha *= 0.88;\n  1012â†’      e.size *= 0.95;\n  1013â†’    }\n  1014â†’    rs.energyTrail = rs.energyTrail.filter(e => e.alpha > 0.02);\n  1015â†’\n  1016â†’    rs.electricArcs = rs.electricArcs.filter(arc => {\n  1017â†’      arc.life -= 0.15;\n  1018â†’      return arc.life > 0;\n  1019â†’    });\n  1020â†’\n  1021â†’    if (rs.nearMissTimer > 0) rs.nearMissTimer--;\n  1022â†’\n  1023â†’    const playerHead = this.currentState.snake[0];\n  1024â†’    const playerX = playerHead.x * CELL_SIZE + CELL_SIZE / 2;\n  1025â†’    const playerY = playerHead.y * CELL_SIZE + CELL_SIZE / 2;\n  1026â†’    const rivalHead = rs.segments[0];\n  1027â†’    const distToPlayer = Math.sqrt(\n  1028â†’      Math.pow(playerX - rivalHead.x, 2) + Math.pow(playerY - rivalHead.y, 2)\n  1029â†’    );\n  1030â†’\n  1031â†’    if (distToPlayer < 60 && rs.nearMissTimer === 0) {\n  1032â†’      rs.nearMissTimer = 30;\n  1033â†’      rs.electricArcs.push({\n  1034â†’        x1: rivalHead.x,\n  1035â†’        y1: rivalHead.y,\n  1036â†’        x2: playerX,\n  1037â†’        y2: playerY,\n  1038â†’        life: 1.0\n  1039â†’      });\n  1040â†’      rs.aggression = Math.min(1.0, rs.aggression + 0.1);\n  1041â†’    }\n  1042â†’\n  1043â†’    rs.moveTimer++;\n  1044â†’    if (rs.moveTimer >= rs.moveInterval) {\n  1045â†’      rs.moveTimer = 0;\n  1046â†’\n  1047â†’      const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n  1048â†’      const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n  1049â†’      const distToFood = Math.sqrt(\n  1050â†’        Math.pow(foodX - rivalHead.x, 2) + Math.pow(foodY - rivalHead.y, 2)\n  1051â†’      );\n  1052â†’\n  1053â†’      if (distToPlayer < 80) {\n  1054â†’        rs.state = 'fleeing';\n  1055â†’        const fleeAngle = Math.atan2(rivalHead.y - playerY, rivalHead.x - playerX);\n  1056â†’        rs.targetX = rivalHead.x + Math.cos(fleeAngle) * 100;\n  1057â†’        rs.targetY = rivalHead.y + Math.sin(fleeAngle) * 100;\n  1058â†’      } else if (distToFood < 150 || rs.aggression > 0.7) {\n  1059â†’        rs.state = 'hunting';\n  1060â†’        rs.targetX = foodX;\n  1061â†’        rs.targetY = foodY;\n  1062â†’      } else {\n  1063â†’        rs.state = 'circling';\n  1064â†’        const circleAngle = rs.pulsePhase * 0.3;\n  1065â†’        rs.targetX = width / 2 + Math.cos(circleAngle) * 120;\n  1066â†’        rs.targetY = height / 2 + Math.sin(circleAngle) * 120;\n  1067â†’      }\n  1068â†’\n  1069â†’      rs.targetX = Math.max(30, Math.min(width - 30, rs.targetX));\n  1070â†’      rs.targetY = Math.max(30, Math.min(height - 30, rs.targetY));\n  1071â†’\n  1072â†’      const dx = rs.targetX - rivalHead.x;\n  1073â†’      const dy = rs.targetY - rivalHead.y;\n  1074â†’      const dist = Math.sqrt(dx * dx + dy * dy);\n  1075â†’\n  1076â†’      if (dist > 5) {\n  1077â†’        const targetDx = dx / dist;\n  1078â†’        const targetDy = dy / dist;\n  1079â†’        const turnSpeed = rs.state === 'fleeing' ? 0.5 : 0.35;\n  1080â†’\n  1081â†’        rs.direction.dx = rs.direction.dx * (1 - turnSpeed) + targetDx * turnSpeed;\n  1082â†’        rs.direction.dy = rs.direction.dy * (1 - turnSpeed) + targetDy * turnSpeed;\n  1083â†’\n  1084â†’        const len = Math.sqrt(rs.direction.dx * rs.direction.dx + rs.direction.dy * rs.direction.dy);\n  1085â†’        if (len > 0) {\n  1086â†’          rs.direction.dx /= len;\n  1087â†’          rs.direction.dy /= len;\n  1088â†’        }\n  1089â†’      }\n  1090â†’\n  1091â†’      const moveSpeed = rs.state === 'fleeing' ? CELL_SIZE * 0.7 : CELL_SIZE * 0.55;\n  1092â†’      const newHead = {\n  1093â†’        x: rivalHead.x + rs.direction.dx * moveSpeed,\n  1094â†’        y: rivalHead.y + rs.direction.dy * moveSpeed,\n  1095â†’      };\n  1096â†’\n  1097â†’      if (newHead.x < 10) newHead.x = width - 10;\n  1098â†’      if (newHead.x > width - 10) newHead.x = 10;\n  1099â†’      if (newHead.y < 10) newHead.y = height - 10;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"13c09258-a09b-47c3-8b1f-74ed2c95da63"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01U1ywE5PcDFnjAVVX6Y34zR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Sj35Sr7ezmAysM9f9qUV1R","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":1100,"limit":300},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":10196,"cache_read_input_tokens":30909,"cache_creation":{"ephemeral_5m_input_tokens":10196,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"0e77d5c6-9661-43bb-8551-f7b16fa3c355"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Sj35Sr7ezmAysM9f9qUV1R","type":"tool_result","content":"  1100â†’      if (newHead.y > height - 10) newHead.y = 10;\n  1101â†’\n  1102â†’      rs.segments.unshift(newHead);\n  1103â†’      rs.segments.pop();\n  1104â†’    } else {\n  1105â†’      const head = rs.segments[0];\n  1106â†’      const moveSpeed = CELL_SIZE * 0.5;\n  1107â†’\n  1108â†’      head.x += rs.direction.dx * moveSpeed * 0.06;\n  1109â†’      head.y += rs.direction.dy * moveSpeed * 0.06;\n  1110â†’\n  1111â†’      for (let i = 1; i < rs.segments.length; i++) {\n  1112â†’        const seg = rs.segments[i];\n  1113â†’        const prev = rs.segments[i - 1];\n  1114â†’        const pullStrength = 0.18;\n  1115â†’        seg.x += (prev.x - seg.x) * pullStrength;\n  1116â†’        seg.y += (prev.y - seg.y) * pullStrength;\n  1117â†’      }\n  1118â†’    }\n  1119â†’\n  1120â†’    if (this.currentState.gameOver) {\n  1121â†’      rs.hue = 180;\n  1122â†’      rs.glowIntensity *= 0.95;\n  1123â†’      rs.state = 'circling';\n  1124â†’    } else {\n  1125â†’      rs.hue = rs.state === 'hunting' ? 190 : (rs.state === 'fleeing' ? 220 : 200);\n  1126â†’      rs.hue += Math.sin(rs.pulsePhase * 0.5) * 10;\n  1127â†’    }\n  1128â†’\n  1129â†’    rs.aggression *= 0.998;\n  1130â†’  }\n  1131â†’\n  1132â†’  private drawRivalSnake(g: Phaser.GameObjects.Graphics): void {\n  1133â†’    if (!this.rivalSnake || this.rivalSnake.segments.length === 0) return;\n  1134â†’\n  1135â†’    const rs = this.rivalSnake;\n  1136â†’    const pulse = rs.glowIntensity;\n  1137â†’\n  1138â†’    for (const arc of rs.electricArcs) {\n  1139â†’      this.drawElectricArc(g, arc.x1, arc.y1, arc.x2, arc.y2, arc.life);\n  1140â†’    }\n  1141â†’\n  1142â†’    for (const e of rs.energyTrail) {\n  1143â†’      g.fillStyle(this.hslToHex(rs.hue + 20, 80, 70), e.alpha * 0.6);\n  1144â†’      g.fillCircle(e.x, e.y, e.size);\n  1145â†’      g.fillStyle(this.hslToHex(rs.hue, 90, 85), e.alpha * 0.3);\n  1146â†’      g.fillCircle(e.x, e.y, e.size * 0.5);\n  1147â†’    }\n  1148â†’\n  1149â†’    for (let i = 0; i < rs.trail.length; i++) {\n  1150â†’      const t = rs.trail[i];\n  1151â†’      const trailSize = 5 * (1 - i / rs.trail.length);\n  1152â†’      g.fillStyle(this.hslToHex(rs.hue, 80, 55), t.alpha * 0.4);\n  1153â†’      g.fillCircle(t.x, t.y, trailSize * 2);\n  1154â†’      g.fillStyle(this.hslToHex(rs.hue + 30, 70, 70), t.alpha * 0.2);\n  1155â†’      g.fillCircle(t.x, t.y, trailSize);\n  1156â†’    }\n  1157â†’\n  1158â†’    g.lineStyle(14, this.hslToHex(rs.hue, 70, 40), 0.2 * pulse);\n  1159â†’    g.beginPath();\n  1160â†’    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n  1161â†’    for (let i = 1; i < rs.segments.length; i++) {\n  1162â†’      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n  1163â†’    }\n  1164â†’    g.strokePath();\n  1165â†’\n  1166â†’    g.lineStyle(8, this.hslToHex(rs.hue, 80, 55), 0.35 * pulse);\n  1167â†’    g.beginPath();\n  1168â†’    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n  1169â†’    for (let i = 1; i < rs.segments.length; i++) {\n  1170â†’      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n  1171â†’    }\n  1172â†’    g.strokePath();\n  1173â†’\n  1174â†’    for (let i = rs.segments.length - 1; i >= 0; i--) {\n  1175â†’      const seg = rs.segments[i];\n  1176â†’      const t = rs.segments.length > 1 ? i / (rs.segments.length - 1) : 1;\n  1177â†’      const segmentPulse = pulse * (0.8 + Math.sin(rs.pulsePhase + i * 0.4) * 0.2);\n  1178â†’\n  1179â†’      const baseSize = 7 + t * 5;\n  1180â†’      const size = baseSize * (0.9 + segmentPulse * 0.15);\n  1181â†’\n  1182â†’      g.fillStyle(this.hslToHex(rs.hue - 10, 60, 35), 0.15 * segmentPulse);\n  1183â†’      g.fillCircle(seg.x, seg.y, size * 2.8);\n  1184â†’\n  1185â†’      g.fillStyle(this.hslToHex(rs.hue, 75, 50), 0.3 * segmentPulse);\n  1186â†’      g.fillCircle(seg.x, seg.y, size * 1.6);\n  1187â†’\n  1188â†’      g.fillStyle(this.hslToHex(rs.hue + 10, 85, 65), 0.6 * segmentPulse);\n  1189â†’      g.fillCircle(seg.x, seg.y, size);\n  1190â†’\n  1191â†’      g.fillStyle(this.hslToHex(rs.hue + 40, 60, 90), 0.5 * segmentPulse);\n  1192â†’      g.fillCircle(seg.x, seg.y, size * 0.35);\n  1193â†’\n  1194â†’      if (i === 0) {\n  1195â†’        const dx = rs.direction.dx;\n  1196â†’        const dy = rs.direction.dy;\n  1197â†’        const perpX = -dy;\n  1198â†’        const perpY = dx;\n  1199â†’\n  1200â†’        g.fillStyle(this.hslToHex(rs.hue, 90, 70), 0.3);\n  1201â†’        g.fillCircle(seg.x - dx * 3, seg.y - dy * 3, size * 1.8);\n  1202â†’\n  1203â†’        const eyeOffset = 4;\n  1204â†’        const eyeForward = 5;\n  1205â†’        const leftEyeX = seg.x + perpX * eyeOffset + dx * eyeForward;\n  1206â†’        const leftEyeY = seg.y + perpY * eyeOffset + dy * eyeForward;\n  1207â†’        const rightEyeX = seg.x - perpX * eyeOffset + dx * eyeForward;\n  1208â†’        const rightEyeY = seg.y - perpY * eyeOffset + dy * eyeForward;\n  1209â†’\n  1210â†’        const eyeColor = rs.state === 'hunting' ? 0xff4444 :\n  1211â†’                         rs.state === 'fleeing' ? 0xffff44 : 0x44ffff;\n  1212â†’\n  1213â†’        g.fillStyle(0x000000, 0.9 * segmentPulse);\n  1214â†’        g.fillCircle(leftEyeX, leftEyeY, 4);\n  1215â†’        g.fillCircle(rightEyeX, rightEyeY, 4);\n  1216â†’\n  1217â†’        g.fillStyle(eyeColor, 0.9 * segmentPulse);\n  1218â†’        g.fillCircle(leftEyeX, leftEyeY, 3);\n  1219â†’        g.fillCircle(rightEyeX, rightEyeY, 3);\n  1220â†’\n  1221â†’        g.fillStyle(0xffffff, 0.95 * segmentPulse);\n  1222â†’        g.fillCircle(leftEyeX + dx, leftEyeY + dy, 1.2);\n  1223â†’        g.fillCircle(rightEyeX + dx, rightEyeY + dy, 1.2);\n  1224â†’\n  1225â†’        const hornLength = 8;\n  1226â†’        const hornAngle = 0.4;\n  1227â†’        g.lineStyle(3, this.hslToHex(rs.hue - 20, 70, 45), 0.8 * segmentPulse);\n  1228â†’        g.beginPath();\n  1229â†’        g.moveTo(seg.x + perpX * 5, seg.y + perpY * 5);\n  1230â†’        g.lineTo(\n  1231â†’          seg.x + perpX * 5 + Math.cos(Math.atan2(dy, dx) - hornAngle) * hornLength,\n  1232â†’          seg.y + perpY * 5 + Math.sin(Math.atan2(dy, dx) - hornAngle) * hornLength\n  1233â†’        );\n  1234â†’        g.strokePath();\n  1235â†’        g.beginPath();\n  1236â†’        g.moveTo(seg.x - perpX * 5, seg.y - perpY * 5);\n  1237â†’        g.lineTo(\n  1238â†’          seg.x - perpX * 5 + Math.cos(Math.atan2(dy, dx) + hornAngle) * hornLength,\n  1239â†’          seg.y - perpY * 5 + Math.sin(Math.atan2(dy, dx) + hornAngle) * hornLength\n  1240â†’        );\n  1241â†’        g.strokePath();\n  1242â†’      }\n  1243â†’    }\n  1244â†’  }\n  1245â†’\n  1246â†’  private drawElectricArc(g: Phaser.GameObjects.Graphics, x1: number, y1: number, x2: number, y2: number, life: number): void {\n  1247â†’    const segments = 6;\n  1248â†’    const dx = (x2 - x1) / segments;\n  1249â†’    const dy = (y2 - y1) / segments;\n  1250â†’    const jitter = 15 * life;\n  1251â†’\n  1252â†’    g.lineStyle(4, 0x00ffff, 0.2 * life);\n  1253â†’    g.beginPath();\n  1254â†’    g.moveTo(x1, y1);\n  1255â†’    for (let i = 1; i < segments; i++) {\n  1256â†’      const jx = (Math.random() - 0.5) * jitter;\n  1257â†’      const jy = (Math.random() - 0.5) * jitter;\n  1258â†’      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n  1259â†’    }\n  1260â†’    g.lineTo(x2, y2);\n  1261â†’    g.strokePath();\n  1262â†’\n  1263â†’    g.lineStyle(2, 0x88ffff, 0.5 * life);\n  1264â†’    g.beginPath();\n  1265â†’    g.moveTo(x1, y1);\n  1266â†’    for (let i = 1; i < segments; i++) {\n  1267â†’      const jx = (Math.random() - 0.5) * jitter * 0.5;\n  1268â†’      const jy = (Math.random() - 0.5) * jitter * 0.5;\n  1269â†’      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n  1270â†’    }\n  1271â†’    g.lineTo(x2, y2);\n  1272â†’    g.strokePath();\n  1273â†’\n  1274â†’    g.lineStyle(1, 0xffffff, 0.8 * life);\n  1275â†’    g.beginPath();\n  1276â†’    g.moveTo(x1, y1);\n  1277â†’    g.lineTo(x2, y2);\n  1278â†’    g.strokePath();\n  1279â†’  }\n  1280â†’\n  1281â†’  private spawnBee(): void {\n  1282â†’    if (this.bees.length >= NUM_BEES) return;\n  1283â†’\n  1284â†’    const width = GRID_SIZE * CELL_SIZE;\n  1285â†’    const height = GRID_SIZE * CELL_SIZE;\n  1286â†’\n  1287â†’    // Spawn from random edge\n  1288â†’    const edge = Math.floor(Math.random() * 4);\n  1289â†’    let x: number, y: number;\n  1290â†’\n  1291â†’    switch (edge) {\n  1292â†’      case 0: // top\n  1293â†’        x = Math.random() * width;\n  1294â†’        y = -20;\n  1295â†’        break;\n  1296â†’      case 1: // right\n  1297â†’        x = width + 20;\n  1298â†’        y = Math.random() * height;\n  1299â†’        break;\n  1300â†’      case 2: // bottom\n  1301â†’        x = Math.random() * width;\n  1302â†’        y = height + 20;\n  1303â†’        break;\n  1304â†’      default: // left\n  1305â†’        x = -20;\n  1306â†’        y = Math.random() * height;\n  1307â†’        break;\n  1308â†’    }\n  1309â†’\n  1310â†’    // Random target inside the play area\n  1311â†’    const targetX = 50 + Math.random() * (width - 100);\n  1312â†’    const targetY = 50 + Math.random() * (height - 100);\n  1313â†’\n  1314â†’    this.bees.push({\n  1315â†’      x,\n  1316â†’      y,\n  1317â†’      vx: 0,\n  1318â†’      vy: 0,\n  1319â†’      targetX,\n  1320â†’      targetY,\n  1321â†’      wingPhase: Math.random() * Math.PI * 2,\n  1322â†’      wingSpeed: 0.4 + Math.random() * 0.2,\n  1323â†’      size: 6 + Math.random() * 3,\n  1324â†’      hue: 0 + Math.random() * 20, // Crimson/red volcanic color\n  1325â†’      glowIntensity: 0.5 + Math.random() * 0.5,\n  1326â†’      bobPhase: Math.random() * Math.PI * 2,\n  1327â†’      bobSpeed: 0.08 + Math.random() * 0.04,\n  1328â†’      trail: [],\n  1329â†’      state: 'flying',\n  1330â†’      sparkleTimer: 0,\n  1331â†’    });\n  1332â†’  }\n  1333â†’\n  1334â†’  private updateBees(): void {\n  1335â†’    if (!this.currentState) return;\n  1336â†’\n  1337â†’    const width = GRID_SIZE * CELL_SIZE;\n  1338â†’    const height = GRID_SIZE * CELL_SIZE;\n  1339â†’    const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n  1340â†’    const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n  1341â†’    const gameOver = this.currentState.gameOver;\n  1342â†’\n  1343â†’    // Randomly spawn new bees\n  1344â†’    if (!gameOver && Math.random() < BEE_SPAWN_CHANCE && this.bees.length < NUM_BEES) {\n  1345â†’      this.spawnBee();\n  1346â†’    }\n  1347â†’\n  1348â†’    for (let i = this.bees.length - 1; i >= 0; i--) {\n  1349â†’      const bee = this.bees[i];\n  1350â†’\n  1351â†’      // Update wing animation\n  1352â†’      bee.wingPhase += bee.wingSpeed;\n  1353â†’      bee.bobPhase += bee.bobSpeed;\n  1354â†’      bee.sparkleTimer += 0.1;\n  1355â†’\n  1356â†’      // Store trail position\n  1357â†’      if (this.frameCount % 2 === 0) {\n  1358â†’        bee.trail.unshift({ x: bee.x, y: bee.y, alpha: 0.6 });\n  1359â†’        if (bee.trail.length > 8) bee.trail.pop();\n  1360â†’      }\n  1361â†’\n  1362â†’      // Fade trail\n  1363â†’      for (const t of bee.trail) {\n  1364â†’        t.alpha *= 0.85;\n  1365â†’      }\n  1366â†’      bee.trail = bee.trail.filter(t => t.alpha > 0.05);\n  1367â†’\n  1368â†’      // Bees are attracted to food\n  1369â†’      const dxFood = foodX - bee.x;\n  1370â†’      const dyFood = foodY - bee.y;\n  1371â†’      const distFood = Math.sqrt(dxFood * dxFood + dyFood * dyFood);\n  1372â†’\n  1373â†’      // Determine behavior based on distance to food\n  1374â†’      if (distFood < 80) {\n  1375â†’        bee.state = 'attracted';\n  1376â†’        bee.targetX = foodX + Math.cos(bee.bobPhase * 3) * 30;\n  1377â†’        bee.targetY = foodY + Math.sin(bee.bobPhase * 3) * 30;\n  1378â†’      } else if (distFood < 150) {\n  1379â†’        bee.state = 'hovering';\n  1380â†’        // Circle around food loosely\n  1381â†’        const angle = Math.atan2(dyFood, dxFood) + Math.sin(bee.bobPhase) * 0.5;\n  1382â†’        bee.targetX = foodX - Math.cos(angle) * 60;\n  1383â†’        bee.targetY = foodY - Math.sin(angle) * 60;\n  1384â†’      } else {\n  1385â†’        bee.state = 'flying';\n  1386â†’        // Wander towards food with some randomness\n  1387â†’        if (Math.random() < 0.02) {\n  1388â†’          bee.targetX = foodX + (Math.random() - 0.5) * 200;\n  1389â†’          bee.targetY = foodY + (Math.random() - 0.5) * 200;\n  1390â†’        }\n  1391â†’      }\n  1392â†’\n  1393â†’      // Move towards target with smooth steering\n  1394â†’      const dx = bee.targetX - bee.x;\n  1395â†’      const dy = bee.targetY - bee.y;\n  1396â†’      const dist = Math.sqrt(dx * dx + dy * dy);\n  1397â†’\n  1398â†’      if (dist > 1) {\n  1399â†’        const speed = bee.state === 'attracted' ? 2.5 : (bee.state === 'hovering' ? 1.5 : 2);\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"2537ecde-12f4-491d-b1bb-6d2ae825c801"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01U1ywE5PcDFnjAVVX6Y34zR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01A4tgyyEY6ZG61evr2ACXoN","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":1400,"limit":300},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":10196,"cache_read_input_tokens":30909,"cache_creation":{"ephemeral_5m_input_tokens":10196,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"b2466525-e49b-4db9-b685-29f9f9c07f0b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A4tgyyEY6ZG61evr2ACXoN","type":"tool_result","content":"  1400â†’        const ax = (dx / dist) * speed * 0.1;\n  1401â†’        const ay = (dy / dist) * speed * 0.1;\n  1402â†’\n  1403â†’        bee.vx += ax;\n  1404â†’        bee.vy += ay;\n  1405â†’\n  1406â†’        // Add bobbing motion\n  1407â†’        bee.vy += Math.sin(bee.bobPhase) * 0.05;\n  1408â†’      }\n  1409â†’\n  1410â†’      // Limit velocity\n  1411â†’      const maxSpeed = bee.state === 'attracted' ? 3 : 2;\n  1412â†’      const currentSpeed = Math.sqrt(bee.vx * bee.vx + bee.vy * bee.vy);\n  1413â†’      if (currentSpeed > maxSpeed) {\n  1414â†’        bee.vx = (bee.vx / currentSpeed) * maxSpeed;\n  1415â†’        bee.vy = (bee.vy / currentSpeed) * maxSpeed;\n  1416â†’      }\n  1417â†’\n  1418â†’      // Apply velocity with damping\n  1419â†’      bee.x += bee.vx;\n  1420â†’      bee.y += bee.vy;\n  1421â†’      bee.vx *= 0.95;\n  1422â†’      bee.vy *= 0.95;\n  1423â†’\n  1424â†’      // Pulsing glow when near food\n  1425â†’      if (bee.state === 'attracted') {\n  1426â†’        bee.glowIntensity = 0.7 + Math.sin(bee.bobPhase * 4) * 0.3;\n  1427â†’      } else {\n  1428â†’        bee.glowIntensity = 0.5 + Math.sin(bee.bobPhase * 2) * 0.2;\n  1429â†’      }\n  1430â†’\n  1431â†’      // Remove bees that fly too far off screen\n  1432â†’      if (bee.x < -100 || bee.x > width + 100 || bee.y < -100 || bee.y > height + 100) {\n  1433â†’        this.bees.splice(i, 1);\n  1434â†’      }\n  1435â†’\n  1436â†’      // Scatter bees on game over\n  1437â†’      if (gameOver) {\n  1438â†’        bee.targetX = bee.x + (Math.random() - 0.5) * 400;\n  1439â†’        bee.targetY = bee.y - 200 - Math.random() * 200;\n  1440â†’        bee.vx += (Math.random() - 0.5) * 2;\n  1441â†’        bee.vy -= 1 + Math.random();\n  1442â†’      }\n  1443â†’    }\n  1444â†’  }\n  1445â†’\n  1446â†’  private drawBees(g: Phaser.GameObjects.Graphics): void {\n  1447â†’    for (const bee of this.bees) {\n  1448â†’      const { x, y, size, wingPhase, hue, glowIntensity, trail, state, sparkleTimer } = bee;\n  1449â†’\n  1450â†’      // Draw trail\n  1451â†’      for (let i = 0; i < trail.length; i++) {\n  1452â†’        const t = trail[i];\n  1453â†’        const trailSize = size * 0.4 * (1 - i / trail.length);\n  1454â†’        g.fillStyle(this.hslToHex(hue, 80, 60), t.alpha * 0.4);\n  1455â†’        g.fillCircle(t.x, t.y, trailSize);\n  1456â†’      }\n  1457â†’\n  1458â†’      // Outer glow\n  1459â†’      const glowSize = size * 2 * glowIntensity;\n  1460â†’      g.fillStyle(this.hslToHex(hue, 90, 50), 0.2 * glowIntensity);\n  1461â†’      g.fillCircle(x, y, glowSize);\n  1462â†’\n  1463â†’      // Mid glow\n  1464â†’      g.fillStyle(this.hslToHex(hue, 85, 60), 0.3 * glowIntensity);\n  1465â†’      g.fillCircle(x, y, glowSize * 0.6);\n  1466â†’\n  1467â†’      // Bee body - striped pattern\n  1468â†’      const bodyLength = size * 1.2;\n  1469â†’      const bodyWidth = size * 0.7;\n  1470â†’\n  1471â†’      // Body shadow/glow\n  1472â†’      g.fillStyle(this.hslToHex(hue, 70, 30), 0.5);\n  1473â†’      g.fillEllipse(x, y, bodyLength + 2, bodyWidth + 2);\n  1474â†’\n  1475â†’      // Main body (amber/golden)\n  1476â†’      g.fillStyle(this.hslToHex(hue, 90, 55), 1);\n  1477â†’      g.fillEllipse(x, y, bodyLength, bodyWidth);\n  1478â†’\n  1479â†’      // Dark stripes\n  1480â†’      g.fillStyle(0x1a1a1a, 0.8);\n  1481â†’      g.fillRect(x - bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n  1482â†’      g.fillRect(x + bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n  1483â†’\n  1484â†’      // Head\n  1485â†’      g.fillStyle(this.hslToHex(hue - 10, 80, 40), 1);\n  1486â†’      g.fillCircle(x - bodyLength * 0.4, y, size * 0.4);\n  1487â†’\n  1488â†’      // Wings - animated flutter\n  1489â†’      const wingAngle = Math.sin(wingPhase) * 0.8;\n  1490â†’      const wingSize = size * 0.9;\n  1491â†’\n  1492â†’      // Wing glow (ethereal effect)\n  1493â†’      g.fillStyle(0xffffff, 0.2 + Math.abs(Math.sin(wingPhase)) * 0.2);\n  1494â†’      g.fillEllipse(x + Math.cos(wingAngle + 0.5) * wingSize * 0.3, y - wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n  1495â†’      g.fillEllipse(x + Math.cos(-wingAngle + 0.5) * wingSize * 0.3, y + wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n  1496â†’\n  1497â†’      // Wing bodies\n  1498â†’      g.fillStyle(0xffffff, 0.5 + Math.abs(Math.sin(wingPhase)) * 0.3);\n  1499â†’      g.fillEllipse(x + Math.cos(wingAngle) * wingSize * 0.2, y - wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n  1500â†’      g.fillEllipse(x + Math.cos(-wingAngle) * wingSize * 0.2, y + wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n  1501â†’\n  1502â†’      // Eyes\n  1503â†’      g.fillStyle(0x000000, 1);\n  1504â†’      g.fillCircle(x - bodyLength * 0.45, y - size * 0.12, size * 0.12);\n  1505â†’      g.fillCircle(x - bodyLength * 0.45, y + size * 0.12, size * 0.12);\n  1506â†’\n  1507â†’      // Sparkles when attracted to food\n  1508â†’      if (state === 'attracted' && Math.sin(sparkleTimer * 3) > 0.7) {\n  1509â†’        const sparkleAngle = sparkleTimer * 2;\n  1510â†’        const sparkleDist = size * 1.5;\n  1511â†’        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n  1512â†’        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n  1513â†’\n  1514â†’        g.fillStyle(0xffffff, 0.8);\n  1515â†’        g.fillCircle(sparkleX, sparkleY, 2);\n  1516â†’        g.fillStyle(this.hslToHex(hue, 100, 80), 0.6);\n  1517â†’        g.fillCircle(sparkleX, sparkleY, 3);\n  1518â†’      }\n  1519â†’    }\n  1520â†’  }\n  1521â†’\n  1522â†’  // Helper to convert HSL to hex for Phaser\n  1523â†’  private hslToHex(h: number, s: number, l: number): number {\n  1524â†’    h = h / 360;\n  1525â†’    s = s / 100;\n  1526â†’    l = l / 100;\n  1527â†’\n  1528â†’    let r: number, g: number, b: number;\n  1529â†’\n  1530â†’    if (s === 0) {\n  1531â†’      r = g = b = l;\n  1532â†’    } else {\n  1533â†’      const hue2rgb = (p: number, q: number, t: number): number => {\n  1534â†’        if (t < 0) t += 1;\n  1535â†’        if (t > 1) t -= 1;\n  1536â†’        if (t < 1 / 6) return p + (q - p) * 6 * t;\n  1537â†’        if (t < 1 / 2) return q;\n  1538â†’        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  1539â†’        return p;\n  1540â†’      };\n  1541â†’\n  1542â†’      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n  1543â†’      const p = 2 * l - q;\n  1544â†’      r = hue2rgb(p, q, h + 1 / 3);\n  1545â†’      g = hue2rgb(p, q, h);\n  1546â†’      b = hue2rgb(p, q, h - 1 / 3);\n  1547â†’    }\n  1548â†’\n  1549â†’    return (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255);\n  1550â†’  }\n  1551â†’\n  1552â†’  private updateGuardianSpirits(): void {\n  1553â†’    if (!this.currentState) return;\n  1554â†’\n  1555â†’    const width = GRID_SIZE * CELL_SIZE;\n  1556â†’    const height = GRID_SIZE * CELL_SIZE;\n  1557â†’    const gameOver = this.currentState.gameOver;\n  1558â†’    const snakeHead = this.currentState.snake.length > 0 ? this.currentState.snake[0] : null;\n  1559â†’\n  1560â†’    for (const spirit of this.guardianSpirits) {\n  1561â†’      spirit.phase += spirit.speed;\n  1562â†’      spirit.haloPhase += 0.04;\n  1563â†’      spirit.orbPhase += 0.02;\n  1564â†’\n  1565â†’      for (const orb of spirit.orbs) {\n  1566â†’        orb.angle += orb.speed;\n  1567â†’      }\n  1568â†’\n  1569â†’      const floatAmount = gameOver ? 20 : 12;\n  1570â†’      const waveAmount = 5;\n  1571â†’      const wave = Math.sin(spirit.phase) * waveAmount;\n  1572â†’\n  1573â†’      let targetX = spirit.baseX;\n  1574â†’      let targetY = spirit.baseY;\n  1575â†’\n  1576â†’      switch (spirit.edge) {\n  1577â†’        case 'top':\n  1578â†’          targetY = spirit.baseY + floatAmount + wave;\n  1579â†’          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n  1580â†’          break;\n  1581â†’        case 'bottom':\n  1582â†’          targetY = spirit.baseY - floatAmount - wave;\n  1583â†’          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n  1584â†’          break;\n  1585â†’        case 'left':\n  1586â†’          targetX = spirit.baseX + floatAmount + wave;\n  1587â†’          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n  1588â†’          break;\n  1589â†’        case 'right':\n  1590â†’          targetX = spirit.baseX - floatAmount - wave;\n  1591â†’          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n  1592â†’          break;\n  1593â†’      }\n  1594â†’\n  1595â†’      if (snakeHead && !gameOver) {\n  1596â†’        const headX = snakeHead.x * CELL_SIZE + CELL_SIZE / 2;\n  1597â†’        const headY = snakeHead.y * CELL_SIZE + CELL_SIZE / 2;\n  1598â†’        const dx = spirit.x - headX;\n  1599â†’        const dy = spirit.y - headY;\n  1600â†’        const dist = Math.sqrt(dx * dx + dy * dy);\n  1601â†’\n  1602â†’        if (dist < 120) {\n  1603â†’          const attraction = (120 - dist) / 120 * 15;\n  1604â†’          targetX += (dx / dist) * attraction;\n  1605â†’          targetY += (dy / dist) * attraction;\n  1606â†’        }\n  1607â†’      }\n  1608â†’\n  1609â†’      spirit.x += (targetX - spirit.x) * 0.04;\n  1610â†’      spirit.y += (targetY - spirit.y) * 0.04;\n  1611â†’      spirit.x = Math.max(-50, Math.min(width + 50, spirit.x));\n  1612â†’      spirit.y = Math.max(-50, Math.min(height + 50, spirit.y));\n  1613â†’\n  1614â†’      const baseAlpha = gameOver ? 0.8 : spirit.targetAlpha;\n  1615â†’      spirit.currentAlpha += (baseAlpha - spirit.currentAlpha) * 0.05;\n  1616â†’    }\n  1617â†’  }\n  1618â†’\n  1619â†’  private drawGuardianSpirits(g: Phaser.GameObjects.Graphics): void {\n  1620â†’    for (const spirit of this.guardianSpirits) {\n  1621â†’      if (spirit.currentAlpha < 0.01) continue;\n  1622â†’\n  1623â†’      const { x, y, size, phase, haloPhase, currentAlpha, hue, orbs } = spirit;\n  1624â†’      const breathPulse = 1 + Math.sin(phase * 2) * 0.15;\n  1625â†’      const coreSize = size * breathPulse;\n  1626â†’\n  1627â†’      const spiritColor = this.hslToHex(hue, 0.7, 0.6);\n  1628â†’      const glowColor = this.hslToHex(hue, 0.5, 0.8);\n  1629â†’      const haloColor = this.hslToHex(hue, 0.3, 0.9);\n  1630â†’\n  1631â†’      g.fillStyle(glowColor, currentAlpha * 0.1);\n  1632â†’      g.fillCircle(x, y, coreSize * 2.5);\n  1633â†’\n  1634â†’      g.fillStyle(glowColor, currentAlpha * 0.15);\n  1635â†’      g.fillCircle(x, y, coreSize * 1.8);\n  1636â†’\n  1637â†’      const haloRadius = coreSize * 1.4 + Math.sin(haloPhase) * 3;\n  1638â†’      g.lineStyle(2, haloColor, currentAlpha * 0.4);\n  1639â†’      g.strokeCircle(x, y, haloRadius);\n  1640â†’\n  1641â†’      const innerHaloRadius = coreSize * 1.1 + Math.sin(haloPhase + 1) * 2;\n  1642â†’      g.lineStyle(1.5, haloColor, currentAlpha * 0.3);\n  1643â†’      g.strokeCircle(x, y, innerHaloRadius);\n  1644â†’\n  1645â†’      for (const orb of orbs) {\n  1646â†’        const orbX = x + Math.cos(orb.angle) * orb.distance;\n  1647â†’        const orbY = y + Math.sin(orb.angle) * orb.distance;\n  1648â†’        const orbPulse = 1 + Math.sin(phase + orb.angle) * 0.3;\n  1649â†’\n  1650â†’        g.fillStyle(glowColor, currentAlpha * 0.3);\n  1651â†’        g.fillCircle(orbX, orbY, orb.size * orbPulse * 1.5);\n  1652â†’\n  1653â†’        g.fillStyle(spiritColor, currentAlpha * 0.8);\n  1654â†’        g.fillCircle(orbX, orbY, orb.size * orbPulse);\n  1655â†’      }\n  1656â†’\n  1657â†’      g.fillStyle(spiritColor, currentAlpha * 0.9);\n  1658â†’      g.fillCircle(x, y, coreSize * 0.5);\n  1659â†’\n  1660â†’      g.fillStyle(0xffffff, currentAlpha * 0.7);\n  1661â†’      g.fillCircle(x, y, coreSize * 0.25);\n  1662â†’\n  1663â†’      const sparkleCount = 4;\n  1664â†’      for (let i = 0; i < sparkleCount; i++) {\n  1665â†’        const sparkleAngle = (i / sparkleCount) * Math.PI * 2 + phase * 0.5;\n  1666â†’        const sparkleDist = coreSize * (0.8 + Math.sin(phase * 2 + i) * 0.3);\n  1667â†’        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n  1668â†’        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n  1669â†’        const sparkleSize = 1.5 + Math.sin(phase * 3 + i * 2) * 0.5;\n  1670â†’\n  1671â†’        g.fillStyle(0xffffff, currentAlpha * (0.4 + Math.sin(phase * 2 + i) * 0.3));\n  1672â†’        g.fillCircle(sparkleX, sparkleY, sparkleSize);\n  1673â†’      }\n  1674â†’    }\n  1675â†’  }\n  1676â†’\n  1677â†’  private initStars(): void {\n  1678â†’    this.stars = [];\n  1679â†’    const width = GRID_SIZE * CELL_SIZE;\n  1680â†’    const height = GRID_SIZE * CELL_SIZE;\n  1681â†’    for (let i = 0; i < NUM_STARS; i++) {\n  1682â†’      this.stars.push({\n  1683â†’        x: Math.random() * width,\n  1684â†’        y: Math.random() * height,\n  1685â†’        size: 0.5 + Math.random() * 1.5,\n  1686â†’        speed: 0.02 + Math.random() * 0.03,\n  1687â†’        brightness: 0.3 + Math.random() * 0.7,\n  1688â†’      });\n  1689â†’    }\n  1690â†’  }\n  1691â†’\n  1692â†’  private initPlasmaWaves(): void {\n  1693â†’    this.plasmaWaves = [];\n  1694â†’    const hues = [0, 15, 30]; // Red/orange volcanic variations\n  1695â†’    for (let i = 0; i < NUM_PLASMA_WAVES; i++) {\n  1696â†’      this.plasmaWaves.push({\n  1697â†’        phase: Math.random() * Math.PI * 2,\n  1698â†’        speed: 0.015 + Math.random() * 0.01,\n  1699â†’        amplitude: 30 + Math.random() * 20,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"16915298-e02c-4c83-ad0b-b159d9ce4fd0"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GzhJCcEUSPRYUCoTzLqiZ2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HVXSvcSXM5XAGnynMwASwp","name":"Bash","input":{"command":"grep -n \"update\\|render\\|scene\" /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts | head -50"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":11304,"cache_read_input_tokens":41105,"cache_creation":{"ephemeral_5m_input_tokens":11304,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"b152d88c-7133-4920-b795-947a1185520f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HVXSvcSXM5XAGnynMwASwp","type":"tool_result","content":"5:  updateMotes,\n6:  updateRipples,\n7:  updateGlowTrail,\n158:// Comet trail segment - stores historical snake positions for smooth trail rendering\n546:  private updateArmageddonEffects(): void {\n982:  private updateRivalSnake(): void {\n1334:  private updateBees(): void {\n1552:  private updateGuardianSpirits(): void {\n1811:  private updateMeteors(width: number, height: number): void {\n1870:  private updateDeathDebris(): void {\n1914:  private updateParticles(): void {\n2028:  updateGameState(state: GameState): void {\n2217:  private updateThrownFood(): void {\n2379:  update(): void {\n2386:    updateMotes(this.cleanEffects, width, height);\n2387:    updateRipples(this.cleanEffects);\n2395:        updateGlowTrail(this.cleanEffects, headX, headY);\n2453:  private updateSmokeParticles(): void {\n2555:  private updateFlameParticles(): void {\n2979:  private updateCometTrail(): void {\n3058:  private updateEtherealParticles(): void {\n3379:    // Use simple block characters for text rendering\n3389:      // Simple pixel-style character rendering","is_error":false}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"69a26c69-f36d-4152-bad1-63e9f3166fe7"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011NQFqF9uymWQQ9Jxpiw8N5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FVFXauQ6ia47A2eo7XGyVp","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":2400,"limit":400},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":490,"cache_read_input_tokens":52409,"cache_creation":{"ephemeral_5m_input_tokens":490,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"da716a71-9e51-4e5d-8e48-579e4f8840d9"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FVFXauQ6ia47A2eo7XGyVp","type":"tool_result","content":"  2400â†’        const food = this.currentState.food;\n  2401â†’        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n  2402â†’        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n  2403â†’        spawnRipple(this.cleanEffects, foodX, foodY);\n  2404â†’      }\n  2405â†’      this.lastSnakeLength = this.currentState.snake.length;\n  2406â†’    }\n  2407â†’\n  2408â†’    const g = this.graphics;\n  2409â†’    g.clear();\n  2410â†’    g.setPosition(0, 0);\n  2411â†’\n  2412â†’    drawCleanBackground(g, width, height, this.frameCount);\n  2413â†’    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n  2414â†’    drawMotes(g, this.cleanEffects);\n  2415â†’\n  2416â†’    if (!this.currentState) return;\n  2417â†’\n  2418â†’    drawGlowTrail(g, this.cleanEffects);\n  2419â†’    drawRipples(g, this.cleanEffects);\n  2420â†’\n  2421â†’    const food = this.currentState.food;\n  2422â†’    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n  2423â†’    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n  2424â†’    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n  2425â†’\n  2426â†’    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n  2427â†’\n  2428â†’    drawCleanVignette(g, width, height);\n  2429â†’\n  2430â†’    const score = this.currentState.score || 0;\n  2431â†’    const snakeLength = this.currentState.snake.length;\n  2432â†’    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n  2433â†’\n  2434â†’    if (this.currentState.gameOver) {\n  2435â†’      this.drawGameOver(g, width, height);\n  2436â†’      this.drawScoreboard(g, width, height);\n  2437â†’    }\n  2438â†’\n  2439â†’    this.checkAndSaveHighScore();\n  2440â†’    this.needsRedraw = false;\n  2441â†’  }\n  2442â†’\n  2443â†’  private drawStars(g: Phaser.GameObjects.Graphics): void {\n  2444â†’    // In film noir mode, stars are subtle distant lights\n  2445â†’    for (const star of this.stars) {\n  2446â†’      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n  2447â†’      const alpha = star.brightness * twinkle * 0.25;\n  2448â†’      g.fillStyle(COLORS.star, alpha);\n  2449â†’      g.fillCircle(star.x, star.y, star.size * 0.7);\n  2450â†’    }\n  2451â†’  }\n  2452â†’\n  2453â†’  private updateSmokeParticles(): void {\n  2454â†’    const width = GRID_SIZE * CELL_SIZE;\n  2455â†’    const height = GRID_SIZE * CELL_SIZE;\n  2456â†’    for (const smoke of this.smokeParticles) {\n  2457â†’      smoke.x += smoke.vx;\n  2458â†’      smoke.y += smoke.vy;\n  2459â†’      smoke.life -= 0.002;\n  2460â†’      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n  2461â†’        smoke.x = Math.random() * width;\n  2462â†’        smoke.y = height + smoke.size;\n  2463â†’        smoke.life = 1;\n  2464â†’        smoke.size = 30 + Math.random() * 50;\n  2465â†’        smoke.alpha = 0.02 + Math.random() * 0.03;\n  2466â†’      }\n  2467â†’      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n  2468â†’      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n  2469â†’    }\n  2470â†’  }\n  2471â†’\n  2472â†’  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n  2473â†’    // Create dramatic spotlight effect centered on snake\n  2474â†’    const cx = this.spotlightX || width / 2;\n  2475â†’    const cy = this.spotlightY || height / 2;\n  2476â†’    const pulse = 0.9 + Math.sin(this.frameCount * 0.03) * 0.1;\n  2477â†’\n  2478â†’    // Outer darkness vignette\n  2479â†’    g.fillStyle(0x000000, 0.6);\n  2480â†’    g.fillRect(0, 0, width, height);\n  2481â†’\n  2482â†’    // Spotlight cone - multiple layers for smooth falloff\n  2483â†’    const layers = 4;\n  2484â†’    for (let i = layers; i > 0; i--) {\n  2485â†’      const layerRadius = (width * 0.4 + i * 30) * pulse;\n  2486â†’      const layerAlpha = 0.15 * (1 - i / (layers + 1));\n  2487â†’      g.fillStyle(COLORS.spotlight, layerAlpha);\n  2488â†’      g.fillCircle(cx, cy, layerRadius);\n  2489â†’    }\n  2490â†’\n  2491â†’    // Bright center\n  2492â†’    g.fillStyle(COLORS.noirWhite, 0.08 * pulse);\n  2493â†’    g.fillCircle(cx, cy, width * 0.25);\n  2494â†’  }\n  2495â†’\n  2496â†’  private drawVenetianBlinds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n  2497â†’    // Horizontal light streaks simulating light through venetian blinds\n  2498â†’    const blindSpacing = 25;\n  2499â†’    const blindWidth = 8;\n  2500â†’    const waveOffset = Math.sin(this.venetianPhase) * 10;\n  2501â†’\n  2502â†’    for (let y = waveOffset; y < height; y += blindSpacing) {\n  2503â†’      const brightness = 0.03 + Math.sin(y * 0.02 + this.venetianPhase * 2) * 0.015;\n  2504â†’      g.fillStyle(COLORS.noirWhite, brightness);\n  2505â†’      g.fillRect(0, y, width, blindWidth);\n  2506â†’    }\n  2507â†’\n  2508â†’    // Diagonal shadow bars from window frame\n  2509â†’    const diagonalAlpha = 0.04 + Math.sin(this.frameCount * 0.02) * 0.01;\n  2510â†’    g.fillStyle(0x000000, diagonalAlpha);\n  2511â†’    for (let i = -2; i < 6; i++) {\n  2512â†’      const x1 = i * 100 + Math.sin(this.venetianPhase) * 20;\n  2513â†’      g.beginPath();\n  2514â†’      g.moveTo(x1, 0);\n  2515â†’      g.lineTo(x1 + 40, 0);\n  2516â†’      g.lineTo(x1 + 40 + height * 0.3, height);\n  2517â†’      g.lineTo(x1 + height * 0.3, height);\n  2518â†’      g.closePath();\n  2519â†’      g.fillPath();\n  2520â†’    }\n  2521â†’  }\n  2522â†’\n  2523â†’  private drawSmoke(g: Phaser.GameObjects.Graphics): void {\n  2524â†’    for (const smoke of this.smokeParticles) {\n  2525â†’      const alpha = smoke.alpha * smoke.life;\n  2526â†’      g.fillStyle(COLORS.noirGray, alpha);\n  2527â†’      g.fillCircle(smoke.x, smoke.y, smoke.size);\n  2528â†’      g.fillStyle(COLORS.noirWhite, alpha * 0.3);\n  2529â†’      g.fillCircle(smoke.x, smoke.y, smoke.size * 0.5);\n  2530â†’    }\n  2531â†’  }\n  2532â†’\n  2533â†’  private spawnFlameParticle(x: number, y: number, intensity: number): void {\n  2534â†’    if (this.flameParticles.length >= MAX_FLAME_PARTICLES) {\n  2535â†’      this.flameParticles.shift();\n  2536â†’    }\n  2537â†’\n  2538â†’    const angle = Math.random() * Math.PI * 2;\n  2539â†’    const speed = 0.3 + Math.random() * 0.6;\n  2540â†’    const life = 0.5 + Math.random() * 0.5;\n  2541â†’\n  2542â†’    this.flameParticles.push({\n  2543â†’      x: x + (Math.random() - 0.5) * 6,\n  2544â†’      y: y + (Math.random() - 0.5) * 6,\n  2545â†’      vx: Math.cos(angle) * speed * 0.3,\n  2546â†’      vy: -0.5 - Math.random() * 1.5 * intensity,\n  2547â†’      size: 3 + Math.random() * 4 * intensity,\n  2548â†’      life,\n  2549â†’      maxLife: life,\n  2550â†’      hue: 10 + Math.random() * 30,\n  2551â†’      brightness: 0.5 + Math.random() * 0.3,\n  2552â†’    });\n  2553â†’  }\n  2554â†’\n  2555â†’  private updateFlameParticles(): void {\n  2556â†’    for (let i = this.flameParticles.length - 1; i >= 0; i--) {\n  2557â†’      const p = this.flameParticles[i];\n  2558â†’      p.x += p.vx;\n  2559â†’      p.y += p.vy;\n  2560â†’      p.vy -= 0.02;\n  2561â†’      p.vx *= 0.98;\n  2562â†’      p.size *= 0.97;\n  2563â†’      p.life -= 0.025;\n  2564â†’\n  2565â†’      if (p.life <= 0 || p.size < 0.5) {\n  2566â†’        this.flameParticles.splice(i, 1);\n  2567â†’      }\n  2568â†’    }\n  2569â†’  }\n  2570â†’\n  2571â†’  private drawFlameParticles(g: Phaser.GameObjects.Graphics): void {\n  2572â†’    for (const p of this.flameParticles) {\n  2573â†’      const lifeRatio = p.life / p.maxLife;\n  2574â†’\n  2575â†’      // Hue shifts from yellow-orange (high life) to red (low life)\n  2576â†’      const hue = p.hue - (1 - lifeRatio) * 15;\n  2577â†’      const outerColor = this.hslToRgb(hue / 360, 1, 0.3 + lifeRatio * 0.2);\n  2578â†’      const midColor = this.hslToRgb(hue / 360, 1, 0.5 + lifeRatio * 0.2);\n  2579â†’      const coreColor = this.hslToRgb((hue + 20) / 360, 0.7, 0.7 + lifeRatio * 0.2);\n  2580â†’\n  2581â†’      // Outer glow\n  2582â†’      g.fillStyle(outerColor, lifeRatio * 0.3);\n  2583â†’      g.fillCircle(p.x, p.y, p.size * 2);\n  2584â†’\n  2585â†’      // Mid flame\n  2586â†’      g.fillStyle(midColor, lifeRatio * 0.6);\n  2587â†’      g.fillCircle(p.x, p.y, p.size * 1.3);\n  2588â†’\n  2589â†’      // Core (bright yellow/white)\n  2590â†’      g.fillStyle(coreColor, lifeRatio * 0.8);\n  2591â†’      g.fillCircle(p.x, p.y, p.size * 0.6);\n  2592â†’    }\n  2593â†’  }\n  2594â†’\n  2595â†’  private spawnFlamesAlongSnake(): void {\n  2596â†’    if (!this.currentState || this.currentState.gameOver) return;\n  2597â†’\n  2598â†’    const snake = this.currentState.snake;\n  2599â†’    for (let i = 0; i < snake.length; i++) {\n  2600â†’      const seg = snake[i];\n  2601â†’      const segX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n  2602â†’      const segY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n  2603â†’      const intensity = 1 - (i / snake.length) * 0.6;\n  2604â†’      if (Math.random() < 0.4 * intensity) {\n  2605â†’        this.spawnFlameParticle(segX, segY, intensity);\n  2606â†’      }\n  2607â†’    }\n  2608â†’  }\n  2609â†’\n  2610â†’  private drawMeteors(g: Phaser.GameObjects.Graphics): void {\n  2611â†’    for (const m of this.meteors) {\n  2612â†’      const meteorColor = this.hslToRgb(m.hue / 360, 0.9, 0.6);\n  2613â†’      const coreColor = this.hslToRgb(m.hue / 360, 0.6, 0.9);\n  2614â†’\n  2615â†’      // Draw trail (oldest to newest for proper layering)\n  2616â†’      for (let i = m.trail.length - 1; i >= 0; i--) {\n  2617â†’        const t = m.trail[i];\n  2618â†’        const trailProgress = 1 - i / m.trail.length;\n  2619â†’        const trailAlpha = t.alpha * trailProgress * 0.4;\n  2620â†’        const trailSize = m.size * trailProgress * 0.6;\n  2621â†’\n  2622â†’        g.fillStyle(meteorColor, trailAlpha);\n  2623â†’        g.fillCircle(t.x, t.y, trailSize);\n  2624â†’      }\n  2625â†’\n  2626â†’      // Outer glow\n  2627â†’      g.fillStyle(meteorColor, m.alpha * 0.3);\n  2628â†’      g.fillCircle(m.x, m.y, m.size * 2);\n  2629â†’\n  2630â†’      // Main meteor body\n  2631â†’      g.fillStyle(meteorColor, m.alpha * 0.8);\n  2632â†’      g.fillCircle(m.x, m.y, m.size);\n  2633â†’\n  2634â†’      // Bright core\n  2635â†’      g.fillStyle(coreColor, m.alpha);\n  2636â†’      g.fillCircle(m.x, m.y, m.size * 0.5);\n  2637â†’    }\n  2638â†’  }\n  2639â†’\n  2640â†’  private drawDeathDebris(g: Phaser.GameObjects.Graphics): void {\n  2641â†’    // Draw explosion flash at the beginning\n  2642â†’    if (this.deathExplosionPhase > 0.7) {\n  2643â†’      const flashAlpha = (this.deathExplosionPhase - 0.7) * 2;\n  2644â†’      g.fillStyle(0xffffff, flashAlpha * 0.5);\n  2645â†’      g.fillRect(0, 0, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);\n  2646â†’    }\n  2647â†’\n  2648â†’    for (const d of this.deathDebris) {\n  2649â†’      // Film noir: grayscale debris\n  2650â†’      const brightness = 0.4 + (d.hue % 60) / 100;\n  2651â†’      const color = this.hslToRgb(0, 0, brightness);\n  2652â†’      const alpha = d.life * 0.9;\n  2653â†’\n  2654â†’      g.save();\n  2655â†’\n  2656â†’      if (d.type === 'shard') {\n  2657â†’        // Draw triangular shards\n  2658â†’        const cx = d.x;\n  2659â†’        const cy = d.y;\n  2660â†’        const size = d.size * d.life;\n  2661â†’\n  2662â†’        // Calculate rotated triangle points\n  2663â†’        const cos = Math.cos(d.rotation);\n  2664â†’        const sin = Math.sin(d.rotation);\n  2665â†’\n  2666â†’        const p1x = cx + cos * size;\n  2667â†’        const p1y = cy + sin * size;\n  2668â†’        const p2x = cx + cos * (-size * 0.5) - sin * (size * 0.7);\n  2669â†’        const p2y = cy + sin * (-size * 0.5) + cos * (size * 0.7);\n  2670â†’        const p3x = cx + cos * (-size * 0.5) - sin * (-size * 0.7);\n  2671â†’        const p3y = cy + sin * (-size * 0.5) + cos * (-size * 0.7);\n  2672â†’\n  2673â†’        // Glow\n  2674â†’        g.fillStyle(color, alpha * 0.4);\n  2675â†’        g.fillCircle(cx, cy, size * 1.5);\n  2676â†’\n  2677â†’        // Shard body\n  2678â†’        g.fillStyle(color, alpha);\n  2679â†’        g.fillTriangle(p1x, p1y, p2x, p2y, p3x, p3y);\n  2680â†’\n  2681â†’        // Highlight edge\n  2682â†’        g.lineStyle(1, 0xffffff, alpha * 0.6);\n  2683â†’        g.lineBetween(p1x, p1y, p2x, p2y);\n  2684â†’\n  2685â†’      } else if (d.type === 'spark') {\n  2686â†’        // Draw elongated spark\n  2687â†’        const sparkLength = d.size * 2 * d.life;\n  2688â†’        const sparkWidth = d.size * 0.3 * d.life;\n  2689â†’\n  2690â†’        // Direction based on velocity\n  2691â†’        const vLen = Math.sqrt(d.vx * d.vx + d.vy * d.vy);\n  2692â†’        const nx = vLen > 0 ? d.vx / vLen : 1;\n  2693â†’        const ny = vLen > 0 ? d.vy / vLen : 0;\n  2694â†’\n  2695â†’        // Glow\n  2696â†’        g.fillStyle(color, alpha * 0.3);\n  2697â†’        g.fillCircle(d.x, d.y, sparkLength * 0.8);\n  2698â†’\n  2699â†’        // Spark line\n  2700â†’        g.lineStyle(sparkWidth * 2, color, alpha * 0.6);\n  2701â†’        g.lineBetween(d.x - nx * sparkLength, d.y - ny * sparkLength, d.x, d.y);\n  2702â†’\n  2703â†’        // Bright tip\n  2704â†’        g.lineStyle(sparkWidth, 0xffffff, alpha);\n  2705â†’        g.lineBetween(d.x - nx * sparkLength * 0.3, d.y - ny * sparkLength * 0.3, d.x, d.y);\n  2706â†’\n  2707â†’      } else {\n  2708â†’        // Ember - glowing circle\n  2709â†’        const emberSize = d.size * d.life;\n  2710â†’\n  2711â†’        // Outer glow\n  2712â†’        g.fillStyle(color, alpha * 0.2);\n  2713â†’        g.fillCircle(d.x, d.y, emberSize * 2);\n  2714â†’\n  2715â†’        // Mid glow\n  2716â†’        g.fillStyle(color, alpha * 0.5);\n  2717â†’        g.fillCircle(d.x, d.y, emberSize * 1.3);\n  2718â†’\n  2719â†’        // Core\n  2720â†’        g.fillStyle(color, alpha);\n  2721â†’        g.fillCircle(d.x, d.y, emberSize);\n  2722â†’\n  2723â†’        // Hot center\n  2724â†’        g.fillStyle(0xffffff, alpha * 0.7);\n  2725â†’        g.fillCircle(d.x, d.y, emberSize * 0.4);\n  2726â†’      }\n  2727â†’\n  2728â†’      g.restore();\n  2729â†’    }\n  2730â†’  }\n  2731â†’\n  2732â†’  private drawNebulaClouds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n  2733â†’    for (const cloud of this.nebulaClouds) {\n  2734â†’      // Update cloud position (slow drift)\n  2735â†’      cloud.x += cloud.driftX;\n  2736â†’      cloud.y += cloud.driftY;\n  2737â†’      cloud.pulsePhase += cloud.pulseSpeed;\n  2738â†’\n  2739â†’      // Wrap around edges\n  2740â†’      if (cloud.x < -cloud.radius) cloud.x = width + cloud.radius;\n  2741â†’      if (cloud.x > width + cloud.radius) cloud.x = -cloud.radius;\n  2742â†’      if (cloud.y < -cloud.radius) cloud.y = height + cloud.radius;\n  2743â†’      if (cloud.y > height + cloud.radius) cloud.y = -cloud.radius;\n  2744â†’\n  2745â†’      // Pulsing alpha\n  2746â†’      const pulseAlpha = cloud.alpha * (0.7 + Math.sin(cloud.pulsePhase) * 0.3);\n  2747â†’      const color = this.hslToRgb(cloud.hue / 360, 0.6, 0.3);\n  2748â†’\n  2749â†’      // Draw multiple concentric layers for soft cloud effect\n  2750â†’      const layers = 4;\n  2751â†’      for (let i = layers; i > 0; i--) {\n  2752â†’        const layerRadius = cloud.radius * (i / layers);\n  2753â†’        const layerAlpha = pulseAlpha * (1 - i / (layers + 1)) * 0.6;\n  2754â†’        g.fillStyle(color, layerAlpha);\n  2755â†’        g.fillCircle(cloud.x, cloud.y, layerRadius);\n  2756â†’      }\n  2757â†’\n  2758â†’      // Core glow\n  2759â†’      const coreColor = this.hslToRgb(cloud.hue / 360, 0.8, 0.5);\n  2760â†’      g.fillStyle(coreColor, pulseAlpha * 0.4);\n  2761â†’      g.fillCircle(cloud.x, cloud.y, cloud.radius * 0.3);\n  2762â†’    }\n  2763â†’  }\n  2764â†’\n  2765â†’  private drawVortex(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n  2766â†’    const centerX = width / 2;\n  2767â†’    const centerY = height / 2;\n  2768â†’\n  2769â†’    // Update vortex pulse\n  2770â†’    this.vortexPulse += 0.03;\n  2771â†’    const globalPulse = 0.8 + Math.sin(this.vortexPulse) * 0.2;\n  2772â†’\n  2773â†’    // Draw outer glow/halo\n  2774â†’    const outerGlowColor = this.hslToRgb(280 / 360, 0.7, 0.3);\n  2775â†’    g.fillStyle(outerGlowColor, 0.08 * globalPulse);\n  2776â†’    g.fillCircle(centerX, centerY, 120);\n  2777â†’    g.fillStyle(outerGlowColor, 0.05 * globalPulse);\n  2778â†’    g.fillCircle(centerX, centerY, 140);\n  2779â†’\n  2780â†’    // Draw orbiting particles (behind rings)\n  2781â†’    for (const particle of this.vortexParticles) {\n  2782â†’      // Update particle position - spiral inward slightly then reset\n  2783â†’      particle.angle += particle.speed;\n  2784â†’      particle.radius = particle.baseRadius + Math.sin(particle.angle * 3) * 8;\n  2785â†’\n  2786â†’      const px = centerX + Math.cos(particle.angle) * particle.radius;\n  2787â†’      const py = centerY + Math.sin(particle.angle) * particle.radius;\n  2788â†’\n  2789â†’      // Particle hue shifts over time\n  2790â†’      particle.hue = (particle.hue + 0.5) % 360;\n  2791â†’      const particleColor = this.hslToRgb(particle.hue / 360, 0.8, 0.6);\n  2792â†’\n  2793â†’      // Draw particle with trail\n  2794â†’      const trailAngle = particle.angle - 0.3;\n  2795â†’      const trailX = centerX + Math.cos(trailAngle) * particle.radius;\n  2796â†’      const trailY = centerY + Math.sin(trailAngle) * particle.radius;\n  2797â†’\n  2798â†’      g.lineStyle(particle.size * 0.8, particleColor, particle.alpha * 0.3 * globalPulse);\n  2799â†’      g.lineBetween(trailX, trailY, px, py);\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"e28271fa-1685-4146-8e80-5d16ad9792cd"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RrWKZeF6DSKA146HrAxr2t","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Qdqa6HTnEW4LuYxt5nxXvB","name":"Bash","input":{"command":"grep -n \"^  update()\" /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":7267,"cache_read_input_tokens":52899,"cache_creation":{"ephemeral_5m_input_tokens":7267,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"56ab1fe0-d682-42c2-87e2-bd3179db6ec3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Qdqa6HTnEW4LuYxt5nxXvB","type":"tool_result","content":"2379:  update(): void {","is_error":false}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"6eda3578-425d-445c-a993-24860a9b4e9b"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017DXkHEqgPjLBjb1C3oZLbd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EZ6uqPMwXQJbvvaiDMKENX","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":2379,"limit":70},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":160,"cache_read_input_tokens":60166,"cache_creation":{"ephemeral_5m_input_tokens":160,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"4131489c-c147-44d9-992e-3d774ed80ec2"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EZ6uqPMwXQJbvvaiDMKENX","type":"tool_result","content":"  2379â†’  update(): void {\n  2380â†’    this.frameCount++;\n  2381â†’    this.cleanEffects.frameCount = this.frameCount;\n  2382â†’\n  2383â†’    const width = this.scale.width;\n  2384â†’    const height = this.scale.height;\n  2385â†’\n  2386â†’    updateMotes(this.cleanEffects, width, height);\n  2387â†’    updateRipples(this.cleanEffects);\n  2388â†’\n  2389â†’    if (this.currentState && this.currentState.snake.length > 0) {\n  2390â†’      const head = this.currentState.snake[0];\n  2391â†’      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n  2392â†’      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n  2393â†’\n  2394â†’      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n  2395â†’        updateGlowTrail(this.cleanEffects, headX, headY);\n  2396â†’      }\n  2397â†’      this.lastHeadPos = { x: head.x, y: head.y };\n  2398â†’\n  2399â†’      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n  2400â†’        const food = this.currentState.food;\n  2401â†’        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n  2402â†’        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n  2403â†’        spawnRipple(this.cleanEffects, foodX, foodY);\n  2404â†’      }\n  2405â†’      this.lastSnakeLength = this.currentState.snake.length;\n  2406â†’    }\n  2407â†’\n  2408â†’    const g = this.graphics;\n  2409â†’    g.clear();\n  2410â†’    g.setPosition(0, 0);\n  2411â†’\n  2412â†’    drawCleanBackground(g, width, height, this.frameCount);\n  2413â†’    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n  2414â†’    drawMotes(g, this.cleanEffects);\n  2415â†’\n  2416â†’    if (!this.currentState) return;\n  2417â†’\n  2418â†’    drawGlowTrail(g, this.cleanEffects);\n  2419â†’    drawRipples(g, this.cleanEffects);\n  2420â†’\n  2421â†’    const food = this.currentState.food;\n  2422â†’    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n  2423â†’    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n  2424â†’    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n  2425â†’\n  2426â†’    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n  2427â†’\n  2428â†’    drawCleanVignette(g, width, height);\n  2429â†’\n  2430â†’    const score = this.currentState.score || 0;\n  2431â†’    const snakeLength = this.currentState.snake.length;\n  2432â†’    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n  2433â†’\n  2434â†’    if (this.currentState.gameOver) {\n  2435â†’      this.drawGameOver(g, width, height);\n  2436â†’      this.drawScoreboard(g, width, height);\n  2437â†’    }\n  2438â†’\n  2439â†’    this.checkAndSaveHighScore();\n  2440â†’    this.needsRedraw = false;\n  2441â†’  }\n  2442â†’\n  2443â†’  private drawStars(g: Phaser.GameObjects.Graphics): void {\n  2444â†’    // In film noir mode, stars are subtle distant lights\n  2445â†’    for (const star of this.stars) {\n  2446â†’      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n  2447â†’      const alpha = star.brightness * twinkle * 0.25;\n  2448â†’      g.fillStyle(COLORS.star, alpha);\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"f8457a37-dc1b-450e-8ba8-ec78ffc3b27f"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01VGQjknLK14KDLv7PGnATaA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MVWpoMNAkvATKpPY5P1Wjc","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/game/constants.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1522,"cache_read_input_tokens":60326,"cache_creation":{"ephemeral_5m_input_tokens":1522,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"e187efc0-d8b1-41da-a8c0-c33e3937578d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MVWpoMNAkvATKpPY5P1Wjc","type":"tool_result","content":"     1â†’/**\n     2â†’ * Game constants - single source of truth for game configuration\n     3â†’ */\n     4â†’\n     5â†’import { Position, GameState, PowerUpType } from './types';\n     6â†’\n     7â†’export const GRID_SIZE = 20;\n     8â†’export const CELL_SIZE = 20;\n     9â†’export const GAME_SPEED_MS = 150;\n    10â†’export const MAX_DIRECTION_QUEUE = 3;\n    11â†’export const POINTS_PER_FOOD = 10;\n    12â†’\n    13â†’export const INITIAL_SNAKE: Position[] = [{ x: 10, y: 10 }];\n    14â†’export const INITIAL_FOOD: Position = { x: 15, y: 15 };\n    15â†’export const INITIAL_DIRECTION = 'RIGHT' as const;\n    16â†’\n    17â†’// Power-up configuration\n    18â†’export const POWERUP_SPAWN_CHANCE = 0.03;\n    19â†’export const POWERUP_DESPAWN_TICKS = 100;\n    20â†’export const POWERUP_DURATIONS: Record<PowerUpType, number> = {\n    21â†’  SPEED_BOOST: 50,\n    22â†’  INVINCIBILITY: 40,\n    23â†’  SCORE_MULTIPLIER: 60,\n    24â†’  MAGNET: 45,\n    25â†’};\n    26â†’export const POWERUP_TYPES: PowerUpType[] = ['SPEED_BOOST', 'INVINCIBILITY', 'SCORE_MULTIPLIER', 'MAGNET'];\n    27â†’export const SCORE_MULTIPLIER_VALUE = 3;\n    28â†’export const SPEED_BOOST_MS = 80;\n    29â†’\n    30â†’export const createInitialState = (): GameState => ({\n    31â†’  snake: [...INITIAL_SNAKE],\n    32â†’  food: { ...INITIAL_FOOD },\n    33â†’  direction: INITIAL_DIRECTION,\n    34â†’  gameOver: false,\n    35â†’  gameStarted: false,\n    36â†’  score: 0,\n    37â†’  powerUp: null,\n    38â†’  activePowerUps: [],\n    39â†’  tickCount: 0,\n    40â†’});\n    41â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"05f6c829-e8ca-40a7-9a35-53e8c23153b8"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Aqx6bpN9wt6sFzHSAZCdat","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019FGWcLCKg8iEAtfkChis7K","name":"Bash","input":{"command":"cd /__w/perfect-snake-platform/perfect-snake-platform && git log --oneline -20"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":782,"cache_read_input_tokens":61848,"cache_creation":{"ephemeral_5m_input_tokens":782,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"2796909c-5c2c-4003-bc54-b7f486ab866d"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"cd in '/__w/perfect-snake-platform/perfect-snake-platform' was blocked. For security, Claude Code may only change directories to the allowed working directories for this session: '/__w/perfect-snake-platform/perfect-snake-platform/game'.","is_error":true,"tool_use_id":"toolu_019FGWcLCKg8iEAtfkChis7K"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"83d7a69f-da1c-45b6-bdc1-15323de0dbcd","tool_use_result":"Error: cd in '/__w/perfect-snake-platform/perfect-snake-platform' was blocked. For security, Claude Code may only change directories to the allowed working directories for this session: '/__w/perfect-snake-platform/perfect-snake-platform/game'."}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01V8HLWamvjvJm14ceLLkurv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BFAhwrDvWHjEk6bn8qVVBC","name":"Bash","input":{"command":"git -C /__w/perfect-snake-platform/perfect-snake-platform log --oneline -20"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":203,"cache_read_input_tokens":62630,"cache_creation":{"ephemeral_5m_input_tokens":203,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"482a699a-a82e-413d-9398-06a2ab594105"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"This command requires approval","is_error":true,"tool_use_id":"toolu_01BFAhwrDvWHjEk6bn8qVVBC"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"707b81bb-1f18-4eb5-9e1a-805bc2ccab40","tool_use_result":"Error: This command requires approval"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01BQoWy54P7AwKd71W4Cm4LT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Rt1QT9j2cfVKGDyyhcRk2F","name":"Bash","input":{"command":"git log --oneline -20"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":134,"cache_read_input_tokens":62833,"cache_creation":{"ephemeral_5m_input_tokens":134,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"ed8e94da-471f-4a6b-bc58-b903d5aba127"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Rt1QT9j2cfVKGDyyhcRk2F","type":"tool_result","content":"fbf5473 AI improvement: clean effects\ne641601 AI improvement: halloween themed\na417abe AI improvement: remove monsters\n5891ff1 AI improvement: add another snake\n036b00e AI improvement: armageddon chaos\n506f22e AI improvement: add scoreboard\na4e71ed AI improvement: make bees red\n0cd798a merged from main\n43e8d74 AI improvement: remove bees\ndbcb05e AI improvement: add scoreboard\nd13fbe2 AI improvement: make snake human\nfc312ac AI improvement: penis themed\n8fcd82a AI improvement: two balls at tail\ne0c7a86 AI improvement: Add hud\n545acd7 AI improvement: Add power ups\n8a5cb77 AI improvement: Follow apples\n0d384be AI improvement: add another snake\n4d997c2 AI improvement: another cool snake\n648ddb0 AI improvement: bee randomly shown\n3f384fe AI improvement: apples thrown","is_error":false}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"890236c7-cc32-48f1-91c4-aa34dab961f2"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_015eFVTq7Ti61pDi45Da8PhV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AzDYXEr7Y3mWuA66RtpziK","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/GameBoard.test.tsx"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":339,"cache_read_input_tokens":62967,"cache_creation":{"ephemeral_5m_input_tokens":339,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"277215a3-4862-4884-ae53-f51f1a9abfd6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AzDYXEr7Y3mWuA66RtpziK","type":"tool_result","content":"     1â†’// Visual CSS-only improvements do not require tests per project requirements\n     2â†’// This is a placeholder test file for future rendering logic tests\n     3â†’\n     4â†’import { describe, it, expect } from 'vitest';\n     5â†’import { render } from '@testing-library/react';\n     6â†’import { GameBoard } from './GameBoard';\n     7â†’\n     8â†’describe('GameBoard', () => {\n     9â†’  it('should render without crashing', () => {\n    10â†’    const mockGameState = {\n    11â†’      snake: [{ x: 10, y: 10 }],\n    12â†’      food: { x: 15, y: 15 },\n    13â†’      direction: 'RIGHT' as const,\n    14â†’      gameStarted: false,\n    15â†’      gameOver: false,\n    16â†’      score: 0\n    17â†’    };\n    18â†’\n    19â†’    const { container } = render(<GameBoard gameState={mockGameState} gridSize={20} />);\n    20â†’    const canvas = container.querySelector('canvas');\n    21â†’    expect(canvas).toBeTruthy();\n    22â†’  });\n    23â†’});\n    24â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"1c8f5fa5-73c7-44c5-b444-8ed50b12811a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TRWGUZb9FhpmpBj1UgKEF9","type":"tool_result","content":[{"type":"text","text":"Perfect! Now let me create a comprehensive summary of the codebase exploration:\n\n## Codebase Structure Summary\n\nI've thoroughly explored the \"Perfect Snake\" game codebase. Here's what I found:\n\n### 1. **Main Game Files Organization**\n\n**Game Logic Layer** (`/src/game/`):\n- `logic.ts` - Pure game state logic (collision detection, food generation, scoring, power-ups)\n- `types.ts` - Core type definitions (GameState, Position, Direction, PowerUp types)\n- `constants.ts` - Game configuration (GRID_SIZE=20, CELL_SIZE=20, GAME_SPEED_MS=150)\n- `useSnakeGame.ts` - React hook for game state management\n- `useKeyboard.ts` - Keyboard input handling\n- `useTouch.ts` - Touch input handling\n- `useDirectionQueue.ts` - Direction buffering\n- `usePostMessage.ts` - iframe postMessage API integration\n\n**Rendering Layer** (`/src/components/`):\n- `SnakeScene.ts` - **Main Phaser scene (3,800+ lines)** - THE KEY FILE for visual effects\n- `GameBoard.tsx` - React wrapper component (33KB)\n- `cleanEffects.ts` - Clean/minimal visual effects module\n- `GameBoard.css` - Canvas styling\n\n### 2. **Current Visual Style & Theme: \"Clean Effects\"**\n\nThe most recent commit (`fbf5473 - AI improvement: clean effects`) shows the current visual theme uses a **minimal, clean aesthetic** with:\n\n**Colors (from cleanEffects.ts)**:\n- Background: Dark blue gradient (`0x0a1628`, `0x0f1d32`, `0x14253e`)\n- Snake: Cyan/teal (`snakeHead: 0x4fd1c5`, `snakeGlow: 0x81e6d9`)\n- Food: White/silver (`0xe2e8f0`, `0xffffff`)\n- Grid: Subtle blue lines (`0x1a3050`, `0x254060`)\n\n**Current Effects in cleanEffects.ts**:\n- Floating motes (ambient particles)\n- Ripple effects (when eating food)\n- Glow trail behind snake\n- Pulsing grid lines\n- Radial background gradient with breathing effect\n- HUD display for score and snake length\n- Vignette effect at screen edges\n\n### 3. **Phaser Rendering Code Architecture**\n\nThe **SnakeScene.ts file** is where ALL visual changes happen. Key structure:\n\n**Main Update Loop** (`update()` method, line 2379):\n```\n- Clear graphics\n- Update cleanEffects (motes, ripples, glow trail)\n- Draw background\n- Draw grid\n- Draw motes\n- Draw glow trail & ripples\n- Draw food & snake\n- Draw vignette\n- Draw HUD\n- Draw game over screen & scoreboard\n```\n\n**Drawing Functions** (in cleanEffects.ts):\n- `drawCleanBackground()` - Radial pulse gradient\n- `drawCleanGrid()` - Grid with pulsing alpha\n- `drawCleanFood()` - Multi-layer food orb with glow\n- `drawCleanSnake()` - Gradient colored segments with head highlight\n- `drawMotes()` - Floating ambient particles\n- `drawRipples()` - Expanding ripple rings\n- `drawGlowTrail()` - Fading trail behind head\n- `drawCleanVignette()` - Edge darkening\n- `drawCleanHUD()` - Score/length display\n\n### 4. **Previous Visual Systems Still in Code** (but not used)\n\nThe SnakeScene.ts file contains **extensive legacy code** for previous themes that have been disabled:\n- Halloween theme (skulls, bats, fire rain, ground fissures)\n- Armageddon chaos effects (explosions, debris)\n- Guardian spirits (ethereal entities at edges)\n- Mystical bees (swarming creatures)\n- Rival snake (spectral AI nemesis)\n- Film noir effects (venetian blinds, spotlight, smoke)\n- Flame particles & meteors\n- Comet trails & ethereal particles\n- Thrown food animations\n\n**These are instantiated but NOT called** in the main `update()` method - they're dead code from previous iterations.\n\n### 5. **Particle Systems & Effects Available**\n\n**Active Systems**:\n- CleanEffectsState with motes, ripples, glowTrail\n- High score scoreboard system\n- Game over screen\n\n**Dormant Systems** (code exists, not integrated):\n- Star field (initialized but not drawn)\n- Plasma waves (data structure exists)\n- Aurora waves\n- Nebula clouds\n- Vortex rings & particles\n- Death debris particles\n- Flame particles\n- Meteor system\n- Comet trail system\n- Lightning bolts\n\n### 6. **Key Constants**\n\n- Grid: 20x20 cells\n- Cell Size: 20 pixels each\n- Game Speed: 150ms per tick\n- Canvas: 400x400 pixels\n- Max high scores: 5 entries\n\n### 7. **Evolution Pattern**\n\nRecent commits show a clear pattern of adding elaborate effects then \"cleaning\" them:\n1. Armageddon chaos (explosions, fire)\n2. Add another snake (rival AI)\n3. Remove monsters (clean up effects)\n4. Halloween themed (spooky visual theme)\n5. Clean effects (current minimalist aesthetic)\n\nThis follows the instruction: **\"Evolve, don't revolutionize\"** - each version builds on the last but can simplify by removing previous complexity.\n\n### 8. **File Sizes**\n\n- SnakeScene.ts: 135KB (massive, contains all historical code)\n- GameBoard.tsx: 33KB\n- cleanEffects.ts: 9KB (focused, clean module)\n- Game logic files: Small, pure functions\n\n---\n\n## Visual Rendering Call Stack\n\n```\nReact Component (GameBoard.tsx)\n    â†“\nPhaser Scene (SnakeScene)\n    â†“\nupdate() method (line 2379)\n    â†“\nDrawing functions from cleanEffects.ts\n    â†“\nPhaser Graphics object g.fillCircle(), g.lineBetween(), etc.\n    â†“\nCanvas render\n```\n\nThe game uses **Phaser's Graphics API** for all drawing - no sprites or textures, just programmatic rendering with shapes and colors."},{"type":"text","text":"agentId: a833c51 (for resuming to continue this agent's work if needed)\n<usage>total_tokens: 65357\ntool_uses: 26\nduration_ms: 50992</usage>"}]}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"8e05726c-b209-4ea4-93ef-31df6a3dce1f","tool_use_result":{"status":"completed","prompt":"Explore the game codebase to understand its structure. I need to understand:\n1. The main game files and their organization\n2. The Phaser rendering code (where visual changes should be made)\n3. The current visual style and effects\n4. Any existing particle systems or visual effects\n\nLook at the src directory structure and read the key files to understand how the game renders and what visual systems are already in place. Focus on files related to rendering, effects, and the snake appearance.","agentId":"a833c51","content":[{"type":"text","text":"Perfect! Now let me create a comprehensive summary of the codebase exploration:\n\n## Codebase Structure Summary\n\nI've thoroughly explored the \"Perfect Snake\" game codebase. Here's what I found:\n\n### 1. **Main Game Files Organization**\n\n**Game Logic Layer** (`/src/game/`):\n- `logic.ts` - Pure game state logic (collision detection, food generation, scoring, power-ups)\n- `types.ts` - Core type definitions (GameState, Position, Direction, PowerUp types)\n- `constants.ts` - Game configuration (GRID_SIZE=20, CELL_SIZE=20, GAME_SPEED_MS=150)\n- `useSnakeGame.ts` - React hook for game state management\n- `useKeyboard.ts` - Keyboard input handling\n- `useTouch.ts` - Touch input handling\n- `useDirectionQueue.ts` - Direction buffering\n- `usePostMessage.ts` - iframe postMessage API integration\n\n**Rendering Layer** (`/src/components/`):\n- `SnakeScene.ts` - **Main Phaser scene (3,800+ lines)** - THE KEY FILE for visual effects\n- `GameBoard.tsx` - React wrapper component (33KB)\n- `cleanEffects.ts` - Clean/minimal visual effects module\n- `GameBoard.css` - Canvas styling\n\n### 2. **Current Visual Style & Theme: \"Clean Effects\"**\n\nThe most recent commit (`fbf5473 - AI improvement: clean effects`) shows the current visual theme uses a **minimal, clean aesthetic** with:\n\n**Colors (from cleanEffects.ts)**:\n- Background: Dark blue gradient (`0x0a1628`, `0x0f1d32`, `0x14253e`)\n- Snake: Cyan/teal (`snakeHead: 0x4fd1c5`, `snakeGlow: 0x81e6d9`)\n- Food: White/silver (`0xe2e8f0`, `0xffffff`)\n- Grid: Subtle blue lines (`0x1a3050`, `0x254060`)\n\n**Current Effects in cleanEffects.ts**:\n- Floating motes (ambient particles)\n- Ripple effects (when eating food)\n- Glow trail behind snake\n- Pulsing grid lines\n- Radial background gradient with breathing effect\n- HUD display for score and snake length\n- Vignette effect at screen edges\n\n### 3. **Phaser Rendering Code Architecture**\n\nThe **SnakeScene.ts file** is where ALL visual changes happen. Key structure:\n\n**Main Update Loop** (`update()` method, line 2379):\n```\n- Clear graphics\n- Update cleanEffects (motes, ripples, glow trail)\n- Draw background\n- Draw grid\n- Draw motes\n- Draw glow trail & ripples\n- Draw food & snake\n- Draw vignette\n- Draw HUD\n- Draw game over screen & scoreboard\n```\n\n**Drawing Functions** (in cleanEffects.ts):\n- `drawCleanBackground()` - Radial pulse gradient\n- `drawCleanGrid()` - Grid with pulsing alpha\n- `drawCleanFood()` - Multi-layer food orb with glow\n- `drawCleanSnake()` - Gradient colored segments with head highlight\n- `drawMotes()` - Floating ambient particles\n- `drawRipples()` - Expanding ripple rings\n- `drawGlowTrail()` - Fading trail behind head\n- `drawCleanVignette()` - Edge darkening\n- `drawCleanHUD()` - Score/length display\n\n### 4. **Previous Visual Systems Still in Code** (but not used)\n\nThe SnakeScene.ts file contains **extensive legacy code** for previous themes that have been disabled:\n- Halloween theme (skulls, bats, fire rain, ground fissures)\n- Armageddon chaos effects (explosions, debris)\n- Guardian spirits (ethereal entities at edges)\n- Mystical bees (swarming creatures)\n- Rival snake (spectral AI nemesis)\n- Film noir effects (venetian blinds, spotlight, smoke)\n- Flame particles & meteors\n- Comet trails & ethereal particles\n- Thrown food animations\n\n**These are instantiated but NOT called** in the main `update()` method - they're dead code from previous iterations.\n\n### 5. **Particle Systems & Effects Available**\n\n**Active Systems**:\n- CleanEffectsState with motes, ripples, glowTrail\n- High score scoreboard system\n- Game over screen\n\n**Dormant Systems** (code exists, not integrated):\n- Star field (initialized but not drawn)\n- Plasma waves (data structure exists)\n- Aurora waves\n- Nebula clouds\n- Vortex rings & particles\n- Death debris particles\n- Flame particles\n- Meteor system\n- Comet trail system\n- Lightning bolts\n\n### 6. **Key Constants**\n\n- Grid: 20x20 cells\n- Cell Size: 20 pixels each\n- Game Speed: 150ms per tick\n- Canvas: 400x400 pixels\n- Max high scores: 5 entries\n\n### 7. **Evolution Pattern**\n\nRecent commits show a clear pattern of adding elaborate effects then \"cleaning\" them:\n1. Armageddon chaos (explosions, fire)\n2. Add another snake (rival AI)\n3. Remove monsters (clean up effects)\n4. Halloween themed (spooky visual theme)\n5. Clean effects (current minimalist aesthetic)\n\nThis follows the instruction: **\"Evolve, don't revolutionize\"** - each version builds on the last but can simplify by removing previous complexity.\n\n### 8. **File Sizes**\n\n- SnakeScene.ts: 135KB (massive, contains all historical code)\n- GameBoard.tsx: 33KB\n- cleanEffects.ts: 9KB (focused, clean module)\n- Game logic files: Small, pure functions\n\n---\n\n## Visual Rendering Call Stack\n\n```\nReact Component (GameBoard.tsx)\n    â†“\nPhaser Scene (SnakeScene)\n    â†“\nupdate() method (line 2379)\n    â†“\nDrawing functions from cleanEffects.ts\n    â†“\nPhaser Graphics object g.fillCircle(), g.lineBetween(), etc.\n    â†“\nCanvas render\n```\n\nThe game uses **Phaser's Graphics API** for all drawing - no sprites or textures, just programmatic rendering with shapes and colors."}],"totalDurationMs":50992,"totalTokens":65357,"totalToolUseCount":26,"usage":{"input_tokens":0,"cache_creation_input_tokens":513,"cache_read_input_tokens":63306,"output_tokens":1538,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":513},"inference_geo":"","iterations":[],"speed":"standard"}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01S9yDwRiCizeL37VLLLz6N8","type":"message","role":"assistant","content":[{"type":"text","text":"Now I understand the codebase. The current theme is \"clean effects\" with a minimal, cyan/teal aesthetic. The user suggestion \"blood and tears\" can be creatively interpreted as adding emotional visual effects - perhaps red particle drops that fall like tears and splatter effects when the snake dies or collides.\n\nLet me read the current cleanEffects.ts file to understand exactly what I'm working with, then create a tasteful enhancement."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1833,"cache_read_input_tokens":20279,"cache_creation":{"ephemeral_5m_input_tokens":1833,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"f43f8ac4-f439-4e7c-bf17-c83b3130bb04"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01S9yDwRiCizeL37VLLLz6N8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YUpPwjF3VaT2PA3uZbQ2fP","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1833,"cache_read_input_tokens":20279,"cache_creation":{"ephemeral_5m_input_tokens":1833,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"bdb0749d-82c9-424f-a4b2-9be5f63a1f35"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YUpPwjF3VaT2PA3uZbQ2fP","type":"tool_result","content":"     1â†’export interface CleanRipple {\n     2â†’  x: number;\n     3â†’  y: number;\n     4â†’  radius: number;\n     5â†’  maxRadius: number;\n     6â†’  alpha: number;\n     7â†’  thickness: number;\n     8â†’}\n     9â†’\n    10â†’export interface FloatingMote {\n    11â†’  x: number;\n    12â†’  y: number;\n    13â†’  vx: number;\n    14â†’  vy: number;\n    15â†’  size: number;\n    16â†’  alpha: number;\n    17â†’  pulsePhase: number;\n    18â†’}\n    19â†’\n    20â†’export interface SnakeGlowTrail {\n    21â†’  x: number;\n    22â†’  y: number;\n    23â†’  alpha: number;\n    24â†’  size: number;\n    25â†’}\n    26â†’\n    27â†’export const CLEAN_COLORS = {\n    28â†’  bgDark: 0x0a1628,\n    29â†’  bgMid: 0x0f1d32,\n    30â†’  bgLight: 0x14253e,\n    31â†’\n    32â†’  gridLine: 0x1a3050,\n    33â†’  gridAccent: 0x254060,\n    34â†’\n    35â†’  snakeHead: 0x4fd1c5,\n    36â†’  snakeBody: 0x38b2ac,\n    37â†’  snakeTail: 0x2c9a94,\n    38â†’  snakeGlow: 0x81e6d9,\n    39â†’\n    40â†’  food: 0xe2e8f0,\n    41â†’  foodCore: 0xffffff,\n    42â†’  foodGlow: 0xcbd5e1,\n    43â†’\n    44â†’  ripple: 0x81e6d9,\n    45â†’  mote: 0x4fd1c5,\n    46â†’\n    47â†’  text: 0xe2e8f0,\n    48â†’  textDim: 0x94a3b8,\n    49â†’};\n    50â†’\n    51â†’const MAX_RIPPLES = 5;\n    52â†’const MAX_MOTES = 20;\n    53â†’const MAX_TRAIL_LENGTH = 15;\n    54â†’\n    55â†’export function createCleanEffectsState() {\n    56â†’  return {\n    57â†’    ripples: [] as CleanRipple[],\n    58â†’    motes: [] as FloatingMote[],\n    59â†’    glowTrail: [] as SnakeGlowTrail[],\n    60â†’    frameCount: 0,\n    61â†’  };\n    62â†’}\n    63â†’\n    64â†’export type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n    65â†’\n    66â†’export function initMotes(state: CleanEffectsState, width: number, height: number): void {\n    67â†’  state.motes = [];\n    68â†’  for (let i = 0; i < MAX_MOTES; i++) {\n    69â†’    state.motes.push({\n    70â†’      x: Math.random() * width,\n    71â†’      y: Math.random() * height,\n    72â†’      vx: (Math.random() - 0.5) * 0.3,\n    73â†’      vy: (Math.random() - 0.5) * 0.3,\n    74â†’      size: 1 + Math.random() * 2,\n    75â†’      alpha: 0.1 + Math.random() * 0.2,\n    76â†’      pulsePhase: Math.random() * Math.PI * 2,\n    77â†’    });\n    78â†’  }\n    79â†’}\n    80â†’\n    81â†’export function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n    82â†’  for (const mote of state.motes) {\n    83â†’    mote.x += mote.vx;\n    84â†’    mote.y += mote.vy;\n    85â†’    mote.pulsePhase += 0.02;\n    86â†’\n    87â†’    if (mote.x < 0) mote.x = width;\n    88â†’    if (mote.x > width) mote.x = 0;\n    89â†’    if (mote.y < 0) mote.y = height;\n    90â†’    if (mote.y > height) mote.y = 0;\n    91â†’  }\n    92â†’}\n    93â†’\n    94â†’export function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n    95â†’  if (state.ripples.length >= MAX_RIPPLES) {\n    96â†’    state.ripples.shift();\n    97â†’  }\n    98â†’\n    99â†’  state.ripples.push({\n   100â†’    x,\n   101â†’    y,\n   102â†’    radius: 5,\n   103â†’    maxRadius: 60,\n   104â†’    alpha: 0.6,\n   105â†’    thickness: 2,\n   106â†’  });\n   107â†’}\n   108â†’\n   109â†’export function updateRipples(state: CleanEffectsState): void {\n   110â†’  for (let i = state.ripples.length - 1; i >= 0; i--) {\n   111â†’    const ripple = state.ripples[i];\n   112â†’    ripple.radius += 2;\n   113â†’    ripple.alpha *= 0.94;\n   114â†’    ripple.thickness *= 0.98;\n   115â†’\n   116â†’    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n   117â†’      state.ripples.splice(i, 1);\n   118â†’    }\n   119â†’  }\n   120â†’}\n   121â†’\n   122â†’export function updateGlowTrail(\n   123â†’  state: CleanEffectsState,\n   124â†’  headX: number,\n   125â†’  headY: number\n   126â†’): void {\n   127â†’  state.glowTrail.unshift({\n   128â†’    x: headX,\n   129â†’    y: headY,\n   130â†’    alpha: 0.5,\n   131â†’    size: 12,\n   132â†’  });\n   133â†’\n   134â†’  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n   135â†’    state.glowTrail.pop();\n   136â†’  }\n   137â†’\n   138â†’  for (let i = 0; i < state.glowTrail.length; i++) {\n   139â†’    const t = state.glowTrail[i];\n   140â†’    t.alpha *= 0.85;\n   141â†’    t.size *= 0.95;\n   142â†’  }\n   143â†’\n   144â†’  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n   145â†’}\n   146â†’\n   147â†’export function drawCleanBackground(\n   148â†’  g: Phaser.GameObjects.Graphics,\n   149â†’  width: number,\n   150â†’  height: number,\n   151â†’  frameCount: number\n   152â†’): void {\n   153â†’  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n   154â†’  g.fillRect(0, 0, width, height);\n   155â†’\n   156â†’  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n   157â†’  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n   158â†’  g.fillCircle(width / 2, height / 2, width * 0.6);\n   159â†’  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n   160â†’  g.fillCircle(width / 2, height / 2, width * 0.3);\n   161â†’}\n   162â†’\n   163â†’export function drawCleanGrid(\n   164â†’  g: Phaser.GameObjects.Graphics,\n   165â†’  width: number,\n   166â†’  height: number,\n   167â†’  cellSize: number,\n   168â†’  gridSize: number,\n   169â†’  frameCount: number\n   170â†’): void {\n   171â†’  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n   172â†’  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n   173â†’\n   174â†’  for (let i = 0; i <= gridSize; i++) {\n   175â†’    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n   176â†’    g.lineBetween(0, i * cellSize, width, i * cellSize);\n   177â†’  }\n   178â†’\n   179â†’  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n   180â†’  for (let i = 0; i <= gridSize; i += 5) {\n   181â†’    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n   182â†’    g.lineBetween(0, i * cellSize, width, i * cellSize);\n   183â†’  }\n   184â†’}\n   185â†’\n   186â†’export function drawMotes(\n   187â†’  g: Phaser.GameObjects.Graphics,\n   188â†’  state: CleanEffectsState\n   189â†’): void {\n   190â†’  for (const mote of state.motes) {\n   191â†’    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n   192â†’    const alpha = mote.alpha * pulse;\n   193â†’\n   194â†’    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n   195â†’    g.fillCircle(mote.x, mote.y, mote.size * 2);\n   196â†’    g.fillStyle(CLEAN_COLORS.mote, alpha);\n   197â†’    g.fillCircle(mote.x, mote.y, mote.size);\n   198â†’  }\n   199â†’}\n   200â†’\n   201â†’export function drawRipples(\n   202â†’  g: Phaser.GameObjects.Graphics,\n   203â†’  state: CleanEffectsState\n   204â†’): void {\n   205â†’  for (const ripple of state.ripples) {\n   206â†’    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n   207â†’    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n   208â†’\n   209â†’    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n   210â†’    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n   211â†’  }\n   212â†’}\n   213â†’\n   214â†’export function drawGlowTrail(\n   215â†’  g: Phaser.GameObjects.Graphics,\n   216â†’  state: CleanEffectsState\n   217â†’): void {\n   218â†’  for (const trail of state.glowTrail) {\n   219â†’    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n   220â†’    g.fillCircle(trail.x, trail.y, trail.size);\n   221â†’  }\n   222â†’}\n   223â†’\n   224â†’export function drawCleanFood(\n   225â†’  g: Phaser.GameObjects.Graphics,\n   226â†’  foodX: number,\n   227â†’  foodY: number,\n   228â†’  cellSize: number,\n   229â†’  frameCount: number\n   230â†’): void {\n   231â†’  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n   232â†’  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n   233â†’  const foodSize = (cellSize / 2 - 2) * pulseScale;\n   234â†’\n   235â†’  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n   236â†’  g.fillCircle(foodX, foodY, foodSize + 12);\n   237â†’  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n   238â†’  g.fillCircle(foodX, foodY, foodSize + 6);\n   239â†’\n   240â†’  g.fillStyle(CLEAN_COLORS.food, 0.9);\n   241â†’  g.fillCircle(foodX, foodY, foodSize);\n   242â†’  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n   243â†’  g.fillCircle(foodX, foodY, foodSize * 0.5);\n   244â†’\n   245â†’  g.fillStyle(0xffffff, 0.6);\n   246â†’  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n   247â†’}\n   248â†’\n   249â†’export function drawCleanSnake(\n   250â†’  g: Phaser.GameObjects.Graphics,\n   251â†’  snake: { x: number; y: number }[],\n   252â†’  cellSize: number,\n   253â†’  frameCount: number\n   254â†’): void {\n   255â†’  const snakeLen = snake.length;\n   256â†’  if (snakeLen === 0) return;\n   257â†’\n   258â†’  for (let i = snakeLen - 1; i >= 0; i--) {\n   259â†’    const segment = snake[i];\n   260â†’    const centerX = segment.x * cellSize + cellSize / 2;\n   261â†’    const centerY = segment.y * cellSize + cellSize / 2;\n   262â†’    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n   263â†’\n   264â†’    const glowAlpha = 0.15 * (1 - t * 0.5);\n   265â†’    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n   266â†’    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n   267â†’    g.fillCircle(centerX, centerY, glowSize);\n   268â†’  }\n   269â†’\n   270â†’  for (let i = snakeLen - 1; i >= 0; i--) {\n   271â†’    const segment = snake[i];\n   272â†’    const centerX = segment.x * cellSize + cellSize / 2;\n   273â†’    const centerY = segment.y * cellSize + cellSize / 2;\n   274â†’    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n   275â†’    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n   276â†’\n   277â†’    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n   278â†’    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n   279â†’    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n   280â†’    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n   281â†’    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n   282â†’    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n   283â†’\n   284â†’    const r = Math.round(r1 + (r2 - r1) * t);\n   285â†’    const gVal = Math.round(g1 + (g2 - g1) * t);\n   286â†’    const b = Math.round(b1 + (b2 - b1) * t);\n   287â†’    const color = (r << 16) | (gVal << 8) | b;\n   288â†’\n   289â†’    g.fillStyle(color, 0.95);\n   290â†’    g.fillCircle(centerX, centerY, radius);\n   291â†’\n   292â†’    if (i === 0) {\n   293â†’      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n   294â†’      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n   295â†’      g.fillCircle(centerX, centerY, radius + 4);\n   296â†’\n   297â†’      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n   298â†’      g.fillCircle(centerX, centerY, radius);\n   299â†’\n   300â†’      g.fillStyle(0xffffff, 0.7);\n   301â†’      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n   302â†’    }\n   303â†’  }\n   304â†’}\n   305â†’\n   306â†’export function drawCleanVignette(\n   307â†’  g: Phaser.GameObjects.Graphics,\n   308â†’  width: number,\n   309â†’  height: number\n   310â†’): void {\n   311â†’  const layers = 4;\n   312â†’  for (let i = 0; i < layers; i++) {\n   313â†’    const inset = i * 25;\n   314â†’    const alpha = 0.08 * (1 - i / layers);\n   315â†’    g.lineStyle(50, 0x000000, alpha);\n   316â†’    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n   317â†’  }\n   318â†’}\n   319â†’\n   320â†’export function drawCleanHUD(\n   321â†’  g: Phaser.GameObjects.Graphics,\n   322â†’  score: number,\n   323â†’  snakeLength: number,\n   324â†’  width: number,\n   325â†’  frameCount: number,\n   326â†’  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n   327â†’): void {\n   328â†’  const padding = 15;\n   329â†’  const digitSize = 12;\n   330â†’  const digitSpacing = digitSize * 0.6;\n   331â†’\n   332â†’  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n   333â†’\n   334â†’  const scoreStr = String(score).padStart(4, '0');\n   335â†’  let xPos = padding;\n   336â†’\n   337â†’  for (let i = 0; i < scoreStr.length; i++) {\n   338â†’    const digit = scoreStr[i];\n   339â†’    g.fillStyle(CLEAN_COLORS.text, pulse);\n   340â†’    drawDigit(g, digit, xPos, padding, digitSize);\n   341â†’    xPos += digitSpacing;\n   342â†’  }\n   343â†’\n   344â†’  const lengthStr = String(snakeLength);\n   345â†’  xPos = width - padding - lengthStr.length * digitSpacing;\n   346â†’\n   347â†’  for (let i = 0; i < lengthStr.length; i++) {\n   348â†’    const digit = lengthStr[i];\n   349â†’    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n   350â†’    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n   351â†’    xPos += digitSpacing * 0.9;\n   352â†’  }\n   353â†’}\n   354â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"5839fd46-98dd-4935-854b-e6b32aff5b53","tool_use_result":{"type":"text","file":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","content":"export interface CleanRipple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport interface FloatingMote {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  pulsePhase: number;\n}\n\nexport interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n};\n\nconst MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\n\nexport function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    frameCount: 0,\n  };\n}\n\nexport type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n\nexport function initMotes(state: CleanEffectsState, width: number, height: number): void {\n  state.motes = [];\n  for (let i = 0; i < MAX_MOTES; i++) {\n    state.motes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: (Math.random() - 0.5) * 0.3,\n      vy: (Math.random() - 0.5) * 0.3,\n      size: 1 + Math.random() * 2,\n      alpha: 0.1 + Math.random() * 0.2,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n  for (const mote of state.motes) {\n    mote.x += mote.vx;\n    mote.y += mote.vy;\n    mote.pulsePhase += 0.02;\n\n    if (mote.x < 0) mote.x = width;\n    if (mote.x > width) mote.x = 0;\n    if (mote.y < 0) mote.y = height;\n    if (mote.y > height) mote.y = 0;\n  }\n}\n\nexport function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n  if (state.ripples.length >= MAX_RIPPLES) {\n    state.ripples.shift();\n  }\n\n  state.ripples.push({\n    x,\n    y,\n    radius: 5,\n    maxRadius: 60,\n    alpha: 0.6,\n    thickness: 2,\n  });\n}\n\nexport function updateRipples(state: CleanEffectsState): void {\n  for (let i = state.ripples.length - 1; i >= 0; i--) {\n    const ripple = state.ripples[i];\n    ripple.radius += 2;\n    ripple.alpha *= 0.94;\n    ripple.thickness *= 0.98;\n\n    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n      state.ripples.splice(i, 1);\n    }\n  }\n}\n\nexport function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}\n\nexport function drawCleanGrid(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  cellSize: number,\n  gridSize: number,\n  frameCount: number\n): void {\n  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n\n  for (let i = 0; i <= gridSize; i++) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n\n  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n  for (let i = 0; i <= gridSize; i += 5) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n}\n\nexport function drawMotes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const mote of state.motes) {\n    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n    const alpha = mote.alpha * pulse;\n\n    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n    g.fillCircle(mote.x, mote.y, mote.size * 2);\n    g.fillStyle(CLEAN_COLORS.mote, alpha);\n    g.fillCircle(mote.x, mote.y, mote.size);\n  }\n}\n\nexport function drawRipples(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const ripple of state.ripples) {\n    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n\n    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n  }\n}\n\nexport function drawGlowTrail(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const trail of state.glowTrail) {\n    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n    g.fillCircle(trail.x, trail.y, trail.size);\n  }\n}\n\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n  const foodSize = (cellSize / 2 - 2) * pulseScale;\n\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n  g.fillCircle(foodX, foodY, foodSize + 12);\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n  g.fillCircle(foodX, foodY, foodSize + 6);\n\n  g.fillStyle(CLEAN_COLORS.food, 0.9);\n  g.fillCircle(foodX, foodY, foodSize);\n  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n  g.fillCircle(foodX, foodY, foodSize * 0.5);\n\n  g.fillStyle(0xffffff, 0.6);\n  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n}\n\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  const snakeLen = snake.length;\n  if (snakeLen === 0) return;\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n\n    const glowAlpha = 0.15 * (1 - t * 0.5);\n    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n    g.fillCircle(centerX, centerY, glowSize);\n  }\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n\n    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n\n    const r = Math.round(r1 + (r2 - r1) * t);\n    const gVal = Math.round(g1 + (g2 - g1) * t);\n    const b = Math.round(b1 + (b2 - b1) * t);\n    const color = (r << 16) | (gVal << 8) | b;\n\n    g.fillStyle(color, 0.95);\n    g.fillCircle(centerX, centerY, radius);\n\n    if (i === 0) {\n      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n      g.fillCircle(centerX, centerY, radius + 4);\n\n      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n      g.fillCircle(centerX, centerY, radius);\n\n      g.fillStyle(0xffffff, 0.7);\n      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n    }\n  }\n}\n\nexport function drawCleanVignette(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number\n): void {\n  const layers = 4;\n  for (let i = 0; i < layers; i++) {\n    const inset = i * 25;\n    const alpha = 0.08 * (1 - i / layers);\n    g.lineStyle(50, 0x000000, alpha);\n    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {\n  const padding = 15;\n  const digitSize = 12;\n  const digitSpacing = digitSize * 0.6;\n\n  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n\n  const scoreStr = String(score).padStart(4, '0');\n  let xPos = padding;\n\n  for (let i = 0; i < scoreStr.length; i++) {\n    const digit = scoreStr[i];\n    g.fillStyle(CLEAN_COLORS.text, pulse);\n    drawDigit(g, digit, xPos, padding, digitSize);\n    xPos += digitSpacing;\n  }\n\n  const lengthStr = String(snakeLength);\n  xPos = width - padding - lengthStr.length * digitSpacing;\n\n  for (let i = 0; i < lengthStr.length; i++) {\n    const digit = lengthStr[i];\n    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n    xPos += digitSpacing * 0.9;\n  }\n}\n","numLines":354,"startLine":1,"totalLines":354}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01S9yDwRiCizeL37VLLLz6N8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MDGh3v7FUyrLNJDqhD3rXt","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","limit":300},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1833,"cache_read_input_tokens":20279,"cache_creation":{"ephemeral_5m_input_tokens":1833,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"55d0d369-77a0-44ab-b3e1-853070070f5d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MDGh3v7FUyrLNJDqhD3rXt","type":"tool_result","content":"     1â†’import Phaser from 'phaser';\n     2â†’import {\n     3â†’  createCleanEffectsState,\n     4â†’  initMotes,\n     5â†’  updateMotes,\n     6â†’  updateRipples,\n     7â†’  updateGlowTrail,\n     8â†’  spawnRipple,\n     9â†’  drawCleanBackground,\n    10â†’  drawCleanGrid,\n    11â†’  drawMotes,\n    12â†’  drawRipples,\n    13â†’  drawGlowTrail,\n    14â†’  drawCleanFood,\n    15â†’  drawCleanSnake,\n    16â†’  drawCleanVignette,\n    17â†’  drawCleanHUD,\n    18â†’  CLEAN_COLORS,\n    19â†’  CleanEffectsState,\n    20â†’} from './cleanEffects';\n    21â†’\n    22â†’interface Position {\n    23â†’  x: number;\n    24â†’  y: number;\n    25â†’}\n    26â†’\n    27â†’interface GameState {\n    28â†’  snake: Position[];\n    29â†’  food: Position;\n    30â†’  gameOver: boolean;\n    31â†’  gameStarted?: boolean;\n    32â†’  score?: number;\n    33â†’}\n    34â†’\n    35â†’interface Star {\n    36â†’  x: number;\n    37â†’  y: number;\n    38â†’  size: number;\n    39â†’  speed: number;\n    40â†’  brightness: number;\n    41â†’}\n    42â†’\n    43â†’interface PlasmaWave {\n    44â†’  phase: number;\n    45â†’  speed: number;\n    46â†’  amplitude: number;\n    47â†’  wavelength: number;\n    48â†’  hue: number;\n    49â†’}\n    50â†’\n    51â†’interface AuroraWave {\n    52â†’  y: number;\n    53â†’  phase: number;\n    54â†’  speed: number;\n    55â†’  hue: number;\n    56â†’  thickness: number;\n    57â†’  amplitude: number;\n    58â†’}\n    59â†’\n    60â†’interface NebulaCloud {\n    61â†’  x: number;\n    62â†’  y: number;\n    63â†’  radius: number;\n    64â†’  hue: number;\n    65â†’  alpha: number;\n    66â†’  driftX: number;\n    67â†’  driftY: number;\n    68â†’  pulsePhase: number;\n    69â†’  pulseSpeed: number;\n    70â†’}\n    71â†’\n    72â†’interface VortexRing {\n    73â†’  radius: number;\n    74â†’  baseRadius: number;\n    75â†’  rotationOffset: number;\n    76â†’  rotationSpeed: number;\n    77â†’  thickness: number;\n    78â†’  hue: number;\n    79â†’  pulsePhase: number;\n    80â†’}\n    81â†’\n    82â†’interface VortexParticle {\n    83â†’  angle: number;\n    84â†’  radius: number;\n    85â†’  baseRadius: number;\n    86â†’  speed: number;\n    87â†’  size: number;\n    88â†’  hue: number;\n    89â†’  alpha: number;\n    90â†’}\n    91â†’\n    92â†’interface SnakeAfterimage {\n    93â†’  segments: Position[];\n    94â†’  life: number;\n    95â†’  maxLife: number;\n    96â†’  hueOffset: number;\n    97â†’}\n    98â†’\n    99â†’interface FoodParticle {\n   100â†’  x: number;\n   101â†’  y: number;\n   102â†’  vx: number;\n   103â†’  vy: number;\n   104â†’  life: number;\n   105â†’  maxLife: number;\n   106â†’  size: number;\n   107â†’}\n   108â†’\n   109â†’interface SnakeTrailParticle {\n   110â†’  x: number;\n   111â†’  y: number;\n   112â†’  vx: number;\n   113â†’  vy: number;\n   114â†’  life: number;\n   115â†’  maxLife: number;\n   116â†’  size: number;\n   117â†’  hue: number;\n   118â†’}\n   119â†’\n   120â†’interface ShockWave {\n   121â†’  x: number;\n   122â†’  y: number;\n   123â†’  radius: number;\n   124â†’  maxRadius: number;\n   125â†’  life: number;\n   126â†’}\n   127â†’\n   128â†’interface LightningBolt {\n   129â†’  points: { x: number; y: number }[];\n   130â†’  life: number;\n   131â†’  maxLife: number;\n   132â†’  hue: number;\n   133â†’}\n   134â†’\n   135â†’const CELL_SIZE = 20;\n   136â†’const GRID_SIZE = 20;\n   137â†’const NUM_STARS = 30;\n   138â†’const MAX_FOOD_PARTICLES = 8;\n   139â†’const MAX_TRAIL_PARTICLES = 40;\n   140â†’const MAX_SHOCKWAVES = 3;\n   141â†’const MAX_LIGHTNING_BOLTS = 5;\n   142â†’const MAX_BURST_PARTICLES = 12;\n   143â†’const NUM_PLASMA_WAVES = 3;\n   144â†’const MAX_AFTERIMAGES = 4;\n   145â†’const NUM_AURORA_WAVES = 5;\n   146â†’const NUM_NEBULA_CLOUDS = 6;\n   147â†’const NUM_VORTEX_RINGS = 5;\n   148â†’const NUM_VORTEX_PARTICLES = 20;\n   149â†’const NUM_METEORS = 8;\n   150â†’const MAX_DEATH_DEBRIS = 24;\n   151â†’const NUM_SPIRITS_PER_EDGE = 2;\n   152â†’const MAX_FLAME_PARTICLES = 60;\n   153â†’const MAX_COMET_TRAIL_LENGTH = 30;\n   154â†’const MAX_ETHEREAL_PARTICLES = 50;\n   155â†’const NUM_BEES = 8;\n   156â†’const BEE_SPAWN_CHANCE = 0.02;\n   157â†’\n   158â†’// Comet trail segment - stores historical snake positions for smooth trail rendering\n   159â†’interface CometTrailSegment {\n   160â†’  x: number;\n   161â†’  y: number;\n   162â†’  alpha: number;\n   163â†’  size: number;\n   164â†’  hue: number;\n   165â†’}\n   166â†’\n   167â†’// Ethereal trail particle - luminous particles that drift away from trail\n   168â†’interface EtherealParticle {\n   169â†’  x: number;\n   170â†’  y: number;\n   171â†’  vx: number;\n   172â†’  vy: number;\n   173â†’  size: number;\n   174â†’  life: number;\n   175â†’  maxLife: number;\n   176â†’  hue: number;\n   177â†’  brightness: number;\n   178â†’  pulsePhase: number;\n   179â†’}\n   180â†’\n   181â†’// Thrown food animation - food launched onto screen with arc trajectory\n   182â†’interface ThrownFood {\n   183â†’  startX: number;\n   184â†’  startY: number;\n   185â†’  targetX: number;\n   186â†’  targetY: number;\n   187â†’  x: number;\n   188â†’  y: number;\n   189â†’  progress: number; // 0 to 1\n   190â†’  rotation: number;\n   191â†’  rotationSpeed: number;\n   192â†’  trail: { x: number; y: number; alpha: number; rotation: number }[];\n   193â†’  landed: boolean;\n   194â†’  landingParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number }[];\n   195â†’  impactRings: { radius: number; alpha: number }[];\n   196â†’}\n   197â†’\n   198â†’// Meteor shower types\n   199â†’interface Meteor {\n   200â†’  x: number;\n   201â†’  y: number;\n   202â†’  vx: number;\n   203â†’  vy: number;\n   204â†’  size: number;\n   205â†’  hue: number;\n   206â†’  alpha: number;\n   207â†’  trail: { x: number; y: number; alpha: number }[];\n   208â†’  life: number;\n   209â†’}\n   210â†’\n   211â†’// Death debris particle\n   212â†’interface DeathDebris {\n   213â†’  x: number;\n   214â†’  y: number;\n   215â†’  vx: number;\n   216â†’  vy: number;\n   217â†’  size: number;\n   218â†’  hue: number;\n   219â†’  rotation: number;\n   220â†’  rotationSpeed: number;\n   221â†’  life: number;\n   222â†’  type: 'shard' | 'spark' | 'ember';\n   223â†’}\n   224â†’\n   225â†’// Guardian spirit - ethereal protectors at edges\n   226â†’interface GuardianSpirit {\n   227â†’  x: number;\n   228â†’  y: number;\n   229â†’  baseX: number;\n   230â†’  baseY: number;\n   231â†’  size: number;\n   232â†’  phase: number;\n   233â†’  speed: number;\n   234â†’  haloPhase: number;\n   235â†’  orbPhase: number;\n   236â†’  edge: 'top' | 'bottom' | 'left' | 'right';\n   237â†’  targetAlpha: number;\n   238â†’  currentAlpha: number;\n   239â†’  hue: number;\n   240â†’  orbs: { angle: number; distance: number; size: number; speed: number }[];\n   241â†’}\n   242â†’\n   243â†’// Flame particle for burning effect\n   244â†’interface FlameParticle {\n   245â†’  x: number;\n   246â†’  y: number;\n   247â†’  vx: number;\n   248â†’  vy: number;\n   249â†’  size: number;\n   250â†’  life: number;\n   251â†’  maxLife: number;\n   252â†’  hue: number;\n   253â†’  brightness: number;\n   254â†’}\n   255â†’\n   256â†’// Mystical bee - glowing magical creatures that swarm around food\n   257â†’interface MysticalBee {\n   258â†’  x: number;\n   259â†’  y: number;\n   260â†’  vx: number;\n   261â†’  vy: number;\n   262â†’  targetX: number;\n   263â†’  targetY: number;\n   264â†’  wingPhase: number;\n   265â†’  wingSpeed: number;\n   266â†’  size: number;\n   267â†’  hue: number;\n   268â†’  glowIntensity: number;\n   269â†’  bobPhase: number;\n   270â†’  bobSpeed: number;\n   271â†’  trail: { x: number; y: number; alpha: number }[];\n   272â†’  state: 'flying' | 'hovering' | 'attracted';\n   273â†’  sparkleTimer: number;\n   274â†’}\n   275â†’\n   276â†’// Rival snake - spectral AI nemesis that competes for food\n   277â†’interface RivalSnake {\n   278â†’  segments: { x: number; y: number }[];\n   279â†’  direction: { dx: number; dy: number };\n   280â†’  targetX: number;\n   281â†’  targetY: number;\n   282â†’  moveTimer: number;\n   283â†’  moveInterval: number;\n   284â†’  pulsePhase: number;\n   285â†’  glowIntensity: number;\n   286â†’  hue: number;\n   287â†’  trail: { x: number; y: number; alpha: number }[];\n   288â†’  energyTrail: { x: number; y: number; alpha: number; size: number }[];\n   289â†’  state: 'hunting' | 'fleeing' | 'circling';\n   290â†’  aggression: number;\n   291â†’  nearMissTimer: number;\n   292â†’  electricArcs: { x1: number; y1: number; x2: number; y2: number; life: number }[];\n   293â†’}\n   294â†’\n   295â†’const RIVAL_SNAKE_LENGTH = 10;\n   296â†’const RIVAL_MOVE_INTERVAL = 8;\n   297â†’\n   298â†’// Armageddon Chaos effect types\n   299â†’interface GroundFissure {\n   300â†’  x1: number;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"3caee477-265c-4194-b6fb-b72c4fbd1a18","tool_use_result":{"type":"text","file":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","content":"import Phaser from 'phaser';\nimport {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface GameState {\n  snake: Position[];\n  food: Position;\n  gameOver: boolean;\n  gameStarted?: boolean;\n  score?: number;\n}\n\ninterface Star {\n  x: number;\n  y: number;\n  size: number;\n  speed: number;\n  brightness: number;\n}\n\ninterface PlasmaWave {\n  phase: number;\n  speed: number;\n  amplitude: number;\n  wavelength: number;\n  hue: number;\n}\n\ninterface AuroraWave {\n  y: number;\n  phase: number;\n  speed: number;\n  hue: number;\n  thickness: number;\n  amplitude: number;\n}\n\ninterface NebulaCloud {\n  x: number;\n  y: number;\n  radius: number;\n  hue: number;\n  alpha: number;\n  driftX: number;\n  driftY: number;\n  pulsePhase: number;\n  pulseSpeed: number;\n}\n\ninterface VortexRing {\n  radius: number;\n  baseRadius: number;\n  rotationOffset: number;\n  rotationSpeed: number;\n  thickness: number;\n  hue: number;\n  pulsePhase: number;\n}\n\ninterface VortexParticle {\n  angle: number;\n  radius: number;\n  baseRadius: number;\n  speed: number;\n  size: number;\n  hue: number;\n  alpha: number;\n}\n\ninterface SnakeAfterimage {\n  segments: Position[];\n  life: number;\n  maxLife: number;\n  hueOffset: number;\n}\n\ninterface FoodParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n}\n\ninterface SnakeTrailParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n  hue: number;\n}\n\ninterface ShockWave {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n}\n\ninterface LightningBolt {\n  points: { x: number; y: number }[];\n  life: number;\n  maxLife: number;\n  hue: number;\n}\n\nconst CELL_SIZE = 20;\nconst GRID_SIZE = 20;\nconst NUM_STARS = 30;\nconst MAX_FOOD_PARTICLES = 8;\nconst MAX_TRAIL_PARTICLES = 40;\nconst MAX_SHOCKWAVES = 3;\nconst MAX_LIGHTNING_BOLTS = 5;\nconst MAX_BURST_PARTICLES = 12;\nconst NUM_PLASMA_WAVES = 3;\nconst MAX_AFTERIMAGES = 4;\nconst NUM_AURORA_WAVES = 5;\nconst NUM_NEBULA_CLOUDS = 6;\nconst NUM_VORTEX_RINGS = 5;\nconst NUM_VORTEX_PARTICLES = 20;\nconst NUM_METEORS = 8;\nconst MAX_DEATH_DEBRIS = 24;\nconst NUM_SPIRITS_PER_EDGE = 2;\nconst MAX_FLAME_PARTICLES = 60;\nconst MAX_COMET_TRAIL_LENGTH = 30;\nconst MAX_ETHEREAL_PARTICLES = 50;\nconst NUM_BEES = 8;\nconst BEE_SPAWN_CHANCE = 0.02;\n\n// Comet trail segment - stores historical snake positions for smooth trail rendering\ninterface CometTrailSegment {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n  hue: number;\n}\n\n// Ethereal trail particle - luminous particles that drift away from trail\ninterface EtherealParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n  pulsePhase: number;\n}\n\n// Thrown food animation - food launched onto screen with arc trajectory\ninterface ThrownFood {\n  startX: number;\n  startY: number;\n  targetX: number;\n  targetY: number;\n  x: number;\n  y: number;\n  progress: number; // 0 to 1\n  rotation: number;\n  rotationSpeed: number;\n  trail: { x: number; y: number; alpha: number; rotation: number }[];\n  landed: boolean;\n  landingParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number }[];\n  impactRings: { radius: number; alpha: number }[];\n}\n\n// Meteor shower types\ninterface Meteor {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  alpha: number;\n  trail: { x: number; y: number; alpha: number }[];\n  life: number;\n}\n\n// Death debris particle\ninterface DeathDebris {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  rotation: number;\n  rotationSpeed: number;\n  life: number;\n  type: 'shard' | 'spark' | 'ember';\n}\n\n// Guardian spirit - ethereal protectors at edges\ninterface GuardianSpirit {\n  x: number;\n  y: number;\n  baseX: number;\n  baseY: number;\n  size: number;\n  phase: number;\n  speed: number;\n  haloPhase: number;\n  orbPhase: number;\n  edge: 'top' | 'bottom' | 'left' | 'right';\n  targetAlpha: number;\n  currentAlpha: number;\n  hue: number;\n  orbs: { angle: number; distance: number; size: number; speed: number }[];\n}\n\n// Flame particle for burning effect\ninterface FlameParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n}\n\n// Mystical bee - glowing magical creatures that swarm around food\ninterface MysticalBee {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  targetX: number;\n  targetY: number;\n  wingPhase: number;\n  wingSpeed: number;\n  size: number;\n  hue: number;\n  glowIntensity: number;\n  bobPhase: number;\n  bobSpeed: number;\n  trail: { x: number; y: number; alpha: number }[];\n  state: 'flying' | 'hovering' | 'attracted';\n  sparkleTimer: number;\n}\n\n// Rival snake - spectral AI nemesis that competes for food\ninterface RivalSnake {\n  segments: { x: number; y: number }[];\n  direction: { dx: number; dy: number };\n  targetX: number;\n  targetY: number;\n  moveTimer: number;\n  moveInterval: number;\n  pulsePhase: number;\n  glowIntensity: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n  energyTrail: { x: number; y: number; alpha: number; size: number }[];\n  state: 'hunting' | 'fleeing' | 'circling';\n  aggression: number;\n  nearMissTimer: number;\n  electricArcs: { x1: number; y1: number; x2: number; y2: number; life: number }[];\n}\n\nconst RIVAL_SNAKE_LENGTH = 10;\nconst RIVAL_MOVE_INTERVAL = 8;\n\n// Armageddon Chaos effect types\ninterface GroundFissure {\n  x1: number;","numLines":300,"startLine":1,"totalLines":4124}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012dsv8WKZdjSbRqrT97GwYW","type":"message","role":"assistant","content":[{"type":"text","text":"Let me continue reading the SnakeScene.ts to see the update loop and understand how effects are integrated."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":8776,"cache_read_input_tokens":22112,"cache_creation":{"ephemeral_5m_input_tokens":8776,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"ae83027c-79c7-4d29-bff8-38d1dcfe90e8"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012dsv8WKZdjSbRqrT97GwYW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DzXXUjvd5x4vHBxG1gmvgd","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":2350,"limit":200},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":8776,"cache_read_input_tokens":22112,"cache_creation":{"ephemeral_5m_input_tokens":8776,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"7746a92b-03ee-4281-948d-01dd586784f9"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DzXXUjvd5x4vHBxG1gmvgd","type":"tool_result","content":"  2350â†’\n  2351â†’      // Motion blur glow\n  2352â†’      g.fillStyle(COLORS.foodGlow, 0.3);\n  2353â†’      g.fillCircle(tf.x, tf.y, foodSize * 2);\n  2354â†’\n  2355â†’      // Outer glow\n  2356â†’      g.fillStyle(COLORS.noirWhite, 0.4);\n  2357â†’      g.fillCircle(tf.x, tf.y, foodSize * 1.5);\n  2358â†’\n  2359â†’      // Main food body\n  2360â†’      g.fillStyle(COLORS.food, 0.95);\n  2361â†’      g.fillCircle(tf.x, tf.y, foodSize);\n  2362â†’\n  2363â†’      // Spinning highlight\n  2364â†’      const highlightAngle = tf.rotation;\n  2365â†’      const highlightX = tf.x + Math.cos(highlightAngle) * foodSize * 0.3;\n  2366â†’      const highlightY = tf.y + Math.sin(highlightAngle) * foodSize * 0.3;\n  2367â†’      g.fillStyle(0xffffff, 0.9);\n  2368â†’      g.fillCircle(highlightX, highlightY, foodSize * 0.25);\n  2369â†’\n  2370â†’      // Secondary sparkle\n  2371â†’      const sparkleAngle = tf.rotation + Math.PI * 0.7;\n  2372â†’      const sparkleX = tf.x + Math.cos(sparkleAngle) * foodSize * 0.4;\n  2373â†’      const sparkleY = tf.y + Math.sin(sparkleAngle) * foodSize * 0.4;\n  2374â†’      g.fillStyle(0xffffff, 0.6);\n  2375â†’      g.fillCircle(sparkleX, sparkleY, foodSize * 0.15);\n  2376â†’    }\n  2377â†’  }\n  2378â†’\n  2379â†’  update(): void {\n  2380â†’    this.frameCount++;\n  2381â†’    this.cleanEffects.frameCount = this.frameCount;\n  2382â†’\n  2383â†’    const width = this.scale.width;\n  2384â†’    const height = this.scale.height;\n  2385â†’\n  2386â†’    updateMotes(this.cleanEffects, width, height);\n  2387â†’    updateRipples(this.cleanEffects);\n  2388â†’\n  2389â†’    if (this.currentState && this.currentState.snake.length > 0) {\n  2390â†’      const head = this.currentState.snake[0];\n  2391â†’      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n  2392â†’      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n  2393â†’\n  2394â†’      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n  2395â†’        updateGlowTrail(this.cleanEffects, headX, headY);\n  2396â†’      }\n  2397â†’      this.lastHeadPos = { x: head.x, y: head.y };\n  2398â†’\n  2399â†’      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n  2400â†’        const food = this.currentState.food;\n  2401â†’        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n  2402â†’        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n  2403â†’        spawnRipple(this.cleanEffects, foodX, foodY);\n  2404â†’      }\n  2405â†’      this.lastSnakeLength = this.currentState.snake.length;\n  2406â†’    }\n  2407â†’\n  2408â†’    const g = this.graphics;\n  2409â†’    g.clear();\n  2410â†’    g.setPosition(0, 0);\n  2411â†’\n  2412â†’    drawCleanBackground(g, width, height, this.frameCount);\n  2413â†’    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n  2414â†’    drawMotes(g, this.cleanEffects);\n  2415â†’\n  2416â†’    if (!this.currentState) return;\n  2417â†’\n  2418â†’    drawGlowTrail(g, this.cleanEffects);\n  2419â†’    drawRipples(g, this.cleanEffects);\n  2420â†’\n  2421â†’    const food = this.currentState.food;\n  2422â†’    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n  2423â†’    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n  2424â†’    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n  2425â†’\n  2426â†’    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n  2427â†’\n  2428â†’    drawCleanVignette(g, width, height);\n  2429â†’\n  2430â†’    const score = this.currentState.score || 0;\n  2431â†’    const snakeLength = this.currentState.snake.length;\n  2432â†’    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n  2433â†’\n  2434â†’    if (this.currentState.gameOver) {\n  2435â†’      this.drawGameOver(g, width, height);\n  2436â†’      this.drawScoreboard(g, width, height);\n  2437â†’    }\n  2438â†’\n  2439â†’    this.checkAndSaveHighScore();\n  2440â†’    this.needsRedraw = false;\n  2441â†’  }\n  2442â†’\n  2443â†’  private drawStars(g: Phaser.GameObjects.Graphics): void {\n  2444â†’    // In film noir mode, stars are subtle distant lights\n  2445â†’    for (const star of this.stars) {\n  2446â†’      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n  2447â†’      const alpha = star.brightness * twinkle * 0.25;\n  2448â†’      g.fillStyle(COLORS.star, alpha);\n  2449â†’      g.fillCircle(star.x, star.y, star.size * 0.7);\n  2450â†’    }\n  2451â†’  }\n  2452â†’\n  2453â†’  private updateSmokeParticles(): void {\n  2454â†’    const width = GRID_SIZE * CELL_SIZE;\n  2455â†’    const height = GRID_SIZE * CELL_SIZE;\n  2456â†’    for (const smoke of this.smokeParticles) {\n  2457â†’      smoke.x += smoke.vx;\n  2458â†’      smoke.y += smoke.vy;\n  2459â†’      smoke.life -= 0.002;\n  2460â†’      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n  2461â†’        smoke.x = Math.random() * width;\n  2462â†’        smoke.y = height + smoke.size;\n  2463â†’        smoke.life = 1;\n  2464â†’        smoke.size = 30 + Math.random() * 50;\n  2465â†’        smoke.alpha = 0.02 + Math.random() * 0.03;\n  2466â†’      }\n  2467â†’      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n  2468â†’      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n  2469â†’    }\n  2470â†’  }\n  2471â†’\n  2472â†’  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n  2473â†’    // Create dramatic spotlight effect centered on snake\n  2474â†’    const cx = this.spotlightX || width / 2;\n  2475â†’    const cy = this.spotlightY || height / 2;\n  2476â†’    const pulse = 0.9 + Math.sin(this.frameCount * 0.03) * 0.1;\n  2477â†’\n  2478â†’    // Outer darkness vignette\n  2479â†’    g.fillStyle(0x000000, 0.6);\n  2480â†’    g.fillRect(0, 0, width, height);\n  2481â†’\n  2482â†’    // Spotlight cone - multiple layers for smooth falloff\n  2483â†’    const layers = 4;\n  2484â†’    for (let i = layers; i > 0; i--) {\n  2485â†’      const layerRadius = (width * 0.4 + i * 30) * pulse;\n  2486â†’      const layerAlpha = 0.15 * (1 - i / (layers + 1));\n  2487â†’      g.fillStyle(COLORS.spotlight, layerAlpha);\n  2488â†’      g.fillCircle(cx, cy, layerRadius);\n  2489â†’    }\n  2490â†’\n  2491â†’    // Bright center\n  2492â†’    g.fillStyle(COLORS.noirWhite, 0.08 * pulse);\n  2493â†’    g.fillCircle(cx, cy, width * 0.25);\n  2494â†’  }\n  2495â†’\n  2496â†’  private drawVenetianBlinds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n  2497â†’    // Horizontal light streaks simulating light through venetian blinds\n  2498â†’    const blindSpacing = 25;\n  2499â†’    const blindWidth = 8;\n  2500â†’    const waveOffset = Math.sin(this.venetianPhase) * 10;\n  2501â†’\n  2502â†’    for (let y = waveOffset; y < height; y += blindSpacing) {\n  2503â†’      const brightness = 0.03 + Math.sin(y * 0.02 + this.venetianPhase * 2) * 0.015;\n  2504â†’      g.fillStyle(COLORS.noirWhite, brightness);\n  2505â†’      g.fillRect(0, y, width, blindWidth);\n  2506â†’    }\n  2507â†’\n  2508â†’    // Diagonal shadow bars from window frame\n  2509â†’    const diagonalAlpha = 0.04 + Math.sin(this.frameCount * 0.02) * 0.01;\n  2510â†’    g.fillStyle(0x000000, diagonalAlpha);\n  2511â†’    for (let i = -2; i < 6; i++) {\n  2512â†’      const x1 = i * 100 + Math.sin(this.venetianPhase) * 20;\n  2513â†’      g.beginPath();\n  2514â†’      g.moveTo(x1, 0);\n  2515â†’      g.lineTo(x1 + 40, 0);\n  2516â†’      g.lineTo(x1 + 40 + height * 0.3, height);\n  2517â†’      g.lineTo(x1 + height * 0.3, height);\n  2518â†’      g.closePath();\n  2519â†’      g.fillPath();\n  2520â†’    }\n  2521â†’  }\n  2522â†’\n  2523â†’  private drawSmoke(g: Phaser.GameObjects.Graphics): void {\n  2524â†’    for (const smoke of this.smokeParticles) {\n  2525â†’      const alpha = smoke.alpha * smoke.life;\n  2526â†’      g.fillStyle(COLORS.noirGray, alpha);\n  2527â†’      g.fillCircle(smoke.x, smoke.y, smoke.size);\n  2528â†’      g.fillStyle(COLORS.noirWhite, alpha * 0.3);\n  2529â†’      g.fillCircle(smoke.x, smoke.y, smoke.size * 0.5);\n  2530â†’    }\n  2531â†’  }\n  2532â†’\n  2533â†’  private spawnFlameParticle(x: number, y: number, intensity: number): void {\n  2534â†’    if (this.flameParticles.length >= MAX_FLAME_PARTICLES) {\n  2535â†’      this.flameParticles.shift();\n  2536â†’    }\n  2537â†’\n  2538â†’    const angle = Math.random() * Math.PI * 2;\n  2539â†’    const speed = 0.3 + Math.random() * 0.6;\n  2540â†’    const life = 0.5 + Math.random() * 0.5;\n  2541â†’\n  2542â†’    this.flameParticles.push({\n  2543â†’      x: x + (Math.random() - 0.5) * 6,\n  2544â†’      y: y + (Math.random() - 0.5) * 6,\n  2545â†’      vx: Math.cos(angle) * speed * 0.3,\n  2546â†’      vy: -0.5 - Math.random() * 1.5 * intensity,\n  2547â†’      size: 3 + Math.random() * 4 * intensity,\n  2548â†’      life,\n  2549â†’      maxLife: life,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"6773f87e-1fbf-40f2-b8dd-6953feb8ee89","tool_use_result":{"type":"text","file":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","content":"\n      // Motion blur glow\n      g.fillStyle(COLORS.foodGlow, 0.3);\n      g.fillCircle(tf.x, tf.y, foodSize * 2);\n\n      // Outer glow\n      g.fillStyle(COLORS.noirWhite, 0.4);\n      g.fillCircle(tf.x, tf.y, foodSize * 1.5);\n\n      // Main food body\n      g.fillStyle(COLORS.food, 0.95);\n      g.fillCircle(tf.x, tf.y, foodSize);\n\n      // Spinning highlight\n      const highlightAngle = tf.rotation;\n      const highlightX = tf.x + Math.cos(highlightAngle) * foodSize * 0.3;\n      const highlightY = tf.y + Math.sin(highlightAngle) * foodSize * 0.3;\n      g.fillStyle(0xffffff, 0.9);\n      g.fillCircle(highlightX, highlightY, foodSize * 0.25);\n\n      // Secondary sparkle\n      const sparkleAngle = tf.rotation + Math.PI * 0.7;\n      const sparkleX = tf.x + Math.cos(sparkleAngle) * foodSize * 0.4;\n      const sparkleY = tf.y + Math.sin(sparkleAngle) * foodSize * 0.4;\n      g.fillStyle(0xffffff, 0.6);\n      g.fillCircle(sparkleX, sparkleY, foodSize * 0.15);\n    }\n  }\n\n  update(): void {\n    this.frameCount++;\n    this.cleanEffects.frameCount = this.frameCount;\n\n    const width = this.scale.width;\n    const height = this.scale.height;\n\n    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n\n    if (this.currentState && this.currentState.snake.length > 0) {\n      const head = this.currentState.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n        updateGlowTrail(this.cleanEffects, headX, headY);\n      }\n      this.lastHeadPos = { x: head.x, y: head.y };\n\n      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n        const food = this.currentState.food;\n        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnRipple(this.cleanEffects, foodX, foodY);\n      }\n      this.lastSnakeLength = this.currentState.snake.length;\n    }\n\n    const g = this.graphics;\n    g.clear();\n    g.setPosition(0, 0);\n\n    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n\n    if (!this.currentState) return;\n\n    drawGlowTrail(g, this.cleanEffects);\n    drawRipples(g, this.cleanEffects);\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n\n    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawCleanVignette(g, width, height);\n\n    const score = this.currentState.score || 0;\n    const snakeLength = this.currentState.snake.length;\n    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n\n    if (this.currentState.gameOver) {\n      this.drawGameOver(g, width, height);\n      this.drawScoreboard(g, width, height);\n    }\n\n    this.checkAndSaveHighScore();\n    this.needsRedraw = false;\n  }\n\n  private drawStars(g: Phaser.GameObjects.Graphics): void {\n    // In film noir mode, stars are subtle distant lights\n    for (const star of this.stars) {\n      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n      const alpha = star.brightness * twinkle * 0.25;\n      g.fillStyle(COLORS.star, alpha);\n      g.fillCircle(star.x, star.y, star.size * 0.7);\n    }\n  }\n\n  private updateSmokeParticles(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (const smoke of this.smokeParticles) {\n      smoke.x += smoke.vx;\n      smoke.y += smoke.vy;\n      smoke.life -= 0.002;\n      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n        smoke.x = Math.random() * width;\n        smoke.y = height + smoke.size;\n        smoke.life = 1;\n        smoke.size = 30 + Math.random() * 50;\n        smoke.alpha = 0.02 + Math.random() * 0.03;\n      }\n      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n    }\n  }\n\n  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Create dramatic spotlight effect centered on snake\n    const cx = this.spotlightX || width / 2;\n    const cy = this.spotlightY || height / 2;\n    const pulse = 0.9 + Math.sin(this.frameCount * 0.03) * 0.1;\n\n    // Outer darkness vignette\n    g.fillStyle(0x000000, 0.6);\n    g.fillRect(0, 0, width, height);\n\n    // Spotlight cone - multiple layers for smooth falloff\n    const layers = 4;\n    for (let i = layers; i > 0; i--) {\n      const layerRadius = (width * 0.4 + i * 30) * pulse;\n      const layerAlpha = 0.15 * (1 - i / (layers + 1));\n      g.fillStyle(COLORS.spotlight, layerAlpha);\n      g.fillCircle(cx, cy, layerRadius);\n    }\n\n    // Bright center\n    g.fillStyle(COLORS.noirWhite, 0.08 * pulse);\n    g.fillCircle(cx, cy, width * 0.25);\n  }\n\n  private drawVenetianBlinds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Horizontal light streaks simulating light through venetian blinds\n    const blindSpacing = 25;\n    const blindWidth = 8;\n    const waveOffset = Math.sin(this.venetianPhase) * 10;\n\n    for (let y = waveOffset; y < height; y += blindSpacing) {\n      const brightness = 0.03 + Math.sin(y * 0.02 + this.venetianPhase * 2) * 0.015;\n      g.fillStyle(COLORS.noirWhite, brightness);\n      g.fillRect(0, y, width, blindWidth);\n    }\n\n    // Diagonal shadow bars from window frame\n    const diagonalAlpha = 0.04 + Math.sin(this.frameCount * 0.02) * 0.01;\n    g.fillStyle(0x000000, diagonalAlpha);\n    for (let i = -2; i < 6; i++) {\n      const x1 = i * 100 + Math.sin(this.venetianPhase) * 20;\n      g.beginPath();\n      g.moveTo(x1, 0);\n      g.lineTo(x1 + 40, 0);\n      g.lineTo(x1 + 40 + height * 0.3, height);\n      g.lineTo(x1 + height * 0.3, height);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawSmoke(g: Phaser.GameObjects.Graphics): void {\n    for (const smoke of this.smokeParticles) {\n      const alpha = smoke.alpha * smoke.life;\n      g.fillStyle(COLORS.noirGray, alpha);\n      g.fillCircle(smoke.x, smoke.y, smoke.size);\n      g.fillStyle(COLORS.noirWhite, alpha * 0.3);\n      g.fillCircle(smoke.x, smoke.y, smoke.size * 0.5);\n    }\n  }\n\n  private spawnFlameParticle(x: number, y: number, intensity: number): void {\n    if (this.flameParticles.length >= MAX_FLAME_PARTICLES) {\n      this.flameParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.6;\n    const life = 0.5 + Math.random() * 0.5;\n\n    this.flameParticles.push({\n      x: x + (Math.random() - 0.5) * 6,\n      y: y + (Math.random() - 0.5) * 6,\n      vx: Math.cos(angle) * speed * 0.3,\n      vy: -0.5 - Math.random() * 1.5 * intensity,\n      size: 3 + Math.random() * 4 * intensity,\n      life,\n      maxLife: life,","numLines":200,"startLine":2350,"totalLines":4124}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Bx9oBirLtTjz1R2hCN7w7E","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a good understanding. I'll create a tasteful \"blood and tears\" effect. The creative interpretation:\n- **Tears**: Red droplets that fall from the snake when it dies (game over) - emotional death effect\n- **Blood**: Red splatter effect that appears when the snake collides with itself or walls\n\nI'll add these effects to the cleanEffects.ts file to keep the code organized, then integrate them into SnakeScene.ts."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3744,"cache_read_input_tokens":30888,"cache_creation":{"ephemeral_5m_input_tokens":3744,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"60349558-7ff2-4fe6-8add-432c3c3277ee"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Bx9oBirLtTjz1R2hCN7w7E","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019xPdCsuWwTHs5afQ4CtmoB","name":"TodoWrite","input":{"todos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"in_progress","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"pending","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"pending","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"pending","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3744,"cache_read_input_tokens":30888,"cache_creation":{"ephemeral_5m_input_tokens":3744,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"7940a444-3252-42a5-8a17-0e2f9894e598"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019xPdCsuWwTHs5afQ4CtmoB","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"4cbf15ce-7ab8-49b8-8640-1bff13952cba","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"in_progress","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"pending","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"pending","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"pending","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WgYLKJyK9MjZv8pjgRj12F","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ACrZBn5kznpbTquK7Vqa9A","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","old_string":"export interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}","new_string":"export interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport interface TearDrop {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n}\n\nexport interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":453,"cache_read_input_tokens":34632,"cache_creation":{"ephemeral_5m_input_tokens":453,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"753f454b-e52b-4feb-ad45-1b01125d9c07"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ACrZBn5kznpbTquK7Vqa9A","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"0763e08e-3d68-434f-b4d2-1b93bbbc8c22","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","oldString":"export interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}","newString":"export interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport interface TearDrop {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n}\n\nexport interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}","originalFile":"export interface CleanRipple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport interface FloatingMote {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  pulsePhase: number;\n}\n\nexport interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n};\n\nconst MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\n\nexport function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    frameCount: 0,\n  };\n}\n\nexport type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n\nexport function initMotes(state: CleanEffectsState, width: number, height: number): void {\n  state.motes = [];\n  for (let i = 0; i < MAX_MOTES; i++) {\n    state.motes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: (Math.random() - 0.5) * 0.3,\n      vy: (Math.random() - 0.5) * 0.3,\n      size: 1 + Math.random() * 2,\n      alpha: 0.1 + Math.random() * 0.2,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n  for (const mote of state.motes) {\n    mote.x += mote.vx;\n    mote.y += mote.vy;\n    mote.pulsePhase += 0.02;\n\n    if (mote.x < 0) mote.x = width;\n    if (mote.x > width) mote.x = 0;\n    if (mote.y < 0) mote.y = height;\n    if (mote.y > height) mote.y = 0;\n  }\n}\n\nexport function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n  if (state.ripples.length >= MAX_RIPPLES) {\n    state.ripples.shift();\n  }\n\n  state.ripples.push({\n    x,\n    y,\n    radius: 5,\n    maxRadius: 60,\n    alpha: 0.6,\n    thickness: 2,\n  });\n}\n\nexport function updateRipples(state: CleanEffectsState): void {\n  for (let i = state.ripples.length - 1; i >= 0; i--) {\n    const ripple = state.ripples[i];\n    ripple.radius += 2;\n    ripple.alpha *= 0.94;\n    ripple.thickness *= 0.98;\n\n    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n      state.ripples.splice(i, 1);\n    }\n  }\n}\n\nexport function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}\n\nexport function drawCleanGrid(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  cellSize: number,\n  gridSize: number,\n  frameCount: number\n): void {\n  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n\n  for (let i = 0; i <= gridSize; i++) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n\n  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n  for (let i = 0; i <= gridSize; i += 5) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n}\n\nexport function drawMotes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const mote of state.motes) {\n    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n    const alpha = mote.alpha * pulse;\n\n    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n    g.fillCircle(mote.x, mote.y, mote.size * 2);\n    g.fillStyle(CLEAN_COLORS.mote, alpha);\n    g.fillCircle(mote.x, mote.y, mote.size);\n  }\n}\n\nexport function drawRipples(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const ripple of state.ripples) {\n    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n\n    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n  }\n}\n\nexport function drawGlowTrail(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const trail of state.glowTrail) {\n    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n    g.fillCircle(trail.x, trail.y, trail.size);\n  }\n}\n\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n  const foodSize = (cellSize / 2 - 2) * pulseScale;\n\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n  g.fillCircle(foodX, foodY, foodSize + 12);\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n  g.fillCircle(foodX, foodY, foodSize + 6);\n\n  g.fillStyle(CLEAN_COLORS.food, 0.9);\n  g.fillCircle(foodX, foodY, foodSize);\n  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n  g.fillCircle(foodX, foodY, foodSize * 0.5);\n\n  g.fillStyle(0xffffff, 0.6);\n  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n}\n\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  const snakeLen = snake.length;\n  if (snakeLen === 0) return;\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n\n    const glowAlpha = 0.15 * (1 - t * 0.5);\n    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n    g.fillCircle(centerX, centerY, glowSize);\n  }\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n\n    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n\n    const r = Math.round(r1 + (r2 - r1) * t);\n    const gVal = Math.round(g1 + (g2 - g1) * t);\n    const b = Math.round(b1 + (b2 - b1) * t);\n    const color = (r << 16) | (gVal << 8) | b;\n\n    g.fillStyle(color, 0.95);\n    g.fillCircle(centerX, centerY, radius);\n\n    if (i === 0) {\n      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n      g.fillCircle(centerX, centerY, radius + 4);\n\n      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n      g.fillCircle(centerX, centerY, radius);\n\n      g.fillStyle(0xffffff, 0.7);\n      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n    }\n  }\n}\n\nexport function drawCleanVignette(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number\n): void {\n  const layers = 4;\n  for (let i = 0; i < layers; i++) {\n    const inset = i * 25;\n    const alpha = 0.08 * (1 - i / layers);\n    g.lineStyle(50, 0x000000, alpha);\n    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {\n  const padding = 15;\n  const digitSize = 12;\n  const digitSpacing = digitSize * 0.6;\n\n  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n\n  const scoreStr = String(score).padStart(4, '0');\n  let xPos = padding;\n\n  for (let i = 0; i < scoreStr.length; i++) {\n    const digit = scoreStr[i];\n    g.fillStyle(CLEAN_COLORS.text, pulse);\n    drawDigit(g, digit, xPos, padding, digitSize);\n    xPos += digitSpacing;\n  }\n\n  const lengthStr = String(snakeLength);\n  xPos = width - padding - lengthStr.length * digitSpacing;\n\n  for (let i = 0; i < lengthStr.length; i++) {\n    const digit = lengthStr[i];\n    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n    xPos += digitSpacing * 0.9;\n  }\n}\n","structuredPatch":[{"oldStart":24,"oldLines":6,"newStart":24,"newLines":27,"lines":["   size: number;"," }"," ","+export interface TearDrop {","+  x: number;","+  y: number;","+  vy: number;","+  size: number;","+  alpha: number;","+  wobblePhase: number;","+}","+","+export interface BloodSplatter {","+  x: number;","+  y: number;","+  vx: number;","+  vy: number;","+  size: number;","+  alpha: number;","+  life: number;","+  splashed: boolean;","+  splashRadius: number;","+}","+"," export const CLEAN_COLORS = {","   bgDark: 0x0a1628,","   bgMid: 0x0f1d32,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LFZMBrpuezmB9o42Ad4CPQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017qSpLWCnKuSmo8YuGeMdZ1","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","old_string":"export const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n};","new_string":"export const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n};"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":403,"cache_read_input_tokens":35085,"cache_creation":{"ephemeral_5m_input_tokens":403,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"e5771053-daee-467d-aa5c-be8bc879f42b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017qSpLWCnKuSmo8YuGeMdZ1","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"1ba0f095-2fdd-4587-80bc-f37e511906b2","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","oldString":"export const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n};","newString":"export const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n};","originalFile":"export interface CleanRipple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport interface FloatingMote {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  pulsePhase: number;\n}\n\nexport interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport interface TearDrop {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n}\n\nexport interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}\n\nexport const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n};\n\nconst MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\n\nexport function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    frameCount: 0,\n  };\n}\n\nexport type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n\nexport function initMotes(state: CleanEffectsState, width: number, height: number): void {\n  state.motes = [];\n  for (let i = 0; i < MAX_MOTES; i++) {\n    state.motes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: (Math.random() - 0.5) * 0.3,\n      vy: (Math.random() - 0.5) * 0.3,\n      size: 1 + Math.random() * 2,\n      alpha: 0.1 + Math.random() * 0.2,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n  for (const mote of state.motes) {\n    mote.x += mote.vx;\n    mote.y += mote.vy;\n    mote.pulsePhase += 0.02;\n\n    if (mote.x < 0) mote.x = width;\n    if (mote.x > width) mote.x = 0;\n    if (mote.y < 0) mote.y = height;\n    if (mote.y > height) mote.y = 0;\n  }\n}\n\nexport function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n  if (state.ripples.length >= MAX_RIPPLES) {\n    state.ripples.shift();\n  }\n\n  state.ripples.push({\n    x,\n    y,\n    radius: 5,\n    maxRadius: 60,\n    alpha: 0.6,\n    thickness: 2,\n  });\n}\n\nexport function updateRipples(state: CleanEffectsState): void {\n  for (let i = state.ripples.length - 1; i >= 0; i--) {\n    const ripple = state.ripples[i];\n    ripple.radius += 2;\n    ripple.alpha *= 0.94;\n    ripple.thickness *= 0.98;\n\n    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n      state.ripples.splice(i, 1);\n    }\n  }\n}\n\nexport function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}\n\nexport function drawCleanGrid(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  cellSize: number,\n  gridSize: number,\n  frameCount: number\n): void {\n  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n\n  for (let i = 0; i <= gridSize; i++) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n\n  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n  for (let i = 0; i <= gridSize; i += 5) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n}\n\nexport function drawMotes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const mote of state.motes) {\n    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n    const alpha = mote.alpha * pulse;\n\n    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n    g.fillCircle(mote.x, mote.y, mote.size * 2);\n    g.fillStyle(CLEAN_COLORS.mote, alpha);\n    g.fillCircle(mote.x, mote.y, mote.size);\n  }\n}\n\nexport function drawRipples(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const ripple of state.ripples) {\n    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n\n    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n  }\n}\n\nexport function drawGlowTrail(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const trail of state.glowTrail) {\n    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n    g.fillCircle(trail.x, trail.y, trail.size);\n  }\n}\n\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n  const foodSize = (cellSize / 2 - 2) * pulseScale;\n\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n  g.fillCircle(foodX, foodY, foodSize + 12);\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n  g.fillCircle(foodX, foodY, foodSize + 6);\n\n  g.fillStyle(CLEAN_COLORS.food, 0.9);\n  g.fillCircle(foodX, foodY, foodSize);\n  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n  g.fillCircle(foodX, foodY, foodSize * 0.5);\n\n  g.fillStyle(0xffffff, 0.6);\n  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n}\n\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  const snakeLen = snake.length;\n  if (snakeLen === 0) return;\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n\n    const glowAlpha = 0.15 * (1 - t * 0.5);\n    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n    g.fillCircle(centerX, centerY, glowSize);\n  }\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n\n    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n\n    const r = Math.round(r1 + (r2 - r1) * t);\n    const gVal = Math.round(g1 + (g2 - g1) * t);\n    const b = Math.round(b1 + (b2 - b1) * t);\n    const color = (r << 16) | (gVal << 8) | b;\n\n    g.fillStyle(color, 0.95);\n    g.fillCircle(centerX, centerY, radius);\n\n    if (i === 0) {\n      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n      g.fillCircle(centerX, centerY, radius + 4);\n\n      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n      g.fillCircle(centerX, centerY, radius);\n\n      g.fillStyle(0xffffff, 0.7);\n      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n    }\n  }\n}\n\nexport function drawCleanVignette(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number\n): void {\n  const layers = 4;\n  for (let i = 0; i < layers; i++) {\n    const inset = i * 25;\n    const alpha = 0.08 * (1 - i / layers);\n    g.lineStyle(50, 0x000000, alpha);\n    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {\n  const padding = 15;\n  const digitSize = 12;\n  const digitSpacing = digitSize * 0.6;\n\n  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n\n  const scoreStr = String(score).padStart(4, '0');\n  let xPos = padding;\n\n  for (let i = 0; i < scoreStr.length; i++) {\n    const digit = scoreStr[i];\n    g.fillStyle(CLEAN_COLORS.text, pulse);\n    drawDigit(g, digit, xPos, padding, digitSize);\n    xPos += digitSpacing;\n  }\n\n  const lengthStr = String(snakeLength);\n  xPos = width - padding - lengthStr.length * digitSpacing;\n\n  for (let i = 0; i < lengthStr.length; i++) {\n    const digit = lengthStr[i];\n    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n    xPos += digitSpacing * 0.9;\n  }\n}\n","structuredPatch":[{"oldStart":67,"oldLines":6,"newStart":67,"newLines":11,"lines":[" ","   text: 0xe2e8f0,","   textDim: 0x94a3b8,","+","+  blood: 0xdc2626,","+  bloodDark: 0x991b1b,","+  tear: 0x60a5fa,","+  tearHighlight: 0x93c5fd,"," };"," "," const MAX_RIPPLES = 5;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EePhnUuEFzeGxxxG13hgcN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RZB6gZkBfY2RvD4k3rZGCv","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","old_string":"const MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;","new_string":"const MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":726,"cache_read_input_tokens":35488,"cache_creation":{"ephemeral_5m_input_tokens":726,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"24b57259-3741-4898-a464-d241598ae2a8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RZB6gZkBfY2RvD4k3rZGCv","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"f5bdc994-2943-4720-9a83-ca296b32fdfc","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","oldString":"const MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;","newString":"const MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;","originalFile":"export interface CleanRipple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport interface FloatingMote {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  pulsePhase: number;\n}\n\nexport interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport interface TearDrop {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n}\n\nexport interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}\n\nexport const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n};\n\nconst MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\n\nexport function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    frameCount: 0,\n  };\n}\n\nexport type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n\nexport function initMotes(state: CleanEffectsState, width: number, height: number): void {\n  state.motes = [];\n  for (let i = 0; i < MAX_MOTES; i++) {\n    state.motes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: (Math.random() - 0.5) * 0.3,\n      vy: (Math.random() - 0.5) * 0.3,\n      size: 1 + Math.random() * 2,\n      alpha: 0.1 + Math.random() * 0.2,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n  for (const mote of state.motes) {\n    mote.x += mote.vx;\n    mote.y += mote.vy;\n    mote.pulsePhase += 0.02;\n\n    if (mote.x < 0) mote.x = width;\n    if (mote.x > width) mote.x = 0;\n    if (mote.y < 0) mote.y = height;\n    if (mote.y > height) mote.y = 0;\n  }\n}\n\nexport function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n  if (state.ripples.length >= MAX_RIPPLES) {\n    state.ripples.shift();\n  }\n\n  state.ripples.push({\n    x,\n    y,\n    radius: 5,\n    maxRadius: 60,\n    alpha: 0.6,\n    thickness: 2,\n  });\n}\n\nexport function updateRipples(state: CleanEffectsState): void {\n  for (let i = state.ripples.length - 1; i >= 0; i--) {\n    const ripple = state.ripples[i];\n    ripple.radius += 2;\n    ripple.alpha *= 0.94;\n    ripple.thickness *= 0.98;\n\n    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n      state.ripples.splice(i, 1);\n    }\n  }\n}\n\nexport function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}\n\nexport function drawCleanGrid(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  cellSize: number,\n  gridSize: number,\n  frameCount: number\n): void {\n  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n\n  for (let i = 0; i <= gridSize; i++) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n\n  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n  for (let i = 0; i <= gridSize; i += 5) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n}\n\nexport function drawMotes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const mote of state.motes) {\n    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n    const alpha = mote.alpha * pulse;\n\n    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n    g.fillCircle(mote.x, mote.y, mote.size * 2);\n    g.fillStyle(CLEAN_COLORS.mote, alpha);\n    g.fillCircle(mote.x, mote.y, mote.size);\n  }\n}\n\nexport function drawRipples(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const ripple of state.ripples) {\n    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n\n    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n  }\n}\n\nexport function drawGlowTrail(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const trail of state.glowTrail) {\n    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n    g.fillCircle(trail.x, trail.y, trail.size);\n  }\n}\n\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n  const foodSize = (cellSize / 2 - 2) * pulseScale;\n\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n  g.fillCircle(foodX, foodY, foodSize + 12);\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n  g.fillCircle(foodX, foodY, foodSize + 6);\n\n  g.fillStyle(CLEAN_COLORS.food, 0.9);\n  g.fillCircle(foodX, foodY, foodSize);\n  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n  g.fillCircle(foodX, foodY, foodSize * 0.5);\n\n  g.fillStyle(0xffffff, 0.6);\n  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n}\n\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  const snakeLen = snake.length;\n  if (snakeLen === 0) return;\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n\n    const glowAlpha = 0.15 * (1 - t * 0.5);\n    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n    g.fillCircle(centerX, centerY, glowSize);\n  }\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n\n    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n\n    const r = Math.round(r1 + (r2 - r1) * t);\n    const gVal = Math.round(g1 + (g2 - g1) * t);\n    const b = Math.round(b1 + (b2 - b1) * t);\n    const color = (r << 16) | (gVal << 8) | b;\n\n    g.fillStyle(color, 0.95);\n    g.fillCircle(centerX, centerY, radius);\n\n    if (i === 0) {\n      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n      g.fillCircle(centerX, centerY, radius + 4);\n\n      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n      g.fillCircle(centerX, centerY, radius);\n\n      g.fillStyle(0xffffff, 0.7);\n      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n    }\n  }\n}\n\nexport function drawCleanVignette(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number\n): void {\n  const layers = 4;\n  for (let i = 0; i < layers; i++) {\n    const inset = i * 25;\n    const alpha = 0.08 * (1 - i / layers);\n    g.lineStyle(50, 0x000000, alpha);\n    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {\n  const padding = 15;\n  const digitSize = 12;\n  const digitSpacing = digitSize * 0.6;\n\n  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n\n  const scoreStr = String(score).padStart(4, '0');\n  let xPos = padding;\n\n  for (let i = 0; i < scoreStr.length; i++) {\n    const digit = scoreStr[i];\n    g.fillStyle(CLEAN_COLORS.text, pulse);\n    drawDigit(g, digit, xPos, padding, digitSize);\n    xPos += digitSpacing;\n  }\n\n  const lengthStr = String(snakeLength);\n  xPos = width - padding - lengthStr.length * digitSpacing;\n\n  for (let i = 0; i < lengthStr.length; i++) {\n    const digit = lengthStr[i];\n    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n    xPos += digitSpacing * 0.9;\n  }\n}\n","structuredPatch":[{"oldStart":77,"oldLines":6,"newStart":77,"newLines":8,"lines":[" const MAX_RIPPLES = 5;"," const MAX_MOTES = 20;"," const MAX_TRAIL_LENGTH = 15;","+const MAX_TEARS = 12;","+const MAX_BLOOD = 20;"," "," export function createCleanEffectsState() {","   return {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WuntN9tr4HYydFbzrT1g1y","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017JgmwywfiNUQ1rQPKCNaxc","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","old_string":"export function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    frameCount: 0,\n  };\n}","new_string":"export function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    frameCount: 0,\n  };\n}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":293,"cache_read_input_tokens":36214,"cache_creation":{"ephemeral_5m_input_tokens":293,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"4859e2b7-4248-447c-bb7b-5c569a692e89"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017JgmwywfiNUQ1rQPKCNaxc","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"23e064cb-fa5c-45d0-97cb-1c013704e374","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","oldString":"export function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    frameCount: 0,\n  };\n}","newString":"export function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    frameCount: 0,\n  };\n}","originalFile":"export interface CleanRipple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport interface FloatingMote {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  pulsePhase: number;\n}\n\nexport interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport interface TearDrop {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n}\n\nexport interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}\n\nexport const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n};\n\nconst MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;\n\nexport function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    frameCount: 0,\n  };\n}\n\nexport type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n\nexport function initMotes(state: CleanEffectsState, width: number, height: number): void {\n  state.motes = [];\n  for (let i = 0; i < MAX_MOTES; i++) {\n    state.motes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: (Math.random() - 0.5) * 0.3,\n      vy: (Math.random() - 0.5) * 0.3,\n      size: 1 + Math.random() * 2,\n      alpha: 0.1 + Math.random() * 0.2,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n  for (const mote of state.motes) {\n    mote.x += mote.vx;\n    mote.y += mote.vy;\n    mote.pulsePhase += 0.02;\n\n    if (mote.x < 0) mote.x = width;\n    if (mote.x > width) mote.x = 0;\n    if (mote.y < 0) mote.y = height;\n    if (mote.y > height) mote.y = 0;\n  }\n}\n\nexport function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n  if (state.ripples.length >= MAX_RIPPLES) {\n    state.ripples.shift();\n  }\n\n  state.ripples.push({\n    x,\n    y,\n    radius: 5,\n    maxRadius: 60,\n    alpha: 0.6,\n    thickness: 2,\n  });\n}\n\nexport function updateRipples(state: CleanEffectsState): void {\n  for (let i = state.ripples.length - 1; i >= 0; i--) {\n    const ripple = state.ripples[i];\n    ripple.radius += 2;\n    ripple.alpha *= 0.94;\n    ripple.thickness *= 0.98;\n\n    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n      state.ripples.splice(i, 1);\n    }\n  }\n}\n\nexport function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}\n\nexport function drawCleanGrid(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  cellSize: number,\n  gridSize: number,\n  frameCount: number\n): void {\n  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n\n  for (let i = 0; i <= gridSize; i++) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n\n  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n  for (let i = 0; i <= gridSize; i += 5) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n}\n\nexport function drawMotes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const mote of state.motes) {\n    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n    const alpha = mote.alpha * pulse;\n\n    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n    g.fillCircle(mote.x, mote.y, mote.size * 2);\n    g.fillStyle(CLEAN_COLORS.mote, alpha);\n    g.fillCircle(mote.x, mote.y, mote.size);\n  }\n}\n\nexport function drawRipples(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const ripple of state.ripples) {\n    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n\n    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n  }\n}\n\nexport function drawGlowTrail(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const trail of state.glowTrail) {\n    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n    g.fillCircle(trail.x, trail.y, trail.size);\n  }\n}\n\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n  const foodSize = (cellSize / 2 - 2) * pulseScale;\n\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n  g.fillCircle(foodX, foodY, foodSize + 12);\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n  g.fillCircle(foodX, foodY, foodSize + 6);\n\n  g.fillStyle(CLEAN_COLORS.food, 0.9);\n  g.fillCircle(foodX, foodY, foodSize);\n  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n  g.fillCircle(foodX, foodY, foodSize * 0.5);\n\n  g.fillStyle(0xffffff, 0.6);\n  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n}\n\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  const snakeLen = snake.length;\n  if (snakeLen === 0) return;\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n\n    const glowAlpha = 0.15 * (1 - t * 0.5);\n    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n    g.fillCircle(centerX, centerY, glowSize);\n  }\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n\n    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n\n    const r = Math.round(r1 + (r2 - r1) * t);\n    const gVal = Math.round(g1 + (g2 - g1) * t);\n    const b = Math.round(b1 + (b2 - b1) * t);\n    const color = (r << 16) | (gVal << 8) | b;\n\n    g.fillStyle(color, 0.95);\n    g.fillCircle(centerX, centerY, radius);\n\n    if (i === 0) {\n      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n      g.fillCircle(centerX, centerY, radius + 4);\n\n      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n      g.fillCircle(centerX, centerY, radius);\n\n      g.fillStyle(0xffffff, 0.7);\n      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n    }\n  }\n}\n\nexport function drawCleanVignette(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number\n): void {\n  const layers = 4;\n  for (let i = 0; i < layers; i++) {\n    const inset = i * 25;\n    const alpha = 0.08 * (1 - i / layers);\n    g.lineStyle(50, 0x000000, alpha);\n    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {\n  const padding = 15;\n  const digitSize = 12;\n  const digitSpacing = digitSize * 0.6;\n\n  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n\n  const scoreStr = String(score).padStart(4, '0');\n  let xPos = padding;\n\n  for (let i = 0; i < scoreStr.length; i++) {\n    const digit = scoreStr[i];\n    g.fillStyle(CLEAN_COLORS.text, pulse);\n    drawDigit(g, digit, xPos, padding, digitSize);\n    xPos += digitSpacing;\n  }\n\n  const lengthStr = String(snakeLength);\n  xPos = width - padding - lengthStr.length * digitSpacing;\n\n  for (let i = 0; i < lengthStr.length; i++) {\n    const digit = lengthStr[i];\n    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n    xPos += digitSpacing * 0.9;\n  }\n}\n","structuredPatch":[{"oldStart":85,"oldLines":6,"newStart":85,"newLines":8,"lines":["     ripples: [] as CleanRipple[],","     motes: [] as FloatingMote[],","     glowTrail: [] as SnakeGlowTrail[],","+    tears: [] as TearDrop[],","+    blood: [] as BloodSplatter[],","     frameCount: 0,","   };"," }"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KrRe46v7b5qgEZk5A8EmrJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JDUGEiovQrhHjBWgHiKX3z","name":"TodoWrite","input":{"todos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"in_progress","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"pending","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"pending","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":382,"cache_read_input_tokens":36507,"cache_creation":{"ephemeral_5m_input_tokens":382,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"94471b31-724e-46fd-a86d-172501c7eca3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JDUGEiovQrhHjBWgHiKX3z","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"5356a59d-0c0c-48df-a465-2ff6af091155","tool_use_result":{"oldTodos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"in_progress","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"pending","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"pending","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"pending","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}],"newTodos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"in_progress","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"pending","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"pending","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TcLmAceQCBBVVmAXUzxqnf","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the spawn and update functions for tears and blood effects."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":354,"cache_read_input_tokens":36889,"cache_creation":{"ephemeral_5m_input_tokens":354,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"15b507ae-c417-4c0b-bde4-a92326b1644d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TcLmAceQCBBVVmAXUzxqnf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KjNdd6saiGUC5P7Vnk7fh2","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","old_string":"export function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}","new_string":"export function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function spawnTears(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.tears.length >= MAX_TEARS) {\n      state.tears.shift();\n    }\n    state.tears.push({\n      x: x + (Math.random() - 0.5) * 20,\n      y: y + (Math.random() - 0.5) * 10,\n      vy: 0.5 + Math.random() * 1.5,\n      size: 3 + Math.random() * 3,\n      alpha: 0.7 + Math.random() * 0.3,\n      wobblePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateTears(state: CleanEffectsState, height: number): void {\n  for (let i = state.tears.length - 1; i >= 0; i--) {\n    const tear = state.tears[i];\n    tear.vy += 0.08;\n    tear.y += tear.vy;\n    tear.wobblePhase += 0.1;\n    tear.x += Math.sin(tear.wobblePhase) * 0.3;\n    tear.alpha *= 0.99;\n\n    if (tear.y > height + 10 || tear.alpha < 0.05) {\n      state.tears.splice(i, 1);\n    }\n  }\n}\n\nexport function spawnBlood(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.blood.length >= MAX_BLOOD) {\n      state.blood.shift();\n    }\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 1 + Math.random() * 3;\n    state.blood.push({\n      x,\n      y,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 1,\n      size: 2 + Math.random() * 4,\n      alpha: 0.8 + Math.random() * 0.2,\n      life: 1.0,\n      splashed: false,\n      splashRadius: 0,\n    });\n  }\n}\n\nexport function updateBlood(state: CleanEffectsState, height: number): void {\n  for (let i = state.blood.length - 1; i >= 0; i--) {\n    const drop = state.blood[i];\n\n    if (!drop.splashed) {\n      drop.vy += 0.15;\n      drop.x += drop.vx;\n      drop.y += drop.vy;\n      drop.vx *= 0.98;\n\n      if (drop.y >= height - 5) {\n        drop.splashed = true;\n        drop.y = height - 5;\n        drop.splashRadius = drop.size * 1.5;\n      }\n    } else {\n      drop.splashRadius += 0.3;\n      drop.alpha *= 0.95;\n    }\n\n    drop.life -= 0.015;\n\n    if (drop.life <= 0 || drop.alpha < 0.02) {\n      state.blood.splice(i, 1);\n    }\n  }\n}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":354,"cache_read_input_tokens":36889,"cache_creation":{"ephemeral_5m_input_tokens":354,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"4f365745-28d6-4df5-a0ba-c8f3898fcfe3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KjNdd6saiGUC5P7Vnk7fh2","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"ed0050d6-3460-44d2-bbe0-32a661652343","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","oldString":"export function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}","newString":"export function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function spawnTears(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.tears.length >= MAX_TEARS) {\n      state.tears.shift();\n    }\n    state.tears.push({\n      x: x + (Math.random() - 0.5) * 20,\n      y: y + (Math.random() - 0.5) * 10,\n      vy: 0.5 + Math.random() * 1.5,\n      size: 3 + Math.random() * 3,\n      alpha: 0.7 + Math.random() * 0.3,\n      wobblePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateTears(state: CleanEffectsState, height: number): void {\n  for (let i = state.tears.length - 1; i >= 0; i--) {\n    const tear = state.tears[i];\n    tear.vy += 0.08;\n    tear.y += tear.vy;\n    tear.wobblePhase += 0.1;\n    tear.x += Math.sin(tear.wobblePhase) * 0.3;\n    tear.alpha *= 0.99;\n\n    if (tear.y > height + 10 || tear.alpha < 0.05) {\n      state.tears.splice(i, 1);\n    }\n  }\n}\n\nexport function spawnBlood(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.blood.length >= MAX_BLOOD) {\n      state.blood.shift();\n    }\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 1 + Math.random() * 3;\n    state.blood.push({\n      x,\n      y,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 1,\n      size: 2 + Math.random() * 4,\n      alpha: 0.8 + Math.random() * 0.2,\n      life: 1.0,\n      splashed: false,\n      splashRadius: 0,\n    });\n  }\n}\n\nexport function updateBlood(state: CleanEffectsState, height: number): void {\n  for (let i = state.blood.length - 1; i >= 0; i--) {\n    const drop = state.blood[i];\n\n    if (!drop.splashed) {\n      drop.vy += 0.15;\n      drop.x += drop.vx;\n      drop.y += drop.vy;\n      drop.vx *= 0.98;\n\n      if (drop.y >= height - 5) {\n        drop.splashed = true;\n        drop.y = height - 5;\n        drop.splashRadius = drop.size * 1.5;\n      }\n    } else {\n      drop.splashRadius += 0.3;\n      drop.alpha *= 0.95;\n    }\n\n    drop.life -= 0.015;\n\n    if (drop.life <= 0 || drop.alpha < 0.02) {\n      state.blood.splice(i, 1);\n    }\n  }\n}","originalFile":"export interface CleanRipple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport interface FloatingMote {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  pulsePhase: number;\n}\n\nexport interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport interface TearDrop {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n}\n\nexport interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}\n\nexport const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n};\n\nconst MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;\n\nexport function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    frameCount: 0,\n  };\n}\n\nexport type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n\nexport function initMotes(state: CleanEffectsState, width: number, height: number): void {\n  state.motes = [];\n  for (let i = 0; i < MAX_MOTES; i++) {\n    state.motes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: (Math.random() - 0.5) * 0.3,\n      vy: (Math.random() - 0.5) * 0.3,\n      size: 1 + Math.random() * 2,\n      alpha: 0.1 + Math.random() * 0.2,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n  for (const mote of state.motes) {\n    mote.x += mote.vx;\n    mote.y += mote.vy;\n    mote.pulsePhase += 0.02;\n\n    if (mote.x < 0) mote.x = width;\n    if (mote.x > width) mote.x = 0;\n    if (mote.y < 0) mote.y = height;\n    if (mote.y > height) mote.y = 0;\n  }\n}\n\nexport function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n  if (state.ripples.length >= MAX_RIPPLES) {\n    state.ripples.shift();\n  }\n\n  state.ripples.push({\n    x,\n    y,\n    radius: 5,\n    maxRadius: 60,\n    alpha: 0.6,\n    thickness: 2,\n  });\n}\n\nexport function updateRipples(state: CleanEffectsState): void {\n  for (let i = state.ripples.length - 1; i >= 0; i--) {\n    const ripple = state.ripples[i];\n    ripple.radius += 2;\n    ripple.alpha *= 0.94;\n    ripple.thickness *= 0.98;\n\n    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n      state.ripples.splice(i, 1);\n    }\n  }\n}\n\nexport function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}\n\nexport function drawCleanGrid(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  cellSize: number,\n  gridSize: number,\n  frameCount: number\n): void {\n  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n\n  for (let i = 0; i <= gridSize; i++) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n\n  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n  for (let i = 0; i <= gridSize; i += 5) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n}\n\nexport function drawMotes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const mote of state.motes) {\n    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n    const alpha = mote.alpha * pulse;\n\n    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n    g.fillCircle(mote.x, mote.y, mote.size * 2);\n    g.fillStyle(CLEAN_COLORS.mote, alpha);\n    g.fillCircle(mote.x, mote.y, mote.size);\n  }\n}\n\nexport function drawRipples(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const ripple of state.ripples) {\n    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n\n    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n  }\n}\n\nexport function drawGlowTrail(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const trail of state.glowTrail) {\n    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n    g.fillCircle(trail.x, trail.y, trail.size);\n  }\n}\n\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n  const foodSize = (cellSize / 2 - 2) * pulseScale;\n\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n  g.fillCircle(foodX, foodY, foodSize + 12);\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n  g.fillCircle(foodX, foodY, foodSize + 6);\n\n  g.fillStyle(CLEAN_COLORS.food, 0.9);\n  g.fillCircle(foodX, foodY, foodSize);\n  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n  g.fillCircle(foodX, foodY, foodSize * 0.5);\n\n  g.fillStyle(0xffffff, 0.6);\n  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n}\n\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  const snakeLen = snake.length;\n  if (snakeLen === 0) return;\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n\n    const glowAlpha = 0.15 * (1 - t * 0.5);\n    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n    g.fillCircle(centerX, centerY, glowSize);\n  }\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n\n    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n\n    const r = Math.round(r1 + (r2 - r1) * t);\n    const gVal = Math.round(g1 + (g2 - g1) * t);\n    const b = Math.round(b1 + (b2 - b1) * t);\n    const color = (r << 16) | (gVal << 8) | b;\n\n    g.fillStyle(color, 0.95);\n    g.fillCircle(centerX, centerY, radius);\n\n    if (i === 0) {\n      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n      g.fillCircle(centerX, centerY, radius + 4);\n\n      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n      g.fillCircle(centerX, centerY, radius);\n\n      g.fillStyle(0xffffff, 0.7);\n      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n    }\n  }\n}\n\nexport function drawCleanVignette(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number\n): void {\n  const layers = 4;\n  for (let i = 0; i < layers; i++) {\n    const inset = i * 25;\n    const alpha = 0.08 * (1 - i / layers);\n    g.lineStyle(50, 0x000000, alpha);\n    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {\n  const padding = 15;\n  const digitSize = 12;\n  const digitSpacing = digitSize * 0.6;\n\n  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n\n  const scoreStr = String(score).padStart(4, '0');\n  let xPos = padding;\n\n  for (let i = 0; i < scoreStr.length; i++) {\n    const digit = scoreStr[i];\n    g.fillStyle(CLEAN_COLORS.text, pulse);\n    drawDigit(g, digit, xPos, padding, digitSize);\n    xPos += digitSpacing;\n  }\n\n  const lengthStr = String(snakeLength);\n  xPos = width - padding - lengthStr.length * digitSpacing;\n\n  for (let i = 0; i < lengthStr.length; i++) {\n    const digit = lengthStr[i];\n    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n    xPos += digitSpacing * 0.9;\n  }\n}\n","structuredPatch":[{"oldStart":174,"oldLines":6,"newStart":174,"newLines":86,"lines":["   state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);"," }"," ","+export function spawnTears(state: CleanEffectsState, x: number, y: number, count: number): void {","+  for (let i = 0; i < count; i++) {","+    if (state.tears.length >= MAX_TEARS) {","+      state.tears.shift();","+    }","+    state.tears.push({","+      x: x + (Math.random() - 0.5) * 20,","+      y: y + (Math.random() - 0.5) * 10,","+      vy: 0.5 + Math.random() * 1.5,","+      size: 3 + Math.random() * 3,","+      alpha: 0.7 + Math.random() * 0.3,","+      wobblePhase: Math.random() * Math.PI * 2,","+    });","+  }","+}","+","+export function updateTears(state: CleanEffectsState, height: number): void {","+  for (let i = state.tears.length - 1; i >= 0; i--) {","+    const tear = state.tears[i];","+    tear.vy += 0.08;","+    tear.y += tear.vy;","+    tear.wobblePhase += 0.1;","+    tear.x += Math.sin(tear.wobblePhase) * 0.3;","+    tear.alpha *= 0.99;","+","+    if (tear.y > height + 10 || tear.alpha < 0.05) {","+      state.tears.splice(i, 1);","+    }","+  }","+}","+","+export function spawnBlood(state: CleanEffectsState, x: number, y: number, count: number): void {","+  for (let i = 0; i < count; i++) {","+    if (state.blood.length >= MAX_BLOOD) {","+      state.blood.shift();","+    }","+    const angle = Math.random() * Math.PI * 2;","+    const speed = 1 + Math.random() * 3;","+    state.blood.push({","+      x,","+      y,","+      vx: Math.cos(angle) * speed,","+      vy: Math.sin(angle) * speed - 1,","+      size: 2 + Math.random() * 4,","+      alpha: 0.8 + Math.random() * 0.2,","+      life: 1.0,","+      splashed: false,","+      splashRadius: 0,","+    });","+  }","+}","+","+export function updateBlood(state: CleanEffectsState, height: number): void {","+  for (let i = state.blood.length - 1; i >= 0; i--) {","+    const drop = state.blood[i];","+","+    if (!drop.splashed) {","+      drop.vy += 0.15;","+      drop.x += drop.vx;","+      drop.y += drop.vy;","+      drop.vx *= 0.98;","+","+      if (drop.y >= height - 5) {","+        drop.splashed = true;","+        drop.y = height - 5;","+        drop.splashRadius = drop.size * 1.5;","+      }","+    } else {","+      drop.splashRadius += 0.3;","+      drop.alpha *= 0.95;","+    }","+","+    drop.life -= 0.015;","+","+    if (drop.life <= 0 || drop.alpha < 0.02) {","+      state.blood.splice(i, 1);","+    }","+  }","+}","+"," export function drawCleanBackground(","   g: Phaser.GameObjects.Graphics,","   width: number,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015YyCX1pZNoCfoDAmpkfGqx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011Bfif7rG7SYtgkBU6chhQe","name":"TodoWrite","input":{"todos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"completed","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"in_progress","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"pending","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1509,"cache_read_input_tokens":37243,"cache_creation":{"ephemeral_5m_input_tokens":1509,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"1db598f8-9af4-41ad-9bbe-7ceed18c95d3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011Bfif7rG7SYtgkBU6chhQe","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"adde8691-e1cc-42eb-a06f-7b5dc8884d1c","tool_use_result":{"oldTodos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"in_progress","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"pending","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"pending","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}],"newTodos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"completed","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"in_progress","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"pending","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TrjK7VKGp2RCkn9cb1Vcqm","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the draw functions for tears and blood."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":352,"cache_read_input_tokens":38752,"cache_creation":{"ephemeral_5m_input_tokens":352,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"9360bc97-4581-4254-ac09-a00c9d37aa21"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TrjK7VKGp2RCkn9cb1Vcqm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011UcNLtrhvNTNv2JJu5qpsS","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","old_string":"export function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {","new_string":"export function drawTears(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const tear of state.tears) {\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha * 0.3);\n    g.fillCircle(tear.x, tear.y, tear.size * 2);\n\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha);\n    g.fillCircle(tear.x, tear.y - tear.size * 0.3, tear.size);\n    g.fillCircle(tear.x, tear.y + tear.size * 0.5, tear.size * 0.7);\n\n    g.fillStyle(CLEAN_COLORS.tearHighlight, tear.alpha * 0.6);\n    g.fillCircle(tear.x - tear.size * 0.25, tear.y - tear.size * 0.4, tear.size * 0.3);\n  }\n}\n\nexport function drawBlood(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const drop of state.blood) {\n    const effectiveAlpha = drop.alpha * drop.life;\n\n    if (drop.splashed) {\n      g.fillStyle(CLEAN_COLORS.bloodDark, effectiveAlpha * 0.5);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.7);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius * 0.6);\n    } else {\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.4);\n      g.fillCircle(drop.x, drop.y, drop.size * 2);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha);\n      g.fillCircle(drop.x, drop.y, drop.size);\n      g.fillStyle(0xffffff, effectiveAlpha * 0.3);\n      g.fillCircle(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.25);\n    }\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":352,"cache_read_input_tokens":38752,"cache_creation":{"ephemeral_5m_input_tokens":352,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"c9dfcf9a-2778-49b8-8449-1fb850ecdcfd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011UcNLtrhvNTNv2JJu5qpsS","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"03830354-cf32-40db-bcb8-c469a7b433fb","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/cleanEffects.ts","oldString":"export function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {","newString":"export function drawTears(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const tear of state.tears) {\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha * 0.3);\n    g.fillCircle(tear.x, tear.y, tear.size * 2);\n\n    g.fillStyle(CLEAN_COLORS.tear, tear.alpha);\n    g.fillCircle(tear.x, tear.y - tear.size * 0.3, tear.size);\n    g.fillCircle(tear.x, tear.y + tear.size * 0.5, tear.size * 0.7);\n\n    g.fillStyle(CLEAN_COLORS.tearHighlight, tear.alpha * 0.6);\n    g.fillCircle(tear.x - tear.size * 0.25, tear.y - tear.size * 0.4, tear.size * 0.3);\n  }\n}\n\nexport function drawBlood(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const drop of state.blood) {\n    const effectiveAlpha = drop.alpha * drop.life;\n\n    if (drop.splashed) {\n      g.fillStyle(CLEAN_COLORS.bloodDark, effectiveAlpha * 0.5);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.7);\n      g.fillCircle(drop.x, drop.y, drop.splashRadius * 0.6);\n    } else {\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.4);\n      g.fillCircle(drop.x, drop.y, drop.size * 2);\n      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha);\n      g.fillCircle(drop.x, drop.y, drop.size);\n      g.fillStyle(0xffffff, effectiveAlpha * 0.3);\n      g.fillCircle(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.25);\n    }\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {","originalFile":"export interface CleanRipple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport interface FloatingMote {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  pulsePhase: number;\n}\n\nexport interface SnakeGlowTrail {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n}\n\nexport interface TearDrop {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  wobblePhase: number;\n}\n\nexport interface BloodSplatter {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  life: number;\n  splashed: boolean;\n  splashRadius: number;\n}\n\nexport const CLEAN_COLORS = {\n  bgDark: 0x0a1628,\n  bgMid: 0x0f1d32,\n  bgLight: 0x14253e,\n\n  gridLine: 0x1a3050,\n  gridAccent: 0x254060,\n\n  snakeHead: 0x4fd1c5,\n  snakeBody: 0x38b2ac,\n  snakeTail: 0x2c9a94,\n  snakeGlow: 0x81e6d9,\n\n  food: 0xe2e8f0,\n  foodCore: 0xffffff,\n  foodGlow: 0xcbd5e1,\n\n  ripple: 0x81e6d9,\n  mote: 0x4fd1c5,\n\n  text: 0xe2e8f0,\n  textDim: 0x94a3b8,\n\n  blood: 0xdc2626,\n  bloodDark: 0x991b1b,\n  tear: 0x60a5fa,\n  tearHighlight: 0x93c5fd,\n};\n\nconst MAX_RIPPLES = 5;\nconst MAX_MOTES = 20;\nconst MAX_TRAIL_LENGTH = 15;\nconst MAX_TEARS = 12;\nconst MAX_BLOOD = 20;\n\nexport function createCleanEffectsState() {\n  return {\n    ripples: [] as CleanRipple[],\n    motes: [] as FloatingMote[],\n    glowTrail: [] as SnakeGlowTrail[],\n    tears: [] as TearDrop[],\n    blood: [] as BloodSplatter[],\n    frameCount: 0,\n  };\n}\n\nexport type CleanEffectsState = ReturnType<typeof createCleanEffectsState>;\n\nexport function initMotes(state: CleanEffectsState, width: number, height: number): void {\n  state.motes = [];\n  for (let i = 0; i < MAX_MOTES; i++) {\n    state.motes.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: (Math.random() - 0.5) * 0.3,\n      vy: (Math.random() - 0.5) * 0.3,\n      size: 1 + Math.random() * 2,\n      alpha: 0.1 + Math.random() * 0.2,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateMotes(state: CleanEffectsState, width: number, height: number): void {\n  for (const mote of state.motes) {\n    mote.x += mote.vx;\n    mote.y += mote.vy;\n    mote.pulsePhase += 0.02;\n\n    if (mote.x < 0) mote.x = width;\n    if (mote.x > width) mote.x = 0;\n    if (mote.y < 0) mote.y = height;\n    if (mote.y > height) mote.y = 0;\n  }\n}\n\nexport function spawnRipple(state: CleanEffectsState, x: number, y: number): void {\n  if (state.ripples.length >= MAX_RIPPLES) {\n    state.ripples.shift();\n  }\n\n  state.ripples.push({\n    x,\n    y,\n    radius: 5,\n    maxRadius: 60,\n    alpha: 0.6,\n    thickness: 2,\n  });\n}\n\nexport function updateRipples(state: CleanEffectsState): void {\n  for (let i = state.ripples.length - 1; i >= 0; i--) {\n    const ripple = state.ripples[i];\n    ripple.radius += 2;\n    ripple.alpha *= 0.94;\n    ripple.thickness *= 0.98;\n\n    if (ripple.alpha < 0.02 || ripple.radius > ripple.maxRadius) {\n      state.ripples.splice(i, 1);\n    }\n  }\n}\n\nexport function updateGlowTrail(\n  state: CleanEffectsState,\n  headX: number,\n  headY: number\n): void {\n  state.glowTrail.unshift({\n    x: headX,\n    y: headY,\n    alpha: 0.5,\n    size: 12,\n  });\n\n  if (state.glowTrail.length > MAX_TRAIL_LENGTH) {\n    state.glowTrail.pop();\n  }\n\n  for (let i = 0; i < state.glowTrail.length; i++) {\n    const t = state.glowTrail[i];\n    t.alpha *= 0.85;\n    t.size *= 0.95;\n  }\n\n  state.glowTrail = state.glowTrail.filter(t => t.alpha > 0.02);\n}\n\nexport function spawnTears(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.tears.length >= MAX_TEARS) {\n      state.tears.shift();\n    }\n    state.tears.push({\n      x: x + (Math.random() - 0.5) * 20,\n      y: y + (Math.random() - 0.5) * 10,\n      vy: 0.5 + Math.random() * 1.5,\n      size: 3 + Math.random() * 3,\n      alpha: 0.7 + Math.random() * 0.3,\n      wobblePhase: Math.random() * Math.PI * 2,\n    });\n  }\n}\n\nexport function updateTears(state: CleanEffectsState, height: number): void {\n  for (let i = state.tears.length - 1; i >= 0; i--) {\n    const tear = state.tears[i];\n    tear.vy += 0.08;\n    tear.y += tear.vy;\n    tear.wobblePhase += 0.1;\n    tear.x += Math.sin(tear.wobblePhase) * 0.3;\n    tear.alpha *= 0.99;\n\n    if (tear.y > height + 10 || tear.alpha < 0.05) {\n      state.tears.splice(i, 1);\n    }\n  }\n}\n\nexport function spawnBlood(state: CleanEffectsState, x: number, y: number, count: number): void {\n  for (let i = 0; i < count; i++) {\n    if (state.blood.length >= MAX_BLOOD) {\n      state.blood.shift();\n    }\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 1 + Math.random() * 3;\n    state.blood.push({\n      x,\n      y,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 1,\n      size: 2 + Math.random() * 4,\n      alpha: 0.8 + Math.random() * 0.2,\n      life: 1.0,\n      splashed: false,\n      splashRadius: 0,\n    });\n  }\n}\n\nexport function updateBlood(state: CleanEffectsState, height: number): void {\n  for (let i = state.blood.length - 1; i >= 0; i--) {\n    const drop = state.blood[i];\n\n    if (!drop.splashed) {\n      drop.vy += 0.15;\n      drop.x += drop.vx;\n      drop.y += drop.vy;\n      drop.vx *= 0.98;\n\n      if (drop.y >= height - 5) {\n        drop.splashed = true;\n        drop.y = height - 5;\n        drop.splashRadius = drop.size * 1.5;\n      }\n    } else {\n      drop.splashRadius += 0.3;\n      drop.alpha *= 0.95;\n    }\n\n    drop.life -= 0.015;\n\n    if (drop.life <= 0 || drop.alpha < 0.02) {\n      state.blood.splice(i, 1);\n    }\n  }\n}\n\nexport function drawCleanBackground(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  frameCount: number\n): void {\n  g.fillStyle(CLEAN_COLORS.bgDark, 1);\n  g.fillRect(0, 0, width, height);\n\n  const pulse = 0.5 + Math.sin(frameCount * 0.01) * 0.1;\n  g.fillStyle(CLEAN_COLORS.bgMid, pulse * 0.4);\n  g.fillCircle(width / 2, height / 2, width * 0.6);\n  g.fillStyle(CLEAN_COLORS.bgLight, pulse * 0.2);\n  g.fillCircle(width / 2, height / 2, width * 0.3);\n}\n\nexport function drawCleanGrid(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number,\n  cellSize: number,\n  gridSize: number,\n  frameCount: number\n): void {\n  const pulse = 0.05 + Math.sin(frameCount * 0.02) * 0.02;\n  g.lineStyle(1, CLEAN_COLORS.gridLine, pulse);\n\n  for (let i = 0; i <= gridSize; i++) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n\n  g.lineStyle(1, CLEAN_COLORS.gridAccent, pulse * 1.5);\n  for (let i = 0; i <= gridSize; i += 5) {\n    g.lineBetween(i * cellSize, 0, i * cellSize, height);\n    g.lineBetween(0, i * cellSize, width, i * cellSize);\n  }\n}\n\nexport function drawMotes(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const mote of state.motes) {\n    const pulse = 0.5 + Math.sin(mote.pulsePhase) * 0.5;\n    const alpha = mote.alpha * pulse;\n\n    g.fillStyle(CLEAN_COLORS.mote, alpha * 0.3);\n    g.fillCircle(mote.x, mote.y, mote.size * 2);\n    g.fillStyle(CLEAN_COLORS.mote, alpha);\n    g.fillCircle(mote.x, mote.y, mote.size);\n  }\n}\n\nexport function drawRipples(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const ripple of state.ripples) {\n    g.lineStyle(ripple.thickness, CLEAN_COLORS.ripple, ripple.alpha);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius);\n\n    g.lineStyle(ripple.thickness * 0.5, 0xffffff, ripple.alpha * 0.5);\n    g.strokeCircle(ripple.x, ripple.y, ripple.radius * 0.8);\n  }\n}\n\nexport function drawGlowTrail(\n  g: Phaser.GameObjects.Graphics,\n  state: CleanEffectsState\n): void {\n  for (const trail of state.glowTrail) {\n    g.fillStyle(CLEAN_COLORS.snakeGlow, trail.alpha * 0.3);\n    g.fillCircle(trail.x, trail.y, trail.size);\n  }\n}\n\nexport function drawCleanFood(\n  g: Phaser.GameObjects.Graphics,\n  foodX: number,\n  foodY: number,\n  cellSize: number,\n  frameCount: number\n): void {\n  const pulseScale = 1 + Math.sin(frameCount * 0.08) * 0.1;\n  const glowPulse = 0.3 + Math.sin(frameCount * 0.06) * 0.15;\n  const foodSize = (cellSize / 2 - 2) * pulseScale;\n\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.3);\n  g.fillCircle(foodX, foodY, foodSize + 12);\n  g.fillStyle(CLEAN_COLORS.foodGlow, glowPulse * 0.5);\n  g.fillCircle(foodX, foodY, foodSize + 6);\n\n  g.fillStyle(CLEAN_COLORS.food, 0.9);\n  g.fillCircle(foodX, foodY, foodSize);\n  g.fillStyle(CLEAN_COLORS.foodCore, 0.8);\n  g.fillCircle(foodX, foodY, foodSize * 0.5);\n\n  g.fillStyle(0xffffff, 0.6);\n  g.fillCircle(foodX - foodSize * 0.3, foodY - foodSize * 0.3, foodSize * 0.15);\n}\n\nexport function drawCleanSnake(\n  g: Phaser.GameObjects.Graphics,\n  snake: { x: number; y: number }[],\n  cellSize: number,\n  frameCount: number\n): void {\n  const snakeLen = snake.length;\n  if (snakeLen === 0) return;\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n\n    const glowAlpha = 0.15 * (1 - t * 0.5);\n    const glowSize = (cellSize / 2 + 6) * (0.6 + t * 0.4);\n    g.fillStyle(CLEAN_COLORS.snakeGlow, glowAlpha);\n    g.fillCircle(centerX, centerY, glowSize);\n  }\n\n  for (let i = snakeLen - 1; i >= 0; i--) {\n    const segment = snake[i];\n    const centerX = segment.x * cellSize + cellSize / 2;\n    const centerY = segment.y * cellSize + cellSize / 2;\n    const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n    const radius = (cellSize / 2 - 2) * (0.8 + t * 0.2);\n\n    const r1 = (CLEAN_COLORS.snakeTail >> 16) & 0xff;\n    const g1 = (CLEAN_COLORS.snakeTail >> 8) & 0xff;\n    const b1 = CLEAN_COLORS.snakeTail & 0xff;\n    const r2 = (CLEAN_COLORS.snakeHead >> 16) & 0xff;\n    const g2 = (CLEAN_COLORS.snakeHead >> 8) & 0xff;\n    const b2 = CLEAN_COLORS.snakeHead & 0xff;\n\n    const r = Math.round(r1 + (r2 - r1) * t);\n    const gVal = Math.round(g1 + (g2 - g1) * t);\n    const b = Math.round(b1 + (b2 - b1) * t);\n    const color = (r << 16) | (gVal << 8) | b;\n\n    g.fillStyle(color, 0.95);\n    g.fillCircle(centerX, centerY, radius);\n\n    if (i === 0) {\n      const pulse = 0.3 + Math.sin(frameCount * 0.1) * 0.1;\n      g.fillStyle(CLEAN_COLORS.snakeGlow, pulse);\n      g.fillCircle(centerX, centerY, radius + 4);\n\n      g.fillStyle(CLEAN_COLORS.snakeHead, 1);\n      g.fillCircle(centerX, centerY, radius);\n\n      g.fillStyle(0xffffff, 0.7);\n      g.fillCircle(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.15);\n    }\n  }\n}\n\nexport function drawCleanVignette(\n  g: Phaser.GameObjects.Graphics,\n  width: number,\n  height: number\n): void {\n  const layers = 4;\n  for (let i = 0; i < layers; i++) {\n    const inset = i * 25;\n    const alpha = 0.08 * (1 - i / layers);\n    g.lineStyle(50, 0x000000, alpha);\n    g.strokeRect(inset - 25, inset - 25, width - inset * 2 + 50, height - inset * 2 + 50);\n  }\n}\n\nexport function drawCleanHUD(\n  g: Phaser.GameObjects.Graphics,\n  score: number,\n  snakeLength: number,\n  width: number,\n  frameCount: number,\n  drawDigit: (g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number) => void\n): void {\n  const padding = 15;\n  const digitSize = 12;\n  const digitSpacing = digitSize * 0.6;\n\n  const pulse = 0.8 + Math.sin(frameCount * 0.05) * 0.1;\n\n  const scoreStr = String(score).padStart(4, '0');\n  let xPos = padding;\n\n  for (let i = 0; i < scoreStr.length; i++) {\n    const digit = scoreStr[i];\n    g.fillStyle(CLEAN_COLORS.text, pulse);\n    drawDigit(g, digit, xPos, padding, digitSize);\n    xPos += digitSpacing;\n  }\n\n  const lengthStr = String(snakeLength);\n  xPos = width - padding - lengthStr.length * digitSpacing;\n\n  for (let i = 0; i < lengthStr.length; i++) {\n    const digit = lengthStr[i];\n    g.fillStyle(CLEAN_COLORS.textDim, pulse * 0.7);\n    drawDigit(g, digit, xPos, padding, digitSize * 0.9);\n    xPos += digitSpacing * 0.9;\n  }\n}\n","structuredPatch":[{"oldStart":427,"oldLines":6,"newStart":427,"newLines":46,"lines":["   }"," }"," ","+export function drawTears(","+  g: Phaser.GameObjects.Graphics,","+  state: CleanEffectsState","+): void {","+  for (const tear of state.tears) {","+    g.fillStyle(CLEAN_COLORS.tear, tear.alpha * 0.3);","+    g.fillCircle(tear.x, tear.y, tear.size * 2);","+","+    g.fillStyle(CLEAN_COLORS.tear, tear.alpha);","+    g.fillCircle(tear.x, tear.y - tear.size * 0.3, tear.size);","+    g.fillCircle(tear.x, tear.y + tear.size * 0.5, tear.size * 0.7);","+","+    g.fillStyle(CLEAN_COLORS.tearHighlight, tear.alpha * 0.6);","+    g.fillCircle(tear.x - tear.size * 0.25, tear.y - tear.size * 0.4, tear.size * 0.3);","+  }","+}","+","+export function drawBlood(","+  g: Phaser.GameObjects.Graphics,","+  state: CleanEffectsState","+): void {","+  for (const drop of state.blood) {","+    const effectiveAlpha = drop.alpha * drop.life;","+","+    if (drop.splashed) {","+      g.fillStyle(CLEAN_COLORS.bloodDark, effectiveAlpha * 0.5);","+      g.fillCircle(drop.x, drop.y, drop.splashRadius);","+      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.7);","+      g.fillCircle(drop.x, drop.y, drop.splashRadius * 0.6);","+    } else {","+      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha * 0.4);","+      g.fillCircle(drop.x, drop.y, drop.size * 2);","+      g.fillStyle(CLEAN_COLORS.blood, effectiveAlpha);","+      g.fillCircle(drop.x, drop.y, drop.size);","+      g.fillStyle(0xffffff, effectiveAlpha * 0.3);","+      g.fillCircle(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.25);","+    }","+  }","+}","+"," export function drawCleanHUD(","   g: Phaser.GameObjects.Graphics,","   score: number,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01C2WJwDAJARG8yM2cpGLTUK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GBGhZvxrc6m5JR2reYAwDz","name":"TodoWrite","input":{"todos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"completed","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"completed","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"in_progress","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":986,"cache_read_input_tokens":39104,"cache_creation":{"ephemeral_5m_input_tokens":986,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"06d29938-8248-4431-bc0d-21fecb8b5f66"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GBGhZvxrc6m5JR2reYAwDz","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"a8bcef5d-765e-425a-9626-f3eb5c9fcb46","tool_use_result":{"oldTodos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"completed","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"in_progress","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"pending","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}],"newTodos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"completed","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"completed","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"in_progress","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KXLfJMqVVtnV2DYWEjJDhk","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to integrate these effects into SnakeScene.ts. Let me update the imports and add the effect calls."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":354,"cache_read_input_tokens":40090,"cache_creation":{"ephemeral_5m_input_tokens":354,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"b92c8b95-a6e0-4b6e-b371-c848ffb00c20"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KXLfJMqVVtnV2DYWEjJDhk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RnpDBiXvZioh2xE1CSTpYB","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","old_string":"import {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';","new_string":"import {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":354,"cache_read_input_tokens":40090,"cache_creation":{"ephemeral_5m_input_tokens":354,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"e142e2b2-1ad3-4aff-85c1-9889c9033fe7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RnpDBiXvZioh2xE1CSTpYB","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"4050a404-9df6-45e8-b4d4-62064b49fa36","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","oldString":"import {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';","newString":"import {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';","originalFile":"import Phaser from 'phaser';\nimport {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface GameState {\n  snake: Position[];\n  food: Position;\n  gameOver: boolean;\n  gameStarted?: boolean;\n  score?: number;\n}\n\ninterface Star {\n  x: number;\n  y: number;\n  size: number;\n  speed: number;\n  brightness: number;\n}\n\ninterface PlasmaWave {\n  phase: number;\n  speed: number;\n  amplitude: number;\n  wavelength: number;\n  hue: number;\n}\n\ninterface AuroraWave {\n  y: number;\n  phase: number;\n  speed: number;\n  hue: number;\n  thickness: number;\n  amplitude: number;\n}\n\ninterface NebulaCloud {\n  x: number;\n  y: number;\n  radius: number;\n  hue: number;\n  alpha: number;\n  driftX: number;\n  driftY: number;\n  pulsePhase: number;\n  pulseSpeed: number;\n}\n\ninterface VortexRing {\n  radius: number;\n  baseRadius: number;\n  rotationOffset: number;\n  rotationSpeed: number;\n  thickness: number;\n  hue: number;\n  pulsePhase: number;\n}\n\ninterface VortexParticle {\n  angle: number;\n  radius: number;\n  baseRadius: number;\n  speed: number;\n  size: number;\n  hue: number;\n  alpha: number;\n}\n\ninterface SnakeAfterimage {\n  segments: Position[];\n  life: number;\n  maxLife: number;\n  hueOffset: number;\n}\n\ninterface FoodParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n}\n\ninterface SnakeTrailParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n  hue: number;\n}\n\ninterface ShockWave {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n}\n\ninterface LightningBolt {\n  points: { x: number; y: number }[];\n  life: number;\n  maxLife: number;\n  hue: number;\n}\n\nconst CELL_SIZE = 20;\nconst GRID_SIZE = 20;\nconst NUM_STARS = 30;\nconst MAX_FOOD_PARTICLES = 8;\nconst MAX_TRAIL_PARTICLES = 40;\nconst MAX_SHOCKWAVES = 3;\nconst MAX_LIGHTNING_BOLTS = 5;\nconst MAX_BURST_PARTICLES = 12;\nconst NUM_PLASMA_WAVES = 3;\nconst MAX_AFTERIMAGES = 4;\nconst NUM_AURORA_WAVES = 5;\nconst NUM_NEBULA_CLOUDS = 6;\nconst NUM_VORTEX_RINGS = 5;\nconst NUM_VORTEX_PARTICLES = 20;\nconst NUM_METEORS = 8;\nconst MAX_DEATH_DEBRIS = 24;\nconst NUM_SPIRITS_PER_EDGE = 2;\nconst MAX_FLAME_PARTICLES = 60;\nconst MAX_COMET_TRAIL_LENGTH = 30;\nconst MAX_ETHEREAL_PARTICLES = 50;\nconst NUM_BEES = 8;\nconst BEE_SPAWN_CHANCE = 0.02;\n\n// Comet trail segment - stores historical snake positions for smooth trail rendering\ninterface CometTrailSegment {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n  hue: number;\n}\n\n// Ethereal trail particle - luminous particles that drift away from trail\ninterface EtherealParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n  pulsePhase: number;\n}\n\n// Thrown food animation - food launched onto screen with arc trajectory\ninterface ThrownFood {\n  startX: number;\n  startY: number;\n  targetX: number;\n  targetY: number;\n  x: number;\n  y: number;\n  progress: number; // 0 to 1\n  rotation: number;\n  rotationSpeed: number;\n  trail: { x: number; y: number; alpha: number; rotation: number }[];\n  landed: boolean;\n  landingParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number }[];\n  impactRings: { radius: number; alpha: number }[];\n}\n\n// Meteor shower types\ninterface Meteor {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  alpha: number;\n  trail: { x: number; y: number; alpha: number }[];\n  life: number;\n}\n\n// Death debris particle\ninterface DeathDebris {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  rotation: number;\n  rotationSpeed: number;\n  life: number;\n  type: 'shard' | 'spark' | 'ember';\n}\n\n// Guardian spirit - ethereal protectors at edges\ninterface GuardianSpirit {\n  x: number;\n  y: number;\n  baseX: number;\n  baseY: number;\n  size: number;\n  phase: number;\n  speed: number;\n  haloPhase: number;\n  orbPhase: number;\n  edge: 'top' | 'bottom' | 'left' | 'right';\n  targetAlpha: number;\n  currentAlpha: number;\n  hue: number;\n  orbs: { angle: number; distance: number; size: number; speed: number }[];\n}\n\n// Flame particle for burning effect\ninterface FlameParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n}\n\n// Mystical bee - glowing magical creatures that swarm around food\ninterface MysticalBee {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  targetX: number;\n  targetY: number;\n  wingPhase: number;\n  wingSpeed: number;\n  size: number;\n  hue: number;\n  glowIntensity: number;\n  bobPhase: number;\n  bobSpeed: number;\n  trail: { x: number; y: number; alpha: number }[];\n  state: 'flying' | 'hovering' | 'attracted';\n  sparkleTimer: number;\n}\n\n// Rival snake - spectral AI nemesis that competes for food\ninterface RivalSnake {\n  segments: { x: number; y: number }[];\n  direction: { dx: number; dy: number };\n  targetX: number;\n  targetY: number;\n  moveTimer: number;\n  moveInterval: number;\n  pulsePhase: number;\n  glowIntensity: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n  energyTrail: { x: number; y: number; alpha: number; size: number }[];\n  state: 'hunting' | 'fleeing' | 'circling';\n  aggression: number;\n  nearMissTimer: number;\n  electricArcs: { x1: number; y1: number; x2: number; y2: number; life: number }[];\n}\n\nconst RIVAL_SNAKE_LENGTH = 10;\nconst RIVAL_MOVE_INTERVAL = 8;\n\n// Armageddon Chaos effect types\ninterface GroundFissure {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  width: number;\n  glowIntensity: number;\n  pulsePhase: number;\n}\n\ninterface FireRainParticle {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n}\n\ninterface ChaosExplosion {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n  rings: { radius: number; alpha: number }[];\n  debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[];\n}\n\ninterface ApocalypticSkull {\n  x: number;\n  y: number;\n  size: number;\n  alpha: number;\n  rotation: number;\n  pulsePhase: number;\n}\n\nconst NUM_FISSURES = 6;\nconst MAX_FIRE_RAIN = 30;\nconst MAX_CHAOS_EXPLOSIONS = 3;\nconst NUM_SKULLS = 4;\n\n// High score entry for scoreboard\ninterface HighScoreEntry {\n  score: number;\n  date: number;\n  rank: number;\n}\n\nconst MAX_HIGH_SCORES = 5;\n\n// Color palette - HALLOWEEN theme: spooky purple/orange, ghostly greens, pumpkin glow\nconst COLORS = {\n  bgDark: 0x0a0012,\n  bgMid: 0x150825,\n  gridLine: 0x2a1540,\n  gridAccent: 0x401860,\n  snakeHead: 0x00ff66,\n  snakeBody: 0x00cc55,\n  snakeTail: 0x009944,\n  snakeHighlight: 0x66ffaa,\n  snakeScale: 0x00aa44,\n  snakeEye: 0xff0000,\n  snakePupil: 0x000000,\n  snakeGlow: 0x00ff80,\n  food: 0xff6600,\n  foodCore: 0xffcc00,\n  foodGlow: 0xff8800,\n  foodParticle: 0xffaa00,\n  star: 0x8844ff,\n  gameOverOverlay: 0x0a0015,\n  gameOverText: 0xff6600,\n  plasma1: 0x9933ff,\n  plasma2: 0xbb55ff,\n  plasma3: 0x7722cc,\n  screenFlash: 0xff6600,\n  // Halloween specific colors\n  noirWhite: 0xeeddff,\n  noirGray: 0x8866aa,\n  noirDark: 0x2a1540,\n  spotlight: 0xff8800,\n  // Halloween additions\n  chaosRed: 0x9933ff,\n  chaosOrange: 0xff6600,\n  chaosYellow: 0xffcc00,\n  lavaGlow: 0x9944ff,\n  ashGray: 0x554466,\n  bloodRed: 0x660088,\n  hellfire: 0xff6600,\n  // New Halloween colors\n  pumpkinOrange: 0xff6600,\n  ghostWhite: 0xeeffee,\n  witchPurple: 0x9933ff,\n  spiderBlack: 0x111122,\n  candyCorn1: 0xffcc00,\n  candyCorn2: 0xff8800,\n  candyCorn3: 0xffffff,\n};\n\nexport class SnakeScene extends Phaser.Scene {\n  private graphics!: Phaser.GameObjects.Graphics;\n  private currentState: GameState | null = null;\n  private needsRedraw = false;\n  private frameCount = 0;\n  private stars: Star[] = [];\n  private foodParticles: FoodParticle[] = [];\n  private trailParticles: SnakeTrailParticle[] = [];\n  private shockWaves: ShockWave[] = [];\n  private lightningBolts: LightningBolt[] = [];\n  private plasmaWaves: PlasmaWave[] = [];\n  private snakeAfterimages: SnakeAfterimage[] = [];\n  private auroraWaves: AuroraWave[] = [];\n  private nebulaClouds: NebulaCloud[] = [];\n  private vortexRings: VortexRing[] = [];\n  private vortexParticles: VortexParticle[] = [];\n  private vortexPulse = 0;\n  private meteors: Meteor[] = [];\n  private deathDebris: DeathDebris[] = [];\n  private deathExplosionPhase = 0;\n  private gameOverAlpha = 0;\n  private lastHeadPos: Position | null = null;\n  private lastSnakeLength = 0;\n  private hueOffset = 0;\n  private screenFlashAlpha = 0;\n  private gameOverGlitchOffset = 0;\n  private screenShakeX = 0;\n  private screenShakeY = 0;\n  private screenShakeIntensity = 0;\n  private energyFieldPulse = 0;\n  private foodBurstParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number; hue: number; trail: { x: number; y: number }[] }[] = [];\n  private chromaticIntensity = 0;\n  // Film noir effects\n  private venetianPhase = 0;\n  private spotlightX = 0;\n  private spotlightY = 0;\n  private smokeParticles: { x: number; y: number; vx: number; vy: number; size: number; alpha: number; life: number }[] = [];\n  private guardianSpirits: GuardianSpirit[] = [];\n  // Burning flame particles trailing behind snake\n  private flameParticles: FlameParticle[] = [];\n  // Comet trail system - historical positions for smooth ribbon trail\n  private cometTrail: CometTrailSegment[] = [];\n  // Ethereal particles that drift away from the trail\n  private etherealParticles: EtherealParticle[] = [];\n  // Track last few head positions for smooth interpolation\n  private headHistory: { x: number; y: number; time: number }[] = [];\n  // Thrown food animation system\n  private thrownFood: ThrownFood | null = null;\n  private lastFoodPos: Position | null = null;\n  // Mystical bees swarming around\n  private bees: MysticalBee[] = [];\n  // Rival snake - spectral AI nemesis\n  private rivalSnake: RivalSnake | null = null;\n  // Scoreboard system\n  private highScores: HighScoreEntry[] = [];\n  private highScoresLoaded = false;\n  private newHighScoreRank = -1;\n  private scoreboardAnimPhase = 0;\n  private scoreboardRevealProgress = 0;\n  private lastGameOverState = false;\n  private hudPulsePhase = 0;\n  private lastHudScore = 0;\n  private scoreFlashIntensity = 0;\n  // Armageddon Chaos effects\n  private groundFissures: GroundFissure[] = [];\n  private fireRainParticles: FireRainParticle[] = [];\n  private chaosExplosions: ChaosExplosion[] = [];\n  private apocalypticSkulls: ApocalypticSkull[] = [];\n  private armageddonPulse = 0;\n  private chaosIntensity = 0;\n  private cleanEffects: CleanEffectsState = createCleanEffectsState();\n\n  constructor() {\n    super({ key: 'SnakeScene' });\n  }\n\n  create(): void {\n    this.graphics = this.add.graphics();\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    initMotes(this.cleanEffects, width, height);\n\n    if (this.currentState) {\n      this.needsRedraw = true;\n    }\n  }\n\n  private initArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Initialize ground fissures - cracks in the earth with lava\n    this.groundFissures = [];\n    for (let i = 0; i < NUM_FISSURES; i++) {\n      const startX = Math.random() * width;\n      const startY = Math.random() * height;\n      const angle = Math.random() * Math.PI;\n      const length = 40 + Math.random() * 80;\n      this.groundFissures.push({\n        x1: startX,\n        y1: startY,\n        x2: startX + Math.cos(angle) * length,\n        y2: startY + Math.sin(angle) * length,\n        width: 2 + Math.random() * 4,\n        glowIntensity: 0.5 + Math.random() * 0.5,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n\n    // Initialize fire rain\n    this.fireRainParticles = [];\n\n    // Initialize chaos explosions\n    this.chaosExplosions = [];\n\n    // Initialize apocalyptic skulls floating in background\n    this.apocalypticSkulls = [];\n    for (let i = 0; i < NUM_SKULLS; i++) {\n      this.apocalypticSkulls.push({\n        x: 30 + Math.random() * (width - 60),\n        y: 30 + Math.random() * (height - 60),\n        size: 15 + Math.random() * 10,\n        alpha: 0.03 + Math.random() * 0.04,\n        rotation: Math.random() * Math.PI * 2,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n  }\n\n  private initSmokeParticles(): void {\n    this.smokeParticles = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < 12; i++) {\n      this.smokeParticles.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        vx: (Math.random() - 0.5) * 0.3,\n        vy: -0.1 - Math.random() * 0.2,\n        size: 30 + Math.random() * 50,\n        alpha: 0.02 + Math.random() * 0.03,\n        life: Math.random(),\n      });\n    }\n  }\n\n  private updateArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    this.armageddonPulse += 0.04;\n\n    // Update ground fissures - pulsing lava glow\n    for (const fissure of this.groundFissures) {\n      fissure.pulsePhase += 0.06;\n      fissure.glowIntensity = 0.5 + Math.sin(fissure.pulsePhase) * 0.3;\n    }\n\n    // Spawn fire rain particles\n    if (this.fireRainParticles.length < MAX_FIRE_RAIN && Math.random() < 0.3) {\n      const hueVariation = Math.random();\n      this.fireRainParticles.push({\n        x: Math.random() * width,\n        y: -20,\n        vy: 2 + Math.random() * 3,\n        size: 2 + Math.random() * 4,\n        alpha: 0.6 + Math.random() * 0.4,\n        hue: hueVariation < 0.6 ? 0 : (hueVariation < 0.85 ? 20 : 40), // Red, orange, yellow\n        trail: [],\n      });\n    }\n\n    // Update fire rain\n    for (let i = this.fireRainParticles.length - 1; i >= 0; i--) {\n      const p = this.fireRainParticles[i];\n      p.trail.unshift({ x: p.x, y: p.y, alpha: p.alpha });\n      if (p.trail.length > 6) p.trail.pop();\n      for (const t of p.trail) { t.alpha *= 0.7; }\n\n      p.y += p.vy;\n      p.x += Math.sin(this.armageddonPulse + p.y * 0.05) * 0.3;\n      p.alpha *= 0.995;\n\n      if (p.y > height + 20 || p.alpha < 0.05) {\n        this.fireRainParticles.splice(i, 1);\n      }\n    }\n\n    // Update chaos explosions\n    for (let i = this.chaosExplosions.length - 1; i >= 0; i--) {\n      const exp = this.chaosExplosions[i];\n      exp.radius += 4;\n      exp.life -= 0.03;\n\n      for (const ring of exp.rings) {\n        ring.radius += 3;\n        ring.alpha *= 0.92;\n      }\n      exp.rings = exp.rings.filter(r => r.alpha > 0.02);\n\n      for (const d of exp.debris) {\n        d.x += d.vx;\n        d.y += d.vy;\n        d.vy += 0.1;\n        d.alpha *= 0.96;\n      }\n      exp.debris = exp.debris.filter(d => d.alpha > 0.02);\n\n      if (exp.life <= 0 && exp.rings.length === 0 && exp.debris.length === 0) {\n        this.chaosExplosions.splice(i, 1);\n      }\n    }\n\n    // Update apocalyptic skulls - slow drift and pulse\n    for (const skull of this.apocalypticSkulls) {\n      skull.pulsePhase += 0.02;\n      skull.rotation += 0.002;\n      skull.x += Math.sin(skull.pulsePhase * 0.5) * 0.1;\n      skull.y += Math.cos(skull.pulsePhase * 0.3) * 0.1;\n\n      // Keep in bounds\n      if (skull.x < 20) skull.x = 20;\n      if (skull.x > width - 20) skull.x = width - 20;\n      if (skull.y < 20) skull.y = 20;\n      if (skull.y > height - 20) skull.y = height - 20;\n    }\n\n    // Chaos intensity increases when snake eats or dies\n    this.chaosIntensity *= 0.97;\n  }\n\n  private spawnChaosExplosion(x: number, y: number): void {\n    if (this.chaosExplosions.length >= MAX_CHAOS_EXPLOSIONS) {\n      this.chaosExplosions.shift();\n    }\n\n    const debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[] = [];\n    for (let i = 0; i < 12; i++) {\n      const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 5;\n      debris.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 2,\n        size: 2 + Math.random() * 4,\n        alpha: 1,\n      });\n    }\n\n    this.chaosExplosions.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: 80,\n      life: 1,\n      rings: [\n        { radius: 10, alpha: 1 },\n        { radius: 5, alpha: 0.8 },\n        { radius: 15, alpha: 0.6 },\n      ],\n      debris,\n    });\n\n    this.chaosIntensity = Math.min(1, this.chaosIntensity + 0.5);\n    this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 12);\n  }\n\n  private drawArmageddonBackground(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Spooky Halloween night sky\n    const skyPulse = 0.8 + Math.sin(this.armageddonPulse * 0.5) * 0.2;\n\n    // Layer 1: Deep purple-black night base\n    g.fillStyle(0x0a0018, 1);\n    g.fillRect(0, 0, width, height);\n\n    // Layer 2: Eerie purple glow from below (like fog)\n    g.fillStyle(0x200840, 0.3 * skyPulse);\n    g.fillRect(0, height * 0.7, width, height * 0.3);\n\n    // Layer 3: Misty purple clouds\n    for (let i = 0; i < 4; i++) {\n      const cloudY = i * 30 + Math.sin(this.armageddonPulse + i) * 10;\n      const cloudAlpha = 0.1 - i * 0.02;\n      g.fillStyle(0x301040, cloudAlpha * skyPulse);\n      g.fillRect(0, cloudY, width, 40);\n    }\n\n    // Draw haunted moon\n    this.drawHauntedMoon(g, width);\n\n    // Draw flying bats in background\n    this.drawFlyingBats(g, width, height);\n\n    // Draw apocalyptic skulls (very faint, background layer)\n    this.drawApocalypticSkulls(g);\n  }\n\n  private drawHauntedMoon(g: Phaser.GameObjects.Graphics, width: number): void {\n    const moonX = width * 0.8;\n    const moonY = 60;\n    const moonRadius = 35;\n    const moonPulse = 0.9 + Math.sin(this.frameCount * 0.02) * 0.1;\n\n    // Moon glow\n    g.fillStyle(0xff8800, 0.1 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 2);\n    g.fillStyle(0xffaa00, 0.15 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 1.5);\n\n    // Main moon (orange harvest moon)\n    g.fillStyle(0xffaa33, 0.9);\n    g.fillCircle(moonX, moonY, moonRadius);\n\n    // Moon craters\n    g.fillStyle(0xcc8822, 0.4);\n    g.fillCircle(moonX - 10, moonY - 5, 8);\n    g.fillCircle(moonX + 12, moonY + 8, 6);\n    g.fillCircle(moonX - 5, moonY + 12, 5);\n  }\n\n  private drawFlyingBats(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const batCount = 6;\n    for (let i = 0; i < batCount; i++) {\n      const phase = this.frameCount * 0.03 + i * 1.5;\n      const batX = ((i * 127 + this.frameCount * 0.5) % (width + 100)) - 50;\n      const batY = 40 + i * 20 + Math.sin(phase) * 15;\n      const wingPhase = Math.sin(this.frameCount * 0.15 + i * 2);\n\n      // Bat body\n      g.fillStyle(0x111122, 0.8);\n      g.fillCircle(batX, batY, 4);\n\n      // Bat wings (flapping)\n      const wingSpread = 8 + wingPhase * 4;\n      g.fillStyle(0x111122, 0.7);\n\n      // Left wing\n      g.beginPath();\n      g.moveTo(batX - 2, batY);\n      g.lineTo(batX - wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX - wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n\n      // Right wing\n      g.beginPath();\n      g.moveTo(batX + 2, batY);\n      g.lineTo(batX + wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX + wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawGroundFissures(g: Phaser.GameObjects.Graphics): void {\n    for (const fissure of this.groundFissures) {\n      const pulse = fissure.glowIntensity;\n\n      // Ghostly purple glow underneath\n      g.lineStyle(fissure.width * 3, COLORS.lavaGlow, 0.12 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Crack edges (dark purple)\n      g.lineStyle(fissure.width + 2, 0x200030, 0.4);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ethereal core (bright purple)\n      g.lineStyle(fissure.width, COLORS.witchPurple, 0.3 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ghostly white center\n      g.lineStyle(fissure.width * 0.3, COLORS.ghostWhite, 0.2 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n    }\n  }\n\n  private drawFireRain(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.fireRainParticles) {\n      // Draw ghostly trail\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailSize = p.size * (1 - i / p.trail.length) * 0.6;\n        // Ghostly purple/green trail\n        const ghostHue = 0.75 + (p.hue % 60) / 360;\n        const trailColor = this.hslToRgb(ghostHue, 0.6, 0.6);\n        g.fillStyle(trailColor, t.alpha * 0.3);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Main spirit particle (ghostly appearance)\n      const outerColor = this.hslToRgb(0.8, 0.5, 0.5);\n      const coreColor = this.hslToRgb(0.85, 0.3, 0.8);\n\n      g.fillStyle(outerColor, p.alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      g.fillStyle(coreColor, p.alpha * 0.6);\n      g.fillCircle(p.x, p.y, p.size);\n\n      g.fillStyle(COLORS.ghostWhite, p.alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawChaosExplosions(g: Phaser.GameObjects.Graphics): void {\n    for (const exp of this.chaosExplosions) {\n      // Central flash\n      if (exp.life > 0.7) {\n        const flashAlpha = (exp.life - 0.7) * 3;\n        g.fillStyle(0xffffff, flashAlpha * 0.5);\n        g.fillCircle(exp.x, exp.y, exp.radius * 0.5);\n        g.fillStyle(COLORS.chaosYellow, flashAlpha * 0.4);\n        g.fillCircle(exp.x, exp.y, exp.radius);\n      }\n\n      // Expanding rings\n      for (const ring of exp.rings) {\n        g.lineStyle(4, COLORS.chaosRed, ring.alpha * 0.5);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(2, COLORS.chaosOrange, ring.alpha * 0.7);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(1, 0xffffff, ring.alpha * 0.4);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n      }\n\n      // Flying debris\n      for (const d of exp.debris) {\n        g.fillStyle(COLORS.chaosOrange, d.alpha * 0.6);\n        g.fillCircle(d.x, d.y, d.size * 1.3);\n        g.fillStyle(COLORS.chaosYellow, d.alpha * 0.9);\n        g.fillCircle(d.x, d.y, d.size);\n      }\n    }\n  }\n\n  private drawApocalypticSkulls(g: Phaser.GameObjects.Graphics): void {\n    for (const skull of this.apocalypticSkulls) {\n      const pulse = 0.7 + Math.sin(skull.pulsePhase) * 0.3;\n      const alpha = skull.alpha * pulse;\n      const s = skull.size;\n\n      // Ghostly purple glow\n      g.fillStyle(COLORS.witchPurple, alpha * 0.2);\n      g.fillCircle(skull.x, skull.y, s * 1.5);\n\n      // Skull outline (bone white)\n      g.fillStyle(0xcccccc, alpha * 0.8);\n      // Cranium\n      g.fillCircle(skull.x, skull.y - s * 0.1, s * 0.8);\n      // Jaw\n      g.fillRect(skull.x - s * 0.4, skull.y + s * 0.3, s * 0.8, s * 0.4);\n\n      // Eye sockets (glowing green - spooky!)\n      g.fillStyle(COLORS.snakeHead, alpha * 1.2);\n      g.fillCircle(skull.x - s * 0.25, skull.y - s * 0.1, s * 0.2);\n      g.fillCircle(skull.x + s * 0.25, skull.y - s * 0.1, s * 0.2);\n\n      // Nose hole\n      g.fillStyle(0x000000, alpha);\n      g.fillTriangle(\n        skull.x, skull.y + s * 0.1,\n        skull.x - s * 0.1, skull.y + s * 0.25,\n        skull.x + s * 0.1, skull.y + s * 0.25\n      );\n    }\n  }\n\n  private drawChaosOverlay(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (this.chaosIntensity <= 0) return;\n\n    // Purple tint overlay when chaos is active\n    g.fillStyle(COLORS.witchPurple, this.chaosIntensity * 0.1);\n    g.fillRect(0, 0, width, height);\n\n    // Pulsing purple vignette edges\n    const vignetteAlpha = this.chaosIntensity * 0.25;\n    g.lineStyle(80, COLORS.bloodRed, vignetteAlpha);\n    g.strokeRect(-40, -40, width + 80, height + 80);\n  }\n\n  private initGuardianSpirits(): void {\n    this.guardianSpirits = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const spiritHues = [180, 220, 280, 320];\n\n    const edges: ('top' | 'bottom' | 'left' | 'right')[] = ['top', 'bottom', 'left', 'right'];\n    for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      const edge = edges[edgeIndex];\n      for (let i = 0; i < NUM_SPIRITS_PER_EDGE; i++) {\n        let x = 0, y = 0;\n        const offset = (i + 0.5) / NUM_SPIRITS_PER_EDGE;\n\n        switch (edge) {\n          case 'top':\n            x = width * offset;\n            y = -15;\n            break;\n          case 'bottom':\n            x = width * offset;\n            y = height + 15;\n            break;\n          case 'left':\n            x = -15;\n            y = height * offset;\n            break;\n          case 'right':\n            x = width + 15;\n            y = height * offset;\n            break;\n        }\n\n        const orbs: { angle: number; distance: number; size: number; speed: number }[] = [];\n        const numOrbs = 3;\n        for (let o = 0; o < numOrbs; o++) {\n          orbs.push({\n            angle: (o / numOrbs) * Math.PI * 2,\n            distance: 15 + Math.random() * 10,\n            size: 3 + Math.random() * 2,\n            speed: 0.03 + Math.random() * 0.02,\n          });\n        }\n\n        this.guardianSpirits.push({\n          x,\n          y,\n          baseX: x,\n          baseY: y,\n          size: 20 + Math.random() * 10,\n          phase: Math.random() * Math.PI * 2,\n          speed: 0.015 + Math.random() * 0.01,\n          haloPhase: Math.random() * Math.PI * 2,\n          orbPhase: Math.random() * Math.PI * 2,\n          edge,\n          targetAlpha: 0.4 + Math.random() * 0.2,\n          currentAlpha: 0,\n          hue: spiritHues[edgeIndex % spiritHues.length] + Math.random() * 30 - 15,\n          orbs,\n        });\n      }\n    }\n  }\n\n  private initBees(): void {\n    this.bees = [];\n  }\n\n  private initRivalSnake(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    const startX = width - 50 - Math.random() * 50;\n    const startY = height - 50 - Math.random() * 50;\n\n    const segments: { x: number; y: number }[] = [];\n    for (let i = 0; i < RIVAL_SNAKE_LENGTH; i++) {\n      segments.push({\n        x: startX + i * CELL_SIZE * 0.6,\n        y: startY,\n      });\n    }\n\n    this.rivalSnake = {\n      segments,\n      direction: { dx: -1, dy: 0 },\n      targetX: width / 2,\n      targetY: height / 2,\n      moveTimer: 0,\n      moveInterval: RIVAL_MOVE_INTERVAL,\n      pulsePhase: 0,\n      glowIntensity: 0.8,\n      hue: 200,\n      trail: [],\n      energyTrail: [],\n      state: 'hunting',\n      aggression: 0.5,\n      nearMissTimer: 0,\n      electricArcs: [],\n    };\n  }\n\n  private updateRivalSnake(): void {\n    if (!this.rivalSnake || !this.currentState) return;\n\n    const rs = this.rivalSnake;\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    rs.pulsePhase += 0.1;\n    rs.glowIntensity = 0.6 + Math.sin(rs.pulsePhase) * 0.3;\n\n    if (rs.segments.length > 0) {\n      rs.trail.unshift({ x: rs.segments[0].x, y: rs.segments[0].y, alpha: 0.7 });\n      if (rs.trail.length > 20) rs.trail.pop();\n\n      rs.energyTrail.unshift({\n        x: rs.segments[0].x + (Math.random() - 0.5) * 8,\n        y: rs.segments[0].y + (Math.random() - 0.5) * 8,\n        alpha: 0.8,\n        size: 3 + Math.random() * 4\n      });\n      if (rs.energyTrail.length > 30) rs.energyTrail.pop();\n    }\n\n    for (const t of rs.trail) {\n      t.alpha *= 0.92;\n    }\n    rs.trail = rs.trail.filter(t => t.alpha > 0.02);\n\n    for (const e of rs.energyTrail) {\n      e.alpha *= 0.88;\n      e.size *= 0.95;\n    }\n    rs.energyTrail = rs.energyTrail.filter(e => e.alpha > 0.02);\n\n    rs.electricArcs = rs.electricArcs.filter(arc => {\n      arc.life -= 0.15;\n      return arc.life > 0;\n    });\n\n    if (rs.nearMissTimer > 0) rs.nearMissTimer--;\n\n    const playerHead = this.currentState.snake[0];\n    const playerX = playerHead.x * CELL_SIZE + CELL_SIZE / 2;\n    const playerY = playerHead.y * CELL_SIZE + CELL_SIZE / 2;\n    const rivalHead = rs.segments[0];\n    const distToPlayer = Math.sqrt(\n      Math.pow(playerX - rivalHead.x, 2) + Math.pow(playerY - rivalHead.y, 2)\n    );\n\n    if (distToPlayer < 60 && rs.nearMissTimer === 0) {\n      rs.nearMissTimer = 30;\n      rs.electricArcs.push({\n        x1: rivalHead.x,\n        y1: rivalHead.y,\n        x2: playerX,\n        y2: playerY,\n        life: 1.0\n      });\n      rs.aggression = Math.min(1.0, rs.aggression + 0.1);\n    }\n\n    rs.moveTimer++;\n    if (rs.moveTimer >= rs.moveInterval) {\n      rs.moveTimer = 0;\n\n      const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n      const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n      const distToFood = Math.sqrt(\n        Math.pow(foodX - rivalHead.x, 2) + Math.pow(foodY - rivalHead.y, 2)\n      );\n\n      if (distToPlayer < 80) {\n        rs.state = 'fleeing';\n        const fleeAngle = Math.atan2(rivalHead.y - playerY, rivalHead.x - playerX);\n        rs.targetX = rivalHead.x + Math.cos(fleeAngle) * 100;\n        rs.targetY = rivalHead.y + Math.sin(fleeAngle) * 100;\n      } else if (distToFood < 150 || rs.aggression > 0.7) {\n        rs.state = 'hunting';\n        rs.targetX = foodX;\n        rs.targetY = foodY;\n      } else {\n        rs.state = 'circling';\n        const circleAngle = rs.pulsePhase * 0.3;\n        rs.targetX = width / 2 + Math.cos(circleAngle) * 120;\n        rs.targetY = height / 2 + Math.sin(circleAngle) * 120;\n      }\n\n      rs.targetX = Math.max(30, Math.min(width - 30, rs.targetX));\n      rs.targetY = Math.max(30, Math.min(height - 30, rs.targetY));\n\n      const dx = rs.targetX - rivalHead.x;\n      const dy = rs.targetY - rivalHead.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 5) {\n        const targetDx = dx / dist;\n        const targetDy = dy / dist;\n        const turnSpeed = rs.state === 'fleeing' ? 0.5 : 0.35;\n\n        rs.direction.dx = rs.direction.dx * (1 - turnSpeed) + targetDx * turnSpeed;\n        rs.direction.dy = rs.direction.dy * (1 - turnSpeed) + targetDy * turnSpeed;\n\n        const len = Math.sqrt(rs.direction.dx * rs.direction.dx + rs.direction.dy * rs.direction.dy);\n        if (len > 0) {\n          rs.direction.dx /= len;\n          rs.direction.dy /= len;\n        }\n      }\n\n      const moveSpeed = rs.state === 'fleeing' ? CELL_SIZE * 0.7 : CELL_SIZE * 0.55;\n      const newHead = {\n        x: rivalHead.x + rs.direction.dx * moveSpeed,\n        y: rivalHead.y + rs.direction.dy * moveSpeed,\n      };\n\n      if (newHead.x < 10) newHead.x = width - 10;\n      if (newHead.x > width - 10) newHead.x = 10;\n      if (newHead.y < 10) newHead.y = height - 10;\n      if (newHead.y > height - 10) newHead.y = 10;\n\n      rs.segments.unshift(newHead);\n      rs.segments.pop();\n    } else {\n      const head = rs.segments[0];\n      const moveSpeed = CELL_SIZE * 0.5;\n\n      head.x += rs.direction.dx * moveSpeed * 0.06;\n      head.y += rs.direction.dy * moveSpeed * 0.06;\n\n      for (let i = 1; i < rs.segments.length; i++) {\n        const seg = rs.segments[i];\n        const prev = rs.segments[i - 1];\n        const pullStrength = 0.18;\n        seg.x += (prev.x - seg.x) * pullStrength;\n        seg.y += (prev.y - seg.y) * pullStrength;\n      }\n    }\n\n    if (this.currentState.gameOver) {\n      rs.hue = 180;\n      rs.glowIntensity *= 0.95;\n      rs.state = 'circling';\n    } else {\n      rs.hue = rs.state === 'hunting' ? 190 : (rs.state === 'fleeing' ? 220 : 200);\n      rs.hue += Math.sin(rs.pulsePhase * 0.5) * 10;\n    }\n\n    rs.aggression *= 0.998;\n  }\n\n  private drawRivalSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.rivalSnake || this.rivalSnake.segments.length === 0) return;\n\n    const rs = this.rivalSnake;\n    const pulse = rs.glowIntensity;\n\n    for (const arc of rs.electricArcs) {\n      this.drawElectricArc(g, arc.x1, arc.y1, arc.x2, arc.y2, arc.life);\n    }\n\n    for (const e of rs.energyTrail) {\n      g.fillStyle(this.hslToHex(rs.hue + 20, 80, 70), e.alpha * 0.6);\n      g.fillCircle(e.x, e.y, e.size);\n      g.fillStyle(this.hslToHex(rs.hue, 90, 85), e.alpha * 0.3);\n      g.fillCircle(e.x, e.y, e.size * 0.5);\n    }\n\n    for (let i = 0; i < rs.trail.length; i++) {\n      const t = rs.trail[i];\n      const trailSize = 5 * (1 - i / rs.trail.length);\n      g.fillStyle(this.hslToHex(rs.hue, 80, 55), t.alpha * 0.4);\n      g.fillCircle(t.x, t.y, trailSize * 2);\n      g.fillStyle(this.hslToHex(rs.hue + 30, 70, 70), t.alpha * 0.2);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    g.lineStyle(14, this.hslToHex(rs.hue, 70, 40), 0.2 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    g.lineStyle(8, this.hslToHex(rs.hue, 80, 55), 0.35 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    for (let i = rs.segments.length - 1; i >= 0; i--) {\n      const seg = rs.segments[i];\n      const t = rs.segments.length > 1 ? i / (rs.segments.length - 1) : 1;\n      const segmentPulse = pulse * (0.8 + Math.sin(rs.pulsePhase + i * 0.4) * 0.2);\n\n      const baseSize = 7 + t * 5;\n      const size = baseSize * (0.9 + segmentPulse * 0.15);\n\n      g.fillStyle(this.hslToHex(rs.hue - 10, 60, 35), 0.15 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 2.8);\n\n      g.fillStyle(this.hslToHex(rs.hue, 75, 50), 0.3 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 1.6);\n\n      g.fillStyle(this.hslToHex(rs.hue + 10, 85, 65), 0.6 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size);\n\n      g.fillStyle(this.hslToHex(rs.hue + 40, 60, 90), 0.5 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 0.35);\n\n      if (i === 0) {\n        const dx = rs.direction.dx;\n        const dy = rs.direction.dy;\n        const perpX = -dy;\n        const perpY = dx;\n\n        g.fillStyle(this.hslToHex(rs.hue, 90, 70), 0.3);\n        g.fillCircle(seg.x - dx * 3, seg.y - dy * 3, size * 1.8);\n\n        const eyeOffset = 4;\n        const eyeForward = 5;\n        const leftEyeX = seg.x + perpX * eyeOffset + dx * eyeForward;\n        const leftEyeY = seg.y + perpY * eyeOffset + dy * eyeForward;\n        const rightEyeX = seg.x - perpX * eyeOffset + dx * eyeForward;\n        const rightEyeY = seg.y - perpY * eyeOffset + dy * eyeForward;\n\n        const eyeColor = rs.state === 'hunting' ? 0xff4444 :\n                         rs.state === 'fleeing' ? 0xffff44 : 0x44ffff;\n\n        g.fillStyle(0x000000, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 4);\n        g.fillCircle(rightEyeX, rightEyeY, 4);\n\n        g.fillStyle(eyeColor, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 3);\n        g.fillCircle(rightEyeX, rightEyeY, 3);\n\n        g.fillStyle(0xffffff, 0.95 * segmentPulse);\n        g.fillCircle(leftEyeX + dx, leftEyeY + dy, 1.2);\n        g.fillCircle(rightEyeX + dx, rightEyeY + dy, 1.2);\n\n        const hornLength = 8;\n        const hornAngle = 0.4;\n        g.lineStyle(3, this.hslToHex(rs.hue - 20, 70, 45), 0.8 * segmentPulse);\n        g.beginPath();\n        g.moveTo(seg.x + perpX * 5, seg.y + perpY * 5);\n        g.lineTo(\n          seg.x + perpX * 5 + Math.cos(Math.atan2(dy, dx) - hornAngle) * hornLength,\n          seg.y + perpY * 5 + Math.sin(Math.atan2(dy, dx) - hornAngle) * hornLength\n        );\n        g.strokePath();\n        g.beginPath();\n        g.moveTo(seg.x - perpX * 5, seg.y - perpY * 5);\n        g.lineTo(\n          seg.x - perpX * 5 + Math.cos(Math.atan2(dy, dx) + hornAngle) * hornLength,\n          seg.y - perpY * 5 + Math.sin(Math.atan2(dy, dx) + hornAngle) * hornLength\n        );\n        g.strokePath();\n      }\n    }\n  }\n\n  private drawElectricArc(g: Phaser.GameObjects.Graphics, x1: number, y1: number, x2: number, y2: number, life: number): void {\n    const segments = 6;\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n    const jitter = 15 * life;\n\n    g.lineStyle(4, 0x00ffff, 0.2 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter;\n      const jy = (Math.random() - 0.5) * jitter;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(2, 0x88ffff, 0.5 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter * 0.5;\n      const jy = (Math.random() - 0.5) * jitter * 0.5;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(1, 0xffffff, 0.8 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    g.lineTo(x2, y2);\n    g.strokePath();\n  }\n\n  private spawnBee(): void {\n    if (this.bees.length >= NUM_BEES) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Spawn from random edge\n    const edge = Math.floor(Math.random() * 4);\n    let x: number, y: number;\n\n    switch (edge) {\n      case 0: // top\n        x = Math.random() * width;\n        y = -20;\n        break;\n      case 1: // right\n        x = width + 20;\n        y = Math.random() * height;\n        break;\n      case 2: // bottom\n        x = Math.random() * width;\n        y = height + 20;\n        break;\n      default: // left\n        x = -20;\n        y = Math.random() * height;\n        break;\n    }\n\n    // Random target inside the play area\n    const targetX = 50 + Math.random() * (width - 100);\n    const targetY = 50 + Math.random() * (height - 100);\n\n    this.bees.push({\n      x,\n      y,\n      vx: 0,\n      vy: 0,\n      targetX,\n      targetY,\n      wingPhase: Math.random() * Math.PI * 2,\n      wingSpeed: 0.4 + Math.random() * 0.2,\n      size: 6 + Math.random() * 3,\n      hue: 0 + Math.random() * 20, // Crimson/red volcanic color\n      glowIntensity: 0.5 + Math.random() * 0.5,\n      bobPhase: Math.random() * Math.PI * 2,\n      bobSpeed: 0.08 + Math.random() * 0.04,\n      trail: [],\n      state: 'flying',\n      sparkleTimer: 0,\n    });\n  }\n\n  private updateBees(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n    const gameOver = this.currentState.gameOver;\n\n    // Randomly spawn new bees\n    if (!gameOver && Math.random() < BEE_SPAWN_CHANCE && this.bees.length < NUM_BEES) {\n      this.spawnBee();\n    }\n\n    for (let i = this.bees.length - 1; i >= 0; i--) {\n      const bee = this.bees[i];\n\n      // Update wing animation\n      bee.wingPhase += bee.wingSpeed;\n      bee.bobPhase += bee.bobSpeed;\n      bee.sparkleTimer += 0.1;\n\n      // Store trail position\n      if (this.frameCount % 2 === 0) {\n        bee.trail.unshift({ x: bee.x, y: bee.y, alpha: 0.6 });\n        if (bee.trail.length > 8) bee.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of bee.trail) {\n        t.alpha *= 0.85;\n      }\n      bee.trail = bee.trail.filter(t => t.alpha > 0.05);\n\n      // Bees are attracted to food\n      const dxFood = foodX - bee.x;\n      const dyFood = foodY - bee.y;\n      const distFood = Math.sqrt(dxFood * dxFood + dyFood * dyFood);\n\n      // Determine behavior based on distance to food\n      if (distFood < 80) {\n        bee.state = 'attracted';\n        bee.targetX = foodX + Math.cos(bee.bobPhase * 3) * 30;\n        bee.targetY = foodY + Math.sin(bee.bobPhase * 3) * 30;\n      } else if (distFood < 150) {\n        bee.state = 'hovering';\n        // Circle around food loosely\n        const angle = Math.atan2(dyFood, dxFood) + Math.sin(bee.bobPhase) * 0.5;\n        bee.targetX = foodX - Math.cos(angle) * 60;\n        bee.targetY = foodY - Math.sin(angle) * 60;\n      } else {\n        bee.state = 'flying';\n        // Wander towards food with some randomness\n        if (Math.random() < 0.02) {\n          bee.targetX = foodX + (Math.random() - 0.5) * 200;\n          bee.targetY = foodY + (Math.random() - 0.5) * 200;\n        }\n      }\n\n      // Move towards target with smooth steering\n      const dx = bee.targetX - bee.x;\n      const dy = bee.targetY - bee.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 1) {\n        const speed = bee.state === 'attracted' ? 2.5 : (bee.state === 'hovering' ? 1.5 : 2);\n        const ax = (dx / dist) * speed * 0.1;\n        const ay = (dy / dist) * speed * 0.1;\n\n        bee.vx += ax;\n        bee.vy += ay;\n\n        // Add bobbing motion\n        bee.vy += Math.sin(bee.bobPhase) * 0.05;\n      }\n\n      // Limit velocity\n      const maxSpeed = bee.state === 'attracted' ? 3 : 2;\n      const currentSpeed = Math.sqrt(bee.vx * bee.vx + bee.vy * bee.vy);\n      if (currentSpeed > maxSpeed) {\n        bee.vx = (bee.vx / currentSpeed) * maxSpeed;\n        bee.vy = (bee.vy / currentSpeed) * maxSpeed;\n      }\n\n      // Apply velocity with damping\n      bee.x += bee.vx;\n      bee.y += bee.vy;\n      bee.vx *= 0.95;\n      bee.vy *= 0.95;\n\n      // Pulsing glow when near food\n      if (bee.state === 'attracted') {\n        bee.glowIntensity = 0.7 + Math.sin(bee.bobPhase * 4) * 0.3;\n      } else {\n        bee.glowIntensity = 0.5 + Math.sin(bee.bobPhase * 2) * 0.2;\n      }\n\n      // Remove bees that fly too far off screen\n      if (bee.x < -100 || bee.x > width + 100 || bee.y < -100 || bee.y > height + 100) {\n        this.bees.splice(i, 1);\n      }\n\n      // Scatter bees on game over\n      if (gameOver) {\n        bee.targetX = bee.x + (Math.random() - 0.5) * 400;\n        bee.targetY = bee.y - 200 - Math.random() * 200;\n        bee.vx += (Math.random() - 0.5) * 2;\n        bee.vy -= 1 + Math.random();\n      }\n    }\n  }\n\n  private drawBees(g: Phaser.GameObjects.Graphics): void {\n    for (const bee of this.bees) {\n      const { x, y, size, wingPhase, hue, glowIntensity, trail, state, sparkleTimer } = bee;\n\n      // Draw trail\n      for (let i = 0; i < trail.length; i++) {\n        const t = trail[i];\n        const trailSize = size * 0.4 * (1 - i / trail.length);\n        g.fillStyle(this.hslToHex(hue, 80, 60), t.alpha * 0.4);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      const glowSize = size * 2 * glowIntensity;\n      g.fillStyle(this.hslToHex(hue, 90, 50), 0.2 * glowIntensity);\n      g.fillCircle(x, y, glowSize);\n\n      // Mid glow\n      g.fillStyle(this.hslToHex(hue, 85, 60), 0.3 * glowIntensity);\n      g.fillCircle(x, y, glowSize * 0.6);\n\n      // Bee body - striped pattern\n      const bodyLength = size * 1.2;\n      const bodyWidth = size * 0.7;\n\n      // Body shadow/glow\n      g.fillStyle(this.hslToHex(hue, 70, 30), 0.5);\n      g.fillEllipse(x, y, bodyLength + 2, bodyWidth + 2);\n\n      // Main body (amber/golden)\n      g.fillStyle(this.hslToHex(hue, 90, 55), 1);\n      g.fillEllipse(x, y, bodyLength, bodyWidth);\n\n      // Dark stripes\n      g.fillStyle(0x1a1a1a, 0.8);\n      g.fillRect(x - bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n      g.fillRect(x + bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n\n      // Head\n      g.fillStyle(this.hslToHex(hue - 10, 80, 40), 1);\n      g.fillCircle(x - bodyLength * 0.4, y, size * 0.4);\n\n      // Wings - animated flutter\n      const wingAngle = Math.sin(wingPhase) * 0.8;\n      const wingSize = size * 0.9;\n\n      // Wing glow (ethereal effect)\n      g.fillStyle(0xffffff, 0.2 + Math.abs(Math.sin(wingPhase)) * 0.2);\n      g.fillEllipse(x + Math.cos(wingAngle + 0.5) * wingSize * 0.3, y - wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n      g.fillEllipse(x + Math.cos(-wingAngle + 0.5) * wingSize * 0.3, y + wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n\n      // Wing bodies\n      g.fillStyle(0xffffff, 0.5 + Math.abs(Math.sin(wingPhase)) * 0.3);\n      g.fillEllipse(x + Math.cos(wingAngle) * wingSize * 0.2, y - wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n      g.fillEllipse(x + Math.cos(-wingAngle) * wingSize * 0.2, y + wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n\n      // Eyes\n      g.fillStyle(0x000000, 1);\n      g.fillCircle(x - bodyLength * 0.45, y - size * 0.12, size * 0.12);\n      g.fillCircle(x - bodyLength * 0.45, y + size * 0.12, size * 0.12);\n\n      // Sparkles when attracted to food\n      if (state === 'attracted' && Math.sin(sparkleTimer * 3) > 0.7) {\n        const sparkleAngle = sparkleTimer * 2;\n        const sparkleDist = size * 1.5;\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n\n        g.fillStyle(0xffffff, 0.8);\n        g.fillCircle(sparkleX, sparkleY, 2);\n        g.fillStyle(this.hslToHex(hue, 100, 80), 0.6);\n        g.fillCircle(sparkleX, sparkleY, 3);\n      }\n    }\n  }\n\n  // Helper to convert HSL to hex for Phaser\n  private hslToHex(h: number, s: number, l: number): number {\n    h = h / 360;\n    s = s / 100;\n    l = l / 100;\n\n    let r: number, g: number, b: number;\n\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    return (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255);\n  }\n\n  private updateGuardianSpirits(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const gameOver = this.currentState.gameOver;\n    const snakeHead = this.currentState.snake.length > 0 ? this.currentState.snake[0] : null;\n\n    for (const spirit of this.guardianSpirits) {\n      spirit.phase += spirit.speed;\n      spirit.haloPhase += 0.04;\n      spirit.orbPhase += 0.02;\n\n      for (const orb of spirit.orbs) {\n        orb.angle += orb.speed;\n      }\n\n      const floatAmount = gameOver ? 20 : 12;\n      const waveAmount = 5;\n      const wave = Math.sin(spirit.phase) * waveAmount;\n\n      let targetX = spirit.baseX;\n      let targetY = spirit.baseY;\n\n      switch (spirit.edge) {\n        case 'top':\n          targetY = spirit.baseY + floatAmount + wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'bottom':\n          targetY = spirit.baseY - floatAmount - wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'left':\n          targetX = spirit.baseX + floatAmount + wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'right':\n          targetX = spirit.baseX - floatAmount - wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n      }\n\n      if (snakeHead && !gameOver) {\n        const headX = snakeHead.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = snakeHead.y * CELL_SIZE + CELL_SIZE / 2;\n        const dx = spirit.x - headX;\n        const dy = spirit.y - headY;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        if (dist < 120) {\n          const attraction = (120 - dist) / 120 * 15;\n          targetX += (dx / dist) * attraction;\n          targetY += (dy / dist) * attraction;\n        }\n      }\n\n      spirit.x += (targetX - spirit.x) * 0.04;\n      spirit.y += (targetY - spirit.y) * 0.04;\n      spirit.x = Math.max(-50, Math.min(width + 50, spirit.x));\n      spirit.y = Math.max(-50, Math.min(height + 50, spirit.y));\n\n      const baseAlpha = gameOver ? 0.8 : spirit.targetAlpha;\n      spirit.currentAlpha += (baseAlpha - spirit.currentAlpha) * 0.05;\n    }\n  }\n\n  private drawGuardianSpirits(g: Phaser.GameObjects.Graphics): void {\n    for (const spirit of this.guardianSpirits) {\n      if (spirit.currentAlpha < 0.01) continue;\n\n      const { x, y, size, phase, haloPhase, currentAlpha, hue, orbs } = spirit;\n      const breathPulse = 1 + Math.sin(phase * 2) * 0.15;\n      const coreSize = size * breathPulse;\n\n      const spiritColor = this.hslToHex(hue, 0.7, 0.6);\n      const glowColor = this.hslToHex(hue, 0.5, 0.8);\n      const haloColor = this.hslToHex(hue, 0.3, 0.9);\n\n      g.fillStyle(glowColor, currentAlpha * 0.1);\n      g.fillCircle(x, y, coreSize * 2.5);\n\n      g.fillStyle(glowColor, currentAlpha * 0.15);\n      g.fillCircle(x, y, coreSize * 1.8);\n\n      const haloRadius = coreSize * 1.4 + Math.sin(haloPhase) * 3;\n      g.lineStyle(2, haloColor, currentAlpha * 0.4);\n      g.strokeCircle(x, y, haloRadius);\n\n      const innerHaloRadius = coreSize * 1.1 + Math.sin(haloPhase + 1) * 2;\n      g.lineStyle(1.5, haloColor, currentAlpha * 0.3);\n      g.strokeCircle(x, y, innerHaloRadius);\n\n      for (const orb of orbs) {\n        const orbX = x + Math.cos(orb.angle) * orb.distance;\n        const orbY = y + Math.sin(orb.angle) * orb.distance;\n        const orbPulse = 1 + Math.sin(phase + orb.angle) * 0.3;\n\n        g.fillStyle(glowColor, currentAlpha * 0.3);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse * 1.5);\n\n        g.fillStyle(spiritColor, currentAlpha * 0.8);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse);\n      }\n\n      g.fillStyle(spiritColor, currentAlpha * 0.9);\n      g.fillCircle(x, y, coreSize * 0.5);\n\n      g.fillStyle(0xffffff, currentAlpha * 0.7);\n      g.fillCircle(x, y, coreSize * 0.25);\n\n      const sparkleCount = 4;\n      for (let i = 0; i < sparkleCount; i++) {\n        const sparkleAngle = (i / sparkleCount) * Math.PI * 2 + phase * 0.5;\n        const sparkleDist = coreSize * (0.8 + Math.sin(phase * 2 + i) * 0.3);\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n        const sparkleSize = 1.5 + Math.sin(phase * 3 + i * 2) * 0.5;\n\n        g.fillStyle(0xffffff, currentAlpha * (0.4 + Math.sin(phase * 2 + i) * 0.3));\n        g.fillCircle(sparkleX, sparkleY, sparkleSize);\n      }\n    }\n  }\n\n  private initStars(): void {\n    this.stars = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_STARS; i++) {\n      this.stars.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: 0.5 + Math.random() * 1.5,\n        speed: 0.02 + Math.random() * 0.03,\n        brightness: 0.3 + Math.random() * 0.7,\n      });\n    }\n  }\n\n  private initPlasmaWaves(): void {\n    this.plasmaWaves = [];\n    const hues = [0, 15, 30]; // Red/orange volcanic variations\n    for (let i = 0; i < NUM_PLASMA_WAVES; i++) {\n      this.plasmaWaves.push({\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.015 + Math.random() * 0.01,\n        amplitude: 30 + Math.random() * 20,\n        wavelength: 80 + Math.random() * 40,\n        hue: hues[i % hues.length],\n      });\n    }\n  }\n\n  private initAuroraWaves(): void {\n    this.auroraWaves = [];\n    const height = GRID_SIZE * CELL_SIZE;\n    // Aurora hues: volcanic reds, oranges, crimsons\n    const auroraHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_AURORA_WAVES; i++) {\n      this.auroraWaves.push({\n        y: height * 0.2 + (height * 0.6 * i) / NUM_AURORA_WAVES,\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.008 + Math.random() * 0.006,\n        hue: auroraHues[i % auroraHues.length],\n        thickness: 25 + Math.random() * 20,\n        amplitude: 15 + Math.random() * 25,\n      });\n    }\n  }\n\n  private initNebulaClouds(): void {\n    this.nebulaClouds = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    // Volcanic smoke and lava glow colors: reds, oranges, crimsons\n    const nebulaHues = [0, 10, 20, 30, 350, 340];\n    for (let i = 0; i < NUM_NEBULA_CLOUDS; i++) {\n      this.nebulaClouds.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        radius: 40 + Math.random() * 60,\n        hue: nebulaHues[i % nebulaHues.length],\n        alpha: 0.04 + Math.random() * 0.04,\n        driftX: (Math.random() - 0.5) * 0.15,\n        driftY: (Math.random() - 0.5) * 0.15,\n        pulsePhase: Math.random() * Math.PI * 2,\n        pulseSpeed: 0.01 + Math.random() * 0.01,\n      });\n    }\n  }\n\n  private initVortex(): void {\n    this.vortexRings = [];\n    this.vortexParticles = [];\n\n    // Create concentric rings with different properties\n    const ringHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_VORTEX_RINGS; i++) {\n      const baseRadius = 25 + i * 18;\n      this.vortexRings.push({\n        radius: baseRadius,\n        baseRadius,\n        rotationOffset: (i * Math.PI * 2) / NUM_VORTEX_RINGS,\n        rotationSpeed: 0.02 - i * 0.003,\n        thickness: 2 + (NUM_VORTEX_RINGS - i) * 0.5,\n        hue: ringHues[i % ringHues.length],\n        pulsePhase: i * 0.5,\n      });\n    }\n\n    // Create orbiting particles\n    for (let i = 0; i < NUM_VORTEX_PARTICLES; i++) {\n      const baseRadius = 20 + Math.random() * 80;\n      this.vortexParticles.push({\n        angle: Math.random() * Math.PI * 2,\n        radius: baseRadius,\n        baseRadius,\n        speed: 0.02 + Math.random() * 0.03,\n        size: 1 + Math.random() * 2,\n        hue: Math.random() * 360,\n        alpha: 0.3 + Math.random() * 0.5,\n      });\n    }\n  }\n\n  private initMeteors(): void {\n    this.meteors = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_METEORS; i++) {\n      this.spawnMeteor(width, height, true);\n    }\n  }\n\n  private spawnMeteor(width: number, height: number, initial = false): void {\n    if (this.meteors.length >= NUM_METEORS) return;\n\n    // Meteors come from top-right and travel to bottom-left\n    const startX = initial ? Math.random() * width * 1.5 : width + 20 + Math.random() * 40;\n    const startY = initial ? Math.random() * height * 0.5 - height * 0.25 : -20 - Math.random() * 40;\n\n    // Random angle variation (mostly diagonal)\n    const angle = Math.PI * 0.65 + (Math.random() - 0.5) * 0.4;\n    const speed = 1.5 + Math.random() * 2;\n\n    this.meteors.push({\n      x: startX,\n      y: startY,\n      vx: -Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed,\n      size: 2 + Math.random() * 3,\n      hue: Math.random() < 0.3 ? 0 + Math.random() * 30 : 20 + Math.random() * 40, // Red or orange volcanic\n      alpha: 0.6 + Math.random() * 0.4,\n      trail: [],\n      life: 1,\n    });\n  }\n\n  private updateMeteors(width: number, height: number): void {\n    for (let i = this.meteors.length - 1; i >= 0; i--) {\n      const m = this.meteors[i];\n\n      // Store trail position\n      m.trail.unshift({ x: m.x, y: m.y, alpha: m.alpha });\n      if (m.trail.length > 12) m.trail.pop();\n\n      // Update position\n      m.x += m.vx;\n      m.y += m.vy;\n\n      // Check if meteor is out of bounds\n      if (m.x < -50 || m.y > height + 50) {\n        this.meteors.splice(i, 1);\n        // Spawn a new one\n        this.spawnMeteor(width, height, false);\n      }\n    }\n  }\n\n  private spawnDeathExplosion(): void {\n    if (!this.currentState) return;\n\n    this.deathDebris = [];\n    this.deathExplosionPhase = 1;\n\n    // Spawn debris from each snake segment\n    for (let i = 0; i < this.currentState.snake.length; i++) {\n      const seg = this.currentState.snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const segHue = (this.hueOffset + i * 15) % 360;\n\n      // Create debris particles per segment (limit total)\n      const debrisPerSeg = Math.min(3, Math.floor(MAX_DEATH_DEBRIS / this.currentState.snake.length));\n      for (let j = 0; j < debrisPerSeg; j++) {\n        if (this.deathDebris.length >= MAX_DEATH_DEBRIS) break;\n\n        const angle = Math.random() * Math.PI * 2;\n        const speed = 2 + Math.random() * 4;\n        const types: ('shard' | 'spark' | 'ember')[] = ['shard', 'spark', 'ember'];\n\n        this.deathDebris.push({\n          x: cx + (Math.random() - 0.5) * 8,\n          y: cy + (Math.random() - 0.5) * 8,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed - 1,\n          size: 3 + Math.random() * 5,\n          hue: segHue + (Math.random() - 0.5) * 40,\n          rotation: Math.random() * Math.PI * 2,\n          rotationSpeed: (Math.random() - 0.5) * 0.4,\n          life: 1,\n          type: types[Math.floor(Math.random() * types.length)],\n        });\n      }\n    }\n  }\n\n  private updateDeathDebris(): void {\n    // Decay explosion phase\n    if (this.deathExplosionPhase > 0) {\n      this.deathExplosionPhase *= 0.95;\n      if (this.deathExplosionPhase < 0.01) this.deathExplosionPhase = 0;\n    }\n\n    for (let i = this.deathDebris.length - 1; i >= 0; i--) {\n      const d = this.deathDebris[i];\n\n      // Update position with gravity\n      d.x += d.vx;\n      d.y += d.vy;\n      d.vy += 0.08; // gravity\n      d.vx *= 0.99; // air resistance\n\n      // Update rotation\n      d.rotation += d.rotationSpeed;\n\n      // Decay life\n      d.life -= 0.015;\n\n      if (d.life <= 0) {\n        this.deathDebris.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnFoodParticles(foodX: number, foodY: number): void {\n    if (this.foodParticles.length < MAX_FOOD_PARTICLES && Math.random() < 0.15) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.3 + Math.random() * 0.5;\n      this.foodParticles.push({\n        x: foodX,\n        y: foodY,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 0.5,\n        life: 1,\n        maxLife: 40 + Math.random() * 20,\n        size: 1 + Math.random() * 2,\n      });\n    }\n  }\n\n  private updateParticles(): void {\n    for (let i = this.foodParticles.length - 1; i >= 0; i--) {\n      const p = this.foodParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy += 0.02;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.foodParticles.splice(i, 1);\n      }\n    }\n    // Update trail particles\n    for (let i = this.trailParticles.length - 1; i >= 0; i--) {\n      const p = this.trailParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.trailParticles.splice(i, 1);\n      }\n    }\n    // Update shockwaves\n    for (let i = this.shockWaves.length - 1; i >= 0; i--) {\n      const sw = this.shockWaves[i];\n      sw.radius += 3;\n      sw.life -= 0.04;\n      if (sw.life <= 0 || sw.radius >= sw.maxRadius) {\n        this.shockWaves.splice(i, 1);\n      }\n    }\n    // Update lightning bolts\n    for (let i = this.lightningBolts.length - 1; i >= 0; i--) {\n      const bolt = this.lightningBolts[i];\n      bolt.life -= 1 / bolt.maxLife;\n      if (bolt.life <= 0) {\n        this.lightningBolts.splice(i, 1);\n      }\n    }\n    // Update afterimages\n    for (let i = this.snakeAfterimages.length - 1; i >= 0; i--) {\n      const ai = this.snakeAfterimages[i];\n      ai.life -= 1 / ai.maxLife;\n      if (ai.life <= 0) {\n        this.snakeAfterimages.splice(i, 1);\n      }\n    }\n    // Decay screen flash\n    if (this.screenFlashAlpha > 0) {\n      this.screenFlashAlpha -= 0.08;\n      if (this.screenFlashAlpha < 0) this.screenFlashAlpha = 0;\n    }\n\n    // Update screen shake\n    if (this.screenShakeIntensity > 0) {\n      this.screenShakeX = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeY = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeIntensity *= 0.9;\n      if (this.screenShakeIntensity < 0.5) {\n        this.screenShakeIntensity = 0;\n        this.screenShakeX = 0;\n        this.screenShakeY = 0;\n      }\n    }\n\n    // Decay chromatic aberration\n    if (this.chromaticIntensity > 0) {\n      this.chromaticIntensity *= 0.92;\n      if (this.chromaticIntensity < 0.05) this.chromaticIntensity = 0;\n    }\n\n    // Decay energy field pulse\n    if (this.energyFieldPulse > 0) {\n      this.energyFieldPulse *= 0.95;\n      if (this.energyFieldPulse < 0.05) this.energyFieldPulse = 0;\n    }\n\n    // Update food burst particles\n    for (let i = this.foodBurstParticles.length - 1; i >= 0; i--) {\n      const p = this.foodBurstParticles[i];\n      // Store trail position\n      p.trail.unshift({ x: p.x, y: p.y });\n      if (p.trail.length > 6) p.trail.pop();\n      // Update position\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vx *= 0.96;\n      p.vy *= 0.96;\n      p.life -= 0.025;\n      if (p.life <= 0) {\n        this.foodBurstParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnTrailParticles(x: number, y: number): void {\n    if (this.trailParticles.length >= MAX_TRAIL_PARTICLES) return;\n    // Spawn 2-3 particles per movement\n    const count = 2 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < count; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.2 + Math.random() * 0.4;\n      this.trailParticles.push({\n        x: x + (Math.random() - 0.5) * 8,\n        y: y + (Math.random() - 0.5) * 8,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        maxLife: 25 + Math.random() * 15,\n        size: 2 + Math.random() * 3,\n        hue: this.hueOffset + Math.random() * 30,\n      });\n    }\n  }\n\n  updateGameState(state: GameState): void {\n    // Detect food eaten - snake got longer\n    if (this.currentState && state.snake.length > this.lastSnakeLength) {\n      const head = state.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n      this.spawnShockWave(headX, headY);\n      this.spawnLightningBurst(headX, headY);\n      this.spawnFoodBurst(headX, headY);\n      this.spawnChaosExplosion(headX, headY); // Armageddon chaos explosion\n      this.screenFlashAlpha = 0.8; // More intense flash for armageddon\n      this.chromaticIntensity = 1.5; // Stronger chromatic aberration\n      this.energyFieldPulse = 1.0; // Trigger energy field expansion\n    }\n    this.lastSnakeLength = state.snake.length;\n\n    // Detect food position change - trigger thrown food animation\n    const newFood = state.food;\n    if (this.lastFoodPos && (newFood.x !== this.lastFoodPos.x || newFood.y !== this.lastFoodPos.y)) {\n      this.spawnThrownFood(newFood.x, newFood.y);\n    } else if (!this.lastFoodPos && !state.gameOver) {\n      // First food spawn\n      this.spawnThrownFood(newFood.x, newFood.y);\n    }\n    this.lastFoodPos = { x: newFood.x, y: newFood.y };\n\n    // Create afterimage when snake moves\n    if (this.currentState && state.snake.length > 0) {\n      const oldHead = this.currentState.snake[0];\n      const newHead = state.snake[0];\n      if (oldHead && newHead && (oldHead.x !== newHead.x || oldHead.y !== newHead.y)) {\n        this.spawnAfterimage(this.currentState.snake);\n      }\n    }\n\n    // Detect game over transition - ARMAGEDDON CHAOS death sequence\n    if (state.gameOver && this.currentState && !this.currentState.gameOver) {\n      this.screenShakeIntensity = 25; // Massive screen shake on death\n      this.chromaticIntensity = 3.0; // Maximum chromatic aberration on death\n      this.chaosIntensity = 1.0; // Full chaos overlay\n      this.spawnDeathExplosion(); // Dramatic death explosion\n      // Spawn chaos explosions across the snake body\n      for (let i = 0; i < Math.min(3, state.snake.length); i++) {\n        const seg = state.snake[Math.floor(i * state.snake.length / 3)];\n        setTimeout(() => {\n          this.spawnChaosExplosion(\n            seg.x * CELL_SIZE + CELL_SIZE / 2,\n            seg.y * CELL_SIZE + CELL_SIZE / 2\n          );\n        }, i * 50);\n      }\n    }\n\n    this.currentState = state;\n    this.needsRedraw = true;\n    if (!state.gameOver) {\n      this.gameOverAlpha = 0;\n      this.gameOverGlitchOffset = 0;\n      this.screenShakeIntensity = 0;\n    }\n  }\n\n  private spawnShockWave(x: number, y: number): void {\n    if (this.shockWaves.length >= MAX_SHOCKWAVES) {\n      this.shockWaves.shift();\n    }\n    this.shockWaves.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: CELL_SIZE * 3,\n      life: 1,\n    });\n  }\n\n  private spawnAfterimage(snake: Position[]): void {\n    if (this.snakeAfterimages.length >= MAX_AFTERIMAGES) {\n      this.snakeAfterimages.shift();\n    }\n    this.snakeAfterimages.push({\n      segments: snake.map(s => ({ x: s.x, y: s.y })),\n      life: 1,\n      maxLife: 12,\n      hueOffset: this.hueOffset,\n    });\n  }\n\n  private spawnLightningBurst(x: number, y: number): void {\n    const numBolts = 3 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < numBolts; i++) {\n      if (this.lightningBolts.length >= MAX_LIGHTNING_BOLTS) {\n        this.lightningBolts.shift();\n      }\n      const angle = (Math.PI * 2 * i) / numBolts + Math.random() * 0.5;\n      const length = 30 + Math.random() * 40;\n      const endX = x + Math.cos(angle) * length;\n      const endY = y + Math.sin(angle) * length;\n      this.lightningBolts.push({\n        points: this.generateLightningPath(x, y, endX, endY),\n        life: 1,\n        maxLife: 15 + Math.random() * 10,\n        hue: this.hueOffset + Math.random() * 60,\n      });\n    }\n  }\n\n  private generateLightningPath(x1: number, y1: number, x2: number, y2: number): { x: number; y: number }[] {\n    const points: { x: number; y: number }[] = [{ x: x1, y: y1 }];\n    const segments = 4 + Math.floor(Math.random() * 3);\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n\n    for (let i = 1; i < segments; i++) {\n      const jitter = 8;\n      points.push({\n        x: x1 + dx * i + (Math.random() - 0.5) * jitter,\n        y: y1 + dy * i + (Math.random() - 0.5) * jitter,\n      });\n    }\n    points.push({ x: x2, y: y2 });\n    return points;\n  }\n\n  private spawnFoodBurst(x: number, y: number): void {\n    // Clear old particles and spawn new dramatic burst\n    this.foodBurstParticles = [];\n    const numParticles = MAX_BURST_PARTICLES;\n    for (let i = 0; i < numParticles; i++) {\n      const angle = (i / numParticles) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 4;\n      this.foodBurstParticles.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        size: 3 + Math.random() * 4,\n        hue: this.hueOffset + Math.random() * 60,\n        trail: [],\n      });\n    }\n  }\n\n  private spawnThrownFood(targetGridX: number, targetGridY: number): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const targetX = targetGridX * CELL_SIZE + CELL_SIZE / 2;\n    const targetY = targetGridY * CELL_SIZE + CELL_SIZE / 2;\n\n    // Choose random edge to throw from\n    const edge = Math.floor(Math.random() * 4);\n    let startX: number, startY: number;\n\n    switch (edge) {\n      case 0: // top\n        startX = Math.random() * width;\n        startY = -40;\n        break;\n      case 1: // right\n        startX = width + 40;\n        startY = Math.random() * height;\n        break;\n      case 2: // bottom\n        startX = Math.random() * width;\n        startY = height + 40;\n        break;\n      default: // left\n        startX = -40;\n        startY = Math.random() * height;\n        break;\n    }\n\n    this.thrownFood = {\n      startX,\n      startY,\n      targetX,\n      targetY,\n      x: startX,\n      y: startY,\n      progress: 0,\n      rotation: 0,\n      rotationSpeed: (Math.random() - 0.5) * 0.6,\n      trail: [],\n      landed: false,\n      landingParticles: [],\n      impactRings: [],\n    };\n  }\n\n  private updateThrownFood(): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    if (!tf.landed) {\n      // Update progress\n      tf.progress += 0.04;\n\n      // Store trail\n      if (this.frameCount % 2 === 0) {\n        tf.trail.unshift({ x: tf.x, y: tf.y, alpha: 1, rotation: tf.rotation });\n        if (tf.trail.length > 12) tf.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.85;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Calculate position with parabolic arc\n      const t = tf.progress;\n      const arcHeight = 80;\n      const arc = 4 * arcHeight * t * (1 - t);\n      tf.x = tf.startX + (tf.targetX - tf.startX) * t;\n      tf.y = tf.startY + (tf.targetY - tf.startY) * t - arc;\n\n      // Rotation\n      tf.rotation += tf.rotationSpeed;\n\n      // Check if landed\n      if (tf.progress >= 1) {\n        tf.landed = true;\n        tf.x = tf.targetX;\n        tf.y = tf.targetY;\n\n        // Spawn landing effects\n        this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 6);\n\n        // Impact rings\n        tf.impactRings = [\n          { radius: 5, alpha: 1 },\n          { radius: 3, alpha: 0.8 },\n        ];\n\n        // Landing particles\n        for (let i = 0; i < 10; i++) {\n          const angle = (i / 10) * Math.PI * 2 + Math.random() * 0.3;\n          const speed = 2 + Math.random() * 3;\n          tf.landingParticles.push({\n            x: tf.targetX,\n            y: tf.targetY,\n            vx: Math.cos(angle) * speed,\n            vy: Math.sin(angle) * speed - 1,\n            life: 1,\n            size: 2 + Math.random() * 3,\n          });\n        }\n      }\n    } else {\n      // Update landing effects\n      for (const ring of tf.impactRings) {\n        ring.radius += 3;\n        ring.alpha *= 0.9;\n      }\n      tf.impactRings = tf.impactRings.filter(r => r.alpha > 0.05);\n\n      for (let i = tf.landingParticles.length - 1; i >= 0; i--) {\n        const p = tf.landingParticles[i];\n        p.x += p.vx;\n        p.y += p.vy;\n        p.vy += 0.15;\n        p.vx *= 0.98;\n        p.life -= 0.04;\n        if (p.life <= 0) {\n          tf.landingParticles.splice(i, 1);\n        }\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.8;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Clear thrown food when effects are done\n      if (tf.impactRings.length === 0 && tf.landingParticles.length === 0 && tf.trail.length === 0) {\n        this.thrownFood = null;\n      }\n    }\n  }\n\n  private drawThrownFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    // Draw trail\n    for (let i = 0; i < tf.trail.length; i++) {\n      const t = tf.trail[i];\n      const trailProgress = i / tf.trail.length;\n      const trailSize = (CELL_SIZE / 2) * (1 - trailProgress * 0.5) * t.alpha;\n\n      // Trail glow\n      g.fillStyle(COLORS.foodGlow, t.alpha * 0.3);\n      g.fillCircle(t.x, t.y, trailSize * 1.5);\n\n      // Trail core\n      g.fillStyle(COLORS.food, t.alpha * 0.6);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    // Draw impact rings\n    for (const ring of tf.impactRings) {\n      g.lineStyle(3, COLORS.foodGlow, ring.alpha * 0.5);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n      g.lineStyle(1.5, COLORS.noirWhite, ring.alpha * 0.7);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n    }\n\n    // Draw landing particles\n    for (const p of tf.landingParticles) {\n      g.fillStyle(COLORS.foodGlow, p.life * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Draw the flying food if not landed\n    if (!tf.landed) {\n      const scale = 0.8 + tf.progress * 0.4;\n      const foodSize = (CELL_SIZE / 2) * scale;\n\n      // Motion blur glow\n      g.fillStyle(COLORS.foodGlow, 0.3);\n      g.fillCircle(tf.x, tf.y, foodSize * 2);\n\n      // Outer glow\n      g.fillStyle(COLORS.noirWhite, 0.4);\n      g.fillCircle(tf.x, tf.y, foodSize * 1.5);\n\n      // Main food body\n      g.fillStyle(COLORS.food, 0.95);\n      g.fillCircle(tf.x, tf.y, foodSize);\n\n      // Spinning highlight\n      const highlightAngle = tf.rotation;\n      const highlightX = tf.x + Math.cos(highlightAngle) * foodSize * 0.3;\n      const highlightY = tf.y + Math.sin(highlightAngle) * foodSize * 0.3;\n      g.fillStyle(0xffffff, 0.9);\n      g.fillCircle(highlightX, highlightY, foodSize * 0.25);\n\n      // Secondary sparkle\n      const sparkleAngle = tf.rotation + Math.PI * 0.7;\n      const sparkleX = tf.x + Math.cos(sparkleAngle) * foodSize * 0.4;\n      const sparkleY = tf.y + Math.sin(sparkleAngle) * foodSize * 0.4;\n      g.fillStyle(0xffffff, 0.6);\n      g.fillCircle(sparkleX, sparkleY, foodSize * 0.15);\n    }\n  }\n\n  update(): void {\n    this.frameCount++;\n    this.cleanEffects.frameCount = this.frameCount;\n\n    const width = this.scale.width;\n    const height = this.scale.height;\n\n    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n\n    if (this.currentState && this.currentState.snake.length > 0) {\n      const head = this.currentState.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n        updateGlowTrail(this.cleanEffects, headX, headY);\n      }\n      this.lastHeadPos = { x: head.x, y: head.y };\n\n      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n        const food = this.currentState.food;\n        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnRipple(this.cleanEffects, foodX, foodY);\n      }\n      this.lastSnakeLength = this.currentState.snake.length;\n    }\n\n    const g = this.graphics;\n    g.clear();\n    g.setPosition(0, 0);\n\n    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n\n    if (!this.currentState) return;\n\n    drawGlowTrail(g, this.cleanEffects);\n    drawRipples(g, this.cleanEffects);\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n\n    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawCleanVignette(g, width, height);\n\n    const score = this.currentState.score || 0;\n    const snakeLength = this.currentState.snake.length;\n    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n\n    if (this.currentState.gameOver) {\n      this.drawGameOver(g, width, height);\n      this.drawScoreboard(g, width, height);\n    }\n\n    this.checkAndSaveHighScore();\n    this.needsRedraw = false;\n  }\n\n  private drawStars(g: Phaser.GameObjects.Graphics): void {\n    // In film noir mode, stars are subtle distant lights\n    for (const star of this.stars) {\n      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n      const alpha = star.brightness * twinkle * 0.25;\n      g.fillStyle(COLORS.star, alpha);\n      g.fillCircle(star.x, star.y, star.size * 0.7);\n    }\n  }\n\n  private updateSmokeParticles(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (const smoke of this.smokeParticles) {\n      smoke.x += smoke.vx;\n      smoke.y += smoke.vy;\n      smoke.life -= 0.002;\n      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n        smoke.x = Math.random() * width;\n        smoke.y = height + smoke.size;\n        smoke.life = 1;\n        smoke.size = 30 + Math.random() * 50;\n        smoke.alpha = 0.02 + Math.random() * 0.03;\n      }\n      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n    }\n  }\n\n  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Create dramatic spotlight effect centered on snake\n    const cx = this.spotlightX || width / 2;\n    const cy = this.spotlightY || height / 2;\n    const pulse = 0.9 + Math.sin(this.frameCount * 0.03) * 0.1;\n\n    // Outer darkness vignette\n    g.fillStyle(0x000000, 0.6);\n    g.fillRect(0, 0, width, height);\n\n    // Spotlight cone - multiple layers for smooth falloff\n    const layers = 4;\n    for (let i = layers; i > 0; i--) {\n      const layerRadius = (width * 0.4 + i * 30) * pulse;\n      const layerAlpha = 0.15 * (1 - i / (layers + 1));\n      g.fillStyle(COLORS.spotlight, layerAlpha);\n      g.fillCircle(cx, cy, layerRadius);\n    }\n\n    // Bright center\n    g.fillStyle(COLORS.noirWhite, 0.08 * pulse);\n    g.fillCircle(cx, cy, width * 0.25);\n  }\n\n  private drawVenetianBlinds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Horizontal light streaks simulating light through venetian blinds\n    const blindSpacing = 25;\n    const blindWidth = 8;\n    const waveOffset = Math.sin(this.venetianPhase) * 10;\n\n    for (let y = waveOffset; y < height; y += blindSpacing) {\n      const brightness = 0.03 + Math.sin(y * 0.02 + this.venetianPhase * 2) * 0.015;\n      g.fillStyle(COLORS.noirWhite, brightness);\n      g.fillRect(0, y, width, blindWidth);\n    }\n\n    // Diagonal shadow bars from window frame\n    const diagonalAlpha = 0.04 + Math.sin(this.frameCount * 0.02) * 0.01;\n    g.fillStyle(0x000000, diagonalAlpha);\n    for (let i = -2; i < 6; i++) {\n      const x1 = i * 100 + Math.sin(this.venetianPhase) * 20;\n      g.beginPath();\n      g.moveTo(x1, 0);\n      g.lineTo(x1 + 40, 0);\n      g.lineTo(x1 + 40 + height * 0.3, height);\n      g.lineTo(x1 + height * 0.3, height);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawSmoke(g: Phaser.GameObjects.Graphics): void {\n    for (const smoke of this.smokeParticles) {\n      const alpha = smoke.alpha * smoke.life;\n      g.fillStyle(COLORS.noirGray, alpha);\n      g.fillCircle(smoke.x, smoke.y, smoke.size);\n      g.fillStyle(COLORS.noirWhite, alpha * 0.3);\n      g.fillCircle(smoke.x, smoke.y, smoke.size * 0.5);\n    }\n  }\n\n  private spawnFlameParticle(x: number, y: number, intensity: number): void {\n    if (this.flameParticles.length >= MAX_FLAME_PARTICLES) {\n      this.flameParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.6;\n    const life = 0.5 + Math.random() * 0.5;\n\n    this.flameParticles.push({\n      x: x + (Math.random() - 0.5) * 6,\n      y: y + (Math.random() - 0.5) * 6,\n      vx: Math.cos(angle) * speed * 0.3,\n      vy: -0.5 - Math.random() * 1.5 * intensity,\n      size: 3 + Math.random() * 4 * intensity,\n      life,\n      maxLife: life,\n      hue: 10 + Math.random() * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n    });\n  }\n\n  private updateFlameParticles(): void {\n    for (let i = this.flameParticles.length - 1; i >= 0; i--) {\n      const p = this.flameParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.02;\n      p.vx *= 0.98;\n      p.size *= 0.97;\n      p.life -= 0.025;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.flameParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private drawFlameParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.flameParticles) {\n      const lifeRatio = p.life / p.maxLife;\n\n      // Hue shifts from yellow-orange (high life) to red (low life)\n      const hue = p.hue - (1 - lifeRatio) * 15;\n      const outerColor = this.hslToRgb(hue / 360, 1, 0.3 + lifeRatio * 0.2);\n      const midColor = this.hslToRgb(hue / 360, 1, 0.5 + lifeRatio * 0.2);\n      const coreColor = this.hslToRgb((hue + 20) / 360, 0.7, 0.7 + lifeRatio * 0.2);\n\n      // Outer glow\n      g.fillStyle(outerColor, lifeRatio * 0.3);\n      g.fillCircle(p.x, p.y, p.size * 2);\n\n      // Mid flame\n      g.fillStyle(midColor, lifeRatio * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3);\n\n      // Core (bright yellow/white)\n      g.fillStyle(coreColor, lifeRatio * 0.8);\n      g.fillCircle(p.x, p.y, p.size * 0.6);\n    }\n  }\n\n  private spawnFlamesAlongSnake(): void {\n    if (!this.currentState || this.currentState.gameOver) return;\n\n    const snake = this.currentState.snake;\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const segX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const segY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const intensity = 1 - (i / snake.length) * 0.6;\n      if (Math.random() < 0.4 * intensity) {\n        this.spawnFlameParticle(segX, segY, intensity);\n      }\n    }\n  }\n\n  private drawMeteors(g: Phaser.GameObjects.Graphics): void {\n    for (const m of this.meteors) {\n      const meteorColor = this.hslToRgb(m.hue / 360, 0.9, 0.6);\n      const coreColor = this.hslToRgb(m.hue / 360, 0.6, 0.9);\n\n      // Draw trail (oldest to newest for proper layering)\n      for (let i = m.trail.length - 1; i >= 0; i--) {\n        const t = m.trail[i];\n        const trailProgress = 1 - i / m.trail.length;\n        const trailAlpha = t.alpha * trailProgress * 0.4;\n        const trailSize = m.size * trailProgress * 0.6;\n\n        g.fillStyle(meteorColor, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      g.fillStyle(meteorColor, m.alpha * 0.3);\n      g.fillCircle(m.x, m.y, m.size * 2);\n\n      // Main meteor body\n      g.fillStyle(meteorColor, m.alpha * 0.8);\n      g.fillCircle(m.x, m.y, m.size);\n\n      // Bright core\n      g.fillStyle(coreColor, m.alpha);\n      g.fillCircle(m.x, m.y, m.size * 0.5);\n    }\n  }\n\n  private drawDeathDebris(g: Phaser.GameObjects.Graphics): void {\n    // Draw explosion flash at the beginning\n    if (this.deathExplosionPhase > 0.7) {\n      const flashAlpha = (this.deathExplosionPhase - 0.7) * 2;\n      g.fillStyle(0xffffff, flashAlpha * 0.5);\n      g.fillRect(0, 0, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);\n    }\n\n    for (const d of this.deathDebris) {\n      // Film noir: grayscale debris\n      const brightness = 0.4 + (d.hue % 60) / 100;\n      const color = this.hslToRgb(0, 0, brightness);\n      const alpha = d.life * 0.9;\n\n      g.save();\n\n      if (d.type === 'shard') {\n        // Draw triangular shards\n        const cx = d.x;\n        const cy = d.y;\n        const size = d.size * d.life;\n\n        // Calculate rotated triangle points\n        const cos = Math.cos(d.rotation);\n        const sin = Math.sin(d.rotation);\n\n        const p1x = cx + cos * size;\n        const p1y = cy + sin * size;\n        const p2x = cx + cos * (-size * 0.5) - sin * (size * 0.7);\n        const p2y = cy + sin * (-size * 0.5) + cos * (size * 0.7);\n        const p3x = cx + cos * (-size * 0.5) - sin * (-size * 0.7);\n        const p3y = cy + sin * (-size * 0.5) + cos * (-size * 0.7);\n\n        // Glow\n        g.fillStyle(color, alpha * 0.4);\n        g.fillCircle(cx, cy, size * 1.5);\n\n        // Shard body\n        g.fillStyle(color, alpha);\n        g.fillTriangle(p1x, p1y, p2x, p2y, p3x, p3y);\n\n        // Highlight edge\n        g.lineStyle(1, 0xffffff, alpha * 0.6);\n        g.lineBetween(p1x, p1y, p2x, p2y);\n\n      } else if (d.type === 'spark') {\n        // Draw elongated spark\n        const sparkLength = d.size * 2 * d.life;\n        const sparkWidth = d.size * 0.3 * d.life;\n\n        // Direction based on velocity\n        const vLen = Math.sqrt(d.vx * d.vx + d.vy * d.vy);\n        const nx = vLen > 0 ? d.vx / vLen : 1;\n        const ny = vLen > 0 ? d.vy / vLen : 0;\n\n        // Glow\n        g.fillStyle(color, alpha * 0.3);\n        g.fillCircle(d.x, d.y, sparkLength * 0.8);\n\n        // Spark line\n        g.lineStyle(sparkWidth * 2, color, alpha * 0.6);\n        g.lineBetween(d.x - nx * sparkLength, d.y - ny * sparkLength, d.x, d.y);\n\n        // Bright tip\n        g.lineStyle(sparkWidth, 0xffffff, alpha);\n        g.lineBetween(d.x - nx * sparkLength * 0.3, d.y - ny * sparkLength * 0.3, d.x, d.y);\n\n      } else {\n        // Ember - glowing circle\n        const emberSize = d.size * d.life;\n\n        // Outer glow\n        g.fillStyle(color, alpha * 0.2);\n        g.fillCircle(d.x, d.y, emberSize * 2);\n\n        // Mid glow\n        g.fillStyle(color, alpha * 0.5);\n        g.fillCircle(d.x, d.y, emberSize * 1.3);\n\n        // Core\n        g.fillStyle(color, alpha);\n        g.fillCircle(d.x, d.y, emberSize);\n\n        // Hot center\n        g.fillStyle(0xffffff, alpha * 0.7);\n        g.fillCircle(d.x, d.y, emberSize * 0.4);\n      }\n\n      g.restore();\n    }\n  }\n\n  private drawNebulaClouds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const cloud of this.nebulaClouds) {\n      // Update cloud position (slow drift)\n      cloud.x += cloud.driftX;\n      cloud.y += cloud.driftY;\n      cloud.pulsePhase += cloud.pulseSpeed;\n\n      // Wrap around edges\n      if (cloud.x < -cloud.radius) cloud.x = width + cloud.radius;\n      if (cloud.x > width + cloud.radius) cloud.x = -cloud.radius;\n      if (cloud.y < -cloud.radius) cloud.y = height + cloud.radius;\n      if (cloud.y > height + cloud.radius) cloud.y = -cloud.radius;\n\n      // Pulsing alpha\n      const pulseAlpha = cloud.alpha * (0.7 + Math.sin(cloud.pulsePhase) * 0.3);\n      const color = this.hslToRgb(cloud.hue / 360, 0.6, 0.3);\n\n      // Draw multiple concentric layers for soft cloud effect\n      const layers = 4;\n      for (let i = layers; i > 0; i--) {\n        const layerRadius = cloud.radius * (i / layers);\n        const layerAlpha = pulseAlpha * (1 - i / (layers + 1)) * 0.6;\n        g.fillStyle(color, layerAlpha);\n        g.fillCircle(cloud.x, cloud.y, layerRadius);\n      }\n\n      // Core glow\n      const coreColor = this.hslToRgb(cloud.hue / 360, 0.8, 0.5);\n      g.fillStyle(coreColor, pulseAlpha * 0.4);\n      g.fillCircle(cloud.x, cloud.y, cloud.radius * 0.3);\n    }\n  }\n\n  private drawVortex(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Update vortex pulse\n    this.vortexPulse += 0.03;\n    const globalPulse = 0.8 + Math.sin(this.vortexPulse) * 0.2;\n\n    // Draw outer glow/halo\n    const outerGlowColor = this.hslToRgb(280 / 360, 0.7, 0.3);\n    g.fillStyle(outerGlowColor, 0.08 * globalPulse);\n    g.fillCircle(centerX, centerY, 120);\n    g.fillStyle(outerGlowColor, 0.05 * globalPulse);\n    g.fillCircle(centerX, centerY, 140);\n\n    // Draw orbiting particles (behind rings)\n    for (const particle of this.vortexParticles) {\n      // Update particle position - spiral inward slightly then reset\n      particle.angle += particle.speed;\n      particle.radius = particle.baseRadius + Math.sin(particle.angle * 3) * 8;\n\n      const px = centerX + Math.cos(particle.angle) * particle.radius;\n      const py = centerY + Math.sin(particle.angle) * particle.radius;\n\n      // Particle hue shifts over time\n      particle.hue = (particle.hue + 0.5) % 360;\n      const particleColor = this.hslToRgb(particle.hue / 360, 0.8, 0.6);\n\n      // Draw particle with trail\n      const trailAngle = particle.angle - 0.3;\n      const trailX = centerX + Math.cos(trailAngle) * particle.radius;\n      const trailY = centerY + Math.sin(trailAngle) * particle.radius;\n\n      g.lineStyle(particle.size * 0.8, particleColor, particle.alpha * 0.3 * globalPulse);\n      g.lineBetween(trailX, trailY, px, py);\n\n      g.fillStyle(particleColor, particle.alpha * globalPulse);\n      g.fillCircle(px, py, particle.size);\n\n      // Bright core\n      g.fillStyle(0xffffff, particle.alpha * 0.5 * globalPulse);\n      g.fillCircle(px, py, particle.size * 0.4);\n    }\n\n    // Draw rotating rings\n    for (const ring of this.vortexRings) {\n      ring.rotationOffset += ring.rotationSpeed;\n      ring.pulsePhase += 0.02;\n\n      const ringPulse = 0.7 + Math.sin(ring.pulsePhase) * 0.3;\n      const adjustedRadius = ring.baseRadius * (0.95 + ringPulse * 0.1);\n\n      const ringColor = this.hslToRgb(ring.hue / 360, 0.8, 0.5);\n\n      // Draw ring as series of arc segments with gaps\n      const segments = 6;\n      const arcLength = (Math.PI * 2) / segments * 0.7;\n\n      for (let i = 0; i < segments; i++) {\n        const startAngle = ring.rotationOffset + (i * Math.PI * 2) / segments;\n        const endAngle = startAngle + arcLength;\n\n        // Calculate alpha based on segment position for 3D effect\n        const segmentAlpha = 0.15 + Math.sin(startAngle + this.frameCount * 0.02) * 0.1;\n\n        g.lineStyle(ring.thickness, ringColor, segmentAlpha * ringPulse * globalPulse);\n        g.beginPath();\n        g.arc(centerX, centerY, adjustedRadius, startAngle, endAngle, false);\n        g.strokePath();\n      }\n\n      // Inner glow line\n      g.lineStyle(ring.thickness * 0.5, 0xffffff, 0.1 * ringPulse * globalPulse);\n      g.beginPath();\n      g.arc(centerX, centerY, adjustedRadius - 1, ring.rotationOffset, ring.rotationOffset + Math.PI, false);\n      g.strokePath();\n    }\n\n    // Central dark core (event horizon)\n    g.fillStyle(0x000000, 0.9);\n    g.fillCircle(centerX, centerY, 12);\n    g.fillStyle(0x000000, 0.7);\n    g.fillCircle(centerX, centerY, 18);\n    g.fillStyle(0x000000, 0.4);\n    g.fillCircle(centerX, centerY, 25);\n\n    // Bright accretion ring at edge of event horizon\n    const accretionHue = (this.frameCount * 2) % 360;\n    const accretionColor = this.hslToRgb(accretionHue / 360, 1, 0.6);\n    g.lineStyle(2, accretionColor, 0.4 * globalPulse);\n    g.strokeCircle(centerX, centerY, 14);\n    g.lineStyle(1, 0xffffff, 0.3 * globalPulse);\n    g.strokeCircle(centerX, centerY, 13);\n\n    // Gravitational lensing effect - distorted light streaks\n    const numStreaks = 4;\n    for (let i = 0; i < numStreaks; i++) {\n      const streakAngle = (i * Math.PI * 2) / numStreaks + this.frameCount * 0.01;\n      const streakHue = (accretionHue + i * 60) % 360;\n      const streakColor = this.hslToRgb(streakHue / 360, 0.9, 0.7);\n\n      const innerRadius = 20;\n      const outerRadius = 35 + Math.sin(this.frameCount * 0.05 + i) * 10;\n\n      const x1 = centerX + Math.cos(streakAngle) * innerRadius;\n      const y1 = centerY + Math.sin(streakAngle) * innerRadius;\n      const x2 = centerX + Math.cos(streakAngle + 0.2) * outerRadius;\n      const y2 = centerY + Math.sin(streakAngle + 0.2) * outerRadius;\n\n      g.lineStyle(3, streakColor, 0.15 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n      g.lineStyle(1.5, 0xffffff, 0.2 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n    }\n  }\n\n  private drawAuroraWaves(g: Phaser.GameObjects.Graphics, width: number): void {\n    for (const aurora of this.auroraWaves) {\n      aurora.phase += aurora.speed;\n\n      // Draw multiple ribbon layers for each aurora\n      const ribbonLayers = 3;\n      for (let layer = 0; layer < ribbonLayers; layer++) {\n        const layerOffset = layer * 5;\n        const layerAlpha = 0.06 - layer * 0.015;\n\n        // Calculate shifting hue for color variation\n        const shiftedHue = (aurora.hue + Math.sin(aurora.phase * 0.5) * 20) % 360;\n        const color = this.hslToRgb(shiftedHue / 360, 0.7, 0.5);\n\n        // Draw aurora as a series of connected curves\n        g.fillStyle(color, layerAlpha);\n        const step = 4;\n        for (let x = 0; x < width; x += step) {\n          // Multiple sine waves combined for organic movement\n          const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n          const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n          const wave3 = Math.sin(x * 0.01 + aurora.phase * 0.7) * aurora.amplitude * 0.3;\n          const yOffset = wave1 + wave2 + wave3;\n\n          const segmentY = aurora.y + yOffset + layerOffset;\n          const thickness = aurora.thickness * (0.7 + Math.sin(x * 0.05 + aurora.phase) * 0.3);\n\n          g.fillRect(x, segmentY - thickness / 2, step + 1, thickness);\n        }\n      }\n\n      // Add bright core line\n      const coreHue = (aurora.hue + 40) % 360;\n      const coreColor = this.hslToRgb(coreHue / 360, 0.9, 0.7);\n      g.lineStyle(1.5, coreColor, 0.15);\n      g.beginPath();\n      for (let x = 0; x < width; x += 3) {\n        const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n        const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n        const y = aurora.y + wave1 + wave2;\n        if (x === 0) {\n          g.moveTo(x, y);\n        } else {\n          g.lineTo(x, y);\n        }\n      }\n      g.strokePath();\n    }\n  }\n\n  private drawPlasmaWaves(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const wave of this.plasmaWaves) {\n      wave.phase += wave.speed;\n      const color = this.hslToRgb(wave.hue / 360, 0.7, 0.4);\n\n      // Draw flowing plasma lines\n      for (let y = 0; y < height; y += 8) {\n        const waveOffset = Math.sin(y / wave.wavelength + wave.phase) * wave.amplitude;\n        const intensity = 0.03 + Math.sin(wave.phase + y * 0.01) * 0.02;\n\n        g.fillStyle(color, intensity);\n        const x1 = width / 2 + waveOffset - 40;\n        const x2 = width / 2 + waveOffset + 40;\n        g.fillRect(x1, y, x2 - x1, 2);\n      }\n    }\n  }\n\n  private drawSnakeAfterimages(g: Phaser.GameObjects.Graphics): void {\n    for (const ai of this.snakeAfterimages) {\n      const alpha = ai.life * 0.25;\n      for (let i = 0; i < ai.segments.length; i++) {\n        const seg = ai.segments[i];\n        const centerX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n        const centerY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n        const t = ai.segments.length > 1 ? i / (ai.segments.length - 1) : 1;\n        const radius = (CELL_SIZE / 2 - 2) * (0.7 + t * 0.2);\n\n        const segmentHue = (ai.hueOffset + i * 15) % 360;\n        const color = this.hslToRgb(segmentHue / 360, 0.6, 0.4);\n\n        g.fillStyle(color, alpha * t);\n        g.fillCircle(centerX, centerY, radius);\n      }\n    }\n  }\n\n  private drawTrailParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.trailParticles) {\n      // Film noir: grayscale trail\n      g.fillStyle(COLORS.noirGray, p.life * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 1.5 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.5);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n  }\n\n  // Update comet trail - add new segments and fade old ones\n  private updateCometTrail(): void {\n    if (!this.currentState || this.currentState.gameOver) {\n      // Fade out trail on game over\n      for (const seg of this.cometTrail) {\n        seg.alpha *= 0.9;\n      }\n      this.cometTrail = this.cometTrail.filter(s => s.alpha > 0.01);\n      return;\n    }\n\n    const snake = this.currentState.snake;\n    if (snake.length === 0) return;\n\n    const head = snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Track head history for smooth interpolation\n    this.headHistory.unshift({ x: headX, y: headY, time: this.frameCount });\n    if (this.headHistory.length > 10) this.headHistory.pop();\n\n    // Add new trail segment at head position\n    if (this.frameCount % 2 === 0) {\n      const hue = 270 + Math.sin(this.frameCount * 0.05) * 20;\n      this.cometTrail.unshift({\n        x: headX,\n        y: headY,\n        alpha: 1,\n        size: CELL_SIZE / 2 + 2,\n        hue,\n      });\n\n      // Spawn ethereal particles from trail\n      if (Math.random() < 0.6) {\n        this.spawnEtherealParticle(headX, headY, hue);\n      }\n    }\n\n    // Limit trail length and fade segments\n    while (this.cometTrail.length > MAX_COMET_TRAIL_LENGTH) {\n      this.cometTrail.pop();\n    }\n\n    // Fade all segments\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const fadeRate = 0.06 + (i / this.cometTrail.length) * 0.04;\n      this.cometTrail[i].alpha -= fadeRate;\n      this.cometTrail[i].size *= 0.97;\n    }\n\n    // Remove fully faded segments\n    this.cometTrail = this.cometTrail.filter(s => s.alpha > 0);\n  }\n\n  // Spawn an ethereal particle that drifts away from the trail\n  private spawnEtherealParticle(x: number, y: number, hue: number): void {\n    if (this.etherealParticles.length >= MAX_ETHEREAL_PARTICLES) {\n      this.etherealParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.5;\n    const life = 0.8 + Math.random() * 0.4;\n\n    this.etherealParticles.push({\n      x: x + (Math.random() - 0.5) * 10,\n      y: y + (Math.random() - 0.5) * 10,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 0.3,\n      size: 3 + Math.random() * 4,\n      life,\n      maxLife: life,\n      hue: hue + (Math.random() - 0.5) * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n\n  // Update ethereal particles\n  private updateEtherealParticles(): void {\n    for (let i = this.etherealParticles.length - 1; i >= 0; i--) {\n      const p = this.etherealParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.015; // Slight upward drift\n      p.vx *= 0.98;\n      p.size *= 0.985;\n      p.life -= 0.02;\n      p.pulsePhase += 0.15;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.etherealParticles.splice(i, 1);\n      }\n    }\n  }\n\n  // Draw the comet trail - smooth glowing ribbon\n  private drawCometTrail(g: Phaser.GameObjects.Graphics): void {\n    if (this.cometTrail.length < 2) return;\n\n    // Draw outer glow layer\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.05) continue;\n\n      const progress = i / this.cometTrail.length;\n      const glowSize = seg.size * (1.5 + progress * 0.5);\n      const glowAlpha = seg.alpha * 0.15 * (1 - progress * 0.5);\n\n      // Outer ethereal glow\n      const outerColor = this.hslToRgb(seg.hue / 360, 0.6, 0.4);\n      g.fillStyle(outerColor, glowAlpha);\n      g.fillCircle(seg.x, seg.y, glowSize * 1.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(seg.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, glowAlpha * 1.5);\n      g.fillCircle(seg.x, seg.y, glowSize);\n    }\n\n    // Draw connecting ribbon between segments\n    if (this.cometTrail.length >= 2) {\n      for (let i = 0; i < this.cometTrail.length - 1; i++) {\n        const seg1 = this.cometTrail[i];\n        const seg2 = this.cometTrail[i + 1];\n        if (seg1.alpha < 0.1 || seg2.alpha < 0.1) continue;\n\n        const progress = i / this.cometTrail.length;\n        const ribbonAlpha = Math.min(seg1.alpha, seg2.alpha) * 0.4 * (1 - progress * 0.5);\n        const ribbonWidth = (seg1.size + seg2.size) / 2 * 0.6;\n\n        // Ribbon core\n        const ribbonColor = this.hslToRgb(seg1.hue / 360, 0.8, 0.6);\n        g.lineStyle(ribbonWidth, ribbonColor, ribbonAlpha);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n\n        // Bright inner ribbon\n        g.lineStyle(ribbonWidth * 0.4, 0xffffff, ribbonAlpha * 0.6);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n      }\n    }\n\n    // Draw core particles at each segment\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.1) continue;\n\n      const progress = i / this.cometTrail.length;\n      const coreAlpha = seg.alpha * 0.6 * (1 - progress * 0.7);\n      const coreSize = seg.size * 0.5 * (1 - progress * 0.3);\n\n      // Core glow\n      const coreColor = this.hslToRgb(seg.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, coreAlpha);\n      g.fillCircle(seg.x, seg.y, coreSize);\n\n      // Bright white center\n      g.fillStyle(0xffffff, coreAlpha * 0.5);\n      g.fillCircle(seg.x, seg.y, coreSize * 0.4);\n    }\n  }\n\n  // Draw ethereal particles - luminous drifting particles\n  private drawEtherealParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.etherealParticles) {\n      const lifeRatio = p.life / p.maxLife;\n      const pulse = 0.7 + Math.sin(p.pulsePhase) * 0.3;\n      const alpha = lifeRatio * pulse;\n\n      // Outer glow\n      const glowColor = this.hslToRgb(p.hue / 360, 0.5, 0.3);\n      g.fillStyle(glowColor, alpha * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 2.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(p.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      // Core\n      const coreColor = this.hslToRgb(p.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, alpha * 0.7);\n      g.fillCircle(p.x, p.y, p.size);\n\n      // Bright center\n      g.fillStyle(0xffffff, alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawShockWaves(g: Phaser.GameObjects.Graphics): void {\n    for (const sw of this.shockWaves) {\n      const alpha = sw.life * 0.6;\n      // Outer ring\n      g.lineStyle(3, 0xffffff, alpha * 0.3);\n      g.strokeCircle(sw.x, sw.y, sw.radius);\n      // Inner bright ring\n      g.lineStyle(2, 0x00ffff, alpha * 0.7);\n      g.strokeCircle(sw.x, sw.y, sw.radius * 0.8);\n      // Core flash\n      if (sw.life > 0.8) {\n        g.fillStyle(0xffffff, (sw.life - 0.8) * 3);\n        g.fillCircle(sw.x, sw.y, sw.radius * 0.3);\n      }\n    }\n  }\n\n  private drawLightningBolts(g: Phaser.GameObjects.Graphics): void {\n    for (const bolt of this.lightningBolts) {\n      const alpha = bolt.life;\n\n      // Film noir: white lightning\n      g.lineStyle(4, COLORS.noirGray, alpha * 0.3);\n      this.drawLightningPath(g, bolt.points);\n\n      g.lineStyle(2, 0xffffff, alpha * 0.8);\n      this.drawLightningPath(g, bolt.points);\n    }\n  }\n\n  private drawLightningPath(g: Phaser.GameObjects.Graphics, points: { x: number; y: number }[]): void {\n    if (points.length < 2) return;\n    g.beginPath();\n    g.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      g.lineTo(points[i].x, points[i].y);\n    }\n    g.strokePath();\n  }\n\n  private drawSnakeElectricity(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n    const snake = this.currentState.snake;\n    if (snake.length < 2) return;\n\n    // Draw electric arcs between segments every few frames\n    if (this.frameCount % 3 !== 0) return;\n\n    for (let i = 0; i < snake.length - 1; i++) {\n      if (Math.random() > 0.4) continue;\n\n      const seg1 = snake[i];\n      const seg2 = snake[i + 1];\n      const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n      const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n      const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n      const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const arcPoints = this.generateLightningPath(x1, y1, x2, y2);\n\n      // Film noir: grayscale arcs\n      g.lineStyle(3, COLORS.noirGray, 0.3);\n      this.drawLightningPath(g, arcPoints);\n      g.lineStyle(1, 0xffffff, 0.7);\n      this.drawLightningPath(g, arcPoints);\n    }\n  }\n\n  private hslToRgb(h: number, s: number, l: number): number {\n    let r: number, g: number, b: number;\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return (Math.round(r * 255) << 16) | (Math.round(g * 255) << 8) | Math.round(b * 255);\n  }\n\n  private loadHighScores(): HighScoreEntry[] {\n    if (this.highScoresLoaded && this.highScores.length > 0) {\n      return this.highScores;\n    }\n    try {\n      const stored = localStorage.getItem('snake_high_scores');\n      if (stored) {\n        const parsed = JSON.parse(stored) as HighScoreEntry[];\n        this.highScores = parsed.slice(0, MAX_HIGH_SCORES);\n        this.highScoresLoaded = true;\n        return this.highScores;\n      }\n    } catch {\n      // localStorage not available\n    }\n    this.highScores = [];\n    this.highScoresLoaded = true;\n    return this.highScores;\n  }\n\n  private saveHighScore(score: number): number {\n    const highScores = this.loadHighScores();\n    const newEntry: HighScoreEntry = { score, date: Date.now(), rank: 0 };\n\n    let insertIndex = highScores.findIndex(entry => score > entry.score);\n    if (insertIndex === -1) insertIndex = highScores.length;\n\n    if (insertIndex < MAX_HIGH_SCORES && score > 0) {\n      highScores.splice(insertIndex, 0, newEntry);\n      highScores.forEach((entry, i) => { entry.rank = i + 1; });\n      this.highScores = highScores.slice(0, MAX_HIGH_SCORES);\n\n      try {\n        localStorage.setItem('snake_high_scores', JSON.stringify(this.highScores));\n      } catch {\n        // localStorage not available\n      }\n      return insertIndex + 1;\n    }\n    return -1;\n  }\n\n  private checkAndSaveHighScore(): void {\n    if (!this.currentState) return;\n\n    if (this.currentState.gameOver && !this.lastGameOverState) {\n      const score = this.currentState.score || 0;\n      const rank = this.saveHighScore(score);\n      this.newHighScoreRank = rank > 0 ? rank : -1;\n      this.scoreboardRevealProgress = 0;\n    }\n    this.lastGameOverState = this.currentState.gameOver;\n\n    if (this.currentState.gameStarted && !this.currentState.gameOver) {\n      this.newHighScoreRank = -1;\n    }\n  }\n\n  private drawHUD(g: Phaser.GameObjects.Graphics, width: number): void {\n    if (!this.currentState || !this.currentState.gameStarted) return;\n\n    this.hudPulsePhase += 0.08;\n    const score = this.currentState.score || 0;\n\n    if (score > this.lastHudScore) {\n      this.scoreFlashIntensity = 1;\n    }\n    this.lastHudScore = score;\n    this.scoreFlashIntensity *= 0.92;\n\n    const padding = 12;\n    const scorePanelWidth = 120;\n    const scorePanelHeight = 50;\n\n    // Score panel background - volcanic lava theme\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Glowing border\n    const borderGlow = 0.6 + this.scoreFlashIntensity * 0.4;\n    g.lineStyle(2, COLORS.snakeGlow, borderGlow);\n    g.strokeRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Score label\n    this.drawText(g, 'SCORE', padding + 10, padding + 12, 10, COLORS.snakeBody, 0.9);\n\n    // Score value with flash effect\n    const scoreColor = this.scoreFlashIntensity > 0.5 ? 0xffffff : COLORS.snakeHead;\n    this.drawText(g, String(score).padStart(5, '0'), padding + 10, padding + 32, 18, scoreColor, 1);\n\n    // Outer glow on score when flashing\n    if (this.scoreFlashIntensity > 0.1) {\n      g.fillStyle(COLORS.snakeGlow, this.scoreFlashIntensity * 0.3);\n      g.fillRoundedRect(padding + 5, padding + 20, 100, 28, 4);\n    }\n\n    // Length panel on the right\n    const lengthPanelWidth = 80;\n    const lengthPanelHeight = 50;\n    const lengthX = width - padding - lengthPanelWidth;\n\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    g.lineStyle(2, COLORS.foodGlow, 0.6);\n    g.strokeRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    this.drawText(g, 'LENGTH', lengthX + 10, padding + 12, 10, COLORS.food, 0.9);\n    this.drawText(g, String(this.currentState.snake.length), lengthX + 10, padding + 32, 18, COLORS.foodCore, 1);\n  }\n\n  private drawText(\n    g: Phaser.GameObjects.Graphics,\n    text: string,\n    x: number,\n    y: number,\n    size: number,\n    color: number,\n    alpha: number\n  ): void {\n    // Use simple block characters for text rendering\n    const charWidth = size * 0.6;\n    const charHeight = size;\n\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const cx = x + i * charWidth;\n\n      g.fillStyle(color, alpha);\n\n      // Simple pixel-style character rendering\n      if (char >= '0' && char <= '9') {\n        this.drawDigit(g, char, cx, y, size);\n      } else {\n        this.drawLetter(g, char, cx, y, size);\n      }\n    }\n  }\n\n  private drawDigit(g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15; // thickness\n\n    // 7-segment style digits\n    const segments: Record<string, number[]> = {\n      '0': [1, 1, 1, 0, 1, 1, 1],\n      '1': [0, 0, 1, 0, 0, 1, 0],\n      '2': [1, 0, 1, 1, 1, 0, 1],\n      '3': [1, 0, 1, 1, 0, 1, 1],\n      '4': [0, 1, 1, 1, 0, 1, 0],\n      '5': [1, 1, 0, 1, 0, 1, 1],\n      '6': [1, 1, 0, 1, 1, 1, 1],\n      '7': [1, 0, 1, 0, 0, 1, 0],\n      '8': [1, 1, 1, 1, 1, 1, 1],\n      '9': [1, 1, 1, 1, 0, 1, 1],\n    };\n\n    const seg = segments[digit] || segments['0'];\n\n    // Top horizontal\n    if (seg[0]) g.fillRect(x, y - h / 2, w, t);\n    // Top-left vertical\n    if (seg[1]) g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n    // Top-right vertical\n    if (seg[2]) g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n    // Middle horizontal\n    if (seg[3]) g.fillRect(x, y - t / 2, w, t);\n    // Bottom-left vertical\n    if (seg[4]) g.fillRect(x - t / 2, y, t, h / 2);\n    // Bottom-right vertical\n    if (seg[5]) g.fillRect(x + w - t / 2, y, t, h / 2);\n    // Bottom horizontal\n    if (seg[6]) g.fillRect(x, y + h / 2 - t, w, t);\n  }\n\n  private drawLetter(g: Phaser.GameObjects.Graphics, letter: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15;\n\n    // Simple block letters\n    switch (letter.toUpperCase()) {\n      case 'S':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'C':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'O':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'R':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w / 2, y, t, h / 2);\n        break;\n      case 'E':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w * 0.7, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'L':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'N':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - h / 2 + t, w, t);\n        break;\n      case 'G':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x + w / 2, y - t / 2, w / 2, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'T':\n        g.fillRect(x - t, y - h / 2, w + t * 2, t);\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'H':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n      case 'I':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'Y':\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        break;\n      case 'U':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'W':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case '!':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h * 0.6);\n        g.fillRect(x + w / 2 - t / 2, y + h / 2 - t * 2, t, t);\n        break;\n      case ' ':\n        break;\n      default:\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n    }\n  }\n\n  private drawScoreboard(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (!this.currentState || !this.currentState.gameOver) return;\n\n    this.scoreboardAnimPhase += 0.06;\n    this.scoreboardRevealProgress = Math.min(1, this.scoreboardRevealProgress + 0.02);\n\n    const highScores = this.loadHighScores();\n    const centerX = width / 2;\n    const baseY = height * 0.18;\n    const panelWidth = 180;\n    const panelHeight = 170;\n    const panelX = centerX - panelWidth / 2;\n    const panelY = baseY;\n    const slideOffset = (1 - this.scoreboardRevealProgress) * 50;\n    const alphaMultiplier = this.scoreboardRevealProgress;\n\n    // Panel background - volcanic lava glow\n    g.fillStyle(0x150510, 0.95 * alphaMultiplier);\n    g.fillRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Glowing border - animated\n    const borderHue = this.newHighScoreRank > 0 ? 45 : 0;\n    const borderPulse = 0.6 + Math.sin(this.scoreboardAnimPhase) * 0.2;\n    const borderColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    g.lineStyle(3, borderColor, borderPulse * alphaMultiplier);\n    g.strokeRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Title\n    const titleY = panelY - slideOffset + 22;\n    this.drawText(g, 'HIGH SCORES', centerX - 55, titleY, 10, COLORS.foodCore, alphaMultiplier);\n\n    // Divider line\n    g.lineStyle(1, COLORS.snakeGlow, 0.5 * alphaMultiplier);\n    g.lineBetween(panelX + 20, titleY + 8, panelX + panelWidth - 20, titleY + 8);\n\n    const entryStartY = titleY + 25;\n    const entryHeight = 22;\n\n    if (highScores.length === 0) {\n      this.drawText(g, 'NO SCORES YET', centerX - 50, entryStartY + 30, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n    } else {\n      for (let i = 0; i < Math.min(highScores.length, 5); i++) {\n        const entry = highScores[i];\n        const entryY = entryStartY + i * entryHeight;\n        const isNewScore = this.newHighScoreRank === i + 1;\n        const entryDelay = i * 0.15;\n        const entryProgress = Math.max(0, Math.min(1, (this.scoreboardRevealProgress - entryDelay) * 2));\n        if (entryProgress <= 0) continue;\n\n        const entryAlpha = alphaMultiplier * entryProgress;\n\n        // Highlight new high score row\n        if (isNewScore) {\n          const flashIntensity = 0.3 + Math.sin(this.scoreboardAnimPhase * 3) * 0.2;\n          g.fillStyle(0xffcc00, flashIntensity * entryAlpha);\n          g.fillRoundedRect(panelX + 8, entryY - slideOffset - 8, panelWidth - 16, entryHeight - 2, 4);\n        }\n\n        // Rank colors: gold, silver, bronze, then volcanic colors\n        const rankColors = [0xffd700, 0xc0c0c0, 0xcd7f32, COLORS.snakeGlow, COLORS.foodGlow];\n        const rankColor = rankColors[i] || 0x888888;\n\n        // Rank number\n        this.drawText(g, `${i + 1}`, panelX + 18, entryY - slideOffset, 10, rankColor, entryAlpha);\n\n        // Score value\n        const scoreColor = isNewScore ? 0xffffff : COLORS.foodCore;\n        this.drawText(g, String(entry.score).padStart(5, '0'), panelX + panelWidth - 70, entryY - slideOffset, 10, scoreColor, entryAlpha);\n\n        // NEW! label\n        if (isNewScore) {\n          const newAlpha = 0.8 + Math.sin(this.scoreboardAnimPhase * 4) * 0.2;\n          this.drawText(g, 'NEW', panelX + 50, entryY - slideOffset, 7, 0xffcc00, newAlpha * entryAlpha);\n        }\n      }\n    }\n\n    // Current score at bottom\n    const currentScoreY = panelY - slideOffset + panelHeight - 30;\n    this.drawText(g, 'YOUR SCORE', centerX - 40, currentScoreY - 10, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n\n    const currentScore = this.currentState.score || 0;\n    const scoreColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    this.drawText(g, String(currentScore).padStart(5, '0'), centerX - 25, currentScoreY + 8, 14, scoreColor, alphaMultiplier);\n  }\n\n  private drawGrid(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir grid: subtle, dark lines suggesting tile floor or city grid\n    g.lineStyle(1, COLORS.gridLine, 0.08);\n    for (let i = 0; i <= GRID_SIZE; i++) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Accent lines every 5 cells - subtle gray\n    const accentPulse = 0.12 + Math.sin(this.frameCount * 0.03) * 0.04;\n    g.lineStyle(1, COLORS.gridAccent, accentPulse);\n    for (let i = 0; i <= GRID_SIZE; i += 5) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Heavy vignette for dramatic noir look\n    this.drawVignette(g, width, height);\n  }\n\n  private drawVignette(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Multiple layers of vignette for smooth falloff\n    const layers = 5;\n    for (let i = 0; i < layers; i++) {\n      const inset = i * 30;\n      const alpha = 0.15 * (1 - i / layers);\n      g.lineStyle(60, 0x000000, alpha);\n      g.strokeRect(inset - 30, inset - 30, width - inset * 2 + 60, height - inset * 2 + 60);\n    }\n  }\n\n  private drawFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    // Don't draw food if it's still being thrown\n    if (this.thrownFood && !this.thrownFood.landed) return;\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    const pulseScale = 1 + Math.sin(this.frameCount * 0.15) * 0.08;\n    const glowPulse = 0.4 + Math.sin(this.frameCount * 0.1) * 0.2;\n\n    // Spawn particles (orange/yellow for Halloween)\n    this.spawnFoodParticles(foodX, foodY);\n\n    // Draw particles\n    for (const p of this.foodParticles) {\n      g.fillStyle(COLORS.pumpkinOrange, p.life * 0.4);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Halloween pumpkin!\n    const pumpkinSize = (CELL_SIZE / 2) * pulseScale;\n\n    // Shadow underneath\n    g.fillStyle(0x000000, 0.5);\n    g.fillEllipse(foodX + 2, foodY + pumpkinSize * 0.8, pumpkinSize * 1.2, pumpkinSize * 0.4);\n\n    // Outer orange glow (candlelight effect)\n    g.fillStyle(COLORS.pumpkinOrange, glowPulse * 0.15);\n    g.fillCircle(foodX, foodY, pumpkinSize + 12);\n    g.fillStyle(COLORS.candyCorn1, glowPulse * 0.2);\n    g.fillCircle(foodX, foodY, pumpkinSize + 6);\n\n    // Pumpkin body (slightly squashed circle)\n    g.fillStyle(COLORS.pumpkinOrange, 0.95);\n    g.fillEllipse(foodX, foodY, pumpkinSize * 1.1, pumpkinSize * 0.9);\n\n    // Pumpkin segments (darker lines)\n    g.lineStyle(2, 0xcc4400, 0.5);\n    g.lineBetween(foodX, foodY - pumpkinSize * 0.8, foodX, foodY + pumpkinSize * 0.7);\n    g.lineStyle(1.5, 0xcc4400, 0.3);\n    g.lineBetween(foodX - pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX - pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n    g.lineBetween(foodX + pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX + pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n\n    // Pumpkin stem\n    g.fillStyle(0x228822, 0.9);\n    g.fillRect(foodX - 2, foodY - pumpkinSize * 0.9 - 4, 4, 6);\n\n    // Jack-o-lantern face - glowing eyes and mouth\n    const faceGlow = 0.8 + Math.sin(this.frameCount * 0.12) * 0.2;\n    g.fillStyle(COLORS.candyCorn1, faceGlow);\n\n    // Eyes (triangles)\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n\n    // Mouth (jagged smile)\n    g.fillStyle(COLORS.candyCorn1, faceGlow * 0.9);\n    g.fillRect(foodX - pumpkinSize * 0.35, foodY + pumpkinSize * 0.15, pumpkinSize * 0.7, pumpkinSize * 0.25);\n\n    // Teeth (dark gaps in mouth)\n    g.fillStyle(COLORS.pumpkinOrange, 1);\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX, foodY + pumpkinSize * 0.15,\n      foodX - pumpkinSize * 0.075, foodY + pumpkinSize * 0.3\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.3, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.225, foodY + pumpkinSize * 0.3\n    );\n  }\n\n  private drawEnergyTendrils(g: Phaser.GameObjects.Graphics, foodX: number, foodY: number): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const head = this.currentState.snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Calculate distance to snake head\n    const dx = headX - foodX;\n    const dy = headY - foodY;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    // Only draw tendrils when snake is somewhat close\n    if (dist > CELL_SIZE * 6) return;\n\n    // Intensity increases as snake gets closer\n    const intensity = 1 - dist / (CELL_SIZE * 6);\n    const numTendrils = 2 + Math.floor(intensity * 2);\n\n    for (let i = 0; i < numTendrils; i++) {\n      // Tendril reaches partway toward the snake\n      const reach = 0.3 + intensity * 0.4;\n      const targetX = foodX + dx * reach;\n      const targetY = foodY + dy * reach;\n\n      // Add some wave offset for each tendril\n      const waveOffset = Math.sin(this.frameCount * 0.15 + i * 2) * 10;\n      const perpX = -dy / dist;\n      const perpY = dx / dist;\n      const wavyTargetX = targetX + perpX * waveOffset * (1 - reach);\n      const wavyTargetY = targetY + perpY * waveOffset * (1 - reach);\n\n      // Generate tendril path\n      const points = this.generateLightningPath(foodX, foodY, wavyTargetX, wavyTargetY);\n\n      // Draw tendril with glow\n      g.lineStyle(3, COLORS.foodGlow, intensity * 0.3);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1.5, COLORS.food, intensity * 0.7);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1, 0xffffff, intensity * 0.5);\n      this.drawLightningPath(g, points);\n    }\n  }\n\n  private drawSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const snakeLen = snake.length;\n\n    // Spooky shadow under snake\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const shadowRadius = (CELL_SIZE / 2) * (0.9 + t * 0.1);\n      g.fillStyle(0x000000, 0.5 * t);\n      g.fillCircle(centerX, centerY, shadowRadius);\n    }\n\n    // Draw trailing glow (ghostly green)\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const glowAlpha = 0.2 * t;\n      const glowSize = (CELL_SIZE / 2 + 4) * (0.5 + t * 0.5);\n\n      g.fillStyle(COLORS.snakeGlow, glowAlpha);\n      g.fillCircle(centerX, centerY, glowSize);\n    }\n\n    // Draw snake segments from tail to head with green gradient\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n\n      // Green gradient from tail (dark) to head (bright)\n      const brightness = 0.3 + t * 0.4;\n      const segmentColor = this.hslToRgb(0.4, 0.9, brightness);\n\n      if (i === 0) {\n        // Head: brightest green with eerie glow\n        g.fillStyle(COLORS.snakeGlow, 0.4);\n        g.fillCircle(centerX, centerY, radius + 8);\n\n        g.fillStyle(COLORS.snakeHead, 1);\n        g.fillCircle(centerX, centerY, radius + 1);\n\n        // Slimy highlight\n        g.fillStyle(0xaaffcc, 0.6);\n        g.fillCircle(centerX - 2, centerY - 2, radius * 0.35);\n\n        this.drawSnakeHead(g, segment, snake[1]);\n      } else {\n        // Body segment with green tones\n        g.fillStyle(COLORS.snakeGlow, 0.15);\n        g.fillCircle(centerX, centerY, radius + 2);\n\n        g.fillStyle(segmentColor, 1);\n        g.fillCircle(centerX, centerY, radius);\n\n        // Slimy specular highlight\n        g.fillStyle(0xaaffcc, 0.15 * t);\n        g.fillCircle(centerX - 1, centerY - 1, radius * 0.25);\n      }\n    }\n  }\n\n  private drawFoodBurst(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.foodBurstParticles) {\n      // Halloween: orange pumpkin burst\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailAlpha = p.life * 0.4 * (1 - i / p.trail.length);\n        const trailSize = p.size * p.life * (1 - i / p.trail.length);\n        g.fillStyle(COLORS.pumpkinOrange, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      g.fillStyle(COLORS.candyCorn1, p.life * 0.7);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n      g.fillStyle(COLORS.candyCorn3, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life * 0.4);\n    }\n  }\n\n  private drawEnergyField(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const snake = this.currentState.snake;\n    const baseIntensity = 0.06 + this.energyFieldPulse * 0.2;\n    const pulseOffset = Math.sin(this.frameCount * 0.1) * 0.02;\n    const alpha = Math.min(0.3, baseIntensity + pulseOffset);\n\n    // Halloween: ghostly green energy field\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const fieldRadius = CELL_SIZE * (0.8 + this.energyFieldPulse * 0.5) + Math.sin(this.frameCount * 0.15 + i * 0.5) * 2;\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.2);\n      g.fillCircle(cx, cy, fieldRadius + 4);\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.35);\n      g.fillCircle(cx, cy, fieldRadius);\n    }\n\n    // Connecting lines when pulse is active\n    if (this.energyFieldPulse > 0.3 && snake.length > 1) {\n      for (let i = 0; i < snake.length - 1; i++) {\n        const seg1 = snake[i];\n        const seg2 = snake[i + 1];\n        const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n        const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n        const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n        const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n        g.lineStyle(3, COLORS.noirGray, this.energyFieldPulse * 0.3);\n        g.lineBetween(x1, y1, x2, y2);\n        g.lineStyle(1.5, 0xffffff, this.energyFieldPulse * 0.5);\n        g.lineBetween(x1, y1, x2, y2);\n      }\n    }\n  }\n\n  private drawChromaticAberration(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const offset = this.chromaticIntensity * 3;\n\n    // Film noir: grayscale ghosting effect instead of color split\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snake.length > 1 ? i / (snake.length - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n      const alpha = this.chromaticIntensity * 0.3 * (i === 0 ? 1 : 0.5);\n\n      // Light ghost - offset left\n      g.fillStyle(0xffffff, alpha);\n      g.fillCircle(cx - offset, cy, radius);\n\n      // Dark ghost - offset right\n      g.fillStyle(0x404040, alpha);\n      g.fillCircle(cx + offset, cy, radius);\n    }\n  }\n\n  private drawGameOver(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir game over: dramatic fade to black with spotlight\n    if (this.gameOverAlpha < 0.85) {\n      this.gameOverAlpha += 0.03;\n    }\n\n    // Heavy dark overlay\n    g.fillStyle(COLORS.gameOverOverlay, this.gameOverAlpha);\n    g.fillRect(0, 0, width, height);\n\n    // Film grain effect (subtle noise lines)\n    for (let y = 0; y < height; y += 3) {\n      const grainAlpha = 0.05 + Math.random() * 0.05;\n      g.fillStyle(Math.random() > 0.5 ? 0xffffff : 0x000000, grainAlpha);\n      g.fillRect(0, y, width, 1);\n    }\n\n    // Dramatic spotlight in center\n    const spotPulse = 0.15 + Math.sin(this.frameCount * 0.05) * 0.05;\n    g.fillStyle(COLORS.noirWhite, spotPulse);\n    g.fillCircle(width / 2, height / 2, 80);\n    g.fillStyle(COLORS.noirWhite, spotPulse * 0.5);\n    g.fillCircle(width / 2, height / 2, 120);\n\n    // Noir border: thick black frame\n    const borderSize = 8;\n    g.fillStyle(0x000000, 0.8);\n    g.fillRect(0, 0, width, borderSize);\n    g.fillRect(0, height - borderSize, width, borderSize);\n    g.fillRect(0, 0, borderSize, height);\n    g.fillRect(width - borderSize, 0, borderSize, height);\n\n    // White inner border\n    const innerBorder = 2;\n    const innerOffset = borderSize;\n    g.fillStyle(COLORS.noirWhite, 0.3);\n    g.fillRect(innerOffset, innerOffset, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, height - innerOffset - innerBorder, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, innerOffset, innerBorder, height - innerOffset * 2);\n    g.fillRect(width - innerOffset - innerBorder, innerOffset, innerBorder, height - innerOffset * 2);\n  }\n\n  private drawSnakeHead(\n    g: Phaser.GameObjects.Graphics,\n    head: Position,\n    nextSegment: Position | undefined\n  ): void {\n    const centerX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const centerY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Determine direction for eye placement\n    let dx = 1, dy = 0;\n    if (nextSegment) {\n      dx = head.x - nextSegment.x;\n      dy = head.y - nextSegment.y;\n      // Normalize\n      const len = Math.sqrt(dx * dx + dy * dy);\n      if (len > 0) {\n        dx /= len;\n        dy /= len;\n      }\n    }\n\n    // Perpendicular for eye offset\n    const perpX = -dy;\n    const perpY = dx;\n\n    const eyeOffset = 4;\n    const eyeForward = 3;\n    const eyeRadius = 3;\n    const pupilRadius = 1.5;\n\n    // Left eye\n    const leftEyeX = centerX + perpX * eyeOffset + dx * eyeForward;\n    const leftEyeY = centerY + perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(leftEyeX, leftEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(leftEyeX + dx * 1, leftEyeY + dy * 1, pupilRadius);\n\n    // Right eye\n    const rightEyeX = centerX - perpX * eyeOffset + dx * eyeForward;\n    const rightEyeY = centerY - perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(rightEyeX, rightEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(rightEyeX + dx * 1, rightEyeY + dy * 1, pupilRadius);\n\n    // Draw the royal crown\n    this.drawCrown(g, centerX, centerY, dx, dy, perpX, perpY);\n  }\n\n  private drawCrown(\n    g: Phaser.GameObjects.Graphics,\n    headX: number,\n    headY: number,\n    dx: number,\n    dy: number,\n    perpX: number,\n    perpY: number\n  ): void {\n    // Volcanic crown: molten gold with ruby gems\n    const crownOffset = -8;\n    const crownBaseX = headX - dx * crownOffset;\n    const crownBaseY = headY - dy * crownOffset;\n\n    const crownWidth = 14;\n    const crownHeight = 10;\n    const halfWidth = crownWidth / 2;\n\n    const sparkle = 0.7 + Math.sin(this.frameCount * 0.15) * 0.3;\n\n    const baseLeft = {\n      x: crownBaseX + perpX * halfWidth,\n      y: crownBaseY + perpY * halfWidth\n    };\n    const baseRight = {\n      x: crownBaseX - perpX * halfWidth,\n      y: crownBaseY - perpY * halfWidth\n    };\n\n    const pointOffset = -dx * crownHeight;\n    const pointOffsetY = -dy * crownHeight;\n\n    const crownPoints = [\n      baseLeft,\n      { x: baseLeft.x + pointOffset * 0.4, y: baseLeft.y + pointOffsetY * 0.4 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: crownBaseX + perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY + perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY },\n      { x: crownBaseX - perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY - perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: baseRight.x + pointOffset * 0.4, y: baseRight.y + pointOffsetY * 0.4 },\n      baseRight\n    ];\n\n    // Crown glow (molten orange/red aura)\n    g.fillStyle(COLORS.noirWhite, 0.25 * sparkle);\n    g.fillCircle(crownBaseX + pointOffset * 0.5, crownBaseY + pointOffsetY * 0.5, crownHeight + 4);\n\n    // Crown base (molten gold)\n    g.fillStyle(0xffa500, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.fillPath();\n\n    // Crown outline (dark crimson)\n    g.lineStyle(1.5, 0x801010, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.strokePath();\n\n    // Crown band\n    const bandY1 = {\n      x: baseLeft.x + pointOffset * 0.15,\n      y: baseLeft.y + pointOffsetY * 0.15\n    };\n    const bandY2 = {\n      x: baseRight.x + pointOffset * 0.15,\n      y: baseRight.y + pointOffsetY * 0.15\n    };\n    g.lineStyle(3, 0xcc6600, 1);\n    g.lineBetween(bandY1.x, bandY1.y, bandY2.x, bandY2.y);\n\n    // Ruby jewels: glowing red gems\n    const jewelPositions = [\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY, size: 2.5 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n    ];\n\n    for (const jewel of jewelPositions) {\n      g.fillStyle(0xff4020, 0.5 * sparkle);\n      g.fillCircle(jewel.x, jewel.y, jewel.size + 2);\n\n      g.fillStyle(0xff2000, 1);\n      g.fillCircle(jewel.x, jewel.y, jewel.size);\n\n      g.fillStyle(0xffff80, 0.9 * sparkle);\n      g.fillCircle(jewel.x - 0.5, jewel.y - 0.5, jewel.size * 0.4);\n    }\n\n    // Crown highlight (golden gleam)\n    g.fillStyle(0xffff80, 0.6 * sparkle);\n    g.fillCircle(crownBaseX + perpX * 3 + pointOffset * 0.3, crownBaseY + perpY * 3 + pointOffsetY * 0.3, 2);\n  }\n}\n","structuredPatch":[{"oldStart":6,"oldLines":6,"newStart":6,"newLines":10,"lines":["   updateRipples,","   updateGlowTrail,","   spawnRipple,","+  spawnTears,","+  spawnBlood,","+  updateTears,","+  updateBlood,","   drawCleanBackground,","   drawCleanGrid,","   drawMotes,"]},{"oldStart":15,"oldLines":6,"newStart":19,"newLines":8,"lines":["   drawCleanSnake,","   drawCleanVignette,","   drawCleanHUD,","+  drawTears,","+  drawBlood,","   CLEAN_COLORS,","   CleanEffectsState,"," } from './cleanEffects';"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TbtxbfgRXzLjZ2etpRDfNr","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to find where the gameOver state is set and trigger the effects. Let me look at where the game over is detected."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":558,"cache_read_input_tokens":40444,"cache_creation":{"ephemeral_5m_input_tokens":558,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"af175131-7b39-4cf5-8882-c2e77f70f7f4"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TbtxbfgRXzLjZ2etpRDfNr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Kjpxkxr4cx8kNVKeCN3GqG","name":"Grep","input":{"pattern":"gameOver","path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","output_mode":"content","-n":true},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":558,"cache_read_input_tokens":40444,"cache_creation":{"ephemeral_5m_input_tokens":558,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"8e41df17-338a-4e6e-899f-0232f0686e16"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Kjpxkxr4cx8kNVKeCN3GqG","type":"tool_result","content":"36:  gameOver: boolean;\n377:  gameOverOverlay: 0x0a0015,\n378:  gameOverText: 0xff6600,\n426:  private gameOverAlpha = 0;\n431:  private gameOverGlitchOffset = 0;\n1126:    if (this.currentState.gameOver) {\n1347:    const gameOver = this.currentState.gameOver;\n1350:    if (!gameOver && Math.random() < BEE_SPAWN_CHANCE && this.bees.length < NUM_BEES) {\n1443:      if (gameOver) {\n1563:    const gameOver = this.currentState.gameOver;\n1575:      const floatAmount = gameOver ? 20 : 12;\n1601:      if (snakeHead && !gameOver) {\n1620:      const baseAlpha = gameOver ? 0.8 : spirit.targetAlpha;\n2054:    } else if (!this.lastFoodPos && !state.gameOver) {\n2070:    if (state.gameOver && this.currentState && !this.currentState.gameOver) {\n2089:    if (!state.gameOver) {\n2090:      this.gameOverAlpha = 0;\n2091:      this.gameOverGlitchOffset = 0;\n2440:    if (this.currentState.gameOver) {\n2602:    if (!this.currentState || this.currentState.gameOver) return;\n2986:    if (!this.currentState || this.currentState.gameOver) {\n3310:    if (this.currentState.gameOver && !this.lastGameOverState) {\n3316:    this.lastGameOverState = this.currentState.gameOver;\n3318:    if (this.currentState.gameStarted && !this.currentState.gameOver) {\n3536:    if (!this.currentState || !this.currentState.gameOver) return;\n3937:    if (this.gameOverAlpha < 0.85) {\n3938:      this.gameOverAlpha += 0.03;\n3942:    g.fillStyle(COLORS.gameOverOverlay, this.gameOverAlpha);"}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"2649bdea-069c-4773-a25d-bad61d51cf2e","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"36:  gameOver: boolean;\n377:  gameOverOverlay: 0x0a0015,\n378:  gameOverText: 0xff6600,\n426:  private gameOverAlpha = 0;\n431:  private gameOverGlitchOffset = 0;\n1126:    if (this.currentState.gameOver) {\n1347:    const gameOver = this.currentState.gameOver;\n1350:    if (!gameOver && Math.random() < BEE_SPAWN_CHANCE && this.bees.length < NUM_BEES) {\n1443:      if (gameOver) {\n1563:    const gameOver = this.currentState.gameOver;\n1575:      const floatAmount = gameOver ? 20 : 12;\n1601:      if (snakeHead && !gameOver) {\n1620:      const baseAlpha = gameOver ? 0.8 : spirit.targetAlpha;\n2054:    } else if (!this.lastFoodPos && !state.gameOver) {\n2070:    if (state.gameOver && this.currentState && !this.currentState.gameOver) {\n2089:    if (!state.gameOver) {\n2090:      this.gameOverAlpha = 0;\n2091:      this.gameOverGlitchOffset = 0;\n2440:    if (this.currentState.gameOver) {\n2602:    if (!this.currentState || this.currentState.gameOver) return;\n2986:    if (!this.currentState || this.currentState.gameOver) {\n3310:    if (this.currentState.gameOver && !this.lastGameOverState) {\n3316:    this.lastGameOverState = this.currentState.gameOver;\n3318:    if (this.currentState.gameStarted && !this.currentState.gameOver) {\n3536:    if (!this.currentState || !this.currentState.gameOver) return;\n3937:    if (this.gameOverAlpha < 0.85) {\n3938:      this.gameOverAlpha += 0.03;\n3942:    g.fillStyle(COLORS.gameOverOverlay, this.gameOverAlpha);","numLines":28}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UsR1qhdvrwDihFWDBcEx2w","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the area around line 3310 where game over state transition is detected."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":745,"cache_read_input_tokens":41002,"cache_creation":{"ephemeral_5m_input_tokens":745,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"d73a450f-645e-40ad-80ef-15ab56d9e715"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UsR1qhdvrwDihFWDBcEx2w","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SndyUyBt4vLKMsKLaER6xE","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":3300,"limit":80},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":745,"cache_read_input_tokens":41002,"cache_creation":{"ephemeral_5m_input_tokens":745,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"0d5c4d5e-c95b-44d5-90f5-85194fa7e55c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SndyUyBt4vLKMsKLaER6xE","type":"tool_result","content":"  3300â†’        // localStorage not available\n  3301â†’      }\n  3302â†’      return insertIndex + 1;\n  3303â†’    }\n  3304â†’    return -1;\n  3305â†’  }\n  3306â†’\n  3307â†’  private checkAndSaveHighScore(): void {\n  3308â†’    if (!this.currentState) return;\n  3309â†’\n  3310â†’    if (this.currentState.gameOver && !this.lastGameOverState) {\n  3311â†’      const score = this.currentState.score || 0;\n  3312â†’      const rank = this.saveHighScore(score);\n  3313â†’      this.newHighScoreRank = rank > 0 ? rank : -1;\n  3314â†’      this.scoreboardRevealProgress = 0;\n  3315â†’    }\n  3316â†’    this.lastGameOverState = this.currentState.gameOver;\n  3317â†’\n  3318â†’    if (this.currentState.gameStarted && !this.currentState.gameOver) {\n  3319â†’      this.newHighScoreRank = -1;\n  3320â†’    }\n  3321â†’  }\n  3322â†’\n  3323â†’  private drawHUD(g: Phaser.GameObjects.Graphics, width: number): void {\n  3324â†’    if (!this.currentState || !this.currentState.gameStarted) return;\n  3325â†’\n  3326â†’    this.hudPulsePhase += 0.08;\n  3327â†’    const score = this.currentState.score || 0;\n  3328â†’\n  3329â†’    if (score > this.lastHudScore) {\n  3330â†’      this.scoreFlashIntensity = 1;\n  3331â†’    }\n  3332â†’    this.lastHudScore = score;\n  3333â†’    this.scoreFlashIntensity *= 0.92;\n  3334â†’\n  3335â†’    const padding = 12;\n  3336â†’    const scorePanelWidth = 120;\n  3337â†’    const scorePanelHeight = 50;\n  3338â†’\n  3339â†’    // Score panel background - volcanic lava theme\n  3340â†’    g.fillStyle(0x150508, 0.9);\n  3341â†’    g.fillRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n  3342â†’\n  3343â†’    // Glowing border\n  3344â†’    const borderGlow = 0.6 + this.scoreFlashIntensity * 0.4;\n  3345â†’    g.lineStyle(2, COLORS.snakeGlow, borderGlow);\n  3346â†’    g.strokeRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n  3347â†’\n  3348â†’    // Score label\n  3349â†’    this.drawText(g, 'SCORE', padding + 10, padding + 12, 10, COLORS.snakeBody, 0.9);\n  3350â†’\n  3351â†’    // Score value with flash effect\n  3352â†’    const scoreColor = this.scoreFlashIntensity > 0.5 ? 0xffffff : COLORS.snakeHead;\n  3353â†’    this.drawText(g, String(score).padStart(5, '0'), padding + 10, padding + 32, 18, scoreColor, 1);\n  3354â†’\n  3355â†’    // Outer glow on score when flashing\n  3356â†’    if (this.scoreFlashIntensity > 0.1) {\n  3357â†’      g.fillStyle(COLORS.snakeGlow, this.scoreFlashIntensity * 0.3);\n  3358â†’      g.fillRoundedRect(padding + 5, padding + 20, 100, 28, 4);\n  3359â†’    }\n  3360â†’\n  3361â†’    // Length panel on the right\n  3362â†’    const lengthPanelWidth = 80;\n  3363â†’    const lengthPanelHeight = 50;\n  3364â†’    const lengthX = width - padding - lengthPanelWidth;\n  3365â†’\n  3366â†’    g.fillStyle(0x150508, 0.9);\n  3367â†’    g.fillRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n  3368â†’\n  3369â†’    g.lineStyle(2, COLORS.foodGlow, 0.6);\n  3370â†’    g.strokeRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n  3371â†’\n  3372â†’    this.drawText(g, 'LENGTH', lengthX + 10, padding + 12, 10, COLORS.food, 0.9);\n  3373â†’    this.drawText(g, String(this.currentState.snake.length), lengthX + 10, padding + 32, 18, COLORS.foodCore, 1);\n  3374â†’  }\n  3375â†’\n  3376â†’  private drawText(\n  3377â†’    g: Phaser.GameObjects.Graphics,\n  3378â†’    text: string,\n  3379â†’    x: number,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"b5b5d9fb-698c-4557-a6ec-ab61f48c0f4e","tool_use_result":{"type":"text","file":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","content":"        // localStorage not available\n      }\n      return insertIndex + 1;\n    }\n    return -1;\n  }\n\n  private checkAndSaveHighScore(): void {\n    if (!this.currentState) return;\n\n    if (this.currentState.gameOver && !this.lastGameOverState) {\n      const score = this.currentState.score || 0;\n      const rank = this.saveHighScore(score);\n      this.newHighScoreRank = rank > 0 ? rank : -1;\n      this.scoreboardRevealProgress = 0;\n    }\n    this.lastGameOverState = this.currentState.gameOver;\n\n    if (this.currentState.gameStarted && !this.currentState.gameOver) {\n      this.newHighScoreRank = -1;\n    }\n  }\n\n  private drawHUD(g: Phaser.GameObjects.Graphics, width: number): void {\n    if (!this.currentState || !this.currentState.gameStarted) return;\n\n    this.hudPulsePhase += 0.08;\n    const score = this.currentState.score || 0;\n\n    if (score > this.lastHudScore) {\n      this.scoreFlashIntensity = 1;\n    }\n    this.lastHudScore = score;\n    this.scoreFlashIntensity *= 0.92;\n\n    const padding = 12;\n    const scorePanelWidth = 120;\n    const scorePanelHeight = 50;\n\n    // Score panel background - volcanic lava theme\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Glowing border\n    const borderGlow = 0.6 + this.scoreFlashIntensity * 0.4;\n    g.lineStyle(2, COLORS.snakeGlow, borderGlow);\n    g.strokeRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Score label\n    this.drawText(g, 'SCORE', padding + 10, padding + 12, 10, COLORS.snakeBody, 0.9);\n\n    // Score value with flash effect\n    const scoreColor = this.scoreFlashIntensity > 0.5 ? 0xffffff : COLORS.snakeHead;\n    this.drawText(g, String(score).padStart(5, '0'), padding + 10, padding + 32, 18, scoreColor, 1);\n\n    // Outer glow on score when flashing\n    if (this.scoreFlashIntensity > 0.1) {\n      g.fillStyle(COLORS.snakeGlow, this.scoreFlashIntensity * 0.3);\n      g.fillRoundedRect(padding + 5, padding + 20, 100, 28, 4);\n    }\n\n    // Length panel on the right\n    const lengthPanelWidth = 80;\n    const lengthPanelHeight = 50;\n    const lengthX = width - padding - lengthPanelWidth;\n\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    g.lineStyle(2, COLORS.foodGlow, 0.6);\n    g.strokeRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    this.drawText(g, 'LENGTH', lengthX + 10, padding + 12, 10, COLORS.food, 0.9);\n    this.drawText(g, String(this.currentState.snake.length), lengthX + 10, padding + 32, 18, COLORS.foodCore, 1);\n  }\n\n  private drawText(\n    g: Phaser.GameObjects.Graphics,\n    text: string,\n    x: number,","numLines":80,"startLine":3300,"totalLines":4130}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Y9NWNgWDUk5WDiJggSahhm","type":"message","role":"assistant","content":[{"type":"text","text":"I see the game over detection at line 3310. Now let me find where `lastGameOverState` is declared and add the trigger. Let me also look at the update method to add the tear/blood updates and draws."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1589,"cache_read_input_tokens":41747,"cache_creation":{"ephemeral_5m_input_tokens":1589,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"d6f1bb96-5650-47d5-b66d-432d20097c68"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Y9NWNgWDUk5WDiJggSahhm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Xyd5mz4E5HYHeC6GWZtq8s","name":"Read","input":{"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","offset":420,"limit":50},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1589,"cache_read_input_tokens":41747,"cache_creation":{"ephemeral_5m_input_tokens":1589,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"a071b311-d8e2-4d75-9e77-99f0aff5aecd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Xyd5mz4E5HYHeC6GWZtq8s","type":"tool_result","content":"   420â†’  private vortexRings: VortexRing[] = [];\n   421â†’  private vortexParticles: VortexParticle[] = [];\n   422â†’  private vortexPulse = 0;\n   423â†’  private meteors: Meteor[] = [];\n   424â†’  private deathDebris: DeathDebris[] = [];\n   425â†’  private deathExplosionPhase = 0;\n   426â†’  private gameOverAlpha = 0;\n   427â†’  private lastHeadPos: Position | null = null;\n   428â†’  private lastSnakeLength = 0;\n   429â†’  private hueOffset = 0;\n   430â†’  private screenFlashAlpha = 0;\n   431â†’  private gameOverGlitchOffset = 0;\n   432â†’  private screenShakeX = 0;\n   433â†’  private screenShakeY = 0;\n   434â†’  private screenShakeIntensity = 0;\n   435â†’  private energyFieldPulse = 0;\n   436â†’  private foodBurstParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number; hue: number; trail: { x: number; y: number }[] }[] = [];\n   437â†’  private chromaticIntensity = 0;\n   438â†’  // Film noir effects\n   439â†’  private venetianPhase = 0;\n   440â†’  private spotlightX = 0;\n   441â†’  private spotlightY = 0;\n   442â†’  private smokeParticles: { x: number; y: number; vx: number; vy: number; size: number; alpha: number; life: number }[] = [];\n   443â†’  private guardianSpirits: GuardianSpirit[] = [];\n   444â†’  // Burning flame particles trailing behind snake\n   445â†’  private flameParticles: FlameParticle[] = [];\n   446â†’  // Comet trail system - historical positions for smooth ribbon trail\n   447â†’  private cometTrail: CometTrailSegment[] = [];\n   448â†’  // Ethereal particles that drift away from the trail\n   449â†’  private etherealParticles: EtherealParticle[] = [];\n   450â†’  // Track last few head positions for smooth interpolation\n   451â†’  private headHistory: { x: number; y: number; time: number }[] = [];\n   452â†’  // Thrown food animation system\n   453â†’  private thrownFood: ThrownFood | null = null;\n   454â†’  private lastFoodPos: Position | null = null;\n   455â†’  // Mystical bees swarming around\n   456â†’  private bees: MysticalBee[] = [];\n   457â†’  // Rival snake - spectral AI nemesis\n   458â†’  private rivalSnake: RivalSnake | null = null;\n   459â†’  // Scoreboard system\n   460â†’  private highScores: HighScoreEntry[] = [];\n   461â†’  private highScoresLoaded = false;\n   462â†’  private newHighScoreRank = -1;\n   463â†’  private scoreboardAnimPhase = 0;\n   464â†’  private scoreboardRevealProgress = 0;\n   465â†’  private lastGameOverState = false;\n   466â†’  private hudPulsePhase = 0;\n   467â†’  private lastHudScore = 0;\n   468â†’  private scoreFlashIntensity = 0;\n   469â†’  // Armageddon Chaos effects\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"e4abfc8e-3219-4fe7-8a07-7f3d781c3804","tool_use_result":{"type":"text","file":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","content":"  private vortexRings: VortexRing[] = [];\n  private vortexParticles: VortexParticle[] = [];\n  private vortexPulse = 0;\n  private meteors: Meteor[] = [];\n  private deathDebris: DeathDebris[] = [];\n  private deathExplosionPhase = 0;\n  private gameOverAlpha = 0;\n  private lastHeadPos: Position | null = null;\n  private lastSnakeLength = 0;\n  private hueOffset = 0;\n  private screenFlashAlpha = 0;\n  private gameOverGlitchOffset = 0;\n  private screenShakeX = 0;\n  private screenShakeY = 0;\n  private screenShakeIntensity = 0;\n  private energyFieldPulse = 0;\n  private foodBurstParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number; hue: number; trail: { x: number; y: number }[] }[] = [];\n  private chromaticIntensity = 0;\n  // Film noir effects\n  private venetianPhase = 0;\n  private spotlightX = 0;\n  private spotlightY = 0;\n  private smokeParticles: { x: number; y: number; vx: number; vy: number; size: number; alpha: number; life: number }[] = [];\n  private guardianSpirits: GuardianSpirit[] = [];\n  // Burning flame particles trailing behind snake\n  private flameParticles: FlameParticle[] = [];\n  // Comet trail system - historical positions for smooth ribbon trail\n  private cometTrail: CometTrailSegment[] = [];\n  // Ethereal particles that drift away from the trail\n  private etherealParticles: EtherealParticle[] = [];\n  // Track last few head positions for smooth interpolation\n  private headHistory: { x: number; y: number; time: number }[] = [];\n  // Thrown food animation system\n  private thrownFood: ThrownFood | null = null;\n  private lastFoodPos: Position | null = null;\n  // Mystical bees swarming around\n  private bees: MysticalBee[] = [];\n  // Rival snake - spectral AI nemesis\n  private rivalSnake: RivalSnake | null = null;\n  // Scoreboard system\n  private highScores: HighScoreEntry[] = [];\n  private highScoresLoaded = false;\n  private newHighScoreRank = -1;\n  private scoreboardAnimPhase = 0;\n  private scoreboardRevealProgress = 0;\n  private lastGameOverState = false;\n  private hudPulsePhase = 0;\n  private lastHudScore = 0;\n  private scoreFlashIntensity = 0;\n  // Armageddon Chaos effects","numLines":50,"startLine":420,"totalLines":4130}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019BFBLBUVstMBTWHDkob4Lr","type":"message","role":"assistant","content":[{"type":"text","text":"Now I understand the structure. I need to:\n1. Trigger `spawnTears` and `spawnBlood` when gameOver becomes true\n2. Update tears and blood in the update loop\n3. Draw them in the render cycle\n\nLet me update the `checkAndSaveHighScore` method to spawn the effects:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1158,"cache_read_input_tokens":43336,"cache_creation":{"ephemeral_5m_input_tokens":1158,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"4855fdf6-077b-4911-b923-257ea6df6641"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019BFBLBUVstMBTWHDkob4Lr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PwXxkizGbPyDCdZcsuGpFU","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","old_string":"  private checkAndSaveHighScore(): void {\n    if (!this.currentState) return;\n\n    if (this.currentState.gameOver && !this.lastGameOverState) {\n      const score = this.currentState.score || 0;\n      const rank = this.saveHighScore(score);\n      this.newHighScoreRank = rank > 0 ? rank : -1;\n      this.scoreboardRevealProgress = 0;\n    }\n    this.lastGameOverState = this.currentState.gameOver;","new_string":"  private checkAndSaveHighScore(): void {\n    if (!this.currentState) return;\n\n    if (this.currentState.gameOver && !this.lastGameOverState) {\n      const score = this.currentState.score || 0;\n      const rank = this.saveHighScore(score);\n      this.newHighScoreRank = rank > 0 ? rank : -1;\n      this.scoreboardRevealProgress = 0;\n\n      const head = this.currentState.snake[0];\n      if (head) {\n        const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnBlood(this.cleanEffects, headX, headY, 15);\n        spawnTears(this.cleanEffects, headX, headY - 10, 6);\n      }\n    }\n    this.lastGameOverState = this.currentState.gameOver;"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1158,"cache_read_input_tokens":43336,"cache_creation":{"ephemeral_5m_input_tokens":1158,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"2c5afdfe-43c9-4a86-81aa-56045cbc6b46"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PwXxkizGbPyDCdZcsuGpFU","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"81e98e64-4230-4d78-893a-e52786b223fd","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","oldString":"  private checkAndSaveHighScore(): void {\n    if (!this.currentState) return;\n\n    if (this.currentState.gameOver && !this.lastGameOverState) {\n      const score = this.currentState.score || 0;\n      const rank = this.saveHighScore(score);\n      this.newHighScoreRank = rank > 0 ? rank : -1;\n      this.scoreboardRevealProgress = 0;\n    }\n    this.lastGameOverState = this.currentState.gameOver;","newString":"  private checkAndSaveHighScore(): void {\n    if (!this.currentState) return;\n\n    if (this.currentState.gameOver && !this.lastGameOverState) {\n      const score = this.currentState.score || 0;\n      const rank = this.saveHighScore(score);\n      this.newHighScoreRank = rank > 0 ? rank : -1;\n      this.scoreboardRevealProgress = 0;\n\n      const head = this.currentState.snake[0];\n      if (head) {\n        const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnBlood(this.cleanEffects, headX, headY, 15);\n        spawnTears(this.cleanEffects, headX, headY - 10, 6);\n      }\n    }\n    this.lastGameOverState = this.currentState.gameOver;","originalFile":"import Phaser from 'phaser';\nimport {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface GameState {\n  snake: Position[];\n  food: Position;\n  gameOver: boolean;\n  gameStarted?: boolean;\n  score?: number;\n}\n\ninterface Star {\n  x: number;\n  y: number;\n  size: number;\n  speed: number;\n  brightness: number;\n}\n\ninterface PlasmaWave {\n  phase: number;\n  speed: number;\n  amplitude: number;\n  wavelength: number;\n  hue: number;\n}\n\ninterface AuroraWave {\n  y: number;\n  phase: number;\n  speed: number;\n  hue: number;\n  thickness: number;\n  amplitude: number;\n}\n\ninterface NebulaCloud {\n  x: number;\n  y: number;\n  radius: number;\n  hue: number;\n  alpha: number;\n  driftX: number;\n  driftY: number;\n  pulsePhase: number;\n  pulseSpeed: number;\n}\n\ninterface VortexRing {\n  radius: number;\n  baseRadius: number;\n  rotationOffset: number;\n  rotationSpeed: number;\n  thickness: number;\n  hue: number;\n  pulsePhase: number;\n}\n\ninterface VortexParticle {\n  angle: number;\n  radius: number;\n  baseRadius: number;\n  speed: number;\n  size: number;\n  hue: number;\n  alpha: number;\n}\n\ninterface SnakeAfterimage {\n  segments: Position[];\n  life: number;\n  maxLife: number;\n  hueOffset: number;\n}\n\ninterface FoodParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n}\n\ninterface SnakeTrailParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n  hue: number;\n}\n\ninterface ShockWave {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n}\n\ninterface LightningBolt {\n  points: { x: number; y: number }[];\n  life: number;\n  maxLife: number;\n  hue: number;\n}\n\nconst CELL_SIZE = 20;\nconst GRID_SIZE = 20;\nconst NUM_STARS = 30;\nconst MAX_FOOD_PARTICLES = 8;\nconst MAX_TRAIL_PARTICLES = 40;\nconst MAX_SHOCKWAVES = 3;\nconst MAX_LIGHTNING_BOLTS = 5;\nconst MAX_BURST_PARTICLES = 12;\nconst NUM_PLASMA_WAVES = 3;\nconst MAX_AFTERIMAGES = 4;\nconst NUM_AURORA_WAVES = 5;\nconst NUM_NEBULA_CLOUDS = 6;\nconst NUM_VORTEX_RINGS = 5;\nconst NUM_VORTEX_PARTICLES = 20;\nconst NUM_METEORS = 8;\nconst MAX_DEATH_DEBRIS = 24;\nconst NUM_SPIRITS_PER_EDGE = 2;\nconst MAX_FLAME_PARTICLES = 60;\nconst MAX_COMET_TRAIL_LENGTH = 30;\nconst MAX_ETHEREAL_PARTICLES = 50;\nconst NUM_BEES = 8;\nconst BEE_SPAWN_CHANCE = 0.02;\n\n// Comet trail segment - stores historical snake positions for smooth trail rendering\ninterface CometTrailSegment {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n  hue: number;\n}\n\n// Ethereal trail particle - luminous particles that drift away from trail\ninterface EtherealParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n  pulsePhase: number;\n}\n\n// Thrown food animation - food launched onto screen with arc trajectory\ninterface ThrownFood {\n  startX: number;\n  startY: number;\n  targetX: number;\n  targetY: number;\n  x: number;\n  y: number;\n  progress: number; // 0 to 1\n  rotation: number;\n  rotationSpeed: number;\n  trail: { x: number; y: number; alpha: number; rotation: number }[];\n  landed: boolean;\n  landingParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number }[];\n  impactRings: { radius: number; alpha: number }[];\n}\n\n// Meteor shower types\ninterface Meteor {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  alpha: number;\n  trail: { x: number; y: number; alpha: number }[];\n  life: number;\n}\n\n// Death debris particle\ninterface DeathDebris {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  rotation: number;\n  rotationSpeed: number;\n  life: number;\n  type: 'shard' | 'spark' | 'ember';\n}\n\n// Guardian spirit - ethereal protectors at edges\ninterface GuardianSpirit {\n  x: number;\n  y: number;\n  baseX: number;\n  baseY: number;\n  size: number;\n  phase: number;\n  speed: number;\n  haloPhase: number;\n  orbPhase: number;\n  edge: 'top' | 'bottom' | 'left' | 'right';\n  targetAlpha: number;\n  currentAlpha: number;\n  hue: number;\n  orbs: { angle: number; distance: number; size: number; speed: number }[];\n}\n\n// Flame particle for burning effect\ninterface FlameParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n}\n\n// Mystical bee - glowing magical creatures that swarm around food\ninterface MysticalBee {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  targetX: number;\n  targetY: number;\n  wingPhase: number;\n  wingSpeed: number;\n  size: number;\n  hue: number;\n  glowIntensity: number;\n  bobPhase: number;\n  bobSpeed: number;\n  trail: { x: number; y: number; alpha: number }[];\n  state: 'flying' | 'hovering' | 'attracted';\n  sparkleTimer: number;\n}\n\n// Rival snake - spectral AI nemesis that competes for food\ninterface RivalSnake {\n  segments: { x: number; y: number }[];\n  direction: { dx: number; dy: number };\n  targetX: number;\n  targetY: number;\n  moveTimer: number;\n  moveInterval: number;\n  pulsePhase: number;\n  glowIntensity: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n  energyTrail: { x: number; y: number; alpha: number; size: number }[];\n  state: 'hunting' | 'fleeing' | 'circling';\n  aggression: number;\n  nearMissTimer: number;\n  electricArcs: { x1: number; y1: number; x2: number; y2: number; life: number }[];\n}\n\nconst RIVAL_SNAKE_LENGTH = 10;\nconst RIVAL_MOVE_INTERVAL = 8;\n\n// Armageddon Chaos effect types\ninterface GroundFissure {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  width: number;\n  glowIntensity: number;\n  pulsePhase: number;\n}\n\ninterface FireRainParticle {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n}\n\ninterface ChaosExplosion {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n  rings: { radius: number; alpha: number }[];\n  debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[];\n}\n\ninterface ApocalypticSkull {\n  x: number;\n  y: number;\n  size: number;\n  alpha: number;\n  rotation: number;\n  pulsePhase: number;\n}\n\nconst NUM_FISSURES = 6;\nconst MAX_FIRE_RAIN = 30;\nconst MAX_CHAOS_EXPLOSIONS = 3;\nconst NUM_SKULLS = 4;\n\n// High score entry for scoreboard\ninterface HighScoreEntry {\n  score: number;\n  date: number;\n  rank: number;\n}\n\nconst MAX_HIGH_SCORES = 5;\n\n// Color palette - HALLOWEEN theme: spooky purple/orange, ghostly greens, pumpkin glow\nconst COLORS = {\n  bgDark: 0x0a0012,\n  bgMid: 0x150825,\n  gridLine: 0x2a1540,\n  gridAccent: 0x401860,\n  snakeHead: 0x00ff66,\n  snakeBody: 0x00cc55,\n  snakeTail: 0x009944,\n  snakeHighlight: 0x66ffaa,\n  snakeScale: 0x00aa44,\n  snakeEye: 0xff0000,\n  snakePupil: 0x000000,\n  snakeGlow: 0x00ff80,\n  food: 0xff6600,\n  foodCore: 0xffcc00,\n  foodGlow: 0xff8800,\n  foodParticle: 0xffaa00,\n  star: 0x8844ff,\n  gameOverOverlay: 0x0a0015,\n  gameOverText: 0xff6600,\n  plasma1: 0x9933ff,\n  plasma2: 0xbb55ff,\n  plasma3: 0x7722cc,\n  screenFlash: 0xff6600,\n  // Halloween specific colors\n  noirWhite: 0xeeddff,\n  noirGray: 0x8866aa,\n  noirDark: 0x2a1540,\n  spotlight: 0xff8800,\n  // Halloween additions\n  chaosRed: 0x9933ff,\n  chaosOrange: 0xff6600,\n  chaosYellow: 0xffcc00,\n  lavaGlow: 0x9944ff,\n  ashGray: 0x554466,\n  bloodRed: 0x660088,\n  hellfire: 0xff6600,\n  // New Halloween colors\n  pumpkinOrange: 0xff6600,\n  ghostWhite: 0xeeffee,\n  witchPurple: 0x9933ff,\n  spiderBlack: 0x111122,\n  candyCorn1: 0xffcc00,\n  candyCorn2: 0xff8800,\n  candyCorn3: 0xffffff,\n};\n\nexport class SnakeScene extends Phaser.Scene {\n  private graphics!: Phaser.GameObjects.Graphics;\n  private currentState: GameState | null = null;\n  private needsRedraw = false;\n  private frameCount = 0;\n  private stars: Star[] = [];\n  private foodParticles: FoodParticle[] = [];\n  private trailParticles: SnakeTrailParticle[] = [];\n  private shockWaves: ShockWave[] = [];\n  private lightningBolts: LightningBolt[] = [];\n  private plasmaWaves: PlasmaWave[] = [];\n  private snakeAfterimages: SnakeAfterimage[] = [];\n  private auroraWaves: AuroraWave[] = [];\n  private nebulaClouds: NebulaCloud[] = [];\n  private vortexRings: VortexRing[] = [];\n  private vortexParticles: VortexParticle[] = [];\n  private vortexPulse = 0;\n  private meteors: Meteor[] = [];\n  private deathDebris: DeathDebris[] = [];\n  private deathExplosionPhase = 0;\n  private gameOverAlpha = 0;\n  private lastHeadPos: Position | null = null;\n  private lastSnakeLength = 0;\n  private hueOffset = 0;\n  private screenFlashAlpha = 0;\n  private gameOverGlitchOffset = 0;\n  private screenShakeX = 0;\n  private screenShakeY = 0;\n  private screenShakeIntensity = 0;\n  private energyFieldPulse = 0;\n  private foodBurstParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number; hue: number; trail: { x: number; y: number }[] }[] = [];\n  private chromaticIntensity = 0;\n  // Film noir effects\n  private venetianPhase = 0;\n  private spotlightX = 0;\n  private spotlightY = 0;\n  private smokeParticles: { x: number; y: number; vx: number; vy: number; size: number; alpha: number; life: number }[] = [];\n  private guardianSpirits: GuardianSpirit[] = [];\n  // Burning flame particles trailing behind snake\n  private flameParticles: FlameParticle[] = [];\n  // Comet trail system - historical positions for smooth ribbon trail\n  private cometTrail: CometTrailSegment[] = [];\n  // Ethereal particles that drift away from the trail\n  private etherealParticles: EtherealParticle[] = [];\n  // Track last few head positions for smooth interpolation\n  private headHistory: { x: number; y: number; time: number }[] = [];\n  // Thrown food animation system\n  private thrownFood: ThrownFood | null = null;\n  private lastFoodPos: Position | null = null;\n  // Mystical bees swarming around\n  private bees: MysticalBee[] = [];\n  // Rival snake - spectral AI nemesis\n  private rivalSnake: RivalSnake | null = null;\n  // Scoreboard system\n  private highScores: HighScoreEntry[] = [];\n  private highScoresLoaded = false;\n  private newHighScoreRank = -1;\n  private scoreboardAnimPhase = 0;\n  private scoreboardRevealProgress = 0;\n  private lastGameOverState = false;\n  private hudPulsePhase = 0;\n  private lastHudScore = 0;\n  private scoreFlashIntensity = 0;\n  // Armageddon Chaos effects\n  private groundFissures: GroundFissure[] = [];\n  private fireRainParticles: FireRainParticle[] = [];\n  private chaosExplosions: ChaosExplosion[] = [];\n  private apocalypticSkulls: ApocalypticSkull[] = [];\n  private armageddonPulse = 0;\n  private chaosIntensity = 0;\n  private cleanEffects: CleanEffectsState = createCleanEffectsState();\n\n  constructor() {\n    super({ key: 'SnakeScene' });\n  }\n\n  create(): void {\n    this.graphics = this.add.graphics();\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    initMotes(this.cleanEffects, width, height);\n\n    if (this.currentState) {\n      this.needsRedraw = true;\n    }\n  }\n\n  private initArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Initialize ground fissures - cracks in the earth with lava\n    this.groundFissures = [];\n    for (let i = 0; i < NUM_FISSURES; i++) {\n      const startX = Math.random() * width;\n      const startY = Math.random() * height;\n      const angle = Math.random() * Math.PI;\n      const length = 40 + Math.random() * 80;\n      this.groundFissures.push({\n        x1: startX,\n        y1: startY,\n        x2: startX + Math.cos(angle) * length,\n        y2: startY + Math.sin(angle) * length,\n        width: 2 + Math.random() * 4,\n        glowIntensity: 0.5 + Math.random() * 0.5,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n\n    // Initialize fire rain\n    this.fireRainParticles = [];\n\n    // Initialize chaos explosions\n    this.chaosExplosions = [];\n\n    // Initialize apocalyptic skulls floating in background\n    this.apocalypticSkulls = [];\n    for (let i = 0; i < NUM_SKULLS; i++) {\n      this.apocalypticSkulls.push({\n        x: 30 + Math.random() * (width - 60),\n        y: 30 + Math.random() * (height - 60),\n        size: 15 + Math.random() * 10,\n        alpha: 0.03 + Math.random() * 0.04,\n        rotation: Math.random() * Math.PI * 2,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n  }\n\n  private initSmokeParticles(): void {\n    this.smokeParticles = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < 12; i++) {\n      this.smokeParticles.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        vx: (Math.random() - 0.5) * 0.3,\n        vy: -0.1 - Math.random() * 0.2,\n        size: 30 + Math.random() * 50,\n        alpha: 0.02 + Math.random() * 0.03,\n        life: Math.random(),\n      });\n    }\n  }\n\n  private updateArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    this.armageddonPulse += 0.04;\n\n    // Update ground fissures - pulsing lava glow\n    for (const fissure of this.groundFissures) {\n      fissure.pulsePhase += 0.06;\n      fissure.glowIntensity = 0.5 + Math.sin(fissure.pulsePhase) * 0.3;\n    }\n\n    // Spawn fire rain particles\n    if (this.fireRainParticles.length < MAX_FIRE_RAIN && Math.random() < 0.3) {\n      const hueVariation = Math.random();\n      this.fireRainParticles.push({\n        x: Math.random() * width,\n        y: -20,\n        vy: 2 + Math.random() * 3,\n        size: 2 + Math.random() * 4,\n        alpha: 0.6 + Math.random() * 0.4,\n        hue: hueVariation < 0.6 ? 0 : (hueVariation < 0.85 ? 20 : 40), // Red, orange, yellow\n        trail: [],\n      });\n    }\n\n    // Update fire rain\n    for (let i = this.fireRainParticles.length - 1; i >= 0; i--) {\n      const p = this.fireRainParticles[i];\n      p.trail.unshift({ x: p.x, y: p.y, alpha: p.alpha });\n      if (p.trail.length > 6) p.trail.pop();\n      for (const t of p.trail) { t.alpha *= 0.7; }\n\n      p.y += p.vy;\n      p.x += Math.sin(this.armageddonPulse + p.y * 0.05) * 0.3;\n      p.alpha *= 0.995;\n\n      if (p.y > height + 20 || p.alpha < 0.05) {\n        this.fireRainParticles.splice(i, 1);\n      }\n    }\n\n    // Update chaos explosions\n    for (let i = this.chaosExplosions.length - 1; i >= 0; i--) {\n      const exp = this.chaosExplosions[i];\n      exp.radius += 4;\n      exp.life -= 0.03;\n\n      for (const ring of exp.rings) {\n        ring.radius += 3;\n        ring.alpha *= 0.92;\n      }\n      exp.rings = exp.rings.filter(r => r.alpha > 0.02);\n\n      for (const d of exp.debris) {\n        d.x += d.vx;\n        d.y += d.vy;\n        d.vy += 0.1;\n        d.alpha *= 0.96;\n      }\n      exp.debris = exp.debris.filter(d => d.alpha > 0.02);\n\n      if (exp.life <= 0 && exp.rings.length === 0 && exp.debris.length === 0) {\n        this.chaosExplosions.splice(i, 1);\n      }\n    }\n\n    // Update apocalyptic skulls - slow drift and pulse\n    for (const skull of this.apocalypticSkulls) {\n      skull.pulsePhase += 0.02;\n      skull.rotation += 0.002;\n      skull.x += Math.sin(skull.pulsePhase * 0.5) * 0.1;\n      skull.y += Math.cos(skull.pulsePhase * 0.3) * 0.1;\n\n      // Keep in bounds\n      if (skull.x < 20) skull.x = 20;\n      if (skull.x > width - 20) skull.x = width - 20;\n      if (skull.y < 20) skull.y = 20;\n      if (skull.y > height - 20) skull.y = height - 20;\n    }\n\n    // Chaos intensity increases when snake eats or dies\n    this.chaosIntensity *= 0.97;\n  }\n\n  private spawnChaosExplosion(x: number, y: number): void {\n    if (this.chaosExplosions.length >= MAX_CHAOS_EXPLOSIONS) {\n      this.chaosExplosions.shift();\n    }\n\n    const debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[] = [];\n    for (let i = 0; i < 12; i++) {\n      const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 5;\n      debris.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 2,\n        size: 2 + Math.random() * 4,\n        alpha: 1,\n      });\n    }\n\n    this.chaosExplosions.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: 80,\n      life: 1,\n      rings: [\n        { radius: 10, alpha: 1 },\n        { radius: 5, alpha: 0.8 },\n        { radius: 15, alpha: 0.6 },\n      ],\n      debris,\n    });\n\n    this.chaosIntensity = Math.min(1, this.chaosIntensity + 0.5);\n    this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 12);\n  }\n\n  private drawArmageddonBackground(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Spooky Halloween night sky\n    const skyPulse = 0.8 + Math.sin(this.armageddonPulse * 0.5) * 0.2;\n\n    // Layer 1: Deep purple-black night base\n    g.fillStyle(0x0a0018, 1);\n    g.fillRect(0, 0, width, height);\n\n    // Layer 2: Eerie purple glow from below (like fog)\n    g.fillStyle(0x200840, 0.3 * skyPulse);\n    g.fillRect(0, height * 0.7, width, height * 0.3);\n\n    // Layer 3: Misty purple clouds\n    for (let i = 0; i < 4; i++) {\n      const cloudY = i * 30 + Math.sin(this.armageddonPulse + i) * 10;\n      const cloudAlpha = 0.1 - i * 0.02;\n      g.fillStyle(0x301040, cloudAlpha * skyPulse);\n      g.fillRect(0, cloudY, width, 40);\n    }\n\n    // Draw haunted moon\n    this.drawHauntedMoon(g, width);\n\n    // Draw flying bats in background\n    this.drawFlyingBats(g, width, height);\n\n    // Draw apocalyptic skulls (very faint, background layer)\n    this.drawApocalypticSkulls(g);\n  }\n\n  private drawHauntedMoon(g: Phaser.GameObjects.Graphics, width: number): void {\n    const moonX = width * 0.8;\n    const moonY = 60;\n    const moonRadius = 35;\n    const moonPulse = 0.9 + Math.sin(this.frameCount * 0.02) * 0.1;\n\n    // Moon glow\n    g.fillStyle(0xff8800, 0.1 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 2);\n    g.fillStyle(0xffaa00, 0.15 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 1.5);\n\n    // Main moon (orange harvest moon)\n    g.fillStyle(0xffaa33, 0.9);\n    g.fillCircle(moonX, moonY, moonRadius);\n\n    // Moon craters\n    g.fillStyle(0xcc8822, 0.4);\n    g.fillCircle(moonX - 10, moonY - 5, 8);\n    g.fillCircle(moonX + 12, moonY + 8, 6);\n    g.fillCircle(moonX - 5, moonY + 12, 5);\n  }\n\n  private drawFlyingBats(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const batCount = 6;\n    for (let i = 0; i < batCount; i++) {\n      const phase = this.frameCount * 0.03 + i * 1.5;\n      const batX = ((i * 127 + this.frameCount * 0.5) % (width + 100)) - 50;\n      const batY = 40 + i * 20 + Math.sin(phase) * 15;\n      const wingPhase = Math.sin(this.frameCount * 0.15 + i * 2);\n\n      // Bat body\n      g.fillStyle(0x111122, 0.8);\n      g.fillCircle(batX, batY, 4);\n\n      // Bat wings (flapping)\n      const wingSpread = 8 + wingPhase * 4;\n      g.fillStyle(0x111122, 0.7);\n\n      // Left wing\n      g.beginPath();\n      g.moveTo(batX - 2, batY);\n      g.lineTo(batX - wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX - wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n\n      // Right wing\n      g.beginPath();\n      g.moveTo(batX + 2, batY);\n      g.lineTo(batX + wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX + wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawGroundFissures(g: Phaser.GameObjects.Graphics): void {\n    for (const fissure of this.groundFissures) {\n      const pulse = fissure.glowIntensity;\n\n      // Ghostly purple glow underneath\n      g.lineStyle(fissure.width * 3, COLORS.lavaGlow, 0.12 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Crack edges (dark purple)\n      g.lineStyle(fissure.width + 2, 0x200030, 0.4);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ethereal core (bright purple)\n      g.lineStyle(fissure.width, COLORS.witchPurple, 0.3 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ghostly white center\n      g.lineStyle(fissure.width * 0.3, COLORS.ghostWhite, 0.2 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n    }\n  }\n\n  private drawFireRain(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.fireRainParticles) {\n      // Draw ghostly trail\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailSize = p.size * (1 - i / p.trail.length) * 0.6;\n        // Ghostly purple/green trail\n        const ghostHue = 0.75 + (p.hue % 60) / 360;\n        const trailColor = this.hslToRgb(ghostHue, 0.6, 0.6);\n        g.fillStyle(trailColor, t.alpha * 0.3);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Main spirit particle (ghostly appearance)\n      const outerColor = this.hslToRgb(0.8, 0.5, 0.5);\n      const coreColor = this.hslToRgb(0.85, 0.3, 0.8);\n\n      g.fillStyle(outerColor, p.alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      g.fillStyle(coreColor, p.alpha * 0.6);\n      g.fillCircle(p.x, p.y, p.size);\n\n      g.fillStyle(COLORS.ghostWhite, p.alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawChaosExplosions(g: Phaser.GameObjects.Graphics): void {\n    for (const exp of this.chaosExplosions) {\n      // Central flash\n      if (exp.life > 0.7) {\n        const flashAlpha = (exp.life - 0.7) * 3;\n        g.fillStyle(0xffffff, flashAlpha * 0.5);\n        g.fillCircle(exp.x, exp.y, exp.radius * 0.5);\n        g.fillStyle(COLORS.chaosYellow, flashAlpha * 0.4);\n        g.fillCircle(exp.x, exp.y, exp.radius);\n      }\n\n      // Expanding rings\n      for (const ring of exp.rings) {\n        g.lineStyle(4, COLORS.chaosRed, ring.alpha * 0.5);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(2, COLORS.chaosOrange, ring.alpha * 0.7);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(1, 0xffffff, ring.alpha * 0.4);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n      }\n\n      // Flying debris\n      for (const d of exp.debris) {\n        g.fillStyle(COLORS.chaosOrange, d.alpha * 0.6);\n        g.fillCircle(d.x, d.y, d.size * 1.3);\n        g.fillStyle(COLORS.chaosYellow, d.alpha * 0.9);\n        g.fillCircle(d.x, d.y, d.size);\n      }\n    }\n  }\n\n  private drawApocalypticSkulls(g: Phaser.GameObjects.Graphics): void {\n    for (const skull of this.apocalypticSkulls) {\n      const pulse = 0.7 + Math.sin(skull.pulsePhase) * 0.3;\n      const alpha = skull.alpha * pulse;\n      const s = skull.size;\n\n      // Ghostly purple glow\n      g.fillStyle(COLORS.witchPurple, alpha * 0.2);\n      g.fillCircle(skull.x, skull.y, s * 1.5);\n\n      // Skull outline (bone white)\n      g.fillStyle(0xcccccc, alpha * 0.8);\n      // Cranium\n      g.fillCircle(skull.x, skull.y - s * 0.1, s * 0.8);\n      // Jaw\n      g.fillRect(skull.x - s * 0.4, skull.y + s * 0.3, s * 0.8, s * 0.4);\n\n      // Eye sockets (glowing green - spooky!)\n      g.fillStyle(COLORS.snakeHead, alpha * 1.2);\n      g.fillCircle(skull.x - s * 0.25, skull.y - s * 0.1, s * 0.2);\n      g.fillCircle(skull.x + s * 0.25, skull.y - s * 0.1, s * 0.2);\n\n      // Nose hole\n      g.fillStyle(0x000000, alpha);\n      g.fillTriangle(\n        skull.x, skull.y + s * 0.1,\n        skull.x - s * 0.1, skull.y + s * 0.25,\n        skull.x + s * 0.1, skull.y + s * 0.25\n      );\n    }\n  }\n\n  private drawChaosOverlay(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (this.chaosIntensity <= 0) return;\n\n    // Purple tint overlay when chaos is active\n    g.fillStyle(COLORS.witchPurple, this.chaosIntensity * 0.1);\n    g.fillRect(0, 0, width, height);\n\n    // Pulsing purple vignette edges\n    const vignetteAlpha = this.chaosIntensity * 0.25;\n    g.lineStyle(80, COLORS.bloodRed, vignetteAlpha);\n    g.strokeRect(-40, -40, width + 80, height + 80);\n  }\n\n  private initGuardianSpirits(): void {\n    this.guardianSpirits = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const spiritHues = [180, 220, 280, 320];\n\n    const edges: ('top' | 'bottom' | 'left' | 'right')[] = ['top', 'bottom', 'left', 'right'];\n    for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      const edge = edges[edgeIndex];\n      for (let i = 0; i < NUM_SPIRITS_PER_EDGE; i++) {\n        let x = 0, y = 0;\n        const offset = (i + 0.5) / NUM_SPIRITS_PER_EDGE;\n\n        switch (edge) {\n          case 'top':\n            x = width * offset;\n            y = -15;\n            break;\n          case 'bottom':\n            x = width * offset;\n            y = height + 15;\n            break;\n          case 'left':\n            x = -15;\n            y = height * offset;\n            break;\n          case 'right':\n            x = width + 15;\n            y = height * offset;\n            break;\n        }\n\n        const orbs: { angle: number; distance: number; size: number; speed: number }[] = [];\n        const numOrbs = 3;\n        for (let o = 0; o < numOrbs; o++) {\n          orbs.push({\n            angle: (o / numOrbs) * Math.PI * 2,\n            distance: 15 + Math.random() * 10,\n            size: 3 + Math.random() * 2,\n            speed: 0.03 + Math.random() * 0.02,\n          });\n        }\n\n        this.guardianSpirits.push({\n          x,\n          y,\n          baseX: x,\n          baseY: y,\n          size: 20 + Math.random() * 10,\n          phase: Math.random() * Math.PI * 2,\n          speed: 0.015 + Math.random() * 0.01,\n          haloPhase: Math.random() * Math.PI * 2,\n          orbPhase: Math.random() * Math.PI * 2,\n          edge,\n          targetAlpha: 0.4 + Math.random() * 0.2,\n          currentAlpha: 0,\n          hue: spiritHues[edgeIndex % spiritHues.length] + Math.random() * 30 - 15,\n          orbs,\n        });\n      }\n    }\n  }\n\n  private initBees(): void {\n    this.bees = [];\n  }\n\n  private initRivalSnake(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    const startX = width - 50 - Math.random() * 50;\n    const startY = height - 50 - Math.random() * 50;\n\n    const segments: { x: number; y: number }[] = [];\n    for (let i = 0; i < RIVAL_SNAKE_LENGTH; i++) {\n      segments.push({\n        x: startX + i * CELL_SIZE * 0.6,\n        y: startY,\n      });\n    }\n\n    this.rivalSnake = {\n      segments,\n      direction: { dx: -1, dy: 0 },\n      targetX: width / 2,\n      targetY: height / 2,\n      moveTimer: 0,\n      moveInterval: RIVAL_MOVE_INTERVAL,\n      pulsePhase: 0,\n      glowIntensity: 0.8,\n      hue: 200,\n      trail: [],\n      energyTrail: [],\n      state: 'hunting',\n      aggression: 0.5,\n      nearMissTimer: 0,\n      electricArcs: [],\n    };\n  }\n\n  private updateRivalSnake(): void {\n    if (!this.rivalSnake || !this.currentState) return;\n\n    const rs = this.rivalSnake;\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    rs.pulsePhase += 0.1;\n    rs.glowIntensity = 0.6 + Math.sin(rs.pulsePhase) * 0.3;\n\n    if (rs.segments.length > 0) {\n      rs.trail.unshift({ x: rs.segments[0].x, y: rs.segments[0].y, alpha: 0.7 });\n      if (rs.trail.length > 20) rs.trail.pop();\n\n      rs.energyTrail.unshift({\n        x: rs.segments[0].x + (Math.random() - 0.5) * 8,\n        y: rs.segments[0].y + (Math.random() - 0.5) * 8,\n        alpha: 0.8,\n        size: 3 + Math.random() * 4\n      });\n      if (rs.energyTrail.length > 30) rs.energyTrail.pop();\n    }\n\n    for (const t of rs.trail) {\n      t.alpha *= 0.92;\n    }\n    rs.trail = rs.trail.filter(t => t.alpha > 0.02);\n\n    for (const e of rs.energyTrail) {\n      e.alpha *= 0.88;\n      e.size *= 0.95;\n    }\n    rs.energyTrail = rs.energyTrail.filter(e => e.alpha > 0.02);\n\n    rs.electricArcs = rs.electricArcs.filter(arc => {\n      arc.life -= 0.15;\n      return arc.life > 0;\n    });\n\n    if (rs.nearMissTimer > 0) rs.nearMissTimer--;\n\n    const playerHead = this.currentState.snake[0];\n    const playerX = playerHead.x * CELL_SIZE + CELL_SIZE / 2;\n    const playerY = playerHead.y * CELL_SIZE + CELL_SIZE / 2;\n    const rivalHead = rs.segments[0];\n    const distToPlayer = Math.sqrt(\n      Math.pow(playerX - rivalHead.x, 2) + Math.pow(playerY - rivalHead.y, 2)\n    );\n\n    if (distToPlayer < 60 && rs.nearMissTimer === 0) {\n      rs.nearMissTimer = 30;\n      rs.electricArcs.push({\n        x1: rivalHead.x,\n        y1: rivalHead.y,\n        x2: playerX,\n        y2: playerY,\n        life: 1.0\n      });\n      rs.aggression = Math.min(1.0, rs.aggression + 0.1);\n    }\n\n    rs.moveTimer++;\n    if (rs.moveTimer >= rs.moveInterval) {\n      rs.moveTimer = 0;\n\n      const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n      const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n      const distToFood = Math.sqrt(\n        Math.pow(foodX - rivalHead.x, 2) + Math.pow(foodY - rivalHead.y, 2)\n      );\n\n      if (distToPlayer < 80) {\n        rs.state = 'fleeing';\n        const fleeAngle = Math.atan2(rivalHead.y - playerY, rivalHead.x - playerX);\n        rs.targetX = rivalHead.x + Math.cos(fleeAngle) * 100;\n        rs.targetY = rivalHead.y + Math.sin(fleeAngle) * 100;\n      } else if (distToFood < 150 || rs.aggression > 0.7) {\n        rs.state = 'hunting';\n        rs.targetX = foodX;\n        rs.targetY = foodY;\n      } else {\n        rs.state = 'circling';\n        const circleAngle = rs.pulsePhase * 0.3;\n        rs.targetX = width / 2 + Math.cos(circleAngle) * 120;\n        rs.targetY = height / 2 + Math.sin(circleAngle) * 120;\n      }\n\n      rs.targetX = Math.max(30, Math.min(width - 30, rs.targetX));\n      rs.targetY = Math.max(30, Math.min(height - 30, rs.targetY));\n\n      const dx = rs.targetX - rivalHead.x;\n      const dy = rs.targetY - rivalHead.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 5) {\n        const targetDx = dx / dist;\n        const targetDy = dy / dist;\n        const turnSpeed = rs.state === 'fleeing' ? 0.5 : 0.35;\n\n        rs.direction.dx = rs.direction.dx * (1 - turnSpeed) + targetDx * turnSpeed;\n        rs.direction.dy = rs.direction.dy * (1 - turnSpeed) + targetDy * turnSpeed;\n\n        const len = Math.sqrt(rs.direction.dx * rs.direction.dx + rs.direction.dy * rs.direction.dy);\n        if (len > 0) {\n          rs.direction.dx /= len;\n          rs.direction.dy /= len;\n        }\n      }\n\n      const moveSpeed = rs.state === 'fleeing' ? CELL_SIZE * 0.7 : CELL_SIZE * 0.55;\n      const newHead = {\n        x: rivalHead.x + rs.direction.dx * moveSpeed,\n        y: rivalHead.y + rs.direction.dy * moveSpeed,\n      };\n\n      if (newHead.x < 10) newHead.x = width - 10;\n      if (newHead.x > width - 10) newHead.x = 10;\n      if (newHead.y < 10) newHead.y = height - 10;\n      if (newHead.y > height - 10) newHead.y = 10;\n\n      rs.segments.unshift(newHead);\n      rs.segments.pop();\n    } else {\n      const head = rs.segments[0];\n      const moveSpeed = CELL_SIZE * 0.5;\n\n      head.x += rs.direction.dx * moveSpeed * 0.06;\n      head.y += rs.direction.dy * moveSpeed * 0.06;\n\n      for (let i = 1; i < rs.segments.length; i++) {\n        const seg = rs.segments[i];\n        const prev = rs.segments[i - 1];\n        const pullStrength = 0.18;\n        seg.x += (prev.x - seg.x) * pullStrength;\n        seg.y += (prev.y - seg.y) * pullStrength;\n      }\n    }\n\n    if (this.currentState.gameOver) {\n      rs.hue = 180;\n      rs.glowIntensity *= 0.95;\n      rs.state = 'circling';\n    } else {\n      rs.hue = rs.state === 'hunting' ? 190 : (rs.state === 'fleeing' ? 220 : 200);\n      rs.hue += Math.sin(rs.pulsePhase * 0.5) * 10;\n    }\n\n    rs.aggression *= 0.998;\n  }\n\n  private drawRivalSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.rivalSnake || this.rivalSnake.segments.length === 0) return;\n\n    const rs = this.rivalSnake;\n    const pulse = rs.glowIntensity;\n\n    for (const arc of rs.electricArcs) {\n      this.drawElectricArc(g, arc.x1, arc.y1, arc.x2, arc.y2, arc.life);\n    }\n\n    for (const e of rs.energyTrail) {\n      g.fillStyle(this.hslToHex(rs.hue + 20, 80, 70), e.alpha * 0.6);\n      g.fillCircle(e.x, e.y, e.size);\n      g.fillStyle(this.hslToHex(rs.hue, 90, 85), e.alpha * 0.3);\n      g.fillCircle(e.x, e.y, e.size * 0.5);\n    }\n\n    for (let i = 0; i < rs.trail.length; i++) {\n      const t = rs.trail[i];\n      const trailSize = 5 * (1 - i / rs.trail.length);\n      g.fillStyle(this.hslToHex(rs.hue, 80, 55), t.alpha * 0.4);\n      g.fillCircle(t.x, t.y, trailSize * 2);\n      g.fillStyle(this.hslToHex(rs.hue + 30, 70, 70), t.alpha * 0.2);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    g.lineStyle(14, this.hslToHex(rs.hue, 70, 40), 0.2 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    g.lineStyle(8, this.hslToHex(rs.hue, 80, 55), 0.35 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    for (let i = rs.segments.length - 1; i >= 0; i--) {\n      const seg = rs.segments[i];\n      const t = rs.segments.length > 1 ? i / (rs.segments.length - 1) : 1;\n      const segmentPulse = pulse * (0.8 + Math.sin(rs.pulsePhase + i * 0.4) * 0.2);\n\n      const baseSize = 7 + t * 5;\n      const size = baseSize * (0.9 + segmentPulse * 0.15);\n\n      g.fillStyle(this.hslToHex(rs.hue - 10, 60, 35), 0.15 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 2.8);\n\n      g.fillStyle(this.hslToHex(rs.hue, 75, 50), 0.3 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 1.6);\n\n      g.fillStyle(this.hslToHex(rs.hue + 10, 85, 65), 0.6 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size);\n\n      g.fillStyle(this.hslToHex(rs.hue + 40, 60, 90), 0.5 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 0.35);\n\n      if (i === 0) {\n        const dx = rs.direction.dx;\n        const dy = rs.direction.dy;\n        const perpX = -dy;\n        const perpY = dx;\n\n        g.fillStyle(this.hslToHex(rs.hue, 90, 70), 0.3);\n        g.fillCircle(seg.x - dx * 3, seg.y - dy * 3, size * 1.8);\n\n        const eyeOffset = 4;\n        const eyeForward = 5;\n        const leftEyeX = seg.x + perpX * eyeOffset + dx * eyeForward;\n        const leftEyeY = seg.y + perpY * eyeOffset + dy * eyeForward;\n        const rightEyeX = seg.x - perpX * eyeOffset + dx * eyeForward;\n        const rightEyeY = seg.y - perpY * eyeOffset + dy * eyeForward;\n\n        const eyeColor = rs.state === 'hunting' ? 0xff4444 :\n                         rs.state === 'fleeing' ? 0xffff44 : 0x44ffff;\n\n        g.fillStyle(0x000000, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 4);\n        g.fillCircle(rightEyeX, rightEyeY, 4);\n\n        g.fillStyle(eyeColor, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 3);\n        g.fillCircle(rightEyeX, rightEyeY, 3);\n\n        g.fillStyle(0xffffff, 0.95 * segmentPulse);\n        g.fillCircle(leftEyeX + dx, leftEyeY + dy, 1.2);\n        g.fillCircle(rightEyeX + dx, rightEyeY + dy, 1.2);\n\n        const hornLength = 8;\n        const hornAngle = 0.4;\n        g.lineStyle(3, this.hslToHex(rs.hue - 20, 70, 45), 0.8 * segmentPulse);\n        g.beginPath();\n        g.moveTo(seg.x + perpX * 5, seg.y + perpY * 5);\n        g.lineTo(\n          seg.x + perpX * 5 + Math.cos(Math.atan2(dy, dx) - hornAngle) * hornLength,\n          seg.y + perpY * 5 + Math.sin(Math.atan2(dy, dx) - hornAngle) * hornLength\n        );\n        g.strokePath();\n        g.beginPath();\n        g.moveTo(seg.x - perpX * 5, seg.y - perpY * 5);\n        g.lineTo(\n          seg.x - perpX * 5 + Math.cos(Math.atan2(dy, dx) + hornAngle) * hornLength,\n          seg.y - perpY * 5 + Math.sin(Math.atan2(dy, dx) + hornAngle) * hornLength\n        );\n        g.strokePath();\n      }\n    }\n  }\n\n  private drawElectricArc(g: Phaser.GameObjects.Graphics, x1: number, y1: number, x2: number, y2: number, life: number): void {\n    const segments = 6;\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n    const jitter = 15 * life;\n\n    g.lineStyle(4, 0x00ffff, 0.2 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter;\n      const jy = (Math.random() - 0.5) * jitter;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(2, 0x88ffff, 0.5 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter * 0.5;\n      const jy = (Math.random() - 0.5) * jitter * 0.5;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(1, 0xffffff, 0.8 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    g.lineTo(x2, y2);\n    g.strokePath();\n  }\n\n  private spawnBee(): void {\n    if (this.bees.length >= NUM_BEES) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Spawn from random edge\n    const edge = Math.floor(Math.random() * 4);\n    let x: number, y: number;\n\n    switch (edge) {\n      case 0: // top\n        x = Math.random() * width;\n        y = -20;\n        break;\n      case 1: // right\n        x = width + 20;\n        y = Math.random() * height;\n        break;\n      case 2: // bottom\n        x = Math.random() * width;\n        y = height + 20;\n        break;\n      default: // left\n        x = -20;\n        y = Math.random() * height;\n        break;\n    }\n\n    // Random target inside the play area\n    const targetX = 50 + Math.random() * (width - 100);\n    const targetY = 50 + Math.random() * (height - 100);\n\n    this.bees.push({\n      x,\n      y,\n      vx: 0,\n      vy: 0,\n      targetX,\n      targetY,\n      wingPhase: Math.random() * Math.PI * 2,\n      wingSpeed: 0.4 + Math.random() * 0.2,\n      size: 6 + Math.random() * 3,\n      hue: 0 + Math.random() * 20, // Crimson/red volcanic color\n      glowIntensity: 0.5 + Math.random() * 0.5,\n      bobPhase: Math.random() * Math.PI * 2,\n      bobSpeed: 0.08 + Math.random() * 0.04,\n      trail: [],\n      state: 'flying',\n      sparkleTimer: 0,\n    });\n  }\n\n  private updateBees(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n    const gameOver = this.currentState.gameOver;\n\n    // Randomly spawn new bees\n    if (!gameOver && Math.random() < BEE_SPAWN_CHANCE && this.bees.length < NUM_BEES) {\n      this.spawnBee();\n    }\n\n    for (let i = this.bees.length - 1; i >= 0; i--) {\n      const bee = this.bees[i];\n\n      // Update wing animation\n      bee.wingPhase += bee.wingSpeed;\n      bee.bobPhase += bee.bobSpeed;\n      bee.sparkleTimer += 0.1;\n\n      // Store trail position\n      if (this.frameCount % 2 === 0) {\n        bee.trail.unshift({ x: bee.x, y: bee.y, alpha: 0.6 });\n        if (bee.trail.length > 8) bee.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of bee.trail) {\n        t.alpha *= 0.85;\n      }\n      bee.trail = bee.trail.filter(t => t.alpha > 0.05);\n\n      // Bees are attracted to food\n      const dxFood = foodX - bee.x;\n      const dyFood = foodY - bee.y;\n      const distFood = Math.sqrt(dxFood * dxFood + dyFood * dyFood);\n\n      // Determine behavior based on distance to food\n      if (distFood < 80) {\n        bee.state = 'attracted';\n        bee.targetX = foodX + Math.cos(bee.bobPhase * 3) * 30;\n        bee.targetY = foodY + Math.sin(bee.bobPhase * 3) * 30;\n      } else if (distFood < 150) {\n        bee.state = 'hovering';\n        // Circle around food loosely\n        const angle = Math.atan2(dyFood, dxFood) + Math.sin(bee.bobPhase) * 0.5;\n        bee.targetX = foodX - Math.cos(angle) * 60;\n        bee.targetY = foodY - Math.sin(angle) * 60;\n      } else {\n        bee.state = 'flying';\n        // Wander towards food with some randomness\n        if (Math.random() < 0.02) {\n          bee.targetX = foodX + (Math.random() - 0.5) * 200;\n          bee.targetY = foodY + (Math.random() - 0.5) * 200;\n        }\n      }\n\n      // Move towards target with smooth steering\n      const dx = bee.targetX - bee.x;\n      const dy = bee.targetY - bee.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 1) {\n        const speed = bee.state === 'attracted' ? 2.5 : (bee.state === 'hovering' ? 1.5 : 2);\n        const ax = (dx / dist) * speed * 0.1;\n        const ay = (dy / dist) * speed * 0.1;\n\n        bee.vx += ax;\n        bee.vy += ay;\n\n        // Add bobbing motion\n        bee.vy += Math.sin(bee.bobPhase) * 0.05;\n      }\n\n      // Limit velocity\n      const maxSpeed = bee.state === 'attracted' ? 3 : 2;\n      const currentSpeed = Math.sqrt(bee.vx * bee.vx + bee.vy * bee.vy);\n      if (currentSpeed > maxSpeed) {\n        bee.vx = (bee.vx / currentSpeed) * maxSpeed;\n        bee.vy = (bee.vy / currentSpeed) * maxSpeed;\n      }\n\n      // Apply velocity with damping\n      bee.x += bee.vx;\n      bee.y += bee.vy;\n      bee.vx *= 0.95;\n      bee.vy *= 0.95;\n\n      // Pulsing glow when near food\n      if (bee.state === 'attracted') {\n        bee.glowIntensity = 0.7 + Math.sin(bee.bobPhase * 4) * 0.3;\n      } else {\n        bee.glowIntensity = 0.5 + Math.sin(bee.bobPhase * 2) * 0.2;\n      }\n\n      // Remove bees that fly too far off screen\n      if (bee.x < -100 || bee.x > width + 100 || bee.y < -100 || bee.y > height + 100) {\n        this.bees.splice(i, 1);\n      }\n\n      // Scatter bees on game over\n      if (gameOver) {\n        bee.targetX = bee.x + (Math.random() - 0.5) * 400;\n        bee.targetY = bee.y - 200 - Math.random() * 200;\n        bee.vx += (Math.random() - 0.5) * 2;\n        bee.vy -= 1 + Math.random();\n      }\n    }\n  }\n\n  private drawBees(g: Phaser.GameObjects.Graphics): void {\n    for (const bee of this.bees) {\n      const { x, y, size, wingPhase, hue, glowIntensity, trail, state, sparkleTimer } = bee;\n\n      // Draw trail\n      for (let i = 0; i < trail.length; i++) {\n        const t = trail[i];\n        const trailSize = size * 0.4 * (1 - i / trail.length);\n        g.fillStyle(this.hslToHex(hue, 80, 60), t.alpha * 0.4);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      const glowSize = size * 2 * glowIntensity;\n      g.fillStyle(this.hslToHex(hue, 90, 50), 0.2 * glowIntensity);\n      g.fillCircle(x, y, glowSize);\n\n      // Mid glow\n      g.fillStyle(this.hslToHex(hue, 85, 60), 0.3 * glowIntensity);\n      g.fillCircle(x, y, glowSize * 0.6);\n\n      // Bee body - striped pattern\n      const bodyLength = size * 1.2;\n      const bodyWidth = size * 0.7;\n\n      // Body shadow/glow\n      g.fillStyle(this.hslToHex(hue, 70, 30), 0.5);\n      g.fillEllipse(x, y, bodyLength + 2, bodyWidth + 2);\n\n      // Main body (amber/golden)\n      g.fillStyle(this.hslToHex(hue, 90, 55), 1);\n      g.fillEllipse(x, y, bodyLength, bodyWidth);\n\n      // Dark stripes\n      g.fillStyle(0x1a1a1a, 0.8);\n      g.fillRect(x - bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n      g.fillRect(x + bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n\n      // Head\n      g.fillStyle(this.hslToHex(hue - 10, 80, 40), 1);\n      g.fillCircle(x - bodyLength * 0.4, y, size * 0.4);\n\n      // Wings - animated flutter\n      const wingAngle = Math.sin(wingPhase) * 0.8;\n      const wingSize = size * 0.9;\n\n      // Wing glow (ethereal effect)\n      g.fillStyle(0xffffff, 0.2 + Math.abs(Math.sin(wingPhase)) * 0.2);\n      g.fillEllipse(x + Math.cos(wingAngle + 0.5) * wingSize * 0.3, y - wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n      g.fillEllipse(x + Math.cos(-wingAngle + 0.5) * wingSize * 0.3, y + wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n\n      // Wing bodies\n      g.fillStyle(0xffffff, 0.5 + Math.abs(Math.sin(wingPhase)) * 0.3);\n      g.fillEllipse(x + Math.cos(wingAngle) * wingSize * 0.2, y - wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n      g.fillEllipse(x + Math.cos(-wingAngle) * wingSize * 0.2, y + wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n\n      // Eyes\n      g.fillStyle(0x000000, 1);\n      g.fillCircle(x - bodyLength * 0.45, y - size * 0.12, size * 0.12);\n      g.fillCircle(x - bodyLength * 0.45, y + size * 0.12, size * 0.12);\n\n      // Sparkles when attracted to food\n      if (state === 'attracted' && Math.sin(sparkleTimer * 3) > 0.7) {\n        const sparkleAngle = sparkleTimer * 2;\n        const sparkleDist = size * 1.5;\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n\n        g.fillStyle(0xffffff, 0.8);\n        g.fillCircle(sparkleX, sparkleY, 2);\n        g.fillStyle(this.hslToHex(hue, 100, 80), 0.6);\n        g.fillCircle(sparkleX, sparkleY, 3);\n      }\n    }\n  }\n\n  // Helper to convert HSL to hex for Phaser\n  private hslToHex(h: number, s: number, l: number): number {\n    h = h / 360;\n    s = s / 100;\n    l = l / 100;\n\n    let r: number, g: number, b: number;\n\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    return (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255);\n  }\n\n  private updateGuardianSpirits(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const gameOver = this.currentState.gameOver;\n    const snakeHead = this.currentState.snake.length > 0 ? this.currentState.snake[0] : null;\n\n    for (const spirit of this.guardianSpirits) {\n      spirit.phase += spirit.speed;\n      spirit.haloPhase += 0.04;\n      spirit.orbPhase += 0.02;\n\n      for (const orb of spirit.orbs) {\n        orb.angle += orb.speed;\n      }\n\n      const floatAmount = gameOver ? 20 : 12;\n      const waveAmount = 5;\n      const wave = Math.sin(spirit.phase) * waveAmount;\n\n      let targetX = spirit.baseX;\n      let targetY = spirit.baseY;\n\n      switch (spirit.edge) {\n        case 'top':\n          targetY = spirit.baseY + floatAmount + wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'bottom':\n          targetY = spirit.baseY - floatAmount - wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'left':\n          targetX = spirit.baseX + floatAmount + wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'right':\n          targetX = spirit.baseX - floatAmount - wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n      }\n\n      if (snakeHead && !gameOver) {\n        const headX = snakeHead.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = snakeHead.y * CELL_SIZE + CELL_SIZE / 2;\n        const dx = spirit.x - headX;\n        const dy = spirit.y - headY;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        if (dist < 120) {\n          const attraction = (120 - dist) / 120 * 15;\n          targetX += (dx / dist) * attraction;\n          targetY += (dy / dist) * attraction;\n        }\n      }\n\n      spirit.x += (targetX - spirit.x) * 0.04;\n      spirit.y += (targetY - spirit.y) * 0.04;\n      spirit.x = Math.max(-50, Math.min(width + 50, spirit.x));\n      spirit.y = Math.max(-50, Math.min(height + 50, spirit.y));\n\n      const baseAlpha = gameOver ? 0.8 : spirit.targetAlpha;\n      spirit.currentAlpha += (baseAlpha - spirit.currentAlpha) * 0.05;\n    }\n  }\n\n  private drawGuardianSpirits(g: Phaser.GameObjects.Graphics): void {\n    for (const spirit of this.guardianSpirits) {\n      if (spirit.currentAlpha < 0.01) continue;\n\n      const { x, y, size, phase, haloPhase, currentAlpha, hue, orbs } = spirit;\n      const breathPulse = 1 + Math.sin(phase * 2) * 0.15;\n      const coreSize = size * breathPulse;\n\n      const spiritColor = this.hslToHex(hue, 0.7, 0.6);\n      const glowColor = this.hslToHex(hue, 0.5, 0.8);\n      const haloColor = this.hslToHex(hue, 0.3, 0.9);\n\n      g.fillStyle(glowColor, currentAlpha * 0.1);\n      g.fillCircle(x, y, coreSize * 2.5);\n\n      g.fillStyle(glowColor, currentAlpha * 0.15);\n      g.fillCircle(x, y, coreSize * 1.8);\n\n      const haloRadius = coreSize * 1.4 + Math.sin(haloPhase) * 3;\n      g.lineStyle(2, haloColor, currentAlpha * 0.4);\n      g.strokeCircle(x, y, haloRadius);\n\n      const innerHaloRadius = coreSize * 1.1 + Math.sin(haloPhase + 1) * 2;\n      g.lineStyle(1.5, haloColor, currentAlpha * 0.3);\n      g.strokeCircle(x, y, innerHaloRadius);\n\n      for (const orb of orbs) {\n        const orbX = x + Math.cos(orb.angle) * orb.distance;\n        const orbY = y + Math.sin(orb.angle) * orb.distance;\n        const orbPulse = 1 + Math.sin(phase + orb.angle) * 0.3;\n\n        g.fillStyle(glowColor, currentAlpha * 0.3);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse * 1.5);\n\n        g.fillStyle(spiritColor, currentAlpha * 0.8);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse);\n      }\n\n      g.fillStyle(spiritColor, currentAlpha * 0.9);\n      g.fillCircle(x, y, coreSize * 0.5);\n\n      g.fillStyle(0xffffff, currentAlpha * 0.7);\n      g.fillCircle(x, y, coreSize * 0.25);\n\n      const sparkleCount = 4;\n      for (let i = 0; i < sparkleCount; i++) {\n        const sparkleAngle = (i / sparkleCount) * Math.PI * 2 + phase * 0.5;\n        const sparkleDist = coreSize * (0.8 + Math.sin(phase * 2 + i) * 0.3);\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n        const sparkleSize = 1.5 + Math.sin(phase * 3 + i * 2) * 0.5;\n\n        g.fillStyle(0xffffff, currentAlpha * (0.4 + Math.sin(phase * 2 + i) * 0.3));\n        g.fillCircle(sparkleX, sparkleY, sparkleSize);\n      }\n    }\n  }\n\n  private initStars(): void {\n    this.stars = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_STARS; i++) {\n      this.stars.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: 0.5 + Math.random() * 1.5,\n        speed: 0.02 + Math.random() * 0.03,\n        brightness: 0.3 + Math.random() * 0.7,\n      });\n    }\n  }\n\n  private initPlasmaWaves(): void {\n    this.plasmaWaves = [];\n    const hues = [0, 15, 30]; // Red/orange volcanic variations\n    for (let i = 0; i < NUM_PLASMA_WAVES; i++) {\n      this.plasmaWaves.push({\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.015 + Math.random() * 0.01,\n        amplitude: 30 + Math.random() * 20,\n        wavelength: 80 + Math.random() * 40,\n        hue: hues[i % hues.length],\n      });\n    }\n  }\n\n  private initAuroraWaves(): void {\n    this.auroraWaves = [];\n    const height = GRID_SIZE * CELL_SIZE;\n    // Aurora hues: volcanic reds, oranges, crimsons\n    const auroraHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_AURORA_WAVES; i++) {\n      this.auroraWaves.push({\n        y: height * 0.2 + (height * 0.6 * i) / NUM_AURORA_WAVES,\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.008 + Math.random() * 0.006,\n        hue: auroraHues[i % auroraHues.length],\n        thickness: 25 + Math.random() * 20,\n        amplitude: 15 + Math.random() * 25,\n      });\n    }\n  }\n\n  private initNebulaClouds(): void {\n    this.nebulaClouds = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    // Volcanic smoke and lava glow colors: reds, oranges, crimsons\n    const nebulaHues = [0, 10, 20, 30, 350, 340];\n    for (let i = 0; i < NUM_NEBULA_CLOUDS; i++) {\n      this.nebulaClouds.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        radius: 40 + Math.random() * 60,\n        hue: nebulaHues[i % nebulaHues.length],\n        alpha: 0.04 + Math.random() * 0.04,\n        driftX: (Math.random() - 0.5) * 0.15,\n        driftY: (Math.random() - 0.5) * 0.15,\n        pulsePhase: Math.random() * Math.PI * 2,\n        pulseSpeed: 0.01 + Math.random() * 0.01,\n      });\n    }\n  }\n\n  private initVortex(): void {\n    this.vortexRings = [];\n    this.vortexParticles = [];\n\n    // Create concentric rings with different properties\n    const ringHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_VORTEX_RINGS; i++) {\n      const baseRadius = 25 + i * 18;\n      this.vortexRings.push({\n        radius: baseRadius,\n        baseRadius,\n        rotationOffset: (i * Math.PI * 2) / NUM_VORTEX_RINGS,\n        rotationSpeed: 0.02 - i * 0.003,\n        thickness: 2 + (NUM_VORTEX_RINGS - i) * 0.5,\n        hue: ringHues[i % ringHues.length],\n        pulsePhase: i * 0.5,\n      });\n    }\n\n    // Create orbiting particles\n    for (let i = 0; i < NUM_VORTEX_PARTICLES; i++) {\n      const baseRadius = 20 + Math.random() * 80;\n      this.vortexParticles.push({\n        angle: Math.random() * Math.PI * 2,\n        radius: baseRadius,\n        baseRadius,\n        speed: 0.02 + Math.random() * 0.03,\n        size: 1 + Math.random() * 2,\n        hue: Math.random() * 360,\n        alpha: 0.3 + Math.random() * 0.5,\n      });\n    }\n  }\n\n  private initMeteors(): void {\n    this.meteors = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_METEORS; i++) {\n      this.spawnMeteor(width, height, true);\n    }\n  }\n\n  private spawnMeteor(width: number, height: number, initial = false): void {\n    if (this.meteors.length >= NUM_METEORS) return;\n\n    // Meteors come from top-right and travel to bottom-left\n    const startX = initial ? Math.random() * width * 1.5 : width + 20 + Math.random() * 40;\n    const startY = initial ? Math.random() * height * 0.5 - height * 0.25 : -20 - Math.random() * 40;\n\n    // Random angle variation (mostly diagonal)\n    const angle = Math.PI * 0.65 + (Math.random() - 0.5) * 0.4;\n    const speed = 1.5 + Math.random() * 2;\n\n    this.meteors.push({\n      x: startX,\n      y: startY,\n      vx: -Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed,\n      size: 2 + Math.random() * 3,\n      hue: Math.random() < 0.3 ? 0 + Math.random() * 30 : 20 + Math.random() * 40, // Red or orange volcanic\n      alpha: 0.6 + Math.random() * 0.4,\n      trail: [],\n      life: 1,\n    });\n  }\n\n  private updateMeteors(width: number, height: number): void {\n    for (let i = this.meteors.length - 1; i >= 0; i--) {\n      const m = this.meteors[i];\n\n      // Store trail position\n      m.trail.unshift({ x: m.x, y: m.y, alpha: m.alpha });\n      if (m.trail.length > 12) m.trail.pop();\n\n      // Update position\n      m.x += m.vx;\n      m.y += m.vy;\n\n      // Check if meteor is out of bounds\n      if (m.x < -50 || m.y > height + 50) {\n        this.meteors.splice(i, 1);\n        // Spawn a new one\n        this.spawnMeteor(width, height, false);\n      }\n    }\n  }\n\n  private spawnDeathExplosion(): void {\n    if (!this.currentState) return;\n\n    this.deathDebris = [];\n    this.deathExplosionPhase = 1;\n\n    // Spawn debris from each snake segment\n    for (let i = 0; i < this.currentState.snake.length; i++) {\n      const seg = this.currentState.snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const segHue = (this.hueOffset + i * 15) % 360;\n\n      // Create debris particles per segment (limit total)\n      const debrisPerSeg = Math.min(3, Math.floor(MAX_DEATH_DEBRIS / this.currentState.snake.length));\n      for (let j = 0; j < debrisPerSeg; j++) {\n        if (this.deathDebris.length >= MAX_DEATH_DEBRIS) break;\n\n        const angle = Math.random() * Math.PI * 2;\n        const speed = 2 + Math.random() * 4;\n        const types: ('shard' | 'spark' | 'ember')[] = ['shard', 'spark', 'ember'];\n\n        this.deathDebris.push({\n          x: cx + (Math.random() - 0.5) * 8,\n          y: cy + (Math.random() - 0.5) * 8,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed - 1,\n          size: 3 + Math.random() * 5,\n          hue: segHue + (Math.random() - 0.5) * 40,\n          rotation: Math.random() * Math.PI * 2,\n          rotationSpeed: (Math.random() - 0.5) * 0.4,\n          life: 1,\n          type: types[Math.floor(Math.random() * types.length)],\n        });\n      }\n    }\n  }\n\n  private updateDeathDebris(): void {\n    // Decay explosion phase\n    if (this.deathExplosionPhase > 0) {\n      this.deathExplosionPhase *= 0.95;\n      if (this.deathExplosionPhase < 0.01) this.deathExplosionPhase = 0;\n    }\n\n    for (let i = this.deathDebris.length - 1; i >= 0; i--) {\n      const d = this.deathDebris[i];\n\n      // Update position with gravity\n      d.x += d.vx;\n      d.y += d.vy;\n      d.vy += 0.08; // gravity\n      d.vx *= 0.99; // air resistance\n\n      // Update rotation\n      d.rotation += d.rotationSpeed;\n\n      // Decay life\n      d.life -= 0.015;\n\n      if (d.life <= 0) {\n        this.deathDebris.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnFoodParticles(foodX: number, foodY: number): void {\n    if (this.foodParticles.length < MAX_FOOD_PARTICLES && Math.random() < 0.15) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.3 + Math.random() * 0.5;\n      this.foodParticles.push({\n        x: foodX,\n        y: foodY,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 0.5,\n        life: 1,\n        maxLife: 40 + Math.random() * 20,\n        size: 1 + Math.random() * 2,\n      });\n    }\n  }\n\n  private updateParticles(): void {\n    for (let i = this.foodParticles.length - 1; i >= 0; i--) {\n      const p = this.foodParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy += 0.02;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.foodParticles.splice(i, 1);\n      }\n    }\n    // Update trail particles\n    for (let i = this.trailParticles.length - 1; i >= 0; i--) {\n      const p = this.trailParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.trailParticles.splice(i, 1);\n      }\n    }\n    // Update shockwaves\n    for (let i = this.shockWaves.length - 1; i >= 0; i--) {\n      const sw = this.shockWaves[i];\n      sw.radius += 3;\n      sw.life -= 0.04;\n      if (sw.life <= 0 || sw.radius >= sw.maxRadius) {\n        this.shockWaves.splice(i, 1);\n      }\n    }\n    // Update lightning bolts\n    for (let i = this.lightningBolts.length - 1; i >= 0; i--) {\n      const bolt = this.lightningBolts[i];\n      bolt.life -= 1 / bolt.maxLife;\n      if (bolt.life <= 0) {\n        this.lightningBolts.splice(i, 1);\n      }\n    }\n    // Update afterimages\n    for (let i = this.snakeAfterimages.length - 1; i >= 0; i--) {\n      const ai = this.snakeAfterimages[i];\n      ai.life -= 1 / ai.maxLife;\n      if (ai.life <= 0) {\n        this.snakeAfterimages.splice(i, 1);\n      }\n    }\n    // Decay screen flash\n    if (this.screenFlashAlpha > 0) {\n      this.screenFlashAlpha -= 0.08;\n      if (this.screenFlashAlpha < 0) this.screenFlashAlpha = 0;\n    }\n\n    // Update screen shake\n    if (this.screenShakeIntensity > 0) {\n      this.screenShakeX = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeY = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeIntensity *= 0.9;\n      if (this.screenShakeIntensity < 0.5) {\n        this.screenShakeIntensity = 0;\n        this.screenShakeX = 0;\n        this.screenShakeY = 0;\n      }\n    }\n\n    // Decay chromatic aberration\n    if (this.chromaticIntensity > 0) {\n      this.chromaticIntensity *= 0.92;\n      if (this.chromaticIntensity < 0.05) this.chromaticIntensity = 0;\n    }\n\n    // Decay energy field pulse\n    if (this.energyFieldPulse > 0) {\n      this.energyFieldPulse *= 0.95;\n      if (this.energyFieldPulse < 0.05) this.energyFieldPulse = 0;\n    }\n\n    // Update food burst particles\n    for (let i = this.foodBurstParticles.length - 1; i >= 0; i--) {\n      const p = this.foodBurstParticles[i];\n      // Store trail position\n      p.trail.unshift({ x: p.x, y: p.y });\n      if (p.trail.length > 6) p.trail.pop();\n      // Update position\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vx *= 0.96;\n      p.vy *= 0.96;\n      p.life -= 0.025;\n      if (p.life <= 0) {\n        this.foodBurstParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnTrailParticles(x: number, y: number): void {\n    if (this.trailParticles.length >= MAX_TRAIL_PARTICLES) return;\n    // Spawn 2-3 particles per movement\n    const count = 2 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < count; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.2 + Math.random() * 0.4;\n      this.trailParticles.push({\n        x: x + (Math.random() - 0.5) * 8,\n        y: y + (Math.random() - 0.5) * 8,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        maxLife: 25 + Math.random() * 15,\n        size: 2 + Math.random() * 3,\n        hue: this.hueOffset + Math.random() * 30,\n      });\n    }\n  }\n\n  updateGameState(state: GameState): void {\n    // Detect food eaten - snake got longer\n    if (this.currentState && state.snake.length > this.lastSnakeLength) {\n      const head = state.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n      this.spawnShockWave(headX, headY);\n      this.spawnLightningBurst(headX, headY);\n      this.spawnFoodBurst(headX, headY);\n      this.spawnChaosExplosion(headX, headY); // Armageddon chaos explosion\n      this.screenFlashAlpha = 0.8; // More intense flash for armageddon\n      this.chromaticIntensity = 1.5; // Stronger chromatic aberration\n      this.energyFieldPulse = 1.0; // Trigger energy field expansion\n    }\n    this.lastSnakeLength = state.snake.length;\n\n    // Detect food position change - trigger thrown food animation\n    const newFood = state.food;\n    if (this.lastFoodPos && (newFood.x !== this.lastFoodPos.x || newFood.y !== this.lastFoodPos.y)) {\n      this.spawnThrownFood(newFood.x, newFood.y);\n    } else if (!this.lastFoodPos && !state.gameOver) {\n      // First food spawn\n      this.spawnThrownFood(newFood.x, newFood.y);\n    }\n    this.lastFoodPos = { x: newFood.x, y: newFood.y };\n\n    // Create afterimage when snake moves\n    if (this.currentState && state.snake.length > 0) {\n      const oldHead = this.currentState.snake[0];\n      const newHead = state.snake[0];\n      if (oldHead && newHead && (oldHead.x !== newHead.x || oldHead.y !== newHead.y)) {\n        this.spawnAfterimage(this.currentState.snake);\n      }\n    }\n\n    // Detect game over transition - ARMAGEDDON CHAOS death sequence\n    if (state.gameOver && this.currentState && !this.currentState.gameOver) {\n      this.screenShakeIntensity = 25; // Massive screen shake on death\n      this.chromaticIntensity = 3.0; // Maximum chromatic aberration on death\n      this.chaosIntensity = 1.0; // Full chaos overlay\n      this.spawnDeathExplosion(); // Dramatic death explosion\n      // Spawn chaos explosions across the snake body\n      for (let i = 0; i < Math.min(3, state.snake.length); i++) {\n        const seg = state.snake[Math.floor(i * state.snake.length / 3)];\n        setTimeout(() => {\n          this.spawnChaosExplosion(\n            seg.x * CELL_SIZE + CELL_SIZE / 2,\n            seg.y * CELL_SIZE + CELL_SIZE / 2\n          );\n        }, i * 50);\n      }\n    }\n\n    this.currentState = state;\n    this.needsRedraw = true;\n    if (!state.gameOver) {\n      this.gameOverAlpha = 0;\n      this.gameOverGlitchOffset = 0;\n      this.screenShakeIntensity = 0;\n    }\n  }\n\n  private spawnShockWave(x: number, y: number): void {\n    if (this.shockWaves.length >= MAX_SHOCKWAVES) {\n      this.shockWaves.shift();\n    }\n    this.shockWaves.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: CELL_SIZE * 3,\n      life: 1,\n    });\n  }\n\n  private spawnAfterimage(snake: Position[]): void {\n    if (this.snakeAfterimages.length >= MAX_AFTERIMAGES) {\n      this.snakeAfterimages.shift();\n    }\n    this.snakeAfterimages.push({\n      segments: snake.map(s => ({ x: s.x, y: s.y })),\n      life: 1,\n      maxLife: 12,\n      hueOffset: this.hueOffset,\n    });\n  }\n\n  private spawnLightningBurst(x: number, y: number): void {\n    const numBolts = 3 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < numBolts; i++) {\n      if (this.lightningBolts.length >= MAX_LIGHTNING_BOLTS) {\n        this.lightningBolts.shift();\n      }\n      const angle = (Math.PI * 2 * i) / numBolts + Math.random() * 0.5;\n      const length = 30 + Math.random() * 40;\n      const endX = x + Math.cos(angle) * length;\n      const endY = y + Math.sin(angle) * length;\n      this.lightningBolts.push({\n        points: this.generateLightningPath(x, y, endX, endY),\n        life: 1,\n        maxLife: 15 + Math.random() * 10,\n        hue: this.hueOffset + Math.random() * 60,\n      });\n    }\n  }\n\n  private generateLightningPath(x1: number, y1: number, x2: number, y2: number): { x: number; y: number }[] {\n    const points: { x: number; y: number }[] = [{ x: x1, y: y1 }];\n    const segments = 4 + Math.floor(Math.random() * 3);\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n\n    for (let i = 1; i < segments; i++) {\n      const jitter = 8;\n      points.push({\n        x: x1 + dx * i + (Math.random() - 0.5) * jitter,\n        y: y1 + dy * i + (Math.random() - 0.5) * jitter,\n      });\n    }\n    points.push({ x: x2, y: y2 });\n    return points;\n  }\n\n  private spawnFoodBurst(x: number, y: number): void {\n    // Clear old particles and spawn new dramatic burst\n    this.foodBurstParticles = [];\n    const numParticles = MAX_BURST_PARTICLES;\n    for (let i = 0; i < numParticles; i++) {\n      const angle = (i / numParticles) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 4;\n      this.foodBurstParticles.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        size: 3 + Math.random() * 4,\n        hue: this.hueOffset + Math.random() * 60,\n        trail: [],\n      });\n    }\n  }\n\n  private spawnThrownFood(targetGridX: number, targetGridY: number): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const targetX = targetGridX * CELL_SIZE + CELL_SIZE / 2;\n    const targetY = targetGridY * CELL_SIZE + CELL_SIZE / 2;\n\n    // Choose random edge to throw from\n    const edge = Math.floor(Math.random() * 4);\n    let startX: number, startY: number;\n\n    switch (edge) {\n      case 0: // top\n        startX = Math.random() * width;\n        startY = -40;\n        break;\n      case 1: // right\n        startX = width + 40;\n        startY = Math.random() * height;\n        break;\n      case 2: // bottom\n        startX = Math.random() * width;\n        startY = height + 40;\n        break;\n      default: // left\n        startX = -40;\n        startY = Math.random() * height;\n        break;\n    }\n\n    this.thrownFood = {\n      startX,\n      startY,\n      targetX,\n      targetY,\n      x: startX,\n      y: startY,\n      progress: 0,\n      rotation: 0,\n      rotationSpeed: (Math.random() - 0.5) * 0.6,\n      trail: [],\n      landed: false,\n      landingParticles: [],\n      impactRings: [],\n    };\n  }\n\n  private updateThrownFood(): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    if (!tf.landed) {\n      // Update progress\n      tf.progress += 0.04;\n\n      // Store trail\n      if (this.frameCount % 2 === 0) {\n        tf.trail.unshift({ x: tf.x, y: tf.y, alpha: 1, rotation: tf.rotation });\n        if (tf.trail.length > 12) tf.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.85;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Calculate position with parabolic arc\n      const t = tf.progress;\n      const arcHeight = 80;\n      const arc = 4 * arcHeight * t * (1 - t);\n      tf.x = tf.startX + (tf.targetX - tf.startX) * t;\n      tf.y = tf.startY + (tf.targetY - tf.startY) * t - arc;\n\n      // Rotation\n      tf.rotation += tf.rotationSpeed;\n\n      // Check if landed\n      if (tf.progress >= 1) {\n        tf.landed = true;\n        tf.x = tf.targetX;\n        tf.y = tf.targetY;\n\n        // Spawn landing effects\n        this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 6);\n\n        // Impact rings\n        tf.impactRings = [\n          { radius: 5, alpha: 1 },\n          { radius: 3, alpha: 0.8 },\n        ];\n\n        // Landing particles\n        for (let i = 0; i < 10; i++) {\n          const angle = (i / 10) * Math.PI * 2 + Math.random() * 0.3;\n          const speed = 2 + Math.random() * 3;\n          tf.landingParticles.push({\n            x: tf.targetX,\n            y: tf.targetY,\n            vx: Math.cos(angle) * speed,\n            vy: Math.sin(angle) * speed - 1,\n            life: 1,\n            size: 2 + Math.random() * 3,\n          });\n        }\n      }\n    } else {\n      // Update landing effects\n      for (const ring of tf.impactRings) {\n        ring.radius += 3;\n        ring.alpha *= 0.9;\n      }\n      tf.impactRings = tf.impactRings.filter(r => r.alpha > 0.05);\n\n      for (let i = tf.landingParticles.length - 1; i >= 0; i--) {\n        const p = tf.landingParticles[i];\n        p.x += p.vx;\n        p.y += p.vy;\n        p.vy += 0.15;\n        p.vx *= 0.98;\n        p.life -= 0.04;\n        if (p.life <= 0) {\n          tf.landingParticles.splice(i, 1);\n        }\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.8;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Clear thrown food when effects are done\n      if (tf.impactRings.length === 0 && tf.landingParticles.length === 0 && tf.trail.length === 0) {\n        this.thrownFood = null;\n      }\n    }\n  }\n\n  private drawThrownFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    // Draw trail\n    for (let i = 0; i < tf.trail.length; i++) {\n      const t = tf.trail[i];\n      const trailProgress = i / tf.trail.length;\n      const trailSize = (CELL_SIZE / 2) * (1 - trailProgress * 0.5) * t.alpha;\n\n      // Trail glow\n      g.fillStyle(COLORS.foodGlow, t.alpha * 0.3);\n      g.fillCircle(t.x, t.y, trailSize * 1.5);\n\n      // Trail core\n      g.fillStyle(COLORS.food, t.alpha * 0.6);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    // Draw impact rings\n    for (const ring of tf.impactRings) {\n      g.lineStyle(3, COLORS.foodGlow, ring.alpha * 0.5);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n      g.lineStyle(1.5, COLORS.noirWhite, ring.alpha * 0.7);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n    }\n\n    // Draw landing particles\n    for (const p of tf.landingParticles) {\n      g.fillStyle(COLORS.foodGlow, p.life * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Draw the flying food if not landed\n    if (!tf.landed) {\n      const scale = 0.8 + tf.progress * 0.4;\n      const foodSize = (CELL_SIZE / 2) * scale;\n\n      // Motion blur glow\n      g.fillStyle(COLORS.foodGlow, 0.3);\n      g.fillCircle(tf.x, tf.y, foodSize * 2);\n\n      // Outer glow\n      g.fillStyle(COLORS.noirWhite, 0.4);\n      g.fillCircle(tf.x, tf.y, foodSize * 1.5);\n\n      // Main food body\n      g.fillStyle(COLORS.food, 0.95);\n      g.fillCircle(tf.x, tf.y, foodSize);\n\n      // Spinning highlight\n      const highlightAngle = tf.rotation;\n      const highlightX = tf.x + Math.cos(highlightAngle) * foodSize * 0.3;\n      const highlightY = tf.y + Math.sin(highlightAngle) * foodSize * 0.3;\n      g.fillStyle(0xffffff, 0.9);\n      g.fillCircle(highlightX, highlightY, foodSize * 0.25);\n\n      // Secondary sparkle\n      const sparkleAngle = tf.rotation + Math.PI * 0.7;\n      const sparkleX = tf.x + Math.cos(sparkleAngle) * foodSize * 0.4;\n      const sparkleY = tf.y + Math.sin(sparkleAngle) * foodSize * 0.4;\n      g.fillStyle(0xffffff, 0.6);\n      g.fillCircle(sparkleX, sparkleY, foodSize * 0.15);\n    }\n  }\n\n  update(): void {\n    this.frameCount++;\n    this.cleanEffects.frameCount = this.frameCount;\n\n    const width = this.scale.width;\n    const height = this.scale.height;\n\n    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n\n    if (this.currentState && this.currentState.snake.length > 0) {\n      const head = this.currentState.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n        updateGlowTrail(this.cleanEffects, headX, headY);\n      }\n      this.lastHeadPos = { x: head.x, y: head.y };\n\n      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n        const food = this.currentState.food;\n        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnRipple(this.cleanEffects, foodX, foodY);\n      }\n      this.lastSnakeLength = this.currentState.snake.length;\n    }\n\n    const g = this.graphics;\n    g.clear();\n    g.setPosition(0, 0);\n\n    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n\n    if (!this.currentState) return;\n\n    drawGlowTrail(g, this.cleanEffects);\n    drawRipples(g, this.cleanEffects);\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n\n    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawCleanVignette(g, width, height);\n\n    const score = this.currentState.score || 0;\n    const snakeLength = this.currentState.snake.length;\n    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n\n    if (this.currentState.gameOver) {\n      this.drawGameOver(g, width, height);\n      this.drawScoreboard(g, width, height);\n    }\n\n    this.checkAndSaveHighScore();\n    this.needsRedraw = false;\n  }\n\n  private drawStars(g: Phaser.GameObjects.Graphics): void {\n    // In film noir mode, stars are subtle distant lights\n    for (const star of this.stars) {\n      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n      const alpha = star.brightness * twinkle * 0.25;\n      g.fillStyle(COLORS.star, alpha);\n      g.fillCircle(star.x, star.y, star.size * 0.7);\n    }\n  }\n\n  private updateSmokeParticles(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (const smoke of this.smokeParticles) {\n      smoke.x += smoke.vx;\n      smoke.y += smoke.vy;\n      smoke.life -= 0.002;\n      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n        smoke.x = Math.random() * width;\n        smoke.y = height + smoke.size;\n        smoke.life = 1;\n        smoke.size = 30 + Math.random() * 50;\n        smoke.alpha = 0.02 + Math.random() * 0.03;\n      }\n      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n    }\n  }\n\n  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Create dramatic spotlight effect centered on snake\n    const cx = this.spotlightX || width / 2;\n    const cy = this.spotlightY || height / 2;\n    const pulse = 0.9 + Math.sin(this.frameCount * 0.03) * 0.1;\n\n    // Outer darkness vignette\n    g.fillStyle(0x000000, 0.6);\n    g.fillRect(0, 0, width, height);\n\n    // Spotlight cone - multiple layers for smooth falloff\n    const layers = 4;\n    for (let i = layers; i > 0; i--) {\n      const layerRadius = (width * 0.4 + i * 30) * pulse;\n      const layerAlpha = 0.15 * (1 - i / (layers + 1));\n      g.fillStyle(COLORS.spotlight, layerAlpha);\n      g.fillCircle(cx, cy, layerRadius);\n    }\n\n    // Bright center\n    g.fillStyle(COLORS.noirWhite, 0.08 * pulse);\n    g.fillCircle(cx, cy, width * 0.25);\n  }\n\n  private drawVenetianBlinds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Horizontal light streaks simulating light through venetian blinds\n    const blindSpacing = 25;\n    const blindWidth = 8;\n    const waveOffset = Math.sin(this.venetianPhase) * 10;\n\n    for (let y = waveOffset; y < height; y += blindSpacing) {\n      const brightness = 0.03 + Math.sin(y * 0.02 + this.venetianPhase * 2) * 0.015;\n      g.fillStyle(COLORS.noirWhite, brightness);\n      g.fillRect(0, y, width, blindWidth);\n    }\n\n    // Diagonal shadow bars from window frame\n    const diagonalAlpha = 0.04 + Math.sin(this.frameCount * 0.02) * 0.01;\n    g.fillStyle(0x000000, diagonalAlpha);\n    for (let i = -2; i < 6; i++) {\n      const x1 = i * 100 + Math.sin(this.venetianPhase) * 20;\n      g.beginPath();\n      g.moveTo(x1, 0);\n      g.lineTo(x1 + 40, 0);\n      g.lineTo(x1 + 40 + height * 0.3, height);\n      g.lineTo(x1 + height * 0.3, height);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawSmoke(g: Phaser.GameObjects.Graphics): void {\n    for (const smoke of this.smokeParticles) {\n      const alpha = smoke.alpha * smoke.life;\n      g.fillStyle(COLORS.noirGray, alpha);\n      g.fillCircle(smoke.x, smoke.y, smoke.size);\n      g.fillStyle(COLORS.noirWhite, alpha * 0.3);\n      g.fillCircle(smoke.x, smoke.y, smoke.size * 0.5);\n    }\n  }\n\n  private spawnFlameParticle(x: number, y: number, intensity: number): void {\n    if (this.flameParticles.length >= MAX_FLAME_PARTICLES) {\n      this.flameParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.6;\n    const life = 0.5 + Math.random() * 0.5;\n\n    this.flameParticles.push({\n      x: x + (Math.random() - 0.5) * 6,\n      y: y + (Math.random() - 0.5) * 6,\n      vx: Math.cos(angle) * speed * 0.3,\n      vy: -0.5 - Math.random() * 1.5 * intensity,\n      size: 3 + Math.random() * 4 * intensity,\n      life,\n      maxLife: life,\n      hue: 10 + Math.random() * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n    });\n  }\n\n  private updateFlameParticles(): void {\n    for (let i = this.flameParticles.length - 1; i >= 0; i--) {\n      const p = this.flameParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.02;\n      p.vx *= 0.98;\n      p.size *= 0.97;\n      p.life -= 0.025;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.flameParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private drawFlameParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.flameParticles) {\n      const lifeRatio = p.life / p.maxLife;\n\n      // Hue shifts from yellow-orange (high life) to red (low life)\n      const hue = p.hue - (1 - lifeRatio) * 15;\n      const outerColor = this.hslToRgb(hue / 360, 1, 0.3 + lifeRatio * 0.2);\n      const midColor = this.hslToRgb(hue / 360, 1, 0.5 + lifeRatio * 0.2);\n      const coreColor = this.hslToRgb((hue + 20) / 360, 0.7, 0.7 + lifeRatio * 0.2);\n\n      // Outer glow\n      g.fillStyle(outerColor, lifeRatio * 0.3);\n      g.fillCircle(p.x, p.y, p.size * 2);\n\n      // Mid flame\n      g.fillStyle(midColor, lifeRatio * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3);\n\n      // Core (bright yellow/white)\n      g.fillStyle(coreColor, lifeRatio * 0.8);\n      g.fillCircle(p.x, p.y, p.size * 0.6);\n    }\n  }\n\n  private spawnFlamesAlongSnake(): void {\n    if (!this.currentState || this.currentState.gameOver) return;\n\n    const snake = this.currentState.snake;\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const segX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const segY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const intensity = 1 - (i / snake.length) * 0.6;\n      if (Math.random() < 0.4 * intensity) {\n        this.spawnFlameParticle(segX, segY, intensity);\n      }\n    }\n  }\n\n  private drawMeteors(g: Phaser.GameObjects.Graphics): void {\n    for (const m of this.meteors) {\n      const meteorColor = this.hslToRgb(m.hue / 360, 0.9, 0.6);\n      const coreColor = this.hslToRgb(m.hue / 360, 0.6, 0.9);\n\n      // Draw trail (oldest to newest for proper layering)\n      for (let i = m.trail.length - 1; i >= 0; i--) {\n        const t = m.trail[i];\n        const trailProgress = 1 - i / m.trail.length;\n        const trailAlpha = t.alpha * trailProgress * 0.4;\n        const trailSize = m.size * trailProgress * 0.6;\n\n        g.fillStyle(meteorColor, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      g.fillStyle(meteorColor, m.alpha * 0.3);\n      g.fillCircle(m.x, m.y, m.size * 2);\n\n      // Main meteor body\n      g.fillStyle(meteorColor, m.alpha * 0.8);\n      g.fillCircle(m.x, m.y, m.size);\n\n      // Bright core\n      g.fillStyle(coreColor, m.alpha);\n      g.fillCircle(m.x, m.y, m.size * 0.5);\n    }\n  }\n\n  private drawDeathDebris(g: Phaser.GameObjects.Graphics): void {\n    // Draw explosion flash at the beginning\n    if (this.deathExplosionPhase > 0.7) {\n      const flashAlpha = (this.deathExplosionPhase - 0.7) * 2;\n      g.fillStyle(0xffffff, flashAlpha * 0.5);\n      g.fillRect(0, 0, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);\n    }\n\n    for (const d of this.deathDebris) {\n      // Film noir: grayscale debris\n      const brightness = 0.4 + (d.hue % 60) / 100;\n      const color = this.hslToRgb(0, 0, brightness);\n      const alpha = d.life * 0.9;\n\n      g.save();\n\n      if (d.type === 'shard') {\n        // Draw triangular shards\n        const cx = d.x;\n        const cy = d.y;\n        const size = d.size * d.life;\n\n        // Calculate rotated triangle points\n        const cos = Math.cos(d.rotation);\n        const sin = Math.sin(d.rotation);\n\n        const p1x = cx + cos * size;\n        const p1y = cy + sin * size;\n        const p2x = cx + cos * (-size * 0.5) - sin * (size * 0.7);\n        const p2y = cy + sin * (-size * 0.5) + cos * (size * 0.7);\n        const p3x = cx + cos * (-size * 0.5) - sin * (-size * 0.7);\n        const p3y = cy + sin * (-size * 0.5) + cos * (-size * 0.7);\n\n        // Glow\n        g.fillStyle(color, alpha * 0.4);\n        g.fillCircle(cx, cy, size * 1.5);\n\n        // Shard body\n        g.fillStyle(color, alpha);\n        g.fillTriangle(p1x, p1y, p2x, p2y, p3x, p3y);\n\n        // Highlight edge\n        g.lineStyle(1, 0xffffff, alpha * 0.6);\n        g.lineBetween(p1x, p1y, p2x, p2y);\n\n      } else if (d.type === 'spark') {\n        // Draw elongated spark\n        const sparkLength = d.size * 2 * d.life;\n        const sparkWidth = d.size * 0.3 * d.life;\n\n        // Direction based on velocity\n        const vLen = Math.sqrt(d.vx * d.vx + d.vy * d.vy);\n        const nx = vLen > 0 ? d.vx / vLen : 1;\n        const ny = vLen > 0 ? d.vy / vLen : 0;\n\n        // Glow\n        g.fillStyle(color, alpha * 0.3);\n        g.fillCircle(d.x, d.y, sparkLength * 0.8);\n\n        // Spark line\n        g.lineStyle(sparkWidth * 2, color, alpha * 0.6);\n        g.lineBetween(d.x - nx * sparkLength, d.y - ny * sparkLength, d.x, d.y);\n\n        // Bright tip\n        g.lineStyle(sparkWidth, 0xffffff, alpha);\n        g.lineBetween(d.x - nx * sparkLength * 0.3, d.y - ny * sparkLength * 0.3, d.x, d.y);\n\n      } else {\n        // Ember - glowing circle\n        const emberSize = d.size * d.life;\n\n        // Outer glow\n        g.fillStyle(color, alpha * 0.2);\n        g.fillCircle(d.x, d.y, emberSize * 2);\n\n        // Mid glow\n        g.fillStyle(color, alpha * 0.5);\n        g.fillCircle(d.x, d.y, emberSize * 1.3);\n\n        // Core\n        g.fillStyle(color, alpha);\n        g.fillCircle(d.x, d.y, emberSize);\n\n        // Hot center\n        g.fillStyle(0xffffff, alpha * 0.7);\n        g.fillCircle(d.x, d.y, emberSize * 0.4);\n      }\n\n      g.restore();\n    }\n  }\n\n  private drawNebulaClouds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const cloud of this.nebulaClouds) {\n      // Update cloud position (slow drift)\n      cloud.x += cloud.driftX;\n      cloud.y += cloud.driftY;\n      cloud.pulsePhase += cloud.pulseSpeed;\n\n      // Wrap around edges\n      if (cloud.x < -cloud.radius) cloud.x = width + cloud.radius;\n      if (cloud.x > width + cloud.radius) cloud.x = -cloud.radius;\n      if (cloud.y < -cloud.radius) cloud.y = height + cloud.radius;\n      if (cloud.y > height + cloud.radius) cloud.y = -cloud.radius;\n\n      // Pulsing alpha\n      const pulseAlpha = cloud.alpha * (0.7 + Math.sin(cloud.pulsePhase) * 0.3);\n      const color = this.hslToRgb(cloud.hue / 360, 0.6, 0.3);\n\n      // Draw multiple concentric layers for soft cloud effect\n      const layers = 4;\n      for (let i = layers; i > 0; i--) {\n        const layerRadius = cloud.radius * (i / layers);\n        const layerAlpha = pulseAlpha * (1 - i / (layers + 1)) * 0.6;\n        g.fillStyle(color, layerAlpha);\n        g.fillCircle(cloud.x, cloud.y, layerRadius);\n      }\n\n      // Core glow\n      const coreColor = this.hslToRgb(cloud.hue / 360, 0.8, 0.5);\n      g.fillStyle(coreColor, pulseAlpha * 0.4);\n      g.fillCircle(cloud.x, cloud.y, cloud.radius * 0.3);\n    }\n  }\n\n  private drawVortex(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Update vortex pulse\n    this.vortexPulse += 0.03;\n    const globalPulse = 0.8 + Math.sin(this.vortexPulse) * 0.2;\n\n    // Draw outer glow/halo\n    const outerGlowColor = this.hslToRgb(280 / 360, 0.7, 0.3);\n    g.fillStyle(outerGlowColor, 0.08 * globalPulse);\n    g.fillCircle(centerX, centerY, 120);\n    g.fillStyle(outerGlowColor, 0.05 * globalPulse);\n    g.fillCircle(centerX, centerY, 140);\n\n    // Draw orbiting particles (behind rings)\n    for (const particle of this.vortexParticles) {\n      // Update particle position - spiral inward slightly then reset\n      particle.angle += particle.speed;\n      particle.radius = particle.baseRadius + Math.sin(particle.angle * 3) * 8;\n\n      const px = centerX + Math.cos(particle.angle) * particle.radius;\n      const py = centerY + Math.sin(particle.angle) * particle.radius;\n\n      // Particle hue shifts over time\n      particle.hue = (particle.hue + 0.5) % 360;\n      const particleColor = this.hslToRgb(particle.hue / 360, 0.8, 0.6);\n\n      // Draw particle with trail\n      const trailAngle = particle.angle - 0.3;\n      const trailX = centerX + Math.cos(trailAngle) * particle.radius;\n      const trailY = centerY + Math.sin(trailAngle) * particle.radius;\n\n      g.lineStyle(particle.size * 0.8, particleColor, particle.alpha * 0.3 * globalPulse);\n      g.lineBetween(trailX, trailY, px, py);\n\n      g.fillStyle(particleColor, particle.alpha * globalPulse);\n      g.fillCircle(px, py, particle.size);\n\n      // Bright core\n      g.fillStyle(0xffffff, particle.alpha * 0.5 * globalPulse);\n      g.fillCircle(px, py, particle.size * 0.4);\n    }\n\n    // Draw rotating rings\n    for (const ring of this.vortexRings) {\n      ring.rotationOffset += ring.rotationSpeed;\n      ring.pulsePhase += 0.02;\n\n      const ringPulse = 0.7 + Math.sin(ring.pulsePhase) * 0.3;\n      const adjustedRadius = ring.baseRadius * (0.95 + ringPulse * 0.1);\n\n      const ringColor = this.hslToRgb(ring.hue / 360, 0.8, 0.5);\n\n      // Draw ring as series of arc segments with gaps\n      const segments = 6;\n      const arcLength = (Math.PI * 2) / segments * 0.7;\n\n      for (let i = 0; i < segments; i++) {\n        const startAngle = ring.rotationOffset + (i * Math.PI * 2) / segments;\n        const endAngle = startAngle + arcLength;\n\n        // Calculate alpha based on segment position for 3D effect\n        const segmentAlpha = 0.15 + Math.sin(startAngle + this.frameCount * 0.02) * 0.1;\n\n        g.lineStyle(ring.thickness, ringColor, segmentAlpha * ringPulse * globalPulse);\n        g.beginPath();\n        g.arc(centerX, centerY, adjustedRadius, startAngle, endAngle, false);\n        g.strokePath();\n      }\n\n      // Inner glow line\n      g.lineStyle(ring.thickness * 0.5, 0xffffff, 0.1 * ringPulse * globalPulse);\n      g.beginPath();\n      g.arc(centerX, centerY, adjustedRadius - 1, ring.rotationOffset, ring.rotationOffset + Math.PI, false);\n      g.strokePath();\n    }\n\n    // Central dark core (event horizon)\n    g.fillStyle(0x000000, 0.9);\n    g.fillCircle(centerX, centerY, 12);\n    g.fillStyle(0x000000, 0.7);\n    g.fillCircle(centerX, centerY, 18);\n    g.fillStyle(0x000000, 0.4);\n    g.fillCircle(centerX, centerY, 25);\n\n    // Bright accretion ring at edge of event horizon\n    const accretionHue = (this.frameCount * 2) % 360;\n    const accretionColor = this.hslToRgb(accretionHue / 360, 1, 0.6);\n    g.lineStyle(2, accretionColor, 0.4 * globalPulse);\n    g.strokeCircle(centerX, centerY, 14);\n    g.lineStyle(1, 0xffffff, 0.3 * globalPulse);\n    g.strokeCircle(centerX, centerY, 13);\n\n    // Gravitational lensing effect - distorted light streaks\n    const numStreaks = 4;\n    for (let i = 0; i < numStreaks; i++) {\n      const streakAngle = (i * Math.PI * 2) / numStreaks + this.frameCount * 0.01;\n      const streakHue = (accretionHue + i * 60) % 360;\n      const streakColor = this.hslToRgb(streakHue / 360, 0.9, 0.7);\n\n      const innerRadius = 20;\n      const outerRadius = 35 + Math.sin(this.frameCount * 0.05 + i) * 10;\n\n      const x1 = centerX + Math.cos(streakAngle) * innerRadius;\n      const y1 = centerY + Math.sin(streakAngle) * innerRadius;\n      const x2 = centerX + Math.cos(streakAngle + 0.2) * outerRadius;\n      const y2 = centerY + Math.sin(streakAngle + 0.2) * outerRadius;\n\n      g.lineStyle(3, streakColor, 0.15 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n      g.lineStyle(1.5, 0xffffff, 0.2 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n    }\n  }\n\n  private drawAuroraWaves(g: Phaser.GameObjects.Graphics, width: number): void {\n    for (const aurora of this.auroraWaves) {\n      aurora.phase += aurora.speed;\n\n      // Draw multiple ribbon layers for each aurora\n      const ribbonLayers = 3;\n      for (let layer = 0; layer < ribbonLayers; layer++) {\n        const layerOffset = layer * 5;\n        const layerAlpha = 0.06 - layer * 0.015;\n\n        // Calculate shifting hue for color variation\n        const shiftedHue = (aurora.hue + Math.sin(aurora.phase * 0.5) * 20) % 360;\n        const color = this.hslToRgb(shiftedHue / 360, 0.7, 0.5);\n\n        // Draw aurora as a series of connected curves\n        g.fillStyle(color, layerAlpha);\n        const step = 4;\n        for (let x = 0; x < width; x += step) {\n          // Multiple sine waves combined for organic movement\n          const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n          const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n          const wave3 = Math.sin(x * 0.01 + aurora.phase * 0.7) * aurora.amplitude * 0.3;\n          const yOffset = wave1 + wave2 + wave3;\n\n          const segmentY = aurora.y + yOffset + layerOffset;\n          const thickness = aurora.thickness * (0.7 + Math.sin(x * 0.05 + aurora.phase) * 0.3);\n\n          g.fillRect(x, segmentY - thickness / 2, step + 1, thickness);\n        }\n      }\n\n      // Add bright core line\n      const coreHue = (aurora.hue + 40) % 360;\n      const coreColor = this.hslToRgb(coreHue / 360, 0.9, 0.7);\n      g.lineStyle(1.5, coreColor, 0.15);\n      g.beginPath();\n      for (let x = 0; x < width; x += 3) {\n        const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n        const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n        const y = aurora.y + wave1 + wave2;\n        if (x === 0) {\n          g.moveTo(x, y);\n        } else {\n          g.lineTo(x, y);\n        }\n      }\n      g.strokePath();\n    }\n  }\n\n  private drawPlasmaWaves(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const wave of this.plasmaWaves) {\n      wave.phase += wave.speed;\n      const color = this.hslToRgb(wave.hue / 360, 0.7, 0.4);\n\n      // Draw flowing plasma lines\n      for (let y = 0; y < height; y += 8) {\n        const waveOffset = Math.sin(y / wave.wavelength + wave.phase) * wave.amplitude;\n        const intensity = 0.03 + Math.sin(wave.phase + y * 0.01) * 0.02;\n\n        g.fillStyle(color, intensity);\n        const x1 = width / 2 + waveOffset - 40;\n        const x2 = width / 2 + waveOffset + 40;\n        g.fillRect(x1, y, x2 - x1, 2);\n      }\n    }\n  }\n\n  private drawSnakeAfterimages(g: Phaser.GameObjects.Graphics): void {\n    for (const ai of this.snakeAfterimages) {\n      const alpha = ai.life * 0.25;\n      for (let i = 0; i < ai.segments.length; i++) {\n        const seg = ai.segments[i];\n        const centerX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n        const centerY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n        const t = ai.segments.length > 1 ? i / (ai.segments.length - 1) : 1;\n        const radius = (CELL_SIZE / 2 - 2) * (0.7 + t * 0.2);\n\n        const segmentHue = (ai.hueOffset + i * 15) % 360;\n        const color = this.hslToRgb(segmentHue / 360, 0.6, 0.4);\n\n        g.fillStyle(color, alpha * t);\n        g.fillCircle(centerX, centerY, radius);\n      }\n    }\n  }\n\n  private drawTrailParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.trailParticles) {\n      // Film noir: grayscale trail\n      g.fillStyle(COLORS.noirGray, p.life * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 1.5 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.5);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n  }\n\n  // Update comet trail - add new segments and fade old ones\n  private updateCometTrail(): void {\n    if (!this.currentState || this.currentState.gameOver) {\n      // Fade out trail on game over\n      for (const seg of this.cometTrail) {\n        seg.alpha *= 0.9;\n      }\n      this.cometTrail = this.cometTrail.filter(s => s.alpha > 0.01);\n      return;\n    }\n\n    const snake = this.currentState.snake;\n    if (snake.length === 0) return;\n\n    const head = snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Track head history for smooth interpolation\n    this.headHistory.unshift({ x: headX, y: headY, time: this.frameCount });\n    if (this.headHistory.length > 10) this.headHistory.pop();\n\n    // Add new trail segment at head position\n    if (this.frameCount % 2 === 0) {\n      const hue = 270 + Math.sin(this.frameCount * 0.05) * 20;\n      this.cometTrail.unshift({\n        x: headX,\n        y: headY,\n        alpha: 1,\n        size: CELL_SIZE / 2 + 2,\n        hue,\n      });\n\n      // Spawn ethereal particles from trail\n      if (Math.random() < 0.6) {\n        this.spawnEtherealParticle(headX, headY, hue);\n      }\n    }\n\n    // Limit trail length and fade segments\n    while (this.cometTrail.length > MAX_COMET_TRAIL_LENGTH) {\n      this.cometTrail.pop();\n    }\n\n    // Fade all segments\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const fadeRate = 0.06 + (i / this.cometTrail.length) * 0.04;\n      this.cometTrail[i].alpha -= fadeRate;\n      this.cometTrail[i].size *= 0.97;\n    }\n\n    // Remove fully faded segments\n    this.cometTrail = this.cometTrail.filter(s => s.alpha > 0);\n  }\n\n  // Spawn an ethereal particle that drifts away from the trail\n  private spawnEtherealParticle(x: number, y: number, hue: number): void {\n    if (this.etherealParticles.length >= MAX_ETHEREAL_PARTICLES) {\n      this.etherealParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.5;\n    const life = 0.8 + Math.random() * 0.4;\n\n    this.etherealParticles.push({\n      x: x + (Math.random() - 0.5) * 10,\n      y: y + (Math.random() - 0.5) * 10,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 0.3,\n      size: 3 + Math.random() * 4,\n      life,\n      maxLife: life,\n      hue: hue + (Math.random() - 0.5) * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n\n  // Update ethereal particles\n  private updateEtherealParticles(): void {\n    for (let i = this.etherealParticles.length - 1; i >= 0; i--) {\n      const p = this.etherealParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.015; // Slight upward drift\n      p.vx *= 0.98;\n      p.size *= 0.985;\n      p.life -= 0.02;\n      p.pulsePhase += 0.15;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.etherealParticles.splice(i, 1);\n      }\n    }\n  }\n\n  // Draw the comet trail - smooth glowing ribbon\n  private drawCometTrail(g: Phaser.GameObjects.Graphics): void {\n    if (this.cometTrail.length < 2) return;\n\n    // Draw outer glow layer\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.05) continue;\n\n      const progress = i / this.cometTrail.length;\n      const glowSize = seg.size * (1.5 + progress * 0.5);\n      const glowAlpha = seg.alpha * 0.15 * (1 - progress * 0.5);\n\n      // Outer ethereal glow\n      const outerColor = this.hslToRgb(seg.hue / 360, 0.6, 0.4);\n      g.fillStyle(outerColor, glowAlpha);\n      g.fillCircle(seg.x, seg.y, glowSize * 1.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(seg.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, glowAlpha * 1.5);\n      g.fillCircle(seg.x, seg.y, glowSize);\n    }\n\n    // Draw connecting ribbon between segments\n    if (this.cometTrail.length >= 2) {\n      for (let i = 0; i < this.cometTrail.length - 1; i++) {\n        const seg1 = this.cometTrail[i];\n        const seg2 = this.cometTrail[i + 1];\n        if (seg1.alpha < 0.1 || seg2.alpha < 0.1) continue;\n\n        const progress = i / this.cometTrail.length;\n        const ribbonAlpha = Math.min(seg1.alpha, seg2.alpha) * 0.4 * (1 - progress * 0.5);\n        const ribbonWidth = (seg1.size + seg2.size) / 2 * 0.6;\n\n        // Ribbon core\n        const ribbonColor = this.hslToRgb(seg1.hue / 360, 0.8, 0.6);\n        g.lineStyle(ribbonWidth, ribbonColor, ribbonAlpha);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n\n        // Bright inner ribbon\n        g.lineStyle(ribbonWidth * 0.4, 0xffffff, ribbonAlpha * 0.6);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n      }\n    }\n\n    // Draw core particles at each segment\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.1) continue;\n\n      const progress = i / this.cometTrail.length;\n      const coreAlpha = seg.alpha * 0.6 * (1 - progress * 0.7);\n      const coreSize = seg.size * 0.5 * (1 - progress * 0.3);\n\n      // Core glow\n      const coreColor = this.hslToRgb(seg.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, coreAlpha);\n      g.fillCircle(seg.x, seg.y, coreSize);\n\n      // Bright white center\n      g.fillStyle(0xffffff, coreAlpha * 0.5);\n      g.fillCircle(seg.x, seg.y, coreSize * 0.4);\n    }\n  }\n\n  // Draw ethereal particles - luminous drifting particles\n  private drawEtherealParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.etherealParticles) {\n      const lifeRatio = p.life / p.maxLife;\n      const pulse = 0.7 + Math.sin(p.pulsePhase) * 0.3;\n      const alpha = lifeRatio * pulse;\n\n      // Outer glow\n      const glowColor = this.hslToRgb(p.hue / 360, 0.5, 0.3);\n      g.fillStyle(glowColor, alpha * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 2.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(p.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      // Core\n      const coreColor = this.hslToRgb(p.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, alpha * 0.7);\n      g.fillCircle(p.x, p.y, p.size);\n\n      // Bright center\n      g.fillStyle(0xffffff, alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawShockWaves(g: Phaser.GameObjects.Graphics): void {\n    for (const sw of this.shockWaves) {\n      const alpha = sw.life * 0.6;\n      // Outer ring\n      g.lineStyle(3, 0xffffff, alpha * 0.3);\n      g.strokeCircle(sw.x, sw.y, sw.radius);\n      // Inner bright ring\n      g.lineStyle(2, 0x00ffff, alpha * 0.7);\n      g.strokeCircle(sw.x, sw.y, sw.radius * 0.8);\n      // Core flash\n      if (sw.life > 0.8) {\n        g.fillStyle(0xffffff, (sw.life - 0.8) * 3);\n        g.fillCircle(sw.x, sw.y, sw.radius * 0.3);\n      }\n    }\n  }\n\n  private drawLightningBolts(g: Phaser.GameObjects.Graphics): void {\n    for (const bolt of this.lightningBolts) {\n      const alpha = bolt.life;\n\n      // Film noir: white lightning\n      g.lineStyle(4, COLORS.noirGray, alpha * 0.3);\n      this.drawLightningPath(g, bolt.points);\n\n      g.lineStyle(2, 0xffffff, alpha * 0.8);\n      this.drawLightningPath(g, bolt.points);\n    }\n  }\n\n  private drawLightningPath(g: Phaser.GameObjects.Graphics, points: { x: number; y: number }[]): void {\n    if (points.length < 2) return;\n    g.beginPath();\n    g.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      g.lineTo(points[i].x, points[i].y);\n    }\n    g.strokePath();\n  }\n\n  private drawSnakeElectricity(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n    const snake = this.currentState.snake;\n    if (snake.length < 2) return;\n\n    // Draw electric arcs between segments every few frames\n    if (this.frameCount % 3 !== 0) return;\n\n    for (let i = 0; i < snake.length - 1; i++) {\n      if (Math.random() > 0.4) continue;\n\n      const seg1 = snake[i];\n      const seg2 = snake[i + 1];\n      const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n      const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n      const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n      const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const arcPoints = this.generateLightningPath(x1, y1, x2, y2);\n\n      // Film noir: grayscale arcs\n      g.lineStyle(3, COLORS.noirGray, 0.3);\n      this.drawLightningPath(g, arcPoints);\n      g.lineStyle(1, 0xffffff, 0.7);\n      this.drawLightningPath(g, arcPoints);\n    }\n  }\n\n  private hslToRgb(h: number, s: number, l: number): number {\n    let r: number, g: number, b: number;\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return (Math.round(r * 255) << 16) | (Math.round(g * 255) << 8) | Math.round(b * 255);\n  }\n\n  private loadHighScores(): HighScoreEntry[] {\n    if (this.highScoresLoaded && this.highScores.length > 0) {\n      return this.highScores;\n    }\n    try {\n      const stored = localStorage.getItem('snake_high_scores');\n      if (stored) {\n        const parsed = JSON.parse(stored) as HighScoreEntry[];\n        this.highScores = parsed.slice(0, MAX_HIGH_SCORES);\n        this.highScoresLoaded = true;\n        return this.highScores;\n      }\n    } catch {\n      // localStorage not available\n    }\n    this.highScores = [];\n    this.highScoresLoaded = true;\n    return this.highScores;\n  }\n\n  private saveHighScore(score: number): number {\n    const highScores = this.loadHighScores();\n    const newEntry: HighScoreEntry = { score, date: Date.now(), rank: 0 };\n\n    let insertIndex = highScores.findIndex(entry => score > entry.score);\n    if (insertIndex === -1) insertIndex = highScores.length;\n\n    if (insertIndex < MAX_HIGH_SCORES && score > 0) {\n      highScores.splice(insertIndex, 0, newEntry);\n      highScores.forEach((entry, i) => { entry.rank = i + 1; });\n      this.highScores = highScores.slice(0, MAX_HIGH_SCORES);\n\n      try {\n        localStorage.setItem('snake_high_scores', JSON.stringify(this.highScores));\n      } catch {\n        // localStorage not available\n      }\n      return insertIndex + 1;\n    }\n    return -1;\n  }\n\n  private checkAndSaveHighScore(): void {\n    if (!this.currentState) return;\n\n    if (this.currentState.gameOver && !this.lastGameOverState) {\n      const score = this.currentState.score || 0;\n      const rank = this.saveHighScore(score);\n      this.newHighScoreRank = rank > 0 ? rank : -1;\n      this.scoreboardRevealProgress = 0;\n    }\n    this.lastGameOverState = this.currentState.gameOver;\n\n    if (this.currentState.gameStarted && !this.currentState.gameOver) {\n      this.newHighScoreRank = -1;\n    }\n  }\n\n  private drawHUD(g: Phaser.GameObjects.Graphics, width: number): void {\n    if (!this.currentState || !this.currentState.gameStarted) return;\n\n    this.hudPulsePhase += 0.08;\n    const score = this.currentState.score || 0;\n\n    if (score > this.lastHudScore) {\n      this.scoreFlashIntensity = 1;\n    }\n    this.lastHudScore = score;\n    this.scoreFlashIntensity *= 0.92;\n\n    const padding = 12;\n    const scorePanelWidth = 120;\n    const scorePanelHeight = 50;\n\n    // Score panel background - volcanic lava theme\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Glowing border\n    const borderGlow = 0.6 + this.scoreFlashIntensity * 0.4;\n    g.lineStyle(2, COLORS.snakeGlow, borderGlow);\n    g.strokeRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Score label\n    this.drawText(g, 'SCORE', padding + 10, padding + 12, 10, COLORS.snakeBody, 0.9);\n\n    // Score value with flash effect\n    const scoreColor = this.scoreFlashIntensity > 0.5 ? 0xffffff : COLORS.snakeHead;\n    this.drawText(g, String(score).padStart(5, '0'), padding + 10, padding + 32, 18, scoreColor, 1);\n\n    // Outer glow on score when flashing\n    if (this.scoreFlashIntensity > 0.1) {\n      g.fillStyle(COLORS.snakeGlow, this.scoreFlashIntensity * 0.3);\n      g.fillRoundedRect(padding + 5, padding + 20, 100, 28, 4);\n    }\n\n    // Length panel on the right\n    const lengthPanelWidth = 80;\n    const lengthPanelHeight = 50;\n    const lengthX = width - padding - lengthPanelWidth;\n\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    g.lineStyle(2, COLORS.foodGlow, 0.6);\n    g.strokeRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    this.drawText(g, 'LENGTH', lengthX + 10, padding + 12, 10, COLORS.food, 0.9);\n    this.drawText(g, String(this.currentState.snake.length), lengthX + 10, padding + 32, 18, COLORS.foodCore, 1);\n  }\n\n  private drawText(\n    g: Phaser.GameObjects.Graphics,\n    text: string,\n    x: number,\n    y: number,\n    size: number,\n    color: number,\n    alpha: number\n  ): void {\n    // Use simple block characters for text rendering\n    const charWidth = size * 0.6;\n    const charHeight = size;\n\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const cx = x + i * charWidth;\n\n      g.fillStyle(color, alpha);\n\n      // Simple pixel-style character rendering\n      if (char >= '0' && char <= '9') {\n        this.drawDigit(g, char, cx, y, size);\n      } else {\n        this.drawLetter(g, char, cx, y, size);\n      }\n    }\n  }\n\n  private drawDigit(g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15; // thickness\n\n    // 7-segment style digits\n    const segments: Record<string, number[]> = {\n      '0': [1, 1, 1, 0, 1, 1, 1],\n      '1': [0, 0, 1, 0, 0, 1, 0],\n      '2': [1, 0, 1, 1, 1, 0, 1],\n      '3': [1, 0, 1, 1, 0, 1, 1],\n      '4': [0, 1, 1, 1, 0, 1, 0],\n      '5': [1, 1, 0, 1, 0, 1, 1],\n      '6': [1, 1, 0, 1, 1, 1, 1],\n      '7': [1, 0, 1, 0, 0, 1, 0],\n      '8': [1, 1, 1, 1, 1, 1, 1],\n      '9': [1, 1, 1, 1, 0, 1, 1],\n    };\n\n    const seg = segments[digit] || segments['0'];\n\n    // Top horizontal\n    if (seg[0]) g.fillRect(x, y - h / 2, w, t);\n    // Top-left vertical\n    if (seg[1]) g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n    // Top-right vertical\n    if (seg[2]) g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n    // Middle horizontal\n    if (seg[3]) g.fillRect(x, y - t / 2, w, t);\n    // Bottom-left vertical\n    if (seg[4]) g.fillRect(x - t / 2, y, t, h / 2);\n    // Bottom-right vertical\n    if (seg[5]) g.fillRect(x + w - t / 2, y, t, h / 2);\n    // Bottom horizontal\n    if (seg[6]) g.fillRect(x, y + h / 2 - t, w, t);\n  }\n\n  private drawLetter(g: Phaser.GameObjects.Graphics, letter: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15;\n\n    // Simple block letters\n    switch (letter.toUpperCase()) {\n      case 'S':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'C':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'O':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'R':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w / 2, y, t, h / 2);\n        break;\n      case 'E':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w * 0.7, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'L':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'N':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - h / 2 + t, w, t);\n        break;\n      case 'G':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x + w / 2, y - t / 2, w / 2, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'T':\n        g.fillRect(x - t, y - h / 2, w + t * 2, t);\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'H':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n      case 'I':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'Y':\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        break;\n      case 'U':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'W':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case '!':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h * 0.6);\n        g.fillRect(x + w / 2 - t / 2, y + h / 2 - t * 2, t, t);\n        break;\n      case ' ':\n        break;\n      default:\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n    }\n  }\n\n  private drawScoreboard(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (!this.currentState || !this.currentState.gameOver) return;\n\n    this.scoreboardAnimPhase += 0.06;\n    this.scoreboardRevealProgress = Math.min(1, this.scoreboardRevealProgress + 0.02);\n\n    const highScores = this.loadHighScores();\n    const centerX = width / 2;\n    const baseY = height * 0.18;\n    const panelWidth = 180;\n    const panelHeight = 170;\n    const panelX = centerX - panelWidth / 2;\n    const panelY = baseY;\n    const slideOffset = (1 - this.scoreboardRevealProgress) * 50;\n    const alphaMultiplier = this.scoreboardRevealProgress;\n\n    // Panel background - volcanic lava glow\n    g.fillStyle(0x150510, 0.95 * alphaMultiplier);\n    g.fillRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Glowing border - animated\n    const borderHue = this.newHighScoreRank > 0 ? 45 : 0;\n    const borderPulse = 0.6 + Math.sin(this.scoreboardAnimPhase) * 0.2;\n    const borderColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    g.lineStyle(3, borderColor, borderPulse * alphaMultiplier);\n    g.strokeRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Title\n    const titleY = panelY - slideOffset + 22;\n    this.drawText(g, 'HIGH SCORES', centerX - 55, titleY, 10, COLORS.foodCore, alphaMultiplier);\n\n    // Divider line\n    g.lineStyle(1, COLORS.snakeGlow, 0.5 * alphaMultiplier);\n    g.lineBetween(panelX + 20, titleY + 8, panelX + panelWidth - 20, titleY + 8);\n\n    const entryStartY = titleY + 25;\n    const entryHeight = 22;\n\n    if (highScores.length === 0) {\n      this.drawText(g, 'NO SCORES YET', centerX - 50, entryStartY + 30, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n    } else {\n      for (let i = 0; i < Math.min(highScores.length, 5); i++) {\n        const entry = highScores[i];\n        const entryY = entryStartY + i * entryHeight;\n        const isNewScore = this.newHighScoreRank === i + 1;\n        const entryDelay = i * 0.15;\n        const entryProgress = Math.max(0, Math.min(1, (this.scoreboardRevealProgress - entryDelay) * 2));\n        if (entryProgress <= 0) continue;\n\n        const entryAlpha = alphaMultiplier * entryProgress;\n\n        // Highlight new high score row\n        if (isNewScore) {\n          const flashIntensity = 0.3 + Math.sin(this.scoreboardAnimPhase * 3) * 0.2;\n          g.fillStyle(0xffcc00, flashIntensity * entryAlpha);\n          g.fillRoundedRect(panelX + 8, entryY - slideOffset - 8, panelWidth - 16, entryHeight - 2, 4);\n        }\n\n        // Rank colors: gold, silver, bronze, then volcanic colors\n        const rankColors = [0xffd700, 0xc0c0c0, 0xcd7f32, COLORS.snakeGlow, COLORS.foodGlow];\n        const rankColor = rankColors[i] || 0x888888;\n\n        // Rank number\n        this.drawText(g, `${i + 1}`, panelX + 18, entryY - slideOffset, 10, rankColor, entryAlpha);\n\n        // Score value\n        const scoreColor = isNewScore ? 0xffffff : COLORS.foodCore;\n        this.drawText(g, String(entry.score).padStart(5, '0'), panelX + panelWidth - 70, entryY - slideOffset, 10, scoreColor, entryAlpha);\n\n        // NEW! label\n        if (isNewScore) {\n          const newAlpha = 0.8 + Math.sin(this.scoreboardAnimPhase * 4) * 0.2;\n          this.drawText(g, 'NEW', panelX + 50, entryY - slideOffset, 7, 0xffcc00, newAlpha * entryAlpha);\n        }\n      }\n    }\n\n    // Current score at bottom\n    const currentScoreY = panelY - slideOffset + panelHeight - 30;\n    this.drawText(g, 'YOUR SCORE', centerX - 40, currentScoreY - 10, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n\n    const currentScore = this.currentState.score || 0;\n    const scoreColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    this.drawText(g, String(currentScore).padStart(5, '0'), centerX - 25, currentScoreY + 8, 14, scoreColor, alphaMultiplier);\n  }\n\n  private drawGrid(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir grid: subtle, dark lines suggesting tile floor or city grid\n    g.lineStyle(1, COLORS.gridLine, 0.08);\n    for (let i = 0; i <= GRID_SIZE; i++) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Accent lines every 5 cells - subtle gray\n    const accentPulse = 0.12 + Math.sin(this.frameCount * 0.03) * 0.04;\n    g.lineStyle(1, COLORS.gridAccent, accentPulse);\n    for (let i = 0; i <= GRID_SIZE; i += 5) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Heavy vignette for dramatic noir look\n    this.drawVignette(g, width, height);\n  }\n\n  private drawVignette(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Multiple layers of vignette for smooth falloff\n    const layers = 5;\n    for (let i = 0; i < layers; i++) {\n      const inset = i * 30;\n      const alpha = 0.15 * (1 - i / layers);\n      g.lineStyle(60, 0x000000, alpha);\n      g.strokeRect(inset - 30, inset - 30, width - inset * 2 + 60, height - inset * 2 + 60);\n    }\n  }\n\n  private drawFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    // Don't draw food if it's still being thrown\n    if (this.thrownFood && !this.thrownFood.landed) return;\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    const pulseScale = 1 + Math.sin(this.frameCount * 0.15) * 0.08;\n    const glowPulse = 0.4 + Math.sin(this.frameCount * 0.1) * 0.2;\n\n    // Spawn particles (orange/yellow for Halloween)\n    this.spawnFoodParticles(foodX, foodY);\n\n    // Draw particles\n    for (const p of this.foodParticles) {\n      g.fillStyle(COLORS.pumpkinOrange, p.life * 0.4);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Halloween pumpkin!\n    const pumpkinSize = (CELL_SIZE / 2) * pulseScale;\n\n    // Shadow underneath\n    g.fillStyle(0x000000, 0.5);\n    g.fillEllipse(foodX + 2, foodY + pumpkinSize * 0.8, pumpkinSize * 1.2, pumpkinSize * 0.4);\n\n    // Outer orange glow (candlelight effect)\n    g.fillStyle(COLORS.pumpkinOrange, glowPulse * 0.15);\n    g.fillCircle(foodX, foodY, pumpkinSize + 12);\n    g.fillStyle(COLORS.candyCorn1, glowPulse * 0.2);\n    g.fillCircle(foodX, foodY, pumpkinSize + 6);\n\n    // Pumpkin body (slightly squashed circle)\n    g.fillStyle(COLORS.pumpkinOrange, 0.95);\n    g.fillEllipse(foodX, foodY, pumpkinSize * 1.1, pumpkinSize * 0.9);\n\n    // Pumpkin segments (darker lines)\n    g.lineStyle(2, 0xcc4400, 0.5);\n    g.lineBetween(foodX, foodY - pumpkinSize * 0.8, foodX, foodY + pumpkinSize * 0.7);\n    g.lineStyle(1.5, 0xcc4400, 0.3);\n    g.lineBetween(foodX - pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX - pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n    g.lineBetween(foodX + pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX + pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n\n    // Pumpkin stem\n    g.fillStyle(0x228822, 0.9);\n    g.fillRect(foodX - 2, foodY - pumpkinSize * 0.9 - 4, 4, 6);\n\n    // Jack-o-lantern face - glowing eyes and mouth\n    const faceGlow = 0.8 + Math.sin(this.frameCount * 0.12) * 0.2;\n    g.fillStyle(COLORS.candyCorn1, faceGlow);\n\n    // Eyes (triangles)\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n\n    // Mouth (jagged smile)\n    g.fillStyle(COLORS.candyCorn1, faceGlow * 0.9);\n    g.fillRect(foodX - pumpkinSize * 0.35, foodY + pumpkinSize * 0.15, pumpkinSize * 0.7, pumpkinSize * 0.25);\n\n    // Teeth (dark gaps in mouth)\n    g.fillStyle(COLORS.pumpkinOrange, 1);\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX, foodY + pumpkinSize * 0.15,\n      foodX - pumpkinSize * 0.075, foodY + pumpkinSize * 0.3\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.3, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.225, foodY + pumpkinSize * 0.3\n    );\n  }\n\n  private drawEnergyTendrils(g: Phaser.GameObjects.Graphics, foodX: number, foodY: number): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const head = this.currentState.snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Calculate distance to snake head\n    const dx = headX - foodX;\n    const dy = headY - foodY;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    // Only draw tendrils when snake is somewhat close\n    if (dist > CELL_SIZE * 6) return;\n\n    // Intensity increases as snake gets closer\n    const intensity = 1 - dist / (CELL_SIZE * 6);\n    const numTendrils = 2 + Math.floor(intensity * 2);\n\n    for (let i = 0; i < numTendrils; i++) {\n      // Tendril reaches partway toward the snake\n      const reach = 0.3 + intensity * 0.4;\n      const targetX = foodX + dx * reach;\n      const targetY = foodY + dy * reach;\n\n      // Add some wave offset for each tendril\n      const waveOffset = Math.sin(this.frameCount * 0.15 + i * 2) * 10;\n      const perpX = -dy / dist;\n      const perpY = dx / dist;\n      const wavyTargetX = targetX + perpX * waveOffset * (1 - reach);\n      const wavyTargetY = targetY + perpY * waveOffset * (1 - reach);\n\n      // Generate tendril path\n      const points = this.generateLightningPath(foodX, foodY, wavyTargetX, wavyTargetY);\n\n      // Draw tendril with glow\n      g.lineStyle(3, COLORS.foodGlow, intensity * 0.3);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1.5, COLORS.food, intensity * 0.7);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1, 0xffffff, intensity * 0.5);\n      this.drawLightningPath(g, points);\n    }\n  }\n\n  private drawSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const snakeLen = snake.length;\n\n    // Spooky shadow under snake\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const shadowRadius = (CELL_SIZE / 2) * (0.9 + t * 0.1);\n      g.fillStyle(0x000000, 0.5 * t);\n      g.fillCircle(centerX, centerY, shadowRadius);\n    }\n\n    // Draw trailing glow (ghostly green)\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const glowAlpha = 0.2 * t;\n      const glowSize = (CELL_SIZE / 2 + 4) * (0.5 + t * 0.5);\n\n      g.fillStyle(COLORS.snakeGlow, glowAlpha);\n      g.fillCircle(centerX, centerY, glowSize);\n    }\n\n    // Draw snake segments from tail to head with green gradient\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n\n      // Green gradient from tail (dark) to head (bright)\n      const brightness = 0.3 + t * 0.4;\n      const segmentColor = this.hslToRgb(0.4, 0.9, brightness);\n\n      if (i === 0) {\n        // Head: brightest green with eerie glow\n        g.fillStyle(COLORS.snakeGlow, 0.4);\n        g.fillCircle(centerX, centerY, radius + 8);\n\n        g.fillStyle(COLORS.snakeHead, 1);\n        g.fillCircle(centerX, centerY, radius + 1);\n\n        // Slimy highlight\n        g.fillStyle(0xaaffcc, 0.6);\n        g.fillCircle(centerX - 2, centerY - 2, radius * 0.35);\n\n        this.drawSnakeHead(g, segment, snake[1]);\n      } else {\n        // Body segment with green tones\n        g.fillStyle(COLORS.snakeGlow, 0.15);\n        g.fillCircle(centerX, centerY, radius + 2);\n\n        g.fillStyle(segmentColor, 1);\n        g.fillCircle(centerX, centerY, radius);\n\n        // Slimy specular highlight\n        g.fillStyle(0xaaffcc, 0.15 * t);\n        g.fillCircle(centerX - 1, centerY - 1, radius * 0.25);\n      }\n    }\n  }\n\n  private drawFoodBurst(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.foodBurstParticles) {\n      // Halloween: orange pumpkin burst\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailAlpha = p.life * 0.4 * (1 - i / p.trail.length);\n        const trailSize = p.size * p.life * (1 - i / p.trail.length);\n        g.fillStyle(COLORS.pumpkinOrange, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      g.fillStyle(COLORS.candyCorn1, p.life * 0.7);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n      g.fillStyle(COLORS.candyCorn3, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life * 0.4);\n    }\n  }\n\n  private drawEnergyField(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const snake = this.currentState.snake;\n    const baseIntensity = 0.06 + this.energyFieldPulse * 0.2;\n    const pulseOffset = Math.sin(this.frameCount * 0.1) * 0.02;\n    const alpha = Math.min(0.3, baseIntensity + pulseOffset);\n\n    // Halloween: ghostly green energy field\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const fieldRadius = CELL_SIZE * (0.8 + this.energyFieldPulse * 0.5) + Math.sin(this.frameCount * 0.15 + i * 0.5) * 2;\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.2);\n      g.fillCircle(cx, cy, fieldRadius + 4);\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.35);\n      g.fillCircle(cx, cy, fieldRadius);\n    }\n\n    // Connecting lines when pulse is active\n    if (this.energyFieldPulse > 0.3 && snake.length > 1) {\n      for (let i = 0; i < snake.length - 1; i++) {\n        const seg1 = snake[i];\n        const seg2 = snake[i + 1];\n        const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n        const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n        const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n        const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n        g.lineStyle(3, COLORS.noirGray, this.energyFieldPulse * 0.3);\n        g.lineBetween(x1, y1, x2, y2);\n        g.lineStyle(1.5, 0xffffff, this.energyFieldPulse * 0.5);\n        g.lineBetween(x1, y1, x2, y2);\n      }\n    }\n  }\n\n  private drawChromaticAberration(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const offset = this.chromaticIntensity * 3;\n\n    // Film noir: grayscale ghosting effect instead of color split\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snake.length > 1 ? i / (snake.length - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n      const alpha = this.chromaticIntensity * 0.3 * (i === 0 ? 1 : 0.5);\n\n      // Light ghost - offset left\n      g.fillStyle(0xffffff, alpha);\n      g.fillCircle(cx - offset, cy, radius);\n\n      // Dark ghost - offset right\n      g.fillStyle(0x404040, alpha);\n      g.fillCircle(cx + offset, cy, radius);\n    }\n  }\n\n  private drawGameOver(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir game over: dramatic fade to black with spotlight\n    if (this.gameOverAlpha < 0.85) {\n      this.gameOverAlpha += 0.03;\n    }\n\n    // Heavy dark overlay\n    g.fillStyle(COLORS.gameOverOverlay, this.gameOverAlpha);\n    g.fillRect(0, 0, width, height);\n\n    // Film grain effect (subtle noise lines)\n    for (let y = 0; y < height; y += 3) {\n      const grainAlpha = 0.05 + Math.random() * 0.05;\n      g.fillStyle(Math.random() > 0.5 ? 0xffffff : 0x000000, grainAlpha);\n      g.fillRect(0, y, width, 1);\n    }\n\n    // Dramatic spotlight in center\n    const spotPulse = 0.15 + Math.sin(this.frameCount * 0.05) * 0.05;\n    g.fillStyle(COLORS.noirWhite, spotPulse);\n    g.fillCircle(width / 2, height / 2, 80);\n    g.fillStyle(COLORS.noirWhite, spotPulse * 0.5);\n    g.fillCircle(width / 2, height / 2, 120);\n\n    // Noir border: thick black frame\n    const borderSize = 8;\n    g.fillStyle(0x000000, 0.8);\n    g.fillRect(0, 0, width, borderSize);\n    g.fillRect(0, height - borderSize, width, borderSize);\n    g.fillRect(0, 0, borderSize, height);\n    g.fillRect(width - borderSize, 0, borderSize, height);\n\n    // White inner border\n    const innerBorder = 2;\n    const innerOffset = borderSize;\n    g.fillStyle(COLORS.noirWhite, 0.3);\n    g.fillRect(innerOffset, innerOffset, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, height - innerOffset - innerBorder, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, innerOffset, innerBorder, height - innerOffset * 2);\n    g.fillRect(width - innerOffset - innerBorder, innerOffset, innerBorder, height - innerOffset * 2);\n  }\n\n  private drawSnakeHead(\n    g: Phaser.GameObjects.Graphics,\n    head: Position,\n    nextSegment: Position | undefined\n  ): void {\n    const centerX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const centerY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Determine direction for eye placement\n    let dx = 1, dy = 0;\n    if (nextSegment) {\n      dx = head.x - nextSegment.x;\n      dy = head.y - nextSegment.y;\n      // Normalize\n      const len = Math.sqrt(dx * dx + dy * dy);\n      if (len > 0) {\n        dx /= len;\n        dy /= len;\n      }\n    }\n\n    // Perpendicular for eye offset\n    const perpX = -dy;\n    const perpY = dx;\n\n    const eyeOffset = 4;\n    const eyeForward = 3;\n    const eyeRadius = 3;\n    const pupilRadius = 1.5;\n\n    // Left eye\n    const leftEyeX = centerX + perpX * eyeOffset + dx * eyeForward;\n    const leftEyeY = centerY + perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(leftEyeX, leftEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(leftEyeX + dx * 1, leftEyeY + dy * 1, pupilRadius);\n\n    // Right eye\n    const rightEyeX = centerX - perpX * eyeOffset + dx * eyeForward;\n    const rightEyeY = centerY - perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(rightEyeX, rightEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(rightEyeX + dx * 1, rightEyeY + dy * 1, pupilRadius);\n\n    // Draw the royal crown\n    this.drawCrown(g, centerX, centerY, dx, dy, perpX, perpY);\n  }\n\n  private drawCrown(\n    g: Phaser.GameObjects.Graphics,\n    headX: number,\n    headY: number,\n    dx: number,\n    dy: number,\n    perpX: number,\n    perpY: number\n  ): void {\n    // Volcanic crown: molten gold with ruby gems\n    const crownOffset = -8;\n    const crownBaseX = headX - dx * crownOffset;\n    const crownBaseY = headY - dy * crownOffset;\n\n    const crownWidth = 14;\n    const crownHeight = 10;\n    const halfWidth = crownWidth / 2;\n\n    const sparkle = 0.7 + Math.sin(this.frameCount * 0.15) * 0.3;\n\n    const baseLeft = {\n      x: crownBaseX + perpX * halfWidth,\n      y: crownBaseY + perpY * halfWidth\n    };\n    const baseRight = {\n      x: crownBaseX - perpX * halfWidth,\n      y: crownBaseY - perpY * halfWidth\n    };\n\n    const pointOffset = -dx * crownHeight;\n    const pointOffsetY = -dy * crownHeight;\n\n    const crownPoints = [\n      baseLeft,\n      { x: baseLeft.x + pointOffset * 0.4, y: baseLeft.y + pointOffsetY * 0.4 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: crownBaseX + perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY + perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY },\n      { x: crownBaseX - perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY - perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: baseRight.x + pointOffset * 0.4, y: baseRight.y + pointOffsetY * 0.4 },\n      baseRight\n    ];\n\n    // Crown glow (molten orange/red aura)\n    g.fillStyle(COLORS.noirWhite, 0.25 * sparkle);\n    g.fillCircle(crownBaseX + pointOffset * 0.5, crownBaseY + pointOffsetY * 0.5, crownHeight + 4);\n\n    // Crown base (molten gold)\n    g.fillStyle(0xffa500, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.fillPath();\n\n    // Crown outline (dark crimson)\n    g.lineStyle(1.5, 0x801010, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.strokePath();\n\n    // Crown band\n    const bandY1 = {\n      x: baseLeft.x + pointOffset * 0.15,\n      y: baseLeft.y + pointOffsetY * 0.15\n    };\n    const bandY2 = {\n      x: baseRight.x + pointOffset * 0.15,\n      y: baseRight.y + pointOffsetY * 0.15\n    };\n    g.lineStyle(3, 0xcc6600, 1);\n    g.lineBetween(bandY1.x, bandY1.y, bandY2.x, bandY2.y);\n\n    // Ruby jewels: glowing red gems\n    const jewelPositions = [\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY, size: 2.5 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n    ];\n\n    for (const jewel of jewelPositions) {\n      g.fillStyle(0xff4020, 0.5 * sparkle);\n      g.fillCircle(jewel.x, jewel.y, jewel.size + 2);\n\n      g.fillStyle(0xff2000, 1);\n      g.fillCircle(jewel.x, jewel.y, jewel.size);\n\n      g.fillStyle(0xffff80, 0.9 * sparkle);\n      g.fillCircle(jewel.x - 0.5, jewel.y - 0.5, jewel.size * 0.4);\n    }\n\n    // Crown highlight (golden gleam)\n    g.fillStyle(0xffff80, 0.6 * sparkle);\n    g.fillCircle(crownBaseX + perpX * 3 + pointOffset * 0.3, crownBaseY + perpY * 3 + pointOffsetY * 0.3, 2);\n  }\n}\n","structuredPatch":[{"oldStart":3312,"oldLines":6,"newStart":3312,"newLines":14,"lines":["       const rank = this.saveHighScore(score);","       this.newHighScoreRank = rank > 0 ? rank : -1;","       this.scoreboardRevealProgress = 0;","+","+      const head = this.currentState.snake[0];","+      if (head) {","+        const headX = head.x * CELL_SIZE + CELL_SIZE / 2;","+        const headY = head.y * CELL_SIZE + CELL_SIZE / 2;","+        spawnBlood(this.cleanEffects, headX, headY, 15);","+        spawnTears(this.cleanEffects, headX, headY - 10, 6);","+      }","     }","     this.lastGameOverState = this.currentState.gameOver;"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012mkAiubiBQ6y7zDNvZP5gy","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the update and draw calls in the update method. Let me update the main update loop:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":877,"cache_read_input_tokens":44494,"cache_creation":{"ephemeral_5m_input_tokens":877,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"bb2b6414-5876-4c6f-bf31-95b92f6cd255"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012mkAiubiBQ6y7zDNvZP5gy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Gr8SqH1jzC1YfAnjsJEGc7","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","old_string":"    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);","new_string":"    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n    updateTears(this.cleanEffects, height);\n    updateBlood(this.cleanEffects, height);"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":877,"cache_read_input_tokens":44494,"cache_creation":{"ephemeral_5m_input_tokens":877,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"3f35aea8-f0f3-4fce-9aee-efb2b083d000"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Gr8SqH1jzC1YfAnjsJEGc7","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"3050adbe-e112-4343-970c-c03509f33a81","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","oldString":"    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);","newString":"    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n    updateTears(this.cleanEffects, height);\n    updateBlood(this.cleanEffects, height);","originalFile":"import Phaser from 'phaser';\nimport {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface GameState {\n  snake: Position[];\n  food: Position;\n  gameOver: boolean;\n  gameStarted?: boolean;\n  score?: number;\n}\n\ninterface Star {\n  x: number;\n  y: number;\n  size: number;\n  speed: number;\n  brightness: number;\n}\n\ninterface PlasmaWave {\n  phase: number;\n  speed: number;\n  amplitude: number;\n  wavelength: number;\n  hue: number;\n}\n\ninterface AuroraWave {\n  y: number;\n  phase: number;\n  speed: number;\n  hue: number;\n  thickness: number;\n  amplitude: number;\n}\n\ninterface NebulaCloud {\n  x: number;\n  y: number;\n  radius: number;\n  hue: number;\n  alpha: number;\n  driftX: number;\n  driftY: number;\n  pulsePhase: number;\n  pulseSpeed: number;\n}\n\ninterface VortexRing {\n  radius: number;\n  baseRadius: number;\n  rotationOffset: number;\n  rotationSpeed: number;\n  thickness: number;\n  hue: number;\n  pulsePhase: number;\n}\n\ninterface VortexParticle {\n  angle: number;\n  radius: number;\n  baseRadius: number;\n  speed: number;\n  size: number;\n  hue: number;\n  alpha: number;\n}\n\ninterface SnakeAfterimage {\n  segments: Position[];\n  life: number;\n  maxLife: number;\n  hueOffset: number;\n}\n\ninterface FoodParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n}\n\ninterface SnakeTrailParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n  hue: number;\n}\n\ninterface ShockWave {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n}\n\ninterface LightningBolt {\n  points: { x: number; y: number }[];\n  life: number;\n  maxLife: number;\n  hue: number;\n}\n\nconst CELL_SIZE = 20;\nconst GRID_SIZE = 20;\nconst NUM_STARS = 30;\nconst MAX_FOOD_PARTICLES = 8;\nconst MAX_TRAIL_PARTICLES = 40;\nconst MAX_SHOCKWAVES = 3;\nconst MAX_LIGHTNING_BOLTS = 5;\nconst MAX_BURST_PARTICLES = 12;\nconst NUM_PLASMA_WAVES = 3;\nconst MAX_AFTERIMAGES = 4;\nconst NUM_AURORA_WAVES = 5;\nconst NUM_NEBULA_CLOUDS = 6;\nconst NUM_VORTEX_RINGS = 5;\nconst NUM_VORTEX_PARTICLES = 20;\nconst NUM_METEORS = 8;\nconst MAX_DEATH_DEBRIS = 24;\nconst NUM_SPIRITS_PER_EDGE = 2;\nconst MAX_FLAME_PARTICLES = 60;\nconst MAX_COMET_TRAIL_LENGTH = 30;\nconst MAX_ETHEREAL_PARTICLES = 50;\nconst NUM_BEES = 8;\nconst BEE_SPAWN_CHANCE = 0.02;\n\n// Comet trail segment - stores historical snake positions for smooth trail rendering\ninterface CometTrailSegment {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n  hue: number;\n}\n\n// Ethereal trail particle - luminous particles that drift away from trail\ninterface EtherealParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n  pulsePhase: number;\n}\n\n// Thrown food animation - food launched onto screen with arc trajectory\ninterface ThrownFood {\n  startX: number;\n  startY: number;\n  targetX: number;\n  targetY: number;\n  x: number;\n  y: number;\n  progress: number; // 0 to 1\n  rotation: number;\n  rotationSpeed: number;\n  trail: { x: number; y: number; alpha: number; rotation: number }[];\n  landed: boolean;\n  landingParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number }[];\n  impactRings: { radius: number; alpha: number }[];\n}\n\n// Meteor shower types\ninterface Meteor {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  alpha: number;\n  trail: { x: number; y: number; alpha: number }[];\n  life: number;\n}\n\n// Death debris particle\ninterface DeathDebris {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  rotation: number;\n  rotationSpeed: number;\n  life: number;\n  type: 'shard' | 'spark' | 'ember';\n}\n\n// Guardian spirit - ethereal protectors at edges\ninterface GuardianSpirit {\n  x: number;\n  y: number;\n  baseX: number;\n  baseY: number;\n  size: number;\n  phase: number;\n  speed: number;\n  haloPhase: number;\n  orbPhase: number;\n  edge: 'top' | 'bottom' | 'left' | 'right';\n  targetAlpha: number;\n  currentAlpha: number;\n  hue: number;\n  orbs: { angle: number; distance: number; size: number; speed: number }[];\n}\n\n// Flame particle for burning effect\ninterface FlameParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n}\n\n// Mystical bee - glowing magical creatures that swarm around food\ninterface MysticalBee {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  targetX: number;\n  targetY: number;\n  wingPhase: number;\n  wingSpeed: number;\n  size: number;\n  hue: number;\n  glowIntensity: number;\n  bobPhase: number;\n  bobSpeed: number;\n  trail: { x: number; y: number; alpha: number }[];\n  state: 'flying' | 'hovering' | 'attracted';\n  sparkleTimer: number;\n}\n\n// Rival snake - spectral AI nemesis that competes for food\ninterface RivalSnake {\n  segments: { x: number; y: number }[];\n  direction: { dx: number; dy: number };\n  targetX: number;\n  targetY: number;\n  moveTimer: number;\n  moveInterval: number;\n  pulsePhase: number;\n  glowIntensity: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n  energyTrail: { x: number; y: number; alpha: number; size: number }[];\n  state: 'hunting' | 'fleeing' | 'circling';\n  aggression: number;\n  nearMissTimer: number;\n  electricArcs: { x1: number; y1: number; x2: number; y2: number; life: number }[];\n}\n\nconst RIVAL_SNAKE_LENGTH = 10;\nconst RIVAL_MOVE_INTERVAL = 8;\n\n// Armageddon Chaos effect types\ninterface GroundFissure {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  width: number;\n  glowIntensity: number;\n  pulsePhase: number;\n}\n\ninterface FireRainParticle {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n}\n\ninterface ChaosExplosion {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n  rings: { radius: number; alpha: number }[];\n  debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[];\n}\n\ninterface ApocalypticSkull {\n  x: number;\n  y: number;\n  size: number;\n  alpha: number;\n  rotation: number;\n  pulsePhase: number;\n}\n\nconst NUM_FISSURES = 6;\nconst MAX_FIRE_RAIN = 30;\nconst MAX_CHAOS_EXPLOSIONS = 3;\nconst NUM_SKULLS = 4;\n\n// High score entry for scoreboard\ninterface HighScoreEntry {\n  score: number;\n  date: number;\n  rank: number;\n}\n\nconst MAX_HIGH_SCORES = 5;\n\n// Color palette - HALLOWEEN theme: spooky purple/orange, ghostly greens, pumpkin glow\nconst COLORS = {\n  bgDark: 0x0a0012,\n  bgMid: 0x150825,\n  gridLine: 0x2a1540,\n  gridAccent: 0x401860,\n  snakeHead: 0x00ff66,\n  snakeBody: 0x00cc55,\n  snakeTail: 0x009944,\n  snakeHighlight: 0x66ffaa,\n  snakeScale: 0x00aa44,\n  snakeEye: 0xff0000,\n  snakePupil: 0x000000,\n  snakeGlow: 0x00ff80,\n  food: 0xff6600,\n  foodCore: 0xffcc00,\n  foodGlow: 0xff8800,\n  foodParticle: 0xffaa00,\n  star: 0x8844ff,\n  gameOverOverlay: 0x0a0015,\n  gameOverText: 0xff6600,\n  plasma1: 0x9933ff,\n  plasma2: 0xbb55ff,\n  plasma3: 0x7722cc,\n  screenFlash: 0xff6600,\n  // Halloween specific colors\n  noirWhite: 0xeeddff,\n  noirGray: 0x8866aa,\n  noirDark: 0x2a1540,\n  spotlight: 0xff8800,\n  // Halloween additions\n  chaosRed: 0x9933ff,\n  chaosOrange: 0xff6600,\n  chaosYellow: 0xffcc00,\n  lavaGlow: 0x9944ff,\n  ashGray: 0x554466,\n  bloodRed: 0x660088,\n  hellfire: 0xff6600,\n  // New Halloween colors\n  pumpkinOrange: 0xff6600,\n  ghostWhite: 0xeeffee,\n  witchPurple: 0x9933ff,\n  spiderBlack: 0x111122,\n  candyCorn1: 0xffcc00,\n  candyCorn2: 0xff8800,\n  candyCorn3: 0xffffff,\n};\n\nexport class SnakeScene extends Phaser.Scene {\n  private graphics!: Phaser.GameObjects.Graphics;\n  private currentState: GameState | null = null;\n  private needsRedraw = false;\n  private frameCount = 0;\n  private stars: Star[] = [];\n  private foodParticles: FoodParticle[] = [];\n  private trailParticles: SnakeTrailParticle[] = [];\n  private shockWaves: ShockWave[] = [];\n  private lightningBolts: LightningBolt[] = [];\n  private plasmaWaves: PlasmaWave[] = [];\n  private snakeAfterimages: SnakeAfterimage[] = [];\n  private auroraWaves: AuroraWave[] = [];\n  private nebulaClouds: NebulaCloud[] = [];\n  private vortexRings: VortexRing[] = [];\n  private vortexParticles: VortexParticle[] = [];\n  private vortexPulse = 0;\n  private meteors: Meteor[] = [];\n  private deathDebris: DeathDebris[] = [];\n  private deathExplosionPhase = 0;\n  private gameOverAlpha = 0;\n  private lastHeadPos: Position | null = null;\n  private lastSnakeLength = 0;\n  private hueOffset = 0;\n  private screenFlashAlpha = 0;\n  private gameOverGlitchOffset = 0;\n  private screenShakeX = 0;\n  private screenShakeY = 0;\n  private screenShakeIntensity = 0;\n  private energyFieldPulse = 0;\n  private foodBurstParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number; hue: number; trail: { x: number; y: number }[] }[] = [];\n  private chromaticIntensity = 0;\n  // Film noir effects\n  private venetianPhase = 0;\n  private spotlightX = 0;\n  private spotlightY = 0;\n  private smokeParticles: { x: number; y: number; vx: number; vy: number; size: number; alpha: number; life: number }[] = [];\n  private guardianSpirits: GuardianSpirit[] = [];\n  // Burning flame particles trailing behind snake\n  private flameParticles: FlameParticle[] = [];\n  // Comet trail system - historical positions for smooth ribbon trail\n  private cometTrail: CometTrailSegment[] = [];\n  // Ethereal particles that drift away from the trail\n  private etherealParticles: EtherealParticle[] = [];\n  // Track last few head positions for smooth interpolation\n  private headHistory: { x: number; y: number; time: number }[] = [];\n  // Thrown food animation system\n  private thrownFood: ThrownFood | null = null;\n  private lastFoodPos: Position | null = null;\n  // Mystical bees swarming around\n  private bees: MysticalBee[] = [];\n  // Rival snake - spectral AI nemesis\n  private rivalSnake: RivalSnake | null = null;\n  // Scoreboard system\n  private highScores: HighScoreEntry[] = [];\n  private highScoresLoaded = false;\n  private newHighScoreRank = -1;\n  private scoreboardAnimPhase = 0;\n  private scoreboardRevealProgress = 0;\n  private lastGameOverState = false;\n  private hudPulsePhase = 0;\n  private lastHudScore = 0;\n  private scoreFlashIntensity = 0;\n  // Armageddon Chaos effects\n  private groundFissures: GroundFissure[] = [];\n  private fireRainParticles: FireRainParticle[] = [];\n  private chaosExplosions: ChaosExplosion[] = [];\n  private apocalypticSkulls: ApocalypticSkull[] = [];\n  private armageddonPulse = 0;\n  private chaosIntensity = 0;\n  private cleanEffects: CleanEffectsState = createCleanEffectsState();\n\n  constructor() {\n    super({ key: 'SnakeScene' });\n  }\n\n  create(): void {\n    this.graphics = this.add.graphics();\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    initMotes(this.cleanEffects, width, height);\n\n    if (this.currentState) {\n      this.needsRedraw = true;\n    }\n  }\n\n  private initArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Initialize ground fissures - cracks in the earth with lava\n    this.groundFissures = [];\n    for (let i = 0; i < NUM_FISSURES; i++) {\n      const startX = Math.random() * width;\n      const startY = Math.random() * height;\n      const angle = Math.random() * Math.PI;\n      const length = 40 + Math.random() * 80;\n      this.groundFissures.push({\n        x1: startX,\n        y1: startY,\n        x2: startX + Math.cos(angle) * length,\n        y2: startY + Math.sin(angle) * length,\n        width: 2 + Math.random() * 4,\n        glowIntensity: 0.5 + Math.random() * 0.5,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n\n    // Initialize fire rain\n    this.fireRainParticles = [];\n\n    // Initialize chaos explosions\n    this.chaosExplosions = [];\n\n    // Initialize apocalyptic skulls floating in background\n    this.apocalypticSkulls = [];\n    for (let i = 0; i < NUM_SKULLS; i++) {\n      this.apocalypticSkulls.push({\n        x: 30 + Math.random() * (width - 60),\n        y: 30 + Math.random() * (height - 60),\n        size: 15 + Math.random() * 10,\n        alpha: 0.03 + Math.random() * 0.04,\n        rotation: Math.random() * Math.PI * 2,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n  }\n\n  private initSmokeParticles(): void {\n    this.smokeParticles = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < 12; i++) {\n      this.smokeParticles.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        vx: (Math.random() - 0.5) * 0.3,\n        vy: -0.1 - Math.random() * 0.2,\n        size: 30 + Math.random() * 50,\n        alpha: 0.02 + Math.random() * 0.03,\n        life: Math.random(),\n      });\n    }\n  }\n\n  private updateArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    this.armageddonPulse += 0.04;\n\n    // Update ground fissures - pulsing lava glow\n    for (const fissure of this.groundFissures) {\n      fissure.pulsePhase += 0.06;\n      fissure.glowIntensity = 0.5 + Math.sin(fissure.pulsePhase) * 0.3;\n    }\n\n    // Spawn fire rain particles\n    if (this.fireRainParticles.length < MAX_FIRE_RAIN && Math.random() < 0.3) {\n      const hueVariation = Math.random();\n      this.fireRainParticles.push({\n        x: Math.random() * width,\n        y: -20,\n        vy: 2 + Math.random() * 3,\n        size: 2 + Math.random() * 4,\n        alpha: 0.6 + Math.random() * 0.4,\n        hue: hueVariation < 0.6 ? 0 : (hueVariation < 0.85 ? 20 : 40), // Red, orange, yellow\n        trail: [],\n      });\n    }\n\n    // Update fire rain\n    for (let i = this.fireRainParticles.length - 1; i >= 0; i--) {\n      const p = this.fireRainParticles[i];\n      p.trail.unshift({ x: p.x, y: p.y, alpha: p.alpha });\n      if (p.trail.length > 6) p.trail.pop();\n      for (const t of p.trail) { t.alpha *= 0.7; }\n\n      p.y += p.vy;\n      p.x += Math.sin(this.armageddonPulse + p.y * 0.05) * 0.3;\n      p.alpha *= 0.995;\n\n      if (p.y > height + 20 || p.alpha < 0.05) {\n        this.fireRainParticles.splice(i, 1);\n      }\n    }\n\n    // Update chaos explosions\n    for (let i = this.chaosExplosions.length - 1; i >= 0; i--) {\n      const exp = this.chaosExplosions[i];\n      exp.radius += 4;\n      exp.life -= 0.03;\n\n      for (const ring of exp.rings) {\n        ring.radius += 3;\n        ring.alpha *= 0.92;\n      }\n      exp.rings = exp.rings.filter(r => r.alpha > 0.02);\n\n      for (const d of exp.debris) {\n        d.x += d.vx;\n        d.y += d.vy;\n        d.vy += 0.1;\n        d.alpha *= 0.96;\n      }\n      exp.debris = exp.debris.filter(d => d.alpha > 0.02);\n\n      if (exp.life <= 0 && exp.rings.length === 0 && exp.debris.length === 0) {\n        this.chaosExplosions.splice(i, 1);\n      }\n    }\n\n    // Update apocalyptic skulls - slow drift and pulse\n    for (const skull of this.apocalypticSkulls) {\n      skull.pulsePhase += 0.02;\n      skull.rotation += 0.002;\n      skull.x += Math.sin(skull.pulsePhase * 0.5) * 0.1;\n      skull.y += Math.cos(skull.pulsePhase * 0.3) * 0.1;\n\n      // Keep in bounds\n      if (skull.x < 20) skull.x = 20;\n      if (skull.x > width - 20) skull.x = width - 20;\n      if (skull.y < 20) skull.y = 20;\n      if (skull.y > height - 20) skull.y = height - 20;\n    }\n\n    // Chaos intensity increases when snake eats or dies\n    this.chaosIntensity *= 0.97;\n  }\n\n  private spawnChaosExplosion(x: number, y: number): void {\n    if (this.chaosExplosions.length >= MAX_CHAOS_EXPLOSIONS) {\n      this.chaosExplosions.shift();\n    }\n\n    const debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[] = [];\n    for (let i = 0; i < 12; i++) {\n      const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 5;\n      debris.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 2,\n        size: 2 + Math.random() * 4,\n        alpha: 1,\n      });\n    }\n\n    this.chaosExplosions.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: 80,\n      life: 1,\n      rings: [\n        { radius: 10, alpha: 1 },\n        { radius: 5, alpha: 0.8 },\n        { radius: 15, alpha: 0.6 },\n      ],\n      debris,\n    });\n\n    this.chaosIntensity = Math.min(1, this.chaosIntensity + 0.5);\n    this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 12);\n  }\n\n  private drawArmageddonBackground(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Spooky Halloween night sky\n    const skyPulse = 0.8 + Math.sin(this.armageddonPulse * 0.5) * 0.2;\n\n    // Layer 1: Deep purple-black night base\n    g.fillStyle(0x0a0018, 1);\n    g.fillRect(0, 0, width, height);\n\n    // Layer 2: Eerie purple glow from below (like fog)\n    g.fillStyle(0x200840, 0.3 * skyPulse);\n    g.fillRect(0, height * 0.7, width, height * 0.3);\n\n    // Layer 3: Misty purple clouds\n    for (let i = 0; i < 4; i++) {\n      const cloudY = i * 30 + Math.sin(this.armageddonPulse + i) * 10;\n      const cloudAlpha = 0.1 - i * 0.02;\n      g.fillStyle(0x301040, cloudAlpha * skyPulse);\n      g.fillRect(0, cloudY, width, 40);\n    }\n\n    // Draw haunted moon\n    this.drawHauntedMoon(g, width);\n\n    // Draw flying bats in background\n    this.drawFlyingBats(g, width, height);\n\n    // Draw apocalyptic skulls (very faint, background layer)\n    this.drawApocalypticSkulls(g);\n  }\n\n  private drawHauntedMoon(g: Phaser.GameObjects.Graphics, width: number): void {\n    const moonX = width * 0.8;\n    const moonY = 60;\n    const moonRadius = 35;\n    const moonPulse = 0.9 + Math.sin(this.frameCount * 0.02) * 0.1;\n\n    // Moon glow\n    g.fillStyle(0xff8800, 0.1 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 2);\n    g.fillStyle(0xffaa00, 0.15 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 1.5);\n\n    // Main moon (orange harvest moon)\n    g.fillStyle(0xffaa33, 0.9);\n    g.fillCircle(moonX, moonY, moonRadius);\n\n    // Moon craters\n    g.fillStyle(0xcc8822, 0.4);\n    g.fillCircle(moonX - 10, moonY - 5, 8);\n    g.fillCircle(moonX + 12, moonY + 8, 6);\n    g.fillCircle(moonX - 5, moonY + 12, 5);\n  }\n\n  private drawFlyingBats(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const batCount = 6;\n    for (let i = 0; i < batCount; i++) {\n      const phase = this.frameCount * 0.03 + i * 1.5;\n      const batX = ((i * 127 + this.frameCount * 0.5) % (width + 100)) - 50;\n      const batY = 40 + i * 20 + Math.sin(phase) * 15;\n      const wingPhase = Math.sin(this.frameCount * 0.15 + i * 2);\n\n      // Bat body\n      g.fillStyle(0x111122, 0.8);\n      g.fillCircle(batX, batY, 4);\n\n      // Bat wings (flapping)\n      const wingSpread = 8 + wingPhase * 4;\n      g.fillStyle(0x111122, 0.7);\n\n      // Left wing\n      g.beginPath();\n      g.moveTo(batX - 2, batY);\n      g.lineTo(batX - wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX - wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n\n      // Right wing\n      g.beginPath();\n      g.moveTo(batX + 2, batY);\n      g.lineTo(batX + wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX + wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawGroundFissures(g: Phaser.GameObjects.Graphics): void {\n    for (const fissure of this.groundFissures) {\n      const pulse = fissure.glowIntensity;\n\n      // Ghostly purple glow underneath\n      g.lineStyle(fissure.width * 3, COLORS.lavaGlow, 0.12 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Crack edges (dark purple)\n      g.lineStyle(fissure.width + 2, 0x200030, 0.4);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ethereal core (bright purple)\n      g.lineStyle(fissure.width, COLORS.witchPurple, 0.3 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ghostly white center\n      g.lineStyle(fissure.width * 0.3, COLORS.ghostWhite, 0.2 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n    }\n  }\n\n  private drawFireRain(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.fireRainParticles) {\n      // Draw ghostly trail\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailSize = p.size * (1 - i / p.trail.length) * 0.6;\n        // Ghostly purple/green trail\n        const ghostHue = 0.75 + (p.hue % 60) / 360;\n        const trailColor = this.hslToRgb(ghostHue, 0.6, 0.6);\n        g.fillStyle(trailColor, t.alpha * 0.3);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Main spirit particle (ghostly appearance)\n      const outerColor = this.hslToRgb(0.8, 0.5, 0.5);\n      const coreColor = this.hslToRgb(0.85, 0.3, 0.8);\n\n      g.fillStyle(outerColor, p.alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      g.fillStyle(coreColor, p.alpha * 0.6);\n      g.fillCircle(p.x, p.y, p.size);\n\n      g.fillStyle(COLORS.ghostWhite, p.alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawChaosExplosions(g: Phaser.GameObjects.Graphics): void {\n    for (const exp of this.chaosExplosions) {\n      // Central flash\n      if (exp.life > 0.7) {\n        const flashAlpha = (exp.life - 0.7) * 3;\n        g.fillStyle(0xffffff, flashAlpha * 0.5);\n        g.fillCircle(exp.x, exp.y, exp.radius * 0.5);\n        g.fillStyle(COLORS.chaosYellow, flashAlpha * 0.4);\n        g.fillCircle(exp.x, exp.y, exp.radius);\n      }\n\n      // Expanding rings\n      for (const ring of exp.rings) {\n        g.lineStyle(4, COLORS.chaosRed, ring.alpha * 0.5);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(2, COLORS.chaosOrange, ring.alpha * 0.7);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(1, 0xffffff, ring.alpha * 0.4);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n      }\n\n      // Flying debris\n      for (const d of exp.debris) {\n        g.fillStyle(COLORS.chaosOrange, d.alpha * 0.6);\n        g.fillCircle(d.x, d.y, d.size * 1.3);\n        g.fillStyle(COLORS.chaosYellow, d.alpha * 0.9);\n        g.fillCircle(d.x, d.y, d.size);\n      }\n    }\n  }\n\n  private drawApocalypticSkulls(g: Phaser.GameObjects.Graphics): void {\n    for (const skull of this.apocalypticSkulls) {\n      const pulse = 0.7 + Math.sin(skull.pulsePhase) * 0.3;\n      const alpha = skull.alpha * pulse;\n      const s = skull.size;\n\n      // Ghostly purple glow\n      g.fillStyle(COLORS.witchPurple, alpha * 0.2);\n      g.fillCircle(skull.x, skull.y, s * 1.5);\n\n      // Skull outline (bone white)\n      g.fillStyle(0xcccccc, alpha * 0.8);\n      // Cranium\n      g.fillCircle(skull.x, skull.y - s * 0.1, s * 0.8);\n      // Jaw\n      g.fillRect(skull.x - s * 0.4, skull.y + s * 0.3, s * 0.8, s * 0.4);\n\n      // Eye sockets (glowing green - spooky!)\n      g.fillStyle(COLORS.snakeHead, alpha * 1.2);\n      g.fillCircle(skull.x - s * 0.25, skull.y - s * 0.1, s * 0.2);\n      g.fillCircle(skull.x + s * 0.25, skull.y - s * 0.1, s * 0.2);\n\n      // Nose hole\n      g.fillStyle(0x000000, alpha);\n      g.fillTriangle(\n        skull.x, skull.y + s * 0.1,\n        skull.x - s * 0.1, skull.y + s * 0.25,\n        skull.x + s * 0.1, skull.y + s * 0.25\n      );\n    }\n  }\n\n  private drawChaosOverlay(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (this.chaosIntensity <= 0) return;\n\n    // Purple tint overlay when chaos is active\n    g.fillStyle(COLORS.witchPurple, this.chaosIntensity * 0.1);\n    g.fillRect(0, 0, width, height);\n\n    // Pulsing purple vignette edges\n    const vignetteAlpha = this.chaosIntensity * 0.25;\n    g.lineStyle(80, COLORS.bloodRed, vignetteAlpha);\n    g.strokeRect(-40, -40, width + 80, height + 80);\n  }\n\n  private initGuardianSpirits(): void {\n    this.guardianSpirits = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const spiritHues = [180, 220, 280, 320];\n\n    const edges: ('top' | 'bottom' | 'left' | 'right')[] = ['top', 'bottom', 'left', 'right'];\n    for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      const edge = edges[edgeIndex];\n      for (let i = 0; i < NUM_SPIRITS_PER_EDGE; i++) {\n        let x = 0, y = 0;\n        const offset = (i + 0.5) / NUM_SPIRITS_PER_EDGE;\n\n        switch (edge) {\n          case 'top':\n            x = width * offset;\n            y = -15;\n            break;\n          case 'bottom':\n            x = width * offset;\n            y = height + 15;\n            break;\n          case 'left':\n            x = -15;\n            y = height * offset;\n            break;\n          case 'right':\n            x = width + 15;\n            y = height * offset;\n            break;\n        }\n\n        const orbs: { angle: number; distance: number; size: number; speed: number }[] = [];\n        const numOrbs = 3;\n        for (let o = 0; o < numOrbs; o++) {\n          orbs.push({\n            angle: (o / numOrbs) * Math.PI * 2,\n            distance: 15 + Math.random() * 10,\n            size: 3 + Math.random() * 2,\n            speed: 0.03 + Math.random() * 0.02,\n          });\n        }\n\n        this.guardianSpirits.push({\n          x,\n          y,\n          baseX: x,\n          baseY: y,\n          size: 20 + Math.random() * 10,\n          phase: Math.random() * Math.PI * 2,\n          speed: 0.015 + Math.random() * 0.01,\n          haloPhase: Math.random() * Math.PI * 2,\n          orbPhase: Math.random() * Math.PI * 2,\n          edge,\n          targetAlpha: 0.4 + Math.random() * 0.2,\n          currentAlpha: 0,\n          hue: spiritHues[edgeIndex % spiritHues.length] + Math.random() * 30 - 15,\n          orbs,\n        });\n      }\n    }\n  }\n\n  private initBees(): void {\n    this.bees = [];\n  }\n\n  private initRivalSnake(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    const startX = width - 50 - Math.random() * 50;\n    const startY = height - 50 - Math.random() * 50;\n\n    const segments: { x: number; y: number }[] = [];\n    for (let i = 0; i < RIVAL_SNAKE_LENGTH; i++) {\n      segments.push({\n        x: startX + i * CELL_SIZE * 0.6,\n        y: startY,\n      });\n    }\n\n    this.rivalSnake = {\n      segments,\n      direction: { dx: -1, dy: 0 },\n      targetX: width / 2,\n      targetY: height / 2,\n      moveTimer: 0,\n      moveInterval: RIVAL_MOVE_INTERVAL,\n      pulsePhase: 0,\n      glowIntensity: 0.8,\n      hue: 200,\n      trail: [],\n      energyTrail: [],\n      state: 'hunting',\n      aggression: 0.5,\n      nearMissTimer: 0,\n      electricArcs: [],\n    };\n  }\n\n  private updateRivalSnake(): void {\n    if (!this.rivalSnake || !this.currentState) return;\n\n    const rs = this.rivalSnake;\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    rs.pulsePhase += 0.1;\n    rs.glowIntensity = 0.6 + Math.sin(rs.pulsePhase) * 0.3;\n\n    if (rs.segments.length > 0) {\n      rs.trail.unshift({ x: rs.segments[0].x, y: rs.segments[0].y, alpha: 0.7 });\n      if (rs.trail.length > 20) rs.trail.pop();\n\n      rs.energyTrail.unshift({\n        x: rs.segments[0].x + (Math.random() - 0.5) * 8,\n        y: rs.segments[0].y + (Math.random() - 0.5) * 8,\n        alpha: 0.8,\n        size: 3 + Math.random() * 4\n      });\n      if (rs.energyTrail.length > 30) rs.energyTrail.pop();\n    }\n\n    for (const t of rs.trail) {\n      t.alpha *= 0.92;\n    }\n    rs.trail = rs.trail.filter(t => t.alpha > 0.02);\n\n    for (const e of rs.energyTrail) {\n      e.alpha *= 0.88;\n      e.size *= 0.95;\n    }\n    rs.energyTrail = rs.energyTrail.filter(e => e.alpha > 0.02);\n\n    rs.electricArcs = rs.electricArcs.filter(arc => {\n      arc.life -= 0.15;\n      return arc.life > 0;\n    });\n\n    if (rs.nearMissTimer > 0) rs.nearMissTimer--;\n\n    const playerHead = this.currentState.snake[0];\n    const playerX = playerHead.x * CELL_SIZE + CELL_SIZE / 2;\n    const playerY = playerHead.y * CELL_SIZE + CELL_SIZE / 2;\n    const rivalHead = rs.segments[0];\n    const distToPlayer = Math.sqrt(\n      Math.pow(playerX - rivalHead.x, 2) + Math.pow(playerY - rivalHead.y, 2)\n    );\n\n    if (distToPlayer < 60 && rs.nearMissTimer === 0) {\n      rs.nearMissTimer = 30;\n      rs.electricArcs.push({\n        x1: rivalHead.x,\n        y1: rivalHead.y,\n        x2: playerX,\n        y2: playerY,\n        life: 1.0\n      });\n      rs.aggression = Math.min(1.0, rs.aggression + 0.1);\n    }\n\n    rs.moveTimer++;\n    if (rs.moveTimer >= rs.moveInterval) {\n      rs.moveTimer = 0;\n\n      const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n      const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n      const distToFood = Math.sqrt(\n        Math.pow(foodX - rivalHead.x, 2) + Math.pow(foodY - rivalHead.y, 2)\n      );\n\n      if (distToPlayer < 80) {\n        rs.state = 'fleeing';\n        const fleeAngle = Math.atan2(rivalHead.y - playerY, rivalHead.x - playerX);\n        rs.targetX = rivalHead.x + Math.cos(fleeAngle) * 100;\n        rs.targetY = rivalHead.y + Math.sin(fleeAngle) * 100;\n      } else if (distToFood < 150 || rs.aggression > 0.7) {\n        rs.state = 'hunting';\n        rs.targetX = foodX;\n        rs.targetY = foodY;\n      } else {\n        rs.state = 'circling';\n        const circleAngle = rs.pulsePhase * 0.3;\n        rs.targetX = width / 2 + Math.cos(circleAngle) * 120;\n        rs.targetY = height / 2 + Math.sin(circleAngle) * 120;\n      }\n\n      rs.targetX = Math.max(30, Math.min(width - 30, rs.targetX));\n      rs.targetY = Math.max(30, Math.min(height - 30, rs.targetY));\n\n      const dx = rs.targetX - rivalHead.x;\n      const dy = rs.targetY - rivalHead.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 5) {\n        const targetDx = dx / dist;\n        const targetDy = dy / dist;\n        const turnSpeed = rs.state === 'fleeing' ? 0.5 : 0.35;\n\n        rs.direction.dx = rs.direction.dx * (1 - turnSpeed) + targetDx * turnSpeed;\n        rs.direction.dy = rs.direction.dy * (1 - turnSpeed) + targetDy * turnSpeed;\n\n        const len = Math.sqrt(rs.direction.dx * rs.direction.dx + rs.direction.dy * rs.direction.dy);\n        if (len > 0) {\n          rs.direction.dx /= len;\n          rs.direction.dy /= len;\n        }\n      }\n\n      const moveSpeed = rs.state === 'fleeing' ? CELL_SIZE * 0.7 : CELL_SIZE * 0.55;\n      const newHead = {\n        x: rivalHead.x + rs.direction.dx * moveSpeed,\n        y: rivalHead.y + rs.direction.dy * moveSpeed,\n      };\n\n      if (newHead.x < 10) newHead.x = width - 10;\n      if (newHead.x > width - 10) newHead.x = 10;\n      if (newHead.y < 10) newHead.y = height - 10;\n      if (newHead.y > height - 10) newHead.y = 10;\n\n      rs.segments.unshift(newHead);\n      rs.segments.pop();\n    } else {\n      const head = rs.segments[0];\n      const moveSpeed = CELL_SIZE * 0.5;\n\n      head.x += rs.direction.dx * moveSpeed * 0.06;\n      head.y += rs.direction.dy * moveSpeed * 0.06;\n\n      for (let i = 1; i < rs.segments.length; i++) {\n        const seg = rs.segments[i];\n        const prev = rs.segments[i - 1];\n        const pullStrength = 0.18;\n        seg.x += (prev.x - seg.x) * pullStrength;\n        seg.y += (prev.y - seg.y) * pullStrength;\n      }\n    }\n\n    if (this.currentState.gameOver) {\n      rs.hue = 180;\n      rs.glowIntensity *= 0.95;\n      rs.state = 'circling';\n    } else {\n      rs.hue = rs.state === 'hunting' ? 190 : (rs.state === 'fleeing' ? 220 : 200);\n      rs.hue += Math.sin(rs.pulsePhase * 0.5) * 10;\n    }\n\n    rs.aggression *= 0.998;\n  }\n\n  private drawRivalSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.rivalSnake || this.rivalSnake.segments.length === 0) return;\n\n    const rs = this.rivalSnake;\n    const pulse = rs.glowIntensity;\n\n    for (const arc of rs.electricArcs) {\n      this.drawElectricArc(g, arc.x1, arc.y1, arc.x2, arc.y2, arc.life);\n    }\n\n    for (const e of rs.energyTrail) {\n      g.fillStyle(this.hslToHex(rs.hue + 20, 80, 70), e.alpha * 0.6);\n      g.fillCircle(e.x, e.y, e.size);\n      g.fillStyle(this.hslToHex(rs.hue, 90, 85), e.alpha * 0.3);\n      g.fillCircle(e.x, e.y, e.size * 0.5);\n    }\n\n    for (let i = 0; i < rs.trail.length; i++) {\n      const t = rs.trail[i];\n      const trailSize = 5 * (1 - i / rs.trail.length);\n      g.fillStyle(this.hslToHex(rs.hue, 80, 55), t.alpha * 0.4);\n      g.fillCircle(t.x, t.y, trailSize * 2);\n      g.fillStyle(this.hslToHex(rs.hue + 30, 70, 70), t.alpha * 0.2);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    g.lineStyle(14, this.hslToHex(rs.hue, 70, 40), 0.2 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    g.lineStyle(8, this.hslToHex(rs.hue, 80, 55), 0.35 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    for (let i = rs.segments.length - 1; i >= 0; i--) {\n      const seg = rs.segments[i];\n      const t = rs.segments.length > 1 ? i / (rs.segments.length - 1) : 1;\n      const segmentPulse = pulse * (0.8 + Math.sin(rs.pulsePhase + i * 0.4) * 0.2);\n\n      const baseSize = 7 + t * 5;\n      const size = baseSize * (0.9 + segmentPulse * 0.15);\n\n      g.fillStyle(this.hslToHex(rs.hue - 10, 60, 35), 0.15 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 2.8);\n\n      g.fillStyle(this.hslToHex(rs.hue, 75, 50), 0.3 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 1.6);\n\n      g.fillStyle(this.hslToHex(rs.hue + 10, 85, 65), 0.6 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size);\n\n      g.fillStyle(this.hslToHex(rs.hue + 40, 60, 90), 0.5 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 0.35);\n\n      if (i === 0) {\n        const dx = rs.direction.dx;\n        const dy = rs.direction.dy;\n        const perpX = -dy;\n        const perpY = dx;\n\n        g.fillStyle(this.hslToHex(rs.hue, 90, 70), 0.3);\n        g.fillCircle(seg.x - dx * 3, seg.y - dy * 3, size * 1.8);\n\n        const eyeOffset = 4;\n        const eyeForward = 5;\n        const leftEyeX = seg.x + perpX * eyeOffset + dx * eyeForward;\n        const leftEyeY = seg.y + perpY * eyeOffset + dy * eyeForward;\n        const rightEyeX = seg.x - perpX * eyeOffset + dx * eyeForward;\n        const rightEyeY = seg.y - perpY * eyeOffset + dy * eyeForward;\n\n        const eyeColor = rs.state === 'hunting' ? 0xff4444 :\n                         rs.state === 'fleeing' ? 0xffff44 : 0x44ffff;\n\n        g.fillStyle(0x000000, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 4);\n        g.fillCircle(rightEyeX, rightEyeY, 4);\n\n        g.fillStyle(eyeColor, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 3);\n        g.fillCircle(rightEyeX, rightEyeY, 3);\n\n        g.fillStyle(0xffffff, 0.95 * segmentPulse);\n        g.fillCircle(leftEyeX + dx, leftEyeY + dy, 1.2);\n        g.fillCircle(rightEyeX + dx, rightEyeY + dy, 1.2);\n\n        const hornLength = 8;\n        const hornAngle = 0.4;\n        g.lineStyle(3, this.hslToHex(rs.hue - 20, 70, 45), 0.8 * segmentPulse);\n        g.beginPath();\n        g.moveTo(seg.x + perpX * 5, seg.y + perpY * 5);\n        g.lineTo(\n          seg.x + perpX * 5 + Math.cos(Math.atan2(dy, dx) - hornAngle) * hornLength,\n          seg.y + perpY * 5 + Math.sin(Math.atan2(dy, dx) - hornAngle) * hornLength\n        );\n        g.strokePath();\n        g.beginPath();\n        g.moveTo(seg.x - perpX * 5, seg.y - perpY * 5);\n        g.lineTo(\n          seg.x - perpX * 5 + Math.cos(Math.atan2(dy, dx) + hornAngle) * hornLength,\n          seg.y - perpY * 5 + Math.sin(Math.atan2(dy, dx) + hornAngle) * hornLength\n        );\n        g.strokePath();\n      }\n    }\n  }\n\n  private drawElectricArc(g: Phaser.GameObjects.Graphics, x1: number, y1: number, x2: number, y2: number, life: number): void {\n    const segments = 6;\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n    const jitter = 15 * life;\n\n    g.lineStyle(4, 0x00ffff, 0.2 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter;\n      const jy = (Math.random() - 0.5) * jitter;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(2, 0x88ffff, 0.5 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter * 0.5;\n      const jy = (Math.random() - 0.5) * jitter * 0.5;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(1, 0xffffff, 0.8 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    g.lineTo(x2, y2);\n    g.strokePath();\n  }\n\n  private spawnBee(): void {\n    if (this.bees.length >= NUM_BEES) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Spawn from random edge\n    const edge = Math.floor(Math.random() * 4);\n    let x: number, y: number;\n\n    switch (edge) {\n      case 0: // top\n        x = Math.random() * width;\n        y = -20;\n        break;\n      case 1: // right\n        x = width + 20;\n        y = Math.random() * height;\n        break;\n      case 2: // bottom\n        x = Math.random() * width;\n        y = height + 20;\n        break;\n      default: // left\n        x = -20;\n        y = Math.random() * height;\n        break;\n    }\n\n    // Random target inside the play area\n    const targetX = 50 + Math.random() * (width - 100);\n    const targetY = 50 + Math.random() * (height - 100);\n\n    this.bees.push({\n      x,\n      y,\n      vx: 0,\n      vy: 0,\n      targetX,\n      targetY,\n      wingPhase: Math.random() * Math.PI * 2,\n      wingSpeed: 0.4 + Math.random() * 0.2,\n      size: 6 + Math.random() * 3,\n      hue: 0 + Math.random() * 20, // Crimson/red volcanic color\n      glowIntensity: 0.5 + Math.random() * 0.5,\n      bobPhase: Math.random() * Math.PI * 2,\n      bobSpeed: 0.08 + Math.random() * 0.04,\n      trail: [],\n      state: 'flying',\n      sparkleTimer: 0,\n    });\n  }\n\n  private updateBees(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n    const gameOver = this.currentState.gameOver;\n\n    // Randomly spawn new bees\n    if (!gameOver && Math.random() < BEE_SPAWN_CHANCE && this.bees.length < NUM_BEES) {\n      this.spawnBee();\n    }\n\n    for (let i = this.bees.length - 1; i >= 0; i--) {\n      const bee = this.bees[i];\n\n      // Update wing animation\n      bee.wingPhase += bee.wingSpeed;\n      bee.bobPhase += bee.bobSpeed;\n      bee.sparkleTimer += 0.1;\n\n      // Store trail position\n      if (this.frameCount % 2 === 0) {\n        bee.trail.unshift({ x: bee.x, y: bee.y, alpha: 0.6 });\n        if (bee.trail.length > 8) bee.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of bee.trail) {\n        t.alpha *= 0.85;\n      }\n      bee.trail = bee.trail.filter(t => t.alpha > 0.05);\n\n      // Bees are attracted to food\n      const dxFood = foodX - bee.x;\n      const dyFood = foodY - bee.y;\n      const distFood = Math.sqrt(dxFood * dxFood + dyFood * dyFood);\n\n      // Determine behavior based on distance to food\n      if (distFood < 80) {\n        bee.state = 'attracted';\n        bee.targetX = foodX + Math.cos(bee.bobPhase * 3) * 30;\n        bee.targetY = foodY + Math.sin(bee.bobPhase * 3) * 30;\n      } else if (distFood < 150) {\n        bee.state = 'hovering';\n        // Circle around food loosely\n        const angle = Math.atan2(dyFood, dxFood) + Math.sin(bee.bobPhase) * 0.5;\n        bee.targetX = foodX - Math.cos(angle) * 60;\n        bee.targetY = foodY - Math.sin(angle) * 60;\n      } else {\n        bee.state = 'flying';\n        // Wander towards food with some randomness\n        if (Math.random() < 0.02) {\n          bee.targetX = foodX + (Math.random() - 0.5) * 200;\n          bee.targetY = foodY + (Math.random() - 0.5) * 200;\n        }\n      }\n\n      // Move towards target with smooth steering\n      const dx = bee.targetX - bee.x;\n      const dy = bee.targetY - bee.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 1) {\n        const speed = bee.state === 'attracted' ? 2.5 : (bee.state === 'hovering' ? 1.5 : 2);\n        const ax = (dx / dist) * speed * 0.1;\n        const ay = (dy / dist) * speed * 0.1;\n\n        bee.vx += ax;\n        bee.vy += ay;\n\n        // Add bobbing motion\n        bee.vy += Math.sin(bee.bobPhase) * 0.05;\n      }\n\n      // Limit velocity\n      const maxSpeed = bee.state === 'attracted' ? 3 : 2;\n      const currentSpeed = Math.sqrt(bee.vx * bee.vx + bee.vy * bee.vy);\n      if (currentSpeed > maxSpeed) {\n        bee.vx = (bee.vx / currentSpeed) * maxSpeed;\n        bee.vy = (bee.vy / currentSpeed) * maxSpeed;\n      }\n\n      // Apply velocity with damping\n      bee.x += bee.vx;\n      bee.y += bee.vy;\n      bee.vx *= 0.95;\n      bee.vy *= 0.95;\n\n      // Pulsing glow when near food\n      if (bee.state === 'attracted') {\n        bee.glowIntensity = 0.7 + Math.sin(bee.bobPhase * 4) * 0.3;\n      } else {\n        bee.glowIntensity = 0.5 + Math.sin(bee.bobPhase * 2) * 0.2;\n      }\n\n      // Remove bees that fly too far off screen\n      if (bee.x < -100 || bee.x > width + 100 || bee.y < -100 || bee.y > height + 100) {\n        this.bees.splice(i, 1);\n      }\n\n      // Scatter bees on game over\n      if (gameOver) {\n        bee.targetX = bee.x + (Math.random() - 0.5) * 400;\n        bee.targetY = bee.y - 200 - Math.random() * 200;\n        bee.vx += (Math.random() - 0.5) * 2;\n        bee.vy -= 1 + Math.random();\n      }\n    }\n  }\n\n  private drawBees(g: Phaser.GameObjects.Graphics): void {\n    for (const bee of this.bees) {\n      const { x, y, size, wingPhase, hue, glowIntensity, trail, state, sparkleTimer } = bee;\n\n      // Draw trail\n      for (let i = 0; i < trail.length; i++) {\n        const t = trail[i];\n        const trailSize = size * 0.4 * (1 - i / trail.length);\n        g.fillStyle(this.hslToHex(hue, 80, 60), t.alpha * 0.4);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      const glowSize = size * 2 * glowIntensity;\n      g.fillStyle(this.hslToHex(hue, 90, 50), 0.2 * glowIntensity);\n      g.fillCircle(x, y, glowSize);\n\n      // Mid glow\n      g.fillStyle(this.hslToHex(hue, 85, 60), 0.3 * glowIntensity);\n      g.fillCircle(x, y, glowSize * 0.6);\n\n      // Bee body - striped pattern\n      const bodyLength = size * 1.2;\n      const bodyWidth = size * 0.7;\n\n      // Body shadow/glow\n      g.fillStyle(this.hslToHex(hue, 70, 30), 0.5);\n      g.fillEllipse(x, y, bodyLength + 2, bodyWidth + 2);\n\n      // Main body (amber/golden)\n      g.fillStyle(this.hslToHex(hue, 90, 55), 1);\n      g.fillEllipse(x, y, bodyLength, bodyWidth);\n\n      // Dark stripes\n      g.fillStyle(0x1a1a1a, 0.8);\n      g.fillRect(x - bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n      g.fillRect(x + bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n\n      // Head\n      g.fillStyle(this.hslToHex(hue - 10, 80, 40), 1);\n      g.fillCircle(x - bodyLength * 0.4, y, size * 0.4);\n\n      // Wings - animated flutter\n      const wingAngle = Math.sin(wingPhase) * 0.8;\n      const wingSize = size * 0.9;\n\n      // Wing glow (ethereal effect)\n      g.fillStyle(0xffffff, 0.2 + Math.abs(Math.sin(wingPhase)) * 0.2);\n      g.fillEllipse(x + Math.cos(wingAngle + 0.5) * wingSize * 0.3, y - wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n      g.fillEllipse(x + Math.cos(-wingAngle + 0.5) * wingSize * 0.3, y + wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n\n      // Wing bodies\n      g.fillStyle(0xffffff, 0.5 + Math.abs(Math.sin(wingPhase)) * 0.3);\n      g.fillEllipse(x + Math.cos(wingAngle) * wingSize * 0.2, y - wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n      g.fillEllipse(x + Math.cos(-wingAngle) * wingSize * 0.2, y + wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n\n      // Eyes\n      g.fillStyle(0x000000, 1);\n      g.fillCircle(x - bodyLength * 0.45, y - size * 0.12, size * 0.12);\n      g.fillCircle(x - bodyLength * 0.45, y + size * 0.12, size * 0.12);\n\n      // Sparkles when attracted to food\n      if (state === 'attracted' && Math.sin(sparkleTimer * 3) > 0.7) {\n        const sparkleAngle = sparkleTimer * 2;\n        const sparkleDist = size * 1.5;\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n\n        g.fillStyle(0xffffff, 0.8);\n        g.fillCircle(sparkleX, sparkleY, 2);\n        g.fillStyle(this.hslToHex(hue, 100, 80), 0.6);\n        g.fillCircle(sparkleX, sparkleY, 3);\n      }\n    }\n  }\n\n  // Helper to convert HSL to hex for Phaser\n  private hslToHex(h: number, s: number, l: number): number {\n    h = h / 360;\n    s = s / 100;\n    l = l / 100;\n\n    let r: number, g: number, b: number;\n\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    return (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255);\n  }\n\n  private updateGuardianSpirits(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const gameOver = this.currentState.gameOver;\n    const snakeHead = this.currentState.snake.length > 0 ? this.currentState.snake[0] : null;\n\n    for (const spirit of this.guardianSpirits) {\n      spirit.phase += spirit.speed;\n      spirit.haloPhase += 0.04;\n      spirit.orbPhase += 0.02;\n\n      for (const orb of spirit.orbs) {\n        orb.angle += orb.speed;\n      }\n\n      const floatAmount = gameOver ? 20 : 12;\n      const waveAmount = 5;\n      const wave = Math.sin(spirit.phase) * waveAmount;\n\n      let targetX = spirit.baseX;\n      let targetY = spirit.baseY;\n\n      switch (spirit.edge) {\n        case 'top':\n          targetY = spirit.baseY + floatAmount + wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'bottom':\n          targetY = spirit.baseY - floatAmount - wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'left':\n          targetX = spirit.baseX + floatAmount + wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'right':\n          targetX = spirit.baseX - floatAmount - wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n      }\n\n      if (snakeHead && !gameOver) {\n        const headX = snakeHead.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = snakeHead.y * CELL_SIZE + CELL_SIZE / 2;\n        const dx = spirit.x - headX;\n        const dy = spirit.y - headY;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        if (dist < 120) {\n          const attraction = (120 - dist) / 120 * 15;\n          targetX += (dx / dist) * attraction;\n          targetY += (dy / dist) * attraction;\n        }\n      }\n\n      spirit.x += (targetX - spirit.x) * 0.04;\n      spirit.y += (targetY - spirit.y) * 0.04;\n      spirit.x = Math.max(-50, Math.min(width + 50, spirit.x));\n      spirit.y = Math.max(-50, Math.min(height + 50, spirit.y));\n\n      const baseAlpha = gameOver ? 0.8 : spirit.targetAlpha;\n      spirit.currentAlpha += (baseAlpha - spirit.currentAlpha) * 0.05;\n    }\n  }\n\n  private drawGuardianSpirits(g: Phaser.GameObjects.Graphics): void {\n    for (const spirit of this.guardianSpirits) {\n      if (spirit.currentAlpha < 0.01) continue;\n\n      const { x, y, size, phase, haloPhase, currentAlpha, hue, orbs } = spirit;\n      const breathPulse = 1 + Math.sin(phase * 2) * 0.15;\n      const coreSize = size * breathPulse;\n\n      const spiritColor = this.hslToHex(hue, 0.7, 0.6);\n      const glowColor = this.hslToHex(hue, 0.5, 0.8);\n      const haloColor = this.hslToHex(hue, 0.3, 0.9);\n\n      g.fillStyle(glowColor, currentAlpha * 0.1);\n      g.fillCircle(x, y, coreSize * 2.5);\n\n      g.fillStyle(glowColor, currentAlpha * 0.15);\n      g.fillCircle(x, y, coreSize * 1.8);\n\n      const haloRadius = coreSize * 1.4 + Math.sin(haloPhase) * 3;\n      g.lineStyle(2, haloColor, currentAlpha * 0.4);\n      g.strokeCircle(x, y, haloRadius);\n\n      const innerHaloRadius = coreSize * 1.1 + Math.sin(haloPhase + 1) * 2;\n      g.lineStyle(1.5, haloColor, currentAlpha * 0.3);\n      g.strokeCircle(x, y, innerHaloRadius);\n\n      for (const orb of orbs) {\n        const orbX = x + Math.cos(orb.angle) * orb.distance;\n        const orbY = y + Math.sin(orb.angle) * orb.distance;\n        const orbPulse = 1 + Math.sin(phase + orb.angle) * 0.3;\n\n        g.fillStyle(glowColor, currentAlpha * 0.3);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse * 1.5);\n\n        g.fillStyle(spiritColor, currentAlpha * 0.8);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse);\n      }\n\n      g.fillStyle(spiritColor, currentAlpha * 0.9);\n      g.fillCircle(x, y, coreSize * 0.5);\n\n      g.fillStyle(0xffffff, currentAlpha * 0.7);\n      g.fillCircle(x, y, coreSize * 0.25);\n\n      const sparkleCount = 4;\n      for (let i = 0; i < sparkleCount; i++) {\n        const sparkleAngle = (i / sparkleCount) * Math.PI * 2 + phase * 0.5;\n        const sparkleDist = coreSize * (0.8 + Math.sin(phase * 2 + i) * 0.3);\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n        const sparkleSize = 1.5 + Math.sin(phase * 3 + i * 2) * 0.5;\n\n        g.fillStyle(0xffffff, currentAlpha * (0.4 + Math.sin(phase * 2 + i) * 0.3));\n        g.fillCircle(sparkleX, sparkleY, sparkleSize);\n      }\n    }\n  }\n\n  private initStars(): void {\n    this.stars = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_STARS; i++) {\n      this.stars.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: 0.5 + Math.random() * 1.5,\n        speed: 0.02 + Math.random() * 0.03,\n        brightness: 0.3 + Math.random() * 0.7,\n      });\n    }\n  }\n\n  private initPlasmaWaves(): void {\n    this.plasmaWaves = [];\n    const hues = [0, 15, 30]; // Red/orange volcanic variations\n    for (let i = 0; i < NUM_PLASMA_WAVES; i++) {\n      this.plasmaWaves.push({\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.015 + Math.random() * 0.01,\n        amplitude: 30 + Math.random() * 20,\n        wavelength: 80 + Math.random() * 40,\n        hue: hues[i % hues.length],\n      });\n    }\n  }\n\n  private initAuroraWaves(): void {\n    this.auroraWaves = [];\n    const height = GRID_SIZE * CELL_SIZE;\n    // Aurora hues: volcanic reds, oranges, crimsons\n    const auroraHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_AURORA_WAVES; i++) {\n      this.auroraWaves.push({\n        y: height * 0.2 + (height * 0.6 * i) / NUM_AURORA_WAVES,\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.008 + Math.random() * 0.006,\n        hue: auroraHues[i % auroraHues.length],\n        thickness: 25 + Math.random() * 20,\n        amplitude: 15 + Math.random() * 25,\n      });\n    }\n  }\n\n  private initNebulaClouds(): void {\n    this.nebulaClouds = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    // Volcanic smoke and lava glow colors: reds, oranges, crimsons\n    const nebulaHues = [0, 10, 20, 30, 350, 340];\n    for (let i = 0; i < NUM_NEBULA_CLOUDS; i++) {\n      this.nebulaClouds.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        radius: 40 + Math.random() * 60,\n        hue: nebulaHues[i % nebulaHues.length],\n        alpha: 0.04 + Math.random() * 0.04,\n        driftX: (Math.random() - 0.5) * 0.15,\n        driftY: (Math.random() - 0.5) * 0.15,\n        pulsePhase: Math.random() * Math.PI * 2,\n        pulseSpeed: 0.01 + Math.random() * 0.01,\n      });\n    }\n  }\n\n  private initVortex(): void {\n    this.vortexRings = [];\n    this.vortexParticles = [];\n\n    // Create concentric rings with different properties\n    const ringHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_VORTEX_RINGS; i++) {\n      const baseRadius = 25 + i * 18;\n      this.vortexRings.push({\n        radius: baseRadius,\n        baseRadius,\n        rotationOffset: (i * Math.PI * 2) / NUM_VORTEX_RINGS,\n        rotationSpeed: 0.02 - i * 0.003,\n        thickness: 2 + (NUM_VORTEX_RINGS - i) * 0.5,\n        hue: ringHues[i % ringHues.length],\n        pulsePhase: i * 0.5,\n      });\n    }\n\n    // Create orbiting particles\n    for (let i = 0; i < NUM_VORTEX_PARTICLES; i++) {\n      const baseRadius = 20 + Math.random() * 80;\n      this.vortexParticles.push({\n        angle: Math.random() * Math.PI * 2,\n        radius: baseRadius,\n        baseRadius,\n        speed: 0.02 + Math.random() * 0.03,\n        size: 1 + Math.random() * 2,\n        hue: Math.random() * 360,\n        alpha: 0.3 + Math.random() * 0.5,\n      });\n    }\n  }\n\n  private initMeteors(): void {\n    this.meteors = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_METEORS; i++) {\n      this.spawnMeteor(width, height, true);\n    }\n  }\n\n  private spawnMeteor(width: number, height: number, initial = false): void {\n    if (this.meteors.length >= NUM_METEORS) return;\n\n    // Meteors come from top-right and travel to bottom-left\n    const startX = initial ? Math.random() * width * 1.5 : width + 20 + Math.random() * 40;\n    const startY = initial ? Math.random() * height * 0.5 - height * 0.25 : -20 - Math.random() * 40;\n\n    // Random angle variation (mostly diagonal)\n    const angle = Math.PI * 0.65 + (Math.random() - 0.5) * 0.4;\n    const speed = 1.5 + Math.random() * 2;\n\n    this.meteors.push({\n      x: startX,\n      y: startY,\n      vx: -Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed,\n      size: 2 + Math.random() * 3,\n      hue: Math.random() < 0.3 ? 0 + Math.random() * 30 : 20 + Math.random() * 40, // Red or orange volcanic\n      alpha: 0.6 + Math.random() * 0.4,\n      trail: [],\n      life: 1,\n    });\n  }\n\n  private updateMeteors(width: number, height: number): void {\n    for (let i = this.meteors.length - 1; i >= 0; i--) {\n      const m = this.meteors[i];\n\n      // Store trail position\n      m.trail.unshift({ x: m.x, y: m.y, alpha: m.alpha });\n      if (m.trail.length > 12) m.trail.pop();\n\n      // Update position\n      m.x += m.vx;\n      m.y += m.vy;\n\n      // Check if meteor is out of bounds\n      if (m.x < -50 || m.y > height + 50) {\n        this.meteors.splice(i, 1);\n        // Spawn a new one\n        this.spawnMeteor(width, height, false);\n      }\n    }\n  }\n\n  private spawnDeathExplosion(): void {\n    if (!this.currentState) return;\n\n    this.deathDebris = [];\n    this.deathExplosionPhase = 1;\n\n    // Spawn debris from each snake segment\n    for (let i = 0; i < this.currentState.snake.length; i++) {\n      const seg = this.currentState.snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const segHue = (this.hueOffset + i * 15) % 360;\n\n      // Create debris particles per segment (limit total)\n      const debrisPerSeg = Math.min(3, Math.floor(MAX_DEATH_DEBRIS / this.currentState.snake.length));\n      for (let j = 0; j < debrisPerSeg; j++) {\n        if (this.deathDebris.length >= MAX_DEATH_DEBRIS) break;\n\n        const angle = Math.random() * Math.PI * 2;\n        const speed = 2 + Math.random() * 4;\n        const types: ('shard' | 'spark' | 'ember')[] = ['shard', 'spark', 'ember'];\n\n        this.deathDebris.push({\n          x: cx + (Math.random() - 0.5) * 8,\n          y: cy + (Math.random() - 0.5) * 8,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed - 1,\n          size: 3 + Math.random() * 5,\n          hue: segHue + (Math.random() - 0.5) * 40,\n          rotation: Math.random() * Math.PI * 2,\n          rotationSpeed: (Math.random() - 0.5) * 0.4,\n          life: 1,\n          type: types[Math.floor(Math.random() * types.length)],\n        });\n      }\n    }\n  }\n\n  private updateDeathDebris(): void {\n    // Decay explosion phase\n    if (this.deathExplosionPhase > 0) {\n      this.deathExplosionPhase *= 0.95;\n      if (this.deathExplosionPhase < 0.01) this.deathExplosionPhase = 0;\n    }\n\n    for (let i = this.deathDebris.length - 1; i >= 0; i--) {\n      const d = this.deathDebris[i];\n\n      // Update position with gravity\n      d.x += d.vx;\n      d.y += d.vy;\n      d.vy += 0.08; // gravity\n      d.vx *= 0.99; // air resistance\n\n      // Update rotation\n      d.rotation += d.rotationSpeed;\n\n      // Decay life\n      d.life -= 0.015;\n\n      if (d.life <= 0) {\n        this.deathDebris.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnFoodParticles(foodX: number, foodY: number): void {\n    if (this.foodParticles.length < MAX_FOOD_PARTICLES && Math.random() < 0.15) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.3 + Math.random() * 0.5;\n      this.foodParticles.push({\n        x: foodX,\n        y: foodY,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 0.5,\n        life: 1,\n        maxLife: 40 + Math.random() * 20,\n        size: 1 + Math.random() * 2,\n      });\n    }\n  }\n\n  private updateParticles(): void {\n    for (let i = this.foodParticles.length - 1; i >= 0; i--) {\n      const p = this.foodParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy += 0.02;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.foodParticles.splice(i, 1);\n      }\n    }\n    // Update trail particles\n    for (let i = this.trailParticles.length - 1; i >= 0; i--) {\n      const p = this.trailParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.trailParticles.splice(i, 1);\n      }\n    }\n    // Update shockwaves\n    for (let i = this.shockWaves.length - 1; i >= 0; i--) {\n      const sw = this.shockWaves[i];\n      sw.radius += 3;\n      sw.life -= 0.04;\n      if (sw.life <= 0 || sw.radius >= sw.maxRadius) {\n        this.shockWaves.splice(i, 1);\n      }\n    }\n    // Update lightning bolts\n    for (let i = this.lightningBolts.length - 1; i >= 0; i--) {\n      const bolt = this.lightningBolts[i];\n      bolt.life -= 1 / bolt.maxLife;\n      if (bolt.life <= 0) {\n        this.lightningBolts.splice(i, 1);\n      }\n    }\n    // Update afterimages\n    for (let i = this.snakeAfterimages.length - 1; i >= 0; i--) {\n      const ai = this.snakeAfterimages[i];\n      ai.life -= 1 / ai.maxLife;\n      if (ai.life <= 0) {\n        this.snakeAfterimages.splice(i, 1);\n      }\n    }\n    // Decay screen flash\n    if (this.screenFlashAlpha > 0) {\n      this.screenFlashAlpha -= 0.08;\n      if (this.screenFlashAlpha < 0) this.screenFlashAlpha = 0;\n    }\n\n    // Update screen shake\n    if (this.screenShakeIntensity > 0) {\n      this.screenShakeX = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeY = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeIntensity *= 0.9;\n      if (this.screenShakeIntensity < 0.5) {\n        this.screenShakeIntensity = 0;\n        this.screenShakeX = 0;\n        this.screenShakeY = 0;\n      }\n    }\n\n    // Decay chromatic aberration\n    if (this.chromaticIntensity > 0) {\n      this.chromaticIntensity *= 0.92;\n      if (this.chromaticIntensity < 0.05) this.chromaticIntensity = 0;\n    }\n\n    // Decay energy field pulse\n    if (this.energyFieldPulse > 0) {\n      this.energyFieldPulse *= 0.95;\n      if (this.energyFieldPulse < 0.05) this.energyFieldPulse = 0;\n    }\n\n    // Update food burst particles\n    for (let i = this.foodBurstParticles.length - 1; i >= 0; i--) {\n      const p = this.foodBurstParticles[i];\n      // Store trail position\n      p.trail.unshift({ x: p.x, y: p.y });\n      if (p.trail.length > 6) p.trail.pop();\n      // Update position\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vx *= 0.96;\n      p.vy *= 0.96;\n      p.life -= 0.025;\n      if (p.life <= 0) {\n        this.foodBurstParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnTrailParticles(x: number, y: number): void {\n    if (this.trailParticles.length >= MAX_TRAIL_PARTICLES) return;\n    // Spawn 2-3 particles per movement\n    const count = 2 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < count; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.2 + Math.random() * 0.4;\n      this.trailParticles.push({\n        x: x + (Math.random() - 0.5) * 8,\n        y: y + (Math.random() - 0.5) * 8,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        maxLife: 25 + Math.random() * 15,\n        size: 2 + Math.random() * 3,\n        hue: this.hueOffset + Math.random() * 30,\n      });\n    }\n  }\n\n  updateGameState(state: GameState): void {\n    // Detect food eaten - snake got longer\n    if (this.currentState && state.snake.length > this.lastSnakeLength) {\n      const head = state.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n      this.spawnShockWave(headX, headY);\n      this.spawnLightningBurst(headX, headY);\n      this.spawnFoodBurst(headX, headY);\n      this.spawnChaosExplosion(headX, headY); // Armageddon chaos explosion\n      this.screenFlashAlpha = 0.8; // More intense flash for armageddon\n      this.chromaticIntensity = 1.5; // Stronger chromatic aberration\n      this.energyFieldPulse = 1.0; // Trigger energy field expansion\n    }\n    this.lastSnakeLength = state.snake.length;\n\n    // Detect food position change - trigger thrown food animation\n    const newFood = state.food;\n    if (this.lastFoodPos && (newFood.x !== this.lastFoodPos.x || newFood.y !== this.lastFoodPos.y)) {\n      this.spawnThrownFood(newFood.x, newFood.y);\n    } else if (!this.lastFoodPos && !state.gameOver) {\n      // First food spawn\n      this.spawnThrownFood(newFood.x, newFood.y);\n    }\n    this.lastFoodPos = { x: newFood.x, y: newFood.y };\n\n    // Create afterimage when snake moves\n    if (this.currentState && state.snake.length > 0) {\n      const oldHead = this.currentState.snake[0];\n      const newHead = state.snake[0];\n      if (oldHead && newHead && (oldHead.x !== newHead.x || oldHead.y !== newHead.y)) {\n        this.spawnAfterimage(this.currentState.snake);\n      }\n    }\n\n    // Detect game over transition - ARMAGEDDON CHAOS death sequence\n    if (state.gameOver && this.currentState && !this.currentState.gameOver) {\n      this.screenShakeIntensity = 25; // Massive screen shake on death\n      this.chromaticIntensity = 3.0; // Maximum chromatic aberration on death\n      this.chaosIntensity = 1.0; // Full chaos overlay\n      this.spawnDeathExplosion(); // Dramatic death explosion\n      // Spawn chaos explosions across the snake body\n      for (let i = 0; i < Math.min(3, state.snake.length); i++) {\n        const seg = state.snake[Math.floor(i * state.snake.length / 3)];\n        setTimeout(() => {\n          this.spawnChaosExplosion(\n            seg.x * CELL_SIZE + CELL_SIZE / 2,\n            seg.y * CELL_SIZE + CELL_SIZE / 2\n          );\n        }, i * 50);\n      }\n    }\n\n    this.currentState = state;\n    this.needsRedraw = true;\n    if (!state.gameOver) {\n      this.gameOverAlpha = 0;\n      this.gameOverGlitchOffset = 0;\n      this.screenShakeIntensity = 0;\n    }\n  }\n\n  private spawnShockWave(x: number, y: number): void {\n    if (this.shockWaves.length >= MAX_SHOCKWAVES) {\n      this.shockWaves.shift();\n    }\n    this.shockWaves.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: CELL_SIZE * 3,\n      life: 1,\n    });\n  }\n\n  private spawnAfterimage(snake: Position[]): void {\n    if (this.snakeAfterimages.length >= MAX_AFTERIMAGES) {\n      this.snakeAfterimages.shift();\n    }\n    this.snakeAfterimages.push({\n      segments: snake.map(s => ({ x: s.x, y: s.y })),\n      life: 1,\n      maxLife: 12,\n      hueOffset: this.hueOffset,\n    });\n  }\n\n  private spawnLightningBurst(x: number, y: number): void {\n    const numBolts = 3 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < numBolts; i++) {\n      if (this.lightningBolts.length >= MAX_LIGHTNING_BOLTS) {\n        this.lightningBolts.shift();\n      }\n      const angle = (Math.PI * 2 * i) / numBolts + Math.random() * 0.5;\n      const length = 30 + Math.random() * 40;\n      const endX = x + Math.cos(angle) * length;\n      const endY = y + Math.sin(angle) * length;\n      this.lightningBolts.push({\n        points: this.generateLightningPath(x, y, endX, endY),\n        life: 1,\n        maxLife: 15 + Math.random() * 10,\n        hue: this.hueOffset + Math.random() * 60,\n      });\n    }\n  }\n\n  private generateLightningPath(x1: number, y1: number, x2: number, y2: number): { x: number; y: number }[] {\n    const points: { x: number; y: number }[] = [{ x: x1, y: y1 }];\n    const segments = 4 + Math.floor(Math.random() * 3);\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n\n    for (let i = 1; i < segments; i++) {\n      const jitter = 8;\n      points.push({\n        x: x1 + dx * i + (Math.random() - 0.5) * jitter,\n        y: y1 + dy * i + (Math.random() - 0.5) * jitter,\n      });\n    }\n    points.push({ x: x2, y: y2 });\n    return points;\n  }\n\n  private spawnFoodBurst(x: number, y: number): void {\n    // Clear old particles and spawn new dramatic burst\n    this.foodBurstParticles = [];\n    const numParticles = MAX_BURST_PARTICLES;\n    for (let i = 0; i < numParticles; i++) {\n      const angle = (i / numParticles) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 4;\n      this.foodBurstParticles.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        size: 3 + Math.random() * 4,\n        hue: this.hueOffset + Math.random() * 60,\n        trail: [],\n      });\n    }\n  }\n\n  private spawnThrownFood(targetGridX: number, targetGridY: number): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const targetX = targetGridX * CELL_SIZE + CELL_SIZE / 2;\n    const targetY = targetGridY * CELL_SIZE + CELL_SIZE / 2;\n\n    // Choose random edge to throw from\n    const edge = Math.floor(Math.random() * 4);\n    let startX: number, startY: number;\n\n    switch (edge) {\n      case 0: // top\n        startX = Math.random() * width;\n        startY = -40;\n        break;\n      case 1: // right\n        startX = width + 40;\n        startY = Math.random() * height;\n        break;\n      case 2: // bottom\n        startX = Math.random() * width;\n        startY = height + 40;\n        break;\n      default: // left\n        startX = -40;\n        startY = Math.random() * height;\n        break;\n    }\n\n    this.thrownFood = {\n      startX,\n      startY,\n      targetX,\n      targetY,\n      x: startX,\n      y: startY,\n      progress: 0,\n      rotation: 0,\n      rotationSpeed: (Math.random() - 0.5) * 0.6,\n      trail: [],\n      landed: false,\n      landingParticles: [],\n      impactRings: [],\n    };\n  }\n\n  private updateThrownFood(): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    if (!tf.landed) {\n      // Update progress\n      tf.progress += 0.04;\n\n      // Store trail\n      if (this.frameCount % 2 === 0) {\n        tf.trail.unshift({ x: tf.x, y: tf.y, alpha: 1, rotation: tf.rotation });\n        if (tf.trail.length > 12) tf.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.85;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Calculate position with parabolic arc\n      const t = tf.progress;\n      const arcHeight = 80;\n      const arc = 4 * arcHeight * t * (1 - t);\n      tf.x = tf.startX + (tf.targetX - tf.startX) * t;\n      tf.y = tf.startY + (tf.targetY - tf.startY) * t - arc;\n\n      // Rotation\n      tf.rotation += tf.rotationSpeed;\n\n      // Check if landed\n      if (tf.progress >= 1) {\n        tf.landed = true;\n        tf.x = tf.targetX;\n        tf.y = tf.targetY;\n\n        // Spawn landing effects\n        this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 6);\n\n        // Impact rings\n        tf.impactRings = [\n          { radius: 5, alpha: 1 },\n          { radius: 3, alpha: 0.8 },\n        ];\n\n        // Landing particles\n        for (let i = 0; i < 10; i++) {\n          const angle = (i / 10) * Math.PI * 2 + Math.random() * 0.3;\n          const speed = 2 + Math.random() * 3;\n          tf.landingParticles.push({\n            x: tf.targetX,\n            y: tf.targetY,\n            vx: Math.cos(angle) * speed,\n            vy: Math.sin(angle) * speed - 1,\n            life: 1,\n            size: 2 + Math.random() * 3,\n          });\n        }\n      }\n    } else {\n      // Update landing effects\n      for (const ring of tf.impactRings) {\n        ring.radius += 3;\n        ring.alpha *= 0.9;\n      }\n      tf.impactRings = tf.impactRings.filter(r => r.alpha > 0.05);\n\n      for (let i = tf.landingParticles.length - 1; i >= 0; i--) {\n        const p = tf.landingParticles[i];\n        p.x += p.vx;\n        p.y += p.vy;\n        p.vy += 0.15;\n        p.vx *= 0.98;\n        p.life -= 0.04;\n        if (p.life <= 0) {\n          tf.landingParticles.splice(i, 1);\n        }\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.8;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Clear thrown food when effects are done\n      if (tf.impactRings.length === 0 && tf.landingParticles.length === 0 && tf.trail.length === 0) {\n        this.thrownFood = null;\n      }\n    }\n  }\n\n  private drawThrownFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    // Draw trail\n    for (let i = 0; i < tf.trail.length; i++) {\n      const t = tf.trail[i];\n      const trailProgress = i / tf.trail.length;\n      const trailSize = (CELL_SIZE / 2) * (1 - trailProgress * 0.5) * t.alpha;\n\n      // Trail glow\n      g.fillStyle(COLORS.foodGlow, t.alpha * 0.3);\n      g.fillCircle(t.x, t.y, trailSize * 1.5);\n\n      // Trail core\n      g.fillStyle(COLORS.food, t.alpha * 0.6);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    // Draw impact rings\n    for (const ring of tf.impactRings) {\n      g.lineStyle(3, COLORS.foodGlow, ring.alpha * 0.5);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n      g.lineStyle(1.5, COLORS.noirWhite, ring.alpha * 0.7);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n    }\n\n    // Draw landing particles\n    for (const p of tf.landingParticles) {\n      g.fillStyle(COLORS.foodGlow, p.life * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Draw the flying food if not landed\n    if (!tf.landed) {\n      const scale = 0.8 + tf.progress * 0.4;\n      const foodSize = (CELL_SIZE / 2) * scale;\n\n      // Motion blur glow\n      g.fillStyle(COLORS.foodGlow, 0.3);\n      g.fillCircle(tf.x, tf.y, foodSize * 2);\n\n      // Outer glow\n      g.fillStyle(COLORS.noirWhite, 0.4);\n      g.fillCircle(tf.x, tf.y, foodSize * 1.5);\n\n      // Main food body\n      g.fillStyle(COLORS.food, 0.95);\n      g.fillCircle(tf.x, tf.y, foodSize);\n\n      // Spinning highlight\n      const highlightAngle = tf.rotation;\n      const highlightX = tf.x + Math.cos(highlightAngle) * foodSize * 0.3;\n      const highlightY = tf.y + Math.sin(highlightAngle) * foodSize * 0.3;\n      g.fillStyle(0xffffff, 0.9);\n      g.fillCircle(highlightX, highlightY, foodSize * 0.25);\n\n      // Secondary sparkle\n      const sparkleAngle = tf.rotation + Math.PI * 0.7;\n      const sparkleX = tf.x + Math.cos(sparkleAngle) * foodSize * 0.4;\n      const sparkleY = tf.y + Math.sin(sparkleAngle) * foodSize * 0.4;\n      g.fillStyle(0xffffff, 0.6);\n      g.fillCircle(sparkleX, sparkleY, foodSize * 0.15);\n    }\n  }\n\n  update(): void {\n    this.frameCount++;\n    this.cleanEffects.frameCount = this.frameCount;\n\n    const width = this.scale.width;\n    const height = this.scale.height;\n\n    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n\n    if (this.currentState && this.currentState.snake.length > 0) {\n      const head = this.currentState.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n        updateGlowTrail(this.cleanEffects, headX, headY);\n      }\n      this.lastHeadPos = { x: head.x, y: head.y };\n\n      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n        const food = this.currentState.food;\n        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnRipple(this.cleanEffects, foodX, foodY);\n      }\n      this.lastSnakeLength = this.currentState.snake.length;\n    }\n\n    const g = this.graphics;\n    g.clear();\n    g.setPosition(0, 0);\n\n    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n\n    if (!this.currentState) return;\n\n    drawGlowTrail(g, this.cleanEffects);\n    drawRipples(g, this.cleanEffects);\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n\n    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawCleanVignette(g, width, height);\n\n    const score = this.currentState.score || 0;\n    const snakeLength = this.currentState.snake.length;\n    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n\n    if (this.currentState.gameOver) {\n      this.drawGameOver(g, width, height);\n      this.drawScoreboard(g, width, height);\n    }\n\n    this.checkAndSaveHighScore();\n    this.needsRedraw = false;\n  }\n\n  private drawStars(g: Phaser.GameObjects.Graphics): void {\n    // In film noir mode, stars are subtle distant lights\n    for (const star of this.stars) {\n      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n      const alpha = star.brightness * twinkle * 0.25;\n      g.fillStyle(COLORS.star, alpha);\n      g.fillCircle(star.x, star.y, star.size * 0.7);\n    }\n  }\n\n  private updateSmokeParticles(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (const smoke of this.smokeParticles) {\n      smoke.x += smoke.vx;\n      smoke.y += smoke.vy;\n      smoke.life -= 0.002;\n      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n        smoke.x = Math.random() * width;\n        smoke.y = height + smoke.size;\n        smoke.life = 1;\n        smoke.size = 30 + Math.random() * 50;\n        smoke.alpha = 0.02 + Math.random() * 0.03;\n      }\n      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n    }\n  }\n\n  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Create dramatic spotlight effect centered on snake\n    const cx = this.spotlightX || width / 2;\n    const cy = this.spotlightY || height / 2;\n    const pulse = 0.9 + Math.sin(this.frameCount * 0.03) * 0.1;\n\n    // Outer darkness vignette\n    g.fillStyle(0x000000, 0.6);\n    g.fillRect(0, 0, width, height);\n\n    // Spotlight cone - multiple layers for smooth falloff\n    const layers = 4;\n    for (let i = layers; i > 0; i--) {\n      const layerRadius = (width * 0.4 + i * 30) * pulse;\n      const layerAlpha = 0.15 * (1 - i / (layers + 1));\n      g.fillStyle(COLORS.spotlight, layerAlpha);\n      g.fillCircle(cx, cy, layerRadius);\n    }\n\n    // Bright center\n    g.fillStyle(COLORS.noirWhite, 0.08 * pulse);\n    g.fillCircle(cx, cy, width * 0.25);\n  }\n\n  private drawVenetianBlinds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Horizontal light streaks simulating light through venetian blinds\n    const blindSpacing = 25;\n    const blindWidth = 8;\n    const waveOffset = Math.sin(this.venetianPhase) * 10;\n\n    for (let y = waveOffset; y < height; y += blindSpacing) {\n      const brightness = 0.03 + Math.sin(y * 0.02 + this.venetianPhase * 2) * 0.015;\n      g.fillStyle(COLORS.noirWhite, brightness);\n      g.fillRect(0, y, width, blindWidth);\n    }\n\n    // Diagonal shadow bars from window frame\n    const diagonalAlpha = 0.04 + Math.sin(this.frameCount * 0.02) * 0.01;\n    g.fillStyle(0x000000, diagonalAlpha);\n    for (let i = -2; i < 6; i++) {\n      const x1 = i * 100 + Math.sin(this.venetianPhase) * 20;\n      g.beginPath();\n      g.moveTo(x1, 0);\n      g.lineTo(x1 + 40, 0);\n      g.lineTo(x1 + 40 + height * 0.3, height);\n      g.lineTo(x1 + height * 0.3, height);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawSmoke(g: Phaser.GameObjects.Graphics): void {\n    for (const smoke of this.smokeParticles) {\n      const alpha = smoke.alpha * smoke.life;\n      g.fillStyle(COLORS.noirGray, alpha);\n      g.fillCircle(smoke.x, smoke.y, smoke.size);\n      g.fillStyle(COLORS.noirWhite, alpha * 0.3);\n      g.fillCircle(smoke.x, smoke.y, smoke.size * 0.5);\n    }\n  }\n\n  private spawnFlameParticle(x: number, y: number, intensity: number): void {\n    if (this.flameParticles.length >= MAX_FLAME_PARTICLES) {\n      this.flameParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.6;\n    const life = 0.5 + Math.random() * 0.5;\n\n    this.flameParticles.push({\n      x: x + (Math.random() - 0.5) * 6,\n      y: y + (Math.random() - 0.5) * 6,\n      vx: Math.cos(angle) * speed * 0.3,\n      vy: -0.5 - Math.random() * 1.5 * intensity,\n      size: 3 + Math.random() * 4 * intensity,\n      life,\n      maxLife: life,\n      hue: 10 + Math.random() * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n    });\n  }\n\n  private updateFlameParticles(): void {\n    for (let i = this.flameParticles.length - 1; i >= 0; i--) {\n      const p = this.flameParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.02;\n      p.vx *= 0.98;\n      p.size *= 0.97;\n      p.life -= 0.025;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.flameParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private drawFlameParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.flameParticles) {\n      const lifeRatio = p.life / p.maxLife;\n\n      // Hue shifts from yellow-orange (high life) to red (low life)\n      const hue = p.hue - (1 - lifeRatio) * 15;\n      const outerColor = this.hslToRgb(hue / 360, 1, 0.3 + lifeRatio * 0.2);\n      const midColor = this.hslToRgb(hue / 360, 1, 0.5 + lifeRatio * 0.2);\n      const coreColor = this.hslToRgb((hue + 20) / 360, 0.7, 0.7 + lifeRatio * 0.2);\n\n      // Outer glow\n      g.fillStyle(outerColor, lifeRatio * 0.3);\n      g.fillCircle(p.x, p.y, p.size * 2);\n\n      // Mid flame\n      g.fillStyle(midColor, lifeRatio * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3);\n\n      // Core (bright yellow/white)\n      g.fillStyle(coreColor, lifeRatio * 0.8);\n      g.fillCircle(p.x, p.y, p.size * 0.6);\n    }\n  }\n\n  private spawnFlamesAlongSnake(): void {\n    if (!this.currentState || this.currentState.gameOver) return;\n\n    const snake = this.currentState.snake;\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const segX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const segY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const intensity = 1 - (i / snake.length) * 0.6;\n      if (Math.random() < 0.4 * intensity) {\n        this.spawnFlameParticle(segX, segY, intensity);\n      }\n    }\n  }\n\n  private drawMeteors(g: Phaser.GameObjects.Graphics): void {\n    for (const m of this.meteors) {\n      const meteorColor = this.hslToRgb(m.hue / 360, 0.9, 0.6);\n      const coreColor = this.hslToRgb(m.hue / 360, 0.6, 0.9);\n\n      // Draw trail (oldest to newest for proper layering)\n      for (let i = m.trail.length - 1; i >= 0; i--) {\n        const t = m.trail[i];\n        const trailProgress = 1 - i / m.trail.length;\n        const trailAlpha = t.alpha * trailProgress * 0.4;\n        const trailSize = m.size * trailProgress * 0.6;\n\n        g.fillStyle(meteorColor, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      g.fillStyle(meteorColor, m.alpha * 0.3);\n      g.fillCircle(m.x, m.y, m.size * 2);\n\n      // Main meteor body\n      g.fillStyle(meteorColor, m.alpha * 0.8);\n      g.fillCircle(m.x, m.y, m.size);\n\n      // Bright core\n      g.fillStyle(coreColor, m.alpha);\n      g.fillCircle(m.x, m.y, m.size * 0.5);\n    }\n  }\n\n  private drawDeathDebris(g: Phaser.GameObjects.Graphics): void {\n    // Draw explosion flash at the beginning\n    if (this.deathExplosionPhase > 0.7) {\n      const flashAlpha = (this.deathExplosionPhase - 0.7) * 2;\n      g.fillStyle(0xffffff, flashAlpha * 0.5);\n      g.fillRect(0, 0, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);\n    }\n\n    for (const d of this.deathDebris) {\n      // Film noir: grayscale debris\n      const brightness = 0.4 + (d.hue % 60) / 100;\n      const color = this.hslToRgb(0, 0, brightness);\n      const alpha = d.life * 0.9;\n\n      g.save();\n\n      if (d.type === 'shard') {\n        // Draw triangular shards\n        const cx = d.x;\n        const cy = d.y;\n        const size = d.size * d.life;\n\n        // Calculate rotated triangle points\n        const cos = Math.cos(d.rotation);\n        const sin = Math.sin(d.rotation);\n\n        const p1x = cx + cos * size;\n        const p1y = cy + sin * size;\n        const p2x = cx + cos * (-size * 0.5) - sin * (size * 0.7);\n        const p2y = cy + sin * (-size * 0.5) + cos * (size * 0.7);\n        const p3x = cx + cos * (-size * 0.5) - sin * (-size * 0.7);\n        const p3y = cy + sin * (-size * 0.5) + cos * (-size * 0.7);\n\n        // Glow\n        g.fillStyle(color, alpha * 0.4);\n        g.fillCircle(cx, cy, size * 1.5);\n\n        // Shard body\n        g.fillStyle(color, alpha);\n        g.fillTriangle(p1x, p1y, p2x, p2y, p3x, p3y);\n\n        // Highlight edge\n        g.lineStyle(1, 0xffffff, alpha * 0.6);\n        g.lineBetween(p1x, p1y, p2x, p2y);\n\n      } else if (d.type === 'spark') {\n        // Draw elongated spark\n        const sparkLength = d.size * 2 * d.life;\n        const sparkWidth = d.size * 0.3 * d.life;\n\n        // Direction based on velocity\n        const vLen = Math.sqrt(d.vx * d.vx + d.vy * d.vy);\n        const nx = vLen > 0 ? d.vx / vLen : 1;\n        const ny = vLen > 0 ? d.vy / vLen : 0;\n\n        // Glow\n        g.fillStyle(color, alpha * 0.3);\n        g.fillCircle(d.x, d.y, sparkLength * 0.8);\n\n        // Spark line\n        g.lineStyle(sparkWidth * 2, color, alpha * 0.6);\n        g.lineBetween(d.x - nx * sparkLength, d.y - ny * sparkLength, d.x, d.y);\n\n        // Bright tip\n        g.lineStyle(sparkWidth, 0xffffff, alpha);\n        g.lineBetween(d.x - nx * sparkLength * 0.3, d.y - ny * sparkLength * 0.3, d.x, d.y);\n\n      } else {\n        // Ember - glowing circle\n        const emberSize = d.size * d.life;\n\n        // Outer glow\n        g.fillStyle(color, alpha * 0.2);\n        g.fillCircle(d.x, d.y, emberSize * 2);\n\n        // Mid glow\n        g.fillStyle(color, alpha * 0.5);\n        g.fillCircle(d.x, d.y, emberSize * 1.3);\n\n        // Core\n        g.fillStyle(color, alpha);\n        g.fillCircle(d.x, d.y, emberSize);\n\n        // Hot center\n        g.fillStyle(0xffffff, alpha * 0.7);\n        g.fillCircle(d.x, d.y, emberSize * 0.4);\n      }\n\n      g.restore();\n    }\n  }\n\n  private drawNebulaClouds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const cloud of this.nebulaClouds) {\n      // Update cloud position (slow drift)\n      cloud.x += cloud.driftX;\n      cloud.y += cloud.driftY;\n      cloud.pulsePhase += cloud.pulseSpeed;\n\n      // Wrap around edges\n      if (cloud.x < -cloud.radius) cloud.x = width + cloud.radius;\n      if (cloud.x > width + cloud.radius) cloud.x = -cloud.radius;\n      if (cloud.y < -cloud.radius) cloud.y = height + cloud.radius;\n      if (cloud.y > height + cloud.radius) cloud.y = -cloud.radius;\n\n      // Pulsing alpha\n      const pulseAlpha = cloud.alpha * (0.7 + Math.sin(cloud.pulsePhase) * 0.3);\n      const color = this.hslToRgb(cloud.hue / 360, 0.6, 0.3);\n\n      // Draw multiple concentric layers for soft cloud effect\n      const layers = 4;\n      for (let i = layers; i > 0; i--) {\n        const layerRadius = cloud.radius * (i / layers);\n        const layerAlpha = pulseAlpha * (1 - i / (layers + 1)) * 0.6;\n        g.fillStyle(color, layerAlpha);\n        g.fillCircle(cloud.x, cloud.y, layerRadius);\n      }\n\n      // Core glow\n      const coreColor = this.hslToRgb(cloud.hue / 360, 0.8, 0.5);\n      g.fillStyle(coreColor, pulseAlpha * 0.4);\n      g.fillCircle(cloud.x, cloud.y, cloud.radius * 0.3);\n    }\n  }\n\n  private drawVortex(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Update vortex pulse\n    this.vortexPulse += 0.03;\n    const globalPulse = 0.8 + Math.sin(this.vortexPulse) * 0.2;\n\n    // Draw outer glow/halo\n    const outerGlowColor = this.hslToRgb(280 / 360, 0.7, 0.3);\n    g.fillStyle(outerGlowColor, 0.08 * globalPulse);\n    g.fillCircle(centerX, centerY, 120);\n    g.fillStyle(outerGlowColor, 0.05 * globalPulse);\n    g.fillCircle(centerX, centerY, 140);\n\n    // Draw orbiting particles (behind rings)\n    for (const particle of this.vortexParticles) {\n      // Update particle position - spiral inward slightly then reset\n      particle.angle += particle.speed;\n      particle.radius = particle.baseRadius + Math.sin(particle.angle * 3) * 8;\n\n      const px = centerX + Math.cos(particle.angle) * particle.radius;\n      const py = centerY + Math.sin(particle.angle) * particle.radius;\n\n      // Particle hue shifts over time\n      particle.hue = (particle.hue + 0.5) % 360;\n      const particleColor = this.hslToRgb(particle.hue / 360, 0.8, 0.6);\n\n      // Draw particle with trail\n      const trailAngle = particle.angle - 0.3;\n      const trailX = centerX + Math.cos(trailAngle) * particle.radius;\n      const trailY = centerY + Math.sin(trailAngle) * particle.radius;\n\n      g.lineStyle(particle.size * 0.8, particleColor, particle.alpha * 0.3 * globalPulse);\n      g.lineBetween(trailX, trailY, px, py);\n\n      g.fillStyle(particleColor, particle.alpha * globalPulse);\n      g.fillCircle(px, py, particle.size);\n\n      // Bright core\n      g.fillStyle(0xffffff, particle.alpha * 0.5 * globalPulse);\n      g.fillCircle(px, py, particle.size * 0.4);\n    }\n\n    // Draw rotating rings\n    for (const ring of this.vortexRings) {\n      ring.rotationOffset += ring.rotationSpeed;\n      ring.pulsePhase += 0.02;\n\n      const ringPulse = 0.7 + Math.sin(ring.pulsePhase) * 0.3;\n      const adjustedRadius = ring.baseRadius * (0.95 + ringPulse * 0.1);\n\n      const ringColor = this.hslToRgb(ring.hue / 360, 0.8, 0.5);\n\n      // Draw ring as series of arc segments with gaps\n      const segments = 6;\n      const arcLength = (Math.PI * 2) / segments * 0.7;\n\n      for (let i = 0; i < segments; i++) {\n        const startAngle = ring.rotationOffset + (i * Math.PI * 2) / segments;\n        const endAngle = startAngle + arcLength;\n\n        // Calculate alpha based on segment position for 3D effect\n        const segmentAlpha = 0.15 + Math.sin(startAngle + this.frameCount * 0.02) * 0.1;\n\n        g.lineStyle(ring.thickness, ringColor, segmentAlpha * ringPulse * globalPulse);\n        g.beginPath();\n        g.arc(centerX, centerY, adjustedRadius, startAngle, endAngle, false);\n        g.strokePath();\n      }\n\n      // Inner glow line\n      g.lineStyle(ring.thickness * 0.5, 0xffffff, 0.1 * ringPulse * globalPulse);\n      g.beginPath();\n      g.arc(centerX, centerY, adjustedRadius - 1, ring.rotationOffset, ring.rotationOffset + Math.PI, false);\n      g.strokePath();\n    }\n\n    // Central dark core (event horizon)\n    g.fillStyle(0x000000, 0.9);\n    g.fillCircle(centerX, centerY, 12);\n    g.fillStyle(0x000000, 0.7);\n    g.fillCircle(centerX, centerY, 18);\n    g.fillStyle(0x000000, 0.4);\n    g.fillCircle(centerX, centerY, 25);\n\n    // Bright accretion ring at edge of event horizon\n    const accretionHue = (this.frameCount * 2) % 360;\n    const accretionColor = this.hslToRgb(accretionHue / 360, 1, 0.6);\n    g.lineStyle(2, accretionColor, 0.4 * globalPulse);\n    g.strokeCircle(centerX, centerY, 14);\n    g.lineStyle(1, 0xffffff, 0.3 * globalPulse);\n    g.strokeCircle(centerX, centerY, 13);\n\n    // Gravitational lensing effect - distorted light streaks\n    const numStreaks = 4;\n    for (let i = 0; i < numStreaks; i++) {\n      const streakAngle = (i * Math.PI * 2) / numStreaks + this.frameCount * 0.01;\n      const streakHue = (accretionHue + i * 60) % 360;\n      const streakColor = this.hslToRgb(streakHue / 360, 0.9, 0.7);\n\n      const innerRadius = 20;\n      const outerRadius = 35 + Math.sin(this.frameCount * 0.05 + i) * 10;\n\n      const x1 = centerX + Math.cos(streakAngle) * innerRadius;\n      const y1 = centerY + Math.sin(streakAngle) * innerRadius;\n      const x2 = centerX + Math.cos(streakAngle + 0.2) * outerRadius;\n      const y2 = centerY + Math.sin(streakAngle + 0.2) * outerRadius;\n\n      g.lineStyle(3, streakColor, 0.15 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n      g.lineStyle(1.5, 0xffffff, 0.2 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n    }\n  }\n\n  private drawAuroraWaves(g: Phaser.GameObjects.Graphics, width: number): void {\n    for (const aurora of this.auroraWaves) {\n      aurora.phase += aurora.speed;\n\n      // Draw multiple ribbon layers for each aurora\n      const ribbonLayers = 3;\n      for (let layer = 0; layer < ribbonLayers; layer++) {\n        const layerOffset = layer * 5;\n        const layerAlpha = 0.06 - layer * 0.015;\n\n        // Calculate shifting hue for color variation\n        const shiftedHue = (aurora.hue + Math.sin(aurora.phase * 0.5) * 20) % 360;\n        const color = this.hslToRgb(shiftedHue / 360, 0.7, 0.5);\n\n        // Draw aurora as a series of connected curves\n        g.fillStyle(color, layerAlpha);\n        const step = 4;\n        for (let x = 0; x < width; x += step) {\n          // Multiple sine waves combined for organic movement\n          const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n          const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n          const wave3 = Math.sin(x * 0.01 + aurora.phase * 0.7) * aurora.amplitude * 0.3;\n          const yOffset = wave1 + wave2 + wave3;\n\n          const segmentY = aurora.y + yOffset + layerOffset;\n          const thickness = aurora.thickness * (0.7 + Math.sin(x * 0.05 + aurora.phase) * 0.3);\n\n          g.fillRect(x, segmentY - thickness / 2, step + 1, thickness);\n        }\n      }\n\n      // Add bright core line\n      const coreHue = (aurora.hue + 40) % 360;\n      const coreColor = this.hslToRgb(coreHue / 360, 0.9, 0.7);\n      g.lineStyle(1.5, coreColor, 0.15);\n      g.beginPath();\n      for (let x = 0; x < width; x += 3) {\n        const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n        const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n        const y = aurora.y + wave1 + wave2;\n        if (x === 0) {\n          g.moveTo(x, y);\n        } else {\n          g.lineTo(x, y);\n        }\n      }\n      g.strokePath();\n    }\n  }\n\n  private drawPlasmaWaves(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const wave of this.plasmaWaves) {\n      wave.phase += wave.speed;\n      const color = this.hslToRgb(wave.hue / 360, 0.7, 0.4);\n\n      // Draw flowing plasma lines\n      for (let y = 0; y < height; y += 8) {\n        const waveOffset = Math.sin(y / wave.wavelength + wave.phase) * wave.amplitude;\n        const intensity = 0.03 + Math.sin(wave.phase + y * 0.01) * 0.02;\n\n        g.fillStyle(color, intensity);\n        const x1 = width / 2 + waveOffset - 40;\n        const x2 = width / 2 + waveOffset + 40;\n        g.fillRect(x1, y, x2 - x1, 2);\n      }\n    }\n  }\n\n  private drawSnakeAfterimages(g: Phaser.GameObjects.Graphics): void {\n    for (const ai of this.snakeAfterimages) {\n      const alpha = ai.life * 0.25;\n      for (let i = 0; i < ai.segments.length; i++) {\n        const seg = ai.segments[i];\n        const centerX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n        const centerY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n        const t = ai.segments.length > 1 ? i / (ai.segments.length - 1) : 1;\n        const radius = (CELL_SIZE / 2 - 2) * (0.7 + t * 0.2);\n\n        const segmentHue = (ai.hueOffset + i * 15) % 360;\n        const color = this.hslToRgb(segmentHue / 360, 0.6, 0.4);\n\n        g.fillStyle(color, alpha * t);\n        g.fillCircle(centerX, centerY, radius);\n      }\n    }\n  }\n\n  private drawTrailParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.trailParticles) {\n      // Film noir: grayscale trail\n      g.fillStyle(COLORS.noirGray, p.life * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 1.5 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.5);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n  }\n\n  // Update comet trail - add new segments and fade old ones\n  private updateCometTrail(): void {\n    if (!this.currentState || this.currentState.gameOver) {\n      // Fade out trail on game over\n      for (const seg of this.cometTrail) {\n        seg.alpha *= 0.9;\n      }\n      this.cometTrail = this.cometTrail.filter(s => s.alpha > 0.01);\n      return;\n    }\n\n    const snake = this.currentState.snake;\n    if (snake.length === 0) return;\n\n    const head = snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Track head history for smooth interpolation\n    this.headHistory.unshift({ x: headX, y: headY, time: this.frameCount });\n    if (this.headHistory.length > 10) this.headHistory.pop();\n\n    // Add new trail segment at head position\n    if (this.frameCount % 2 === 0) {\n      const hue = 270 + Math.sin(this.frameCount * 0.05) * 20;\n      this.cometTrail.unshift({\n        x: headX,\n        y: headY,\n        alpha: 1,\n        size: CELL_SIZE / 2 + 2,\n        hue,\n      });\n\n      // Spawn ethereal particles from trail\n      if (Math.random() < 0.6) {\n        this.spawnEtherealParticle(headX, headY, hue);\n      }\n    }\n\n    // Limit trail length and fade segments\n    while (this.cometTrail.length > MAX_COMET_TRAIL_LENGTH) {\n      this.cometTrail.pop();\n    }\n\n    // Fade all segments\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const fadeRate = 0.06 + (i / this.cometTrail.length) * 0.04;\n      this.cometTrail[i].alpha -= fadeRate;\n      this.cometTrail[i].size *= 0.97;\n    }\n\n    // Remove fully faded segments\n    this.cometTrail = this.cometTrail.filter(s => s.alpha > 0);\n  }\n\n  // Spawn an ethereal particle that drifts away from the trail\n  private spawnEtherealParticle(x: number, y: number, hue: number): void {\n    if (this.etherealParticles.length >= MAX_ETHEREAL_PARTICLES) {\n      this.etherealParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.5;\n    const life = 0.8 + Math.random() * 0.4;\n\n    this.etherealParticles.push({\n      x: x + (Math.random() - 0.5) * 10,\n      y: y + (Math.random() - 0.5) * 10,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 0.3,\n      size: 3 + Math.random() * 4,\n      life,\n      maxLife: life,\n      hue: hue + (Math.random() - 0.5) * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n\n  // Update ethereal particles\n  private updateEtherealParticles(): void {\n    for (let i = this.etherealParticles.length - 1; i >= 0; i--) {\n      const p = this.etherealParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.015; // Slight upward drift\n      p.vx *= 0.98;\n      p.size *= 0.985;\n      p.life -= 0.02;\n      p.pulsePhase += 0.15;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.etherealParticles.splice(i, 1);\n      }\n    }\n  }\n\n  // Draw the comet trail - smooth glowing ribbon\n  private drawCometTrail(g: Phaser.GameObjects.Graphics): void {\n    if (this.cometTrail.length < 2) return;\n\n    // Draw outer glow layer\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.05) continue;\n\n      const progress = i / this.cometTrail.length;\n      const glowSize = seg.size * (1.5 + progress * 0.5);\n      const glowAlpha = seg.alpha * 0.15 * (1 - progress * 0.5);\n\n      // Outer ethereal glow\n      const outerColor = this.hslToRgb(seg.hue / 360, 0.6, 0.4);\n      g.fillStyle(outerColor, glowAlpha);\n      g.fillCircle(seg.x, seg.y, glowSize * 1.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(seg.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, glowAlpha * 1.5);\n      g.fillCircle(seg.x, seg.y, glowSize);\n    }\n\n    // Draw connecting ribbon between segments\n    if (this.cometTrail.length >= 2) {\n      for (let i = 0; i < this.cometTrail.length - 1; i++) {\n        const seg1 = this.cometTrail[i];\n        const seg2 = this.cometTrail[i + 1];\n        if (seg1.alpha < 0.1 || seg2.alpha < 0.1) continue;\n\n        const progress = i / this.cometTrail.length;\n        const ribbonAlpha = Math.min(seg1.alpha, seg2.alpha) * 0.4 * (1 - progress * 0.5);\n        const ribbonWidth = (seg1.size + seg2.size) / 2 * 0.6;\n\n        // Ribbon core\n        const ribbonColor = this.hslToRgb(seg1.hue / 360, 0.8, 0.6);\n        g.lineStyle(ribbonWidth, ribbonColor, ribbonAlpha);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n\n        // Bright inner ribbon\n        g.lineStyle(ribbonWidth * 0.4, 0xffffff, ribbonAlpha * 0.6);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n      }\n    }\n\n    // Draw core particles at each segment\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.1) continue;\n\n      const progress = i / this.cometTrail.length;\n      const coreAlpha = seg.alpha * 0.6 * (1 - progress * 0.7);\n      const coreSize = seg.size * 0.5 * (1 - progress * 0.3);\n\n      // Core glow\n      const coreColor = this.hslToRgb(seg.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, coreAlpha);\n      g.fillCircle(seg.x, seg.y, coreSize);\n\n      // Bright white center\n      g.fillStyle(0xffffff, coreAlpha * 0.5);\n      g.fillCircle(seg.x, seg.y, coreSize * 0.4);\n    }\n  }\n\n  // Draw ethereal particles - luminous drifting particles\n  private drawEtherealParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.etherealParticles) {\n      const lifeRatio = p.life / p.maxLife;\n      const pulse = 0.7 + Math.sin(p.pulsePhase) * 0.3;\n      const alpha = lifeRatio * pulse;\n\n      // Outer glow\n      const glowColor = this.hslToRgb(p.hue / 360, 0.5, 0.3);\n      g.fillStyle(glowColor, alpha * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 2.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(p.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      // Core\n      const coreColor = this.hslToRgb(p.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, alpha * 0.7);\n      g.fillCircle(p.x, p.y, p.size);\n\n      // Bright center\n      g.fillStyle(0xffffff, alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawShockWaves(g: Phaser.GameObjects.Graphics): void {\n    for (const sw of this.shockWaves) {\n      const alpha = sw.life * 0.6;\n      // Outer ring\n      g.lineStyle(3, 0xffffff, alpha * 0.3);\n      g.strokeCircle(sw.x, sw.y, sw.radius);\n      // Inner bright ring\n      g.lineStyle(2, 0x00ffff, alpha * 0.7);\n      g.strokeCircle(sw.x, sw.y, sw.radius * 0.8);\n      // Core flash\n      if (sw.life > 0.8) {\n        g.fillStyle(0xffffff, (sw.life - 0.8) * 3);\n        g.fillCircle(sw.x, sw.y, sw.radius * 0.3);\n      }\n    }\n  }\n\n  private drawLightningBolts(g: Phaser.GameObjects.Graphics): void {\n    for (const bolt of this.lightningBolts) {\n      const alpha = bolt.life;\n\n      // Film noir: white lightning\n      g.lineStyle(4, COLORS.noirGray, alpha * 0.3);\n      this.drawLightningPath(g, bolt.points);\n\n      g.lineStyle(2, 0xffffff, alpha * 0.8);\n      this.drawLightningPath(g, bolt.points);\n    }\n  }\n\n  private drawLightningPath(g: Phaser.GameObjects.Graphics, points: { x: number; y: number }[]): void {\n    if (points.length < 2) return;\n    g.beginPath();\n    g.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      g.lineTo(points[i].x, points[i].y);\n    }\n    g.strokePath();\n  }\n\n  private drawSnakeElectricity(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n    const snake = this.currentState.snake;\n    if (snake.length < 2) return;\n\n    // Draw electric arcs between segments every few frames\n    if (this.frameCount % 3 !== 0) return;\n\n    for (let i = 0; i < snake.length - 1; i++) {\n      if (Math.random() > 0.4) continue;\n\n      const seg1 = snake[i];\n      const seg2 = snake[i + 1];\n      const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n      const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n      const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n      const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const arcPoints = this.generateLightningPath(x1, y1, x2, y2);\n\n      // Film noir: grayscale arcs\n      g.lineStyle(3, COLORS.noirGray, 0.3);\n      this.drawLightningPath(g, arcPoints);\n      g.lineStyle(1, 0xffffff, 0.7);\n      this.drawLightningPath(g, arcPoints);\n    }\n  }\n\n  private hslToRgb(h: number, s: number, l: number): number {\n    let r: number, g: number, b: number;\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return (Math.round(r * 255) << 16) | (Math.round(g * 255) << 8) | Math.round(b * 255);\n  }\n\n  private loadHighScores(): HighScoreEntry[] {\n    if (this.highScoresLoaded && this.highScores.length > 0) {\n      return this.highScores;\n    }\n    try {\n      const stored = localStorage.getItem('snake_high_scores');\n      if (stored) {\n        const parsed = JSON.parse(stored) as HighScoreEntry[];\n        this.highScores = parsed.slice(0, MAX_HIGH_SCORES);\n        this.highScoresLoaded = true;\n        return this.highScores;\n      }\n    } catch {\n      // localStorage not available\n    }\n    this.highScores = [];\n    this.highScoresLoaded = true;\n    return this.highScores;\n  }\n\n  private saveHighScore(score: number): number {\n    const highScores = this.loadHighScores();\n    const newEntry: HighScoreEntry = { score, date: Date.now(), rank: 0 };\n\n    let insertIndex = highScores.findIndex(entry => score > entry.score);\n    if (insertIndex === -1) insertIndex = highScores.length;\n\n    if (insertIndex < MAX_HIGH_SCORES && score > 0) {\n      highScores.splice(insertIndex, 0, newEntry);\n      highScores.forEach((entry, i) => { entry.rank = i + 1; });\n      this.highScores = highScores.slice(0, MAX_HIGH_SCORES);\n\n      try {\n        localStorage.setItem('snake_high_scores', JSON.stringify(this.highScores));\n      } catch {\n        // localStorage not available\n      }\n      return insertIndex + 1;\n    }\n    return -1;\n  }\n\n  private checkAndSaveHighScore(): void {\n    if (!this.currentState) return;\n\n    if (this.currentState.gameOver && !this.lastGameOverState) {\n      const score = this.currentState.score || 0;\n      const rank = this.saveHighScore(score);\n      this.newHighScoreRank = rank > 0 ? rank : -1;\n      this.scoreboardRevealProgress = 0;\n\n      const head = this.currentState.snake[0];\n      if (head) {\n        const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnBlood(this.cleanEffects, headX, headY, 15);\n        spawnTears(this.cleanEffects, headX, headY - 10, 6);\n      }\n    }\n    this.lastGameOverState = this.currentState.gameOver;\n\n    if (this.currentState.gameStarted && !this.currentState.gameOver) {\n      this.newHighScoreRank = -1;\n    }\n  }\n\n  private drawHUD(g: Phaser.GameObjects.Graphics, width: number): void {\n    if (!this.currentState || !this.currentState.gameStarted) return;\n\n    this.hudPulsePhase += 0.08;\n    const score = this.currentState.score || 0;\n\n    if (score > this.lastHudScore) {\n      this.scoreFlashIntensity = 1;\n    }\n    this.lastHudScore = score;\n    this.scoreFlashIntensity *= 0.92;\n\n    const padding = 12;\n    const scorePanelWidth = 120;\n    const scorePanelHeight = 50;\n\n    // Score panel background - volcanic lava theme\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Glowing border\n    const borderGlow = 0.6 + this.scoreFlashIntensity * 0.4;\n    g.lineStyle(2, COLORS.snakeGlow, borderGlow);\n    g.strokeRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Score label\n    this.drawText(g, 'SCORE', padding + 10, padding + 12, 10, COLORS.snakeBody, 0.9);\n\n    // Score value with flash effect\n    const scoreColor = this.scoreFlashIntensity > 0.5 ? 0xffffff : COLORS.snakeHead;\n    this.drawText(g, String(score).padStart(5, '0'), padding + 10, padding + 32, 18, scoreColor, 1);\n\n    // Outer glow on score when flashing\n    if (this.scoreFlashIntensity > 0.1) {\n      g.fillStyle(COLORS.snakeGlow, this.scoreFlashIntensity * 0.3);\n      g.fillRoundedRect(padding + 5, padding + 20, 100, 28, 4);\n    }\n\n    // Length panel on the right\n    const lengthPanelWidth = 80;\n    const lengthPanelHeight = 50;\n    const lengthX = width - padding - lengthPanelWidth;\n\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    g.lineStyle(2, COLORS.foodGlow, 0.6);\n    g.strokeRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    this.drawText(g, 'LENGTH', lengthX + 10, padding + 12, 10, COLORS.food, 0.9);\n    this.drawText(g, String(this.currentState.snake.length), lengthX + 10, padding + 32, 18, COLORS.foodCore, 1);\n  }\n\n  private drawText(\n    g: Phaser.GameObjects.Graphics,\n    text: string,\n    x: number,\n    y: number,\n    size: number,\n    color: number,\n    alpha: number\n  ): void {\n    // Use simple block characters for text rendering\n    const charWidth = size * 0.6;\n    const charHeight = size;\n\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const cx = x + i * charWidth;\n\n      g.fillStyle(color, alpha);\n\n      // Simple pixel-style character rendering\n      if (char >= '0' && char <= '9') {\n        this.drawDigit(g, char, cx, y, size);\n      } else {\n        this.drawLetter(g, char, cx, y, size);\n      }\n    }\n  }\n\n  private drawDigit(g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15; // thickness\n\n    // 7-segment style digits\n    const segments: Record<string, number[]> = {\n      '0': [1, 1, 1, 0, 1, 1, 1],\n      '1': [0, 0, 1, 0, 0, 1, 0],\n      '2': [1, 0, 1, 1, 1, 0, 1],\n      '3': [1, 0, 1, 1, 0, 1, 1],\n      '4': [0, 1, 1, 1, 0, 1, 0],\n      '5': [1, 1, 0, 1, 0, 1, 1],\n      '6': [1, 1, 0, 1, 1, 1, 1],\n      '7': [1, 0, 1, 0, 0, 1, 0],\n      '8': [1, 1, 1, 1, 1, 1, 1],\n      '9': [1, 1, 1, 1, 0, 1, 1],\n    };\n\n    const seg = segments[digit] || segments['0'];\n\n    // Top horizontal\n    if (seg[0]) g.fillRect(x, y - h / 2, w, t);\n    // Top-left vertical\n    if (seg[1]) g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n    // Top-right vertical\n    if (seg[2]) g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n    // Middle horizontal\n    if (seg[3]) g.fillRect(x, y - t / 2, w, t);\n    // Bottom-left vertical\n    if (seg[4]) g.fillRect(x - t / 2, y, t, h / 2);\n    // Bottom-right vertical\n    if (seg[5]) g.fillRect(x + w - t / 2, y, t, h / 2);\n    // Bottom horizontal\n    if (seg[6]) g.fillRect(x, y + h / 2 - t, w, t);\n  }\n\n  private drawLetter(g: Phaser.GameObjects.Graphics, letter: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15;\n\n    // Simple block letters\n    switch (letter.toUpperCase()) {\n      case 'S':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'C':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'O':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'R':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w / 2, y, t, h / 2);\n        break;\n      case 'E':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w * 0.7, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'L':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'N':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - h / 2 + t, w, t);\n        break;\n      case 'G':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x + w / 2, y - t / 2, w / 2, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'T':\n        g.fillRect(x - t, y - h / 2, w + t * 2, t);\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'H':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n      case 'I':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'Y':\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        break;\n      case 'U':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'W':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case '!':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h * 0.6);\n        g.fillRect(x + w / 2 - t / 2, y + h / 2 - t * 2, t, t);\n        break;\n      case ' ':\n        break;\n      default:\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n    }\n  }\n\n  private drawScoreboard(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (!this.currentState || !this.currentState.gameOver) return;\n\n    this.scoreboardAnimPhase += 0.06;\n    this.scoreboardRevealProgress = Math.min(1, this.scoreboardRevealProgress + 0.02);\n\n    const highScores = this.loadHighScores();\n    const centerX = width / 2;\n    const baseY = height * 0.18;\n    const panelWidth = 180;\n    const panelHeight = 170;\n    const panelX = centerX - panelWidth / 2;\n    const panelY = baseY;\n    const slideOffset = (1 - this.scoreboardRevealProgress) * 50;\n    const alphaMultiplier = this.scoreboardRevealProgress;\n\n    // Panel background - volcanic lava glow\n    g.fillStyle(0x150510, 0.95 * alphaMultiplier);\n    g.fillRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Glowing border - animated\n    const borderHue = this.newHighScoreRank > 0 ? 45 : 0;\n    const borderPulse = 0.6 + Math.sin(this.scoreboardAnimPhase) * 0.2;\n    const borderColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    g.lineStyle(3, borderColor, borderPulse * alphaMultiplier);\n    g.strokeRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Title\n    const titleY = panelY - slideOffset + 22;\n    this.drawText(g, 'HIGH SCORES', centerX - 55, titleY, 10, COLORS.foodCore, alphaMultiplier);\n\n    // Divider line\n    g.lineStyle(1, COLORS.snakeGlow, 0.5 * alphaMultiplier);\n    g.lineBetween(panelX + 20, titleY + 8, panelX + panelWidth - 20, titleY + 8);\n\n    const entryStartY = titleY + 25;\n    const entryHeight = 22;\n\n    if (highScores.length === 0) {\n      this.drawText(g, 'NO SCORES YET', centerX - 50, entryStartY + 30, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n    } else {\n      for (let i = 0; i < Math.min(highScores.length, 5); i++) {\n        const entry = highScores[i];\n        const entryY = entryStartY + i * entryHeight;\n        const isNewScore = this.newHighScoreRank === i + 1;\n        const entryDelay = i * 0.15;\n        const entryProgress = Math.max(0, Math.min(1, (this.scoreboardRevealProgress - entryDelay) * 2));\n        if (entryProgress <= 0) continue;\n\n        const entryAlpha = alphaMultiplier * entryProgress;\n\n        // Highlight new high score row\n        if (isNewScore) {\n          const flashIntensity = 0.3 + Math.sin(this.scoreboardAnimPhase * 3) * 0.2;\n          g.fillStyle(0xffcc00, flashIntensity * entryAlpha);\n          g.fillRoundedRect(panelX + 8, entryY - slideOffset - 8, panelWidth - 16, entryHeight - 2, 4);\n        }\n\n        // Rank colors: gold, silver, bronze, then volcanic colors\n        const rankColors = [0xffd700, 0xc0c0c0, 0xcd7f32, COLORS.snakeGlow, COLORS.foodGlow];\n        const rankColor = rankColors[i] || 0x888888;\n\n        // Rank number\n        this.drawText(g, `${i + 1}`, panelX + 18, entryY - slideOffset, 10, rankColor, entryAlpha);\n\n        // Score value\n        const scoreColor = isNewScore ? 0xffffff : COLORS.foodCore;\n        this.drawText(g, String(entry.score).padStart(5, '0'), panelX + panelWidth - 70, entryY - slideOffset, 10, scoreColor, entryAlpha);\n\n        // NEW! label\n        if (isNewScore) {\n          const newAlpha = 0.8 + Math.sin(this.scoreboardAnimPhase * 4) * 0.2;\n          this.drawText(g, 'NEW', panelX + 50, entryY - slideOffset, 7, 0xffcc00, newAlpha * entryAlpha);\n        }\n      }\n    }\n\n    // Current score at bottom\n    const currentScoreY = panelY - slideOffset + panelHeight - 30;\n    this.drawText(g, 'YOUR SCORE', centerX - 40, currentScoreY - 10, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n\n    const currentScore = this.currentState.score || 0;\n    const scoreColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    this.drawText(g, String(currentScore).padStart(5, '0'), centerX - 25, currentScoreY + 8, 14, scoreColor, alphaMultiplier);\n  }\n\n  private drawGrid(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir grid: subtle, dark lines suggesting tile floor or city grid\n    g.lineStyle(1, COLORS.gridLine, 0.08);\n    for (let i = 0; i <= GRID_SIZE; i++) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Accent lines every 5 cells - subtle gray\n    const accentPulse = 0.12 + Math.sin(this.frameCount * 0.03) * 0.04;\n    g.lineStyle(1, COLORS.gridAccent, accentPulse);\n    for (let i = 0; i <= GRID_SIZE; i += 5) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Heavy vignette for dramatic noir look\n    this.drawVignette(g, width, height);\n  }\n\n  private drawVignette(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Multiple layers of vignette for smooth falloff\n    const layers = 5;\n    for (let i = 0; i < layers; i++) {\n      const inset = i * 30;\n      const alpha = 0.15 * (1 - i / layers);\n      g.lineStyle(60, 0x000000, alpha);\n      g.strokeRect(inset - 30, inset - 30, width - inset * 2 + 60, height - inset * 2 + 60);\n    }\n  }\n\n  private drawFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    // Don't draw food if it's still being thrown\n    if (this.thrownFood && !this.thrownFood.landed) return;\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    const pulseScale = 1 + Math.sin(this.frameCount * 0.15) * 0.08;\n    const glowPulse = 0.4 + Math.sin(this.frameCount * 0.1) * 0.2;\n\n    // Spawn particles (orange/yellow for Halloween)\n    this.spawnFoodParticles(foodX, foodY);\n\n    // Draw particles\n    for (const p of this.foodParticles) {\n      g.fillStyle(COLORS.pumpkinOrange, p.life * 0.4);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Halloween pumpkin!\n    const pumpkinSize = (CELL_SIZE / 2) * pulseScale;\n\n    // Shadow underneath\n    g.fillStyle(0x000000, 0.5);\n    g.fillEllipse(foodX + 2, foodY + pumpkinSize * 0.8, pumpkinSize * 1.2, pumpkinSize * 0.4);\n\n    // Outer orange glow (candlelight effect)\n    g.fillStyle(COLORS.pumpkinOrange, glowPulse * 0.15);\n    g.fillCircle(foodX, foodY, pumpkinSize + 12);\n    g.fillStyle(COLORS.candyCorn1, glowPulse * 0.2);\n    g.fillCircle(foodX, foodY, pumpkinSize + 6);\n\n    // Pumpkin body (slightly squashed circle)\n    g.fillStyle(COLORS.pumpkinOrange, 0.95);\n    g.fillEllipse(foodX, foodY, pumpkinSize * 1.1, pumpkinSize * 0.9);\n\n    // Pumpkin segments (darker lines)\n    g.lineStyle(2, 0xcc4400, 0.5);\n    g.lineBetween(foodX, foodY - pumpkinSize * 0.8, foodX, foodY + pumpkinSize * 0.7);\n    g.lineStyle(1.5, 0xcc4400, 0.3);\n    g.lineBetween(foodX - pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX - pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n    g.lineBetween(foodX + pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX + pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n\n    // Pumpkin stem\n    g.fillStyle(0x228822, 0.9);\n    g.fillRect(foodX - 2, foodY - pumpkinSize * 0.9 - 4, 4, 6);\n\n    // Jack-o-lantern face - glowing eyes and mouth\n    const faceGlow = 0.8 + Math.sin(this.frameCount * 0.12) * 0.2;\n    g.fillStyle(COLORS.candyCorn1, faceGlow);\n\n    // Eyes (triangles)\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n\n    // Mouth (jagged smile)\n    g.fillStyle(COLORS.candyCorn1, faceGlow * 0.9);\n    g.fillRect(foodX - pumpkinSize * 0.35, foodY + pumpkinSize * 0.15, pumpkinSize * 0.7, pumpkinSize * 0.25);\n\n    // Teeth (dark gaps in mouth)\n    g.fillStyle(COLORS.pumpkinOrange, 1);\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX, foodY + pumpkinSize * 0.15,\n      foodX - pumpkinSize * 0.075, foodY + pumpkinSize * 0.3\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.3, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.225, foodY + pumpkinSize * 0.3\n    );\n  }\n\n  private drawEnergyTendrils(g: Phaser.GameObjects.Graphics, foodX: number, foodY: number): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const head = this.currentState.snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Calculate distance to snake head\n    const dx = headX - foodX;\n    const dy = headY - foodY;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    // Only draw tendrils when snake is somewhat close\n    if (dist > CELL_SIZE * 6) return;\n\n    // Intensity increases as snake gets closer\n    const intensity = 1 - dist / (CELL_SIZE * 6);\n    const numTendrils = 2 + Math.floor(intensity * 2);\n\n    for (let i = 0; i < numTendrils; i++) {\n      // Tendril reaches partway toward the snake\n      const reach = 0.3 + intensity * 0.4;\n      const targetX = foodX + dx * reach;\n      const targetY = foodY + dy * reach;\n\n      // Add some wave offset for each tendril\n      const waveOffset = Math.sin(this.frameCount * 0.15 + i * 2) * 10;\n      const perpX = -dy / dist;\n      const perpY = dx / dist;\n      const wavyTargetX = targetX + perpX * waveOffset * (1 - reach);\n      const wavyTargetY = targetY + perpY * waveOffset * (1 - reach);\n\n      // Generate tendril path\n      const points = this.generateLightningPath(foodX, foodY, wavyTargetX, wavyTargetY);\n\n      // Draw tendril with glow\n      g.lineStyle(3, COLORS.foodGlow, intensity * 0.3);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1.5, COLORS.food, intensity * 0.7);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1, 0xffffff, intensity * 0.5);\n      this.drawLightningPath(g, points);\n    }\n  }\n\n  private drawSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const snakeLen = snake.length;\n\n    // Spooky shadow under snake\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const shadowRadius = (CELL_SIZE / 2) * (0.9 + t * 0.1);\n      g.fillStyle(0x000000, 0.5 * t);\n      g.fillCircle(centerX, centerY, shadowRadius);\n    }\n\n    // Draw trailing glow (ghostly green)\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const glowAlpha = 0.2 * t;\n      const glowSize = (CELL_SIZE / 2 + 4) * (0.5 + t * 0.5);\n\n      g.fillStyle(COLORS.snakeGlow, glowAlpha);\n      g.fillCircle(centerX, centerY, glowSize);\n    }\n\n    // Draw snake segments from tail to head with green gradient\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n\n      // Green gradient from tail (dark) to head (bright)\n      const brightness = 0.3 + t * 0.4;\n      const segmentColor = this.hslToRgb(0.4, 0.9, brightness);\n\n      if (i === 0) {\n        // Head: brightest green with eerie glow\n        g.fillStyle(COLORS.snakeGlow, 0.4);\n        g.fillCircle(centerX, centerY, radius + 8);\n\n        g.fillStyle(COLORS.snakeHead, 1);\n        g.fillCircle(centerX, centerY, radius + 1);\n\n        // Slimy highlight\n        g.fillStyle(0xaaffcc, 0.6);\n        g.fillCircle(centerX - 2, centerY - 2, radius * 0.35);\n\n        this.drawSnakeHead(g, segment, snake[1]);\n      } else {\n        // Body segment with green tones\n        g.fillStyle(COLORS.snakeGlow, 0.15);\n        g.fillCircle(centerX, centerY, radius + 2);\n\n        g.fillStyle(segmentColor, 1);\n        g.fillCircle(centerX, centerY, radius);\n\n        // Slimy specular highlight\n        g.fillStyle(0xaaffcc, 0.15 * t);\n        g.fillCircle(centerX - 1, centerY - 1, radius * 0.25);\n      }\n    }\n  }\n\n  private drawFoodBurst(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.foodBurstParticles) {\n      // Halloween: orange pumpkin burst\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailAlpha = p.life * 0.4 * (1 - i / p.trail.length);\n        const trailSize = p.size * p.life * (1 - i / p.trail.length);\n        g.fillStyle(COLORS.pumpkinOrange, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      g.fillStyle(COLORS.candyCorn1, p.life * 0.7);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n      g.fillStyle(COLORS.candyCorn3, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life * 0.4);\n    }\n  }\n\n  private drawEnergyField(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const snake = this.currentState.snake;\n    const baseIntensity = 0.06 + this.energyFieldPulse * 0.2;\n    const pulseOffset = Math.sin(this.frameCount * 0.1) * 0.02;\n    const alpha = Math.min(0.3, baseIntensity + pulseOffset);\n\n    // Halloween: ghostly green energy field\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const fieldRadius = CELL_SIZE * (0.8 + this.energyFieldPulse * 0.5) + Math.sin(this.frameCount * 0.15 + i * 0.5) * 2;\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.2);\n      g.fillCircle(cx, cy, fieldRadius + 4);\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.35);\n      g.fillCircle(cx, cy, fieldRadius);\n    }\n\n    // Connecting lines when pulse is active\n    if (this.energyFieldPulse > 0.3 && snake.length > 1) {\n      for (let i = 0; i < snake.length - 1; i++) {\n        const seg1 = snake[i];\n        const seg2 = snake[i + 1];\n        const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n        const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n        const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n        const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n        g.lineStyle(3, COLORS.noirGray, this.energyFieldPulse * 0.3);\n        g.lineBetween(x1, y1, x2, y2);\n        g.lineStyle(1.5, 0xffffff, this.energyFieldPulse * 0.5);\n        g.lineBetween(x1, y1, x2, y2);\n      }\n    }\n  }\n\n  private drawChromaticAberration(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const offset = this.chromaticIntensity * 3;\n\n    // Film noir: grayscale ghosting effect instead of color split\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snake.length > 1 ? i / (snake.length - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n      const alpha = this.chromaticIntensity * 0.3 * (i === 0 ? 1 : 0.5);\n\n      // Light ghost - offset left\n      g.fillStyle(0xffffff, alpha);\n      g.fillCircle(cx - offset, cy, radius);\n\n      // Dark ghost - offset right\n      g.fillStyle(0x404040, alpha);\n      g.fillCircle(cx + offset, cy, radius);\n    }\n  }\n\n  private drawGameOver(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir game over: dramatic fade to black with spotlight\n    if (this.gameOverAlpha < 0.85) {\n      this.gameOverAlpha += 0.03;\n    }\n\n    // Heavy dark overlay\n    g.fillStyle(COLORS.gameOverOverlay, this.gameOverAlpha);\n    g.fillRect(0, 0, width, height);\n\n    // Film grain effect (subtle noise lines)\n    for (let y = 0; y < height; y += 3) {\n      const grainAlpha = 0.05 + Math.random() * 0.05;\n      g.fillStyle(Math.random() > 0.5 ? 0xffffff : 0x000000, grainAlpha);\n      g.fillRect(0, y, width, 1);\n    }\n\n    // Dramatic spotlight in center\n    const spotPulse = 0.15 + Math.sin(this.frameCount * 0.05) * 0.05;\n    g.fillStyle(COLORS.noirWhite, spotPulse);\n    g.fillCircle(width / 2, height / 2, 80);\n    g.fillStyle(COLORS.noirWhite, spotPulse * 0.5);\n    g.fillCircle(width / 2, height / 2, 120);\n\n    // Noir border: thick black frame\n    const borderSize = 8;\n    g.fillStyle(0x000000, 0.8);\n    g.fillRect(0, 0, width, borderSize);\n    g.fillRect(0, height - borderSize, width, borderSize);\n    g.fillRect(0, 0, borderSize, height);\n    g.fillRect(width - borderSize, 0, borderSize, height);\n\n    // White inner border\n    const innerBorder = 2;\n    const innerOffset = borderSize;\n    g.fillStyle(COLORS.noirWhite, 0.3);\n    g.fillRect(innerOffset, innerOffset, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, height - innerOffset - innerBorder, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, innerOffset, innerBorder, height - innerOffset * 2);\n    g.fillRect(width - innerOffset - innerBorder, innerOffset, innerBorder, height - innerOffset * 2);\n  }\n\n  private drawSnakeHead(\n    g: Phaser.GameObjects.Graphics,\n    head: Position,\n    nextSegment: Position | undefined\n  ): void {\n    const centerX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const centerY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Determine direction for eye placement\n    let dx = 1, dy = 0;\n    if (nextSegment) {\n      dx = head.x - nextSegment.x;\n      dy = head.y - nextSegment.y;\n      // Normalize\n      const len = Math.sqrt(dx * dx + dy * dy);\n      if (len > 0) {\n        dx /= len;\n        dy /= len;\n      }\n    }\n\n    // Perpendicular for eye offset\n    const perpX = -dy;\n    const perpY = dx;\n\n    const eyeOffset = 4;\n    const eyeForward = 3;\n    const eyeRadius = 3;\n    const pupilRadius = 1.5;\n\n    // Left eye\n    const leftEyeX = centerX + perpX * eyeOffset + dx * eyeForward;\n    const leftEyeY = centerY + perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(leftEyeX, leftEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(leftEyeX + dx * 1, leftEyeY + dy * 1, pupilRadius);\n\n    // Right eye\n    const rightEyeX = centerX - perpX * eyeOffset + dx * eyeForward;\n    const rightEyeY = centerY - perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(rightEyeX, rightEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(rightEyeX + dx * 1, rightEyeY + dy * 1, pupilRadius);\n\n    // Draw the royal crown\n    this.drawCrown(g, centerX, centerY, dx, dy, perpX, perpY);\n  }\n\n  private drawCrown(\n    g: Phaser.GameObjects.Graphics,\n    headX: number,\n    headY: number,\n    dx: number,\n    dy: number,\n    perpX: number,\n    perpY: number\n  ): void {\n    // Volcanic crown: molten gold with ruby gems\n    const crownOffset = -8;\n    const crownBaseX = headX - dx * crownOffset;\n    const crownBaseY = headY - dy * crownOffset;\n\n    const crownWidth = 14;\n    const crownHeight = 10;\n    const halfWidth = crownWidth / 2;\n\n    const sparkle = 0.7 + Math.sin(this.frameCount * 0.15) * 0.3;\n\n    const baseLeft = {\n      x: crownBaseX + perpX * halfWidth,\n      y: crownBaseY + perpY * halfWidth\n    };\n    const baseRight = {\n      x: crownBaseX - perpX * halfWidth,\n      y: crownBaseY - perpY * halfWidth\n    };\n\n    const pointOffset = -dx * crownHeight;\n    const pointOffsetY = -dy * crownHeight;\n\n    const crownPoints = [\n      baseLeft,\n      { x: baseLeft.x + pointOffset * 0.4, y: baseLeft.y + pointOffsetY * 0.4 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: crownBaseX + perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY + perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY },\n      { x: crownBaseX - perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY - perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: baseRight.x + pointOffset * 0.4, y: baseRight.y + pointOffsetY * 0.4 },\n      baseRight\n    ];\n\n    // Crown glow (molten orange/red aura)\n    g.fillStyle(COLORS.noirWhite, 0.25 * sparkle);\n    g.fillCircle(crownBaseX + pointOffset * 0.5, crownBaseY + pointOffsetY * 0.5, crownHeight + 4);\n\n    // Crown base (molten gold)\n    g.fillStyle(0xffa500, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.fillPath();\n\n    // Crown outline (dark crimson)\n    g.lineStyle(1.5, 0x801010, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.strokePath();\n\n    // Crown band\n    const bandY1 = {\n      x: baseLeft.x + pointOffset * 0.15,\n      y: baseLeft.y + pointOffsetY * 0.15\n    };\n    const bandY2 = {\n      x: baseRight.x + pointOffset * 0.15,\n      y: baseRight.y + pointOffsetY * 0.15\n    };\n    g.lineStyle(3, 0xcc6600, 1);\n    g.lineBetween(bandY1.x, bandY1.y, bandY2.x, bandY2.y);\n\n    // Ruby jewels: glowing red gems\n    const jewelPositions = [\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY, size: 2.5 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n    ];\n\n    for (const jewel of jewelPositions) {\n      g.fillStyle(0xff4020, 0.5 * sparkle);\n      g.fillCircle(jewel.x, jewel.y, jewel.size + 2);\n\n      g.fillStyle(0xff2000, 1);\n      g.fillCircle(jewel.x, jewel.y, jewel.size);\n\n      g.fillStyle(0xffff80, 0.9 * sparkle);\n      g.fillCircle(jewel.x - 0.5, jewel.y - 0.5, jewel.size * 0.4);\n    }\n\n    // Crown highlight (golden gleam)\n    g.fillStyle(0xffff80, 0.6 * sparkle);\n    g.fillCircle(crownBaseX + perpX * 3 + pointOffset * 0.3, crownBaseY + perpY * 3 + pointOffsetY * 0.3, 2);\n  }\n}\n","structuredPatch":[{"oldStart":2391,"oldLines":6,"newStart":2391,"newLines":8,"lines":[" ","     updateMotes(this.cleanEffects, width, height);","     updateRipples(this.cleanEffects);","+    updateTears(this.cleanEffects, height);","+    updateBlood(this.cleanEffects, height);"," ","     if (this.currentState && this.currentState.snake.length > 0) {","       const head = this.currentState.snake[0];"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013LkRB9edncsXFFz1wN3MCC","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the draw calls. Let me find the right spot to draw tears and blood (after the snake, so they appear on top)."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":321,"cache_read_input_tokens":45371,"cache_creation":{"ephemeral_5m_input_tokens":321,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"257260e4-525c-4561-a004-341d3101a3ca"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013LkRB9edncsXFFz1wN3MCC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HzEQSt5mt5fbdYYJMrvAHr","name":"Edit","input":{"replace_all":false,"file_path":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","old_string":"    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawCleanVignette(g, width, height);","new_string":"    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawTears(g, this.cleanEffects);\n    drawBlood(g, this.cleanEffects);\n\n    drawCleanVignette(g, width, height);"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":321,"cache_read_input_tokens":45371,"cache_creation":{"ephemeral_5m_input_tokens":321,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"061d8625-bfb4-400b-a722-7cdedd965af6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HzEQSt5mt5fbdYYJMrvAHr","type":"tool_result","content":"The file /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"06e0b965-b08f-43fd-b22a-6f53192c10be","tool_use_result":{"filePath":"/__w/perfect-snake-platform/perfect-snake-platform/game/src/components/SnakeScene.ts","oldString":"    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawCleanVignette(g, width, height);","newString":"    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawTears(g, this.cleanEffects);\n    drawBlood(g, this.cleanEffects);\n\n    drawCleanVignette(g, width, height);","originalFile":"import Phaser from 'phaser';\nimport {\n  createCleanEffectsState,\n  initMotes,\n  updateMotes,\n  updateRipples,\n  updateGlowTrail,\n  spawnRipple,\n  spawnTears,\n  spawnBlood,\n  updateTears,\n  updateBlood,\n  drawCleanBackground,\n  drawCleanGrid,\n  drawMotes,\n  drawRipples,\n  drawGlowTrail,\n  drawCleanFood,\n  drawCleanSnake,\n  drawCleanVignette,\n  drawCleanHUD,\n  drawTears,\n  drawBlood,\n  CLEAN_COLORS,\n  CleanEffectsState,\n} from './cleanEffects';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface GameState {\n  snake: Position[];\n  food: Position;\n  gameOver: boolean;\n  gameStarted?: boolean;\n  score?: number;\n}\n\ninterface Star {\n  x: number;\n  y: number;\n  size: number;\n  speed: number;\n  brightness: number;\n}\n\ninterface PlasmaWave {\n  phase: number;\n  speed: number;\n  amplitude: number;\n  wavelength: number;\n  hue: number;\n}\n\ninterface AuroraWave {\n  y: number;\n  phase: number;\n  speed: number;\n  hue: number;\n  thickness: number;\n  amplitude: number;\n}\n\ninterface NebulaCloud {\n  x: number;\n  y: number;\n  radius: number;\n  hue: number;\n  alpha: number;\n  driftX: number;\n  driftY: number;\n  pulsePhase: number;\n  pulseSpeed: number;\n}\n\ninterface VortexRing {\n  radius: number;\n  baseRadius: number;\n  rotationOffset: number;\n  rotationSpeed: number;\n  thickness: number;\n  hue: number;\n  pulsePhase: number;\n}\n\ninterface VortexParticle {\n  angle: number;\n  radius: number;\n  baseRadius: number;\n  speed: number;\n  size: number;\n  hue: number;\n  alpha: number;\n}\n\ninterface SnakeAfterimage {\n  segments: Position[];\n  life: number;\n  maxLife: number;\n  hueOffset: number;\n}\n\ninterface FoodParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n}\n\ninterface SnakeTrailParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n  hue: number;\n}\n\ninterface ShockWave {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n}\n\ninterface LightningBolt {\n  points: { x: number; y: number }[];\n  life: number;\n  maxLife: number;\n  hue: number;\n}\n\nconst CELL_SIZE = 20;\nconst GRID_SIZE = 20;\nconst NUM_STARS = 30;\nconst MAX_FOOD_PARTICLES = 8;\nconst MAX_TRAIL_PARTICLES = 40;\nconst MAX_SHOCKWAVES = 3;\nconst MAX_LIGHTNING_BOLTS = 5;\nconst MAX_BURST_PARTICLES = 12;\nconst NUM_PLASMA_WAVES = 3;\nconst MAX_AFTERIMAGES = 4;\nconst NUM_AURORA_WAVES = 5;\nconst NUM_NEBULA_CLOUDS = 6;\nconst NUM_VORTEX_RINGS = 5;\nconst NUM_VORTEX_PARTICLES = 20;\nconst NUM_METEORS = 8;\nconst MAX_DEATH_DEBRIS = 24;\nconst NUM_SPIRITS_PER_EDGE = 2;\nconst MAX_FLAME_PARTICLES = 60;\nconst MAX_COMET_TRAIL_LENGTH = 30;\nconst MAX_ETHEREAL_PARTICLES = 50;\nconst NUM_BEES = 8;\nconst BEE_SPAWN_CHANCE = 0.02;\n\n// Comet trail segment - stores historical snake positions for smooth trail rendering\ninterface CometTrailSegment {\n  x: number;\n  y: number;\n  alpha: number;\n  size: number;\n  hue: number;\n}\n\n// Ethereal trail particle - luminous particles that drift away from trail\ninterface EtherealParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n  pulsePhase: number;\n}\n\n// Thrown food animation - food launched onto screen with arc trajectory\ninterface ThrownFood {\n  startX: number;\n  startY: number;\n  targetX: number;\n  targetY: number;\n  x: number;\n  y: number;\n  progress: number; // 0 to 1\n  rotation: number;\n  rotationSpeed: number;\n  trail: { x: number; y: number; alpha: number; rotation: number }[];\n  landed: boolean;\n  landingParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number }[];\n  impactRings: { radius: number; alpha: number }[];\n}\n\n// Meteor shower types\ninterface Meteor {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  alpha: number;\n  trail: { x: number; y: number; alpha: number }[];\n  life: number;\n}\n\n// Death debris particle\ninterface DeathDebris {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  hue: number;\n  rotation: number;\n  rotationSpeed: number;\n  life: number;\n  type: 'shard' | 'spark' | 'ember';\n}\n\n// Guardian spirit - ethereal protectors at edges\ninterface GuardianSpirit {\n  x: number;\n  y: number;\n  baseX: number;\n  baseY: number;\n  size: number;\n  phase: number;\n  speed: number;\n  haloPhase: number;\n  orbPhase: number;\n  edge: 'top' | 'bottom' | 'left' | 'right';\n  targetAlpha: number;\n  currentAlpha: number;\n  hue: number;\n  orbs: { angle: number; distance: number; size: number; speed: number }[];\n}\n\n// Flame particle for burning effect\ninterface FlameParticle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  life: number;\n  maxLife: number;\n  hue: number;\n  brightness: number;\n}\n\n// Mystical bee - glowing magical creatures that swarm around food\ninterface MysticalBee {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  targetX: number;\n  targetY: number;\n  wingPhase: number;\n  wingSpeed: number;\n  size: number;\n  hue: number;\n  glowIntensity: number;\n  bobPhase: number;\n  bobSpeed: number;\n  trail: { x: number; y: number; alpha: number }[];\n  state: 'flying' | 'hovering' | 'attracted';\n  sparkleTimer: number;\n}\n\n// Rival snake - spectral AI nemesis that competes for food\ninterface RivalSnake {\n  segments: { x: number; y: number }[];\n  direction: { dx: number; dy: number };\n  targetX: number;\n  targetY: number;\n  moveTimer: number;\n  moveInterval: number;\n  pulsePhase: number;\n  glowIntensity: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n  energyTrail: { x: number; y: number; alpha: number; size: number }[];\n  state: 'hunting' | 'fleeing' | 'circling';\n  aggression: number;\n  nearMissTimer: number;\n  electricArcs: { x1: number; y1: number; x2: number; y2: number; life: number }[];\n}\n\nconst RIVAL_SNAKE_LENGTH = 10;\nconst RIVAL_MOVE_INTERVAL = 8;\n\n// Armageddon Chaos effect types\ninterface GroundFissure {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  width: number;\n  glowIntensity: number;\n  pulsePhase: number;\n}\n\ninterface FireRainParticle {\n  x: number;\n  y: number;\n  vy: number;\n  size: number;\n  alpha: number;\n  hue: number;\n  trail: { x: number; y: number; alpha: number }[];\n}\n\ninterface ChaosExplosion {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  life: number;\n  rings: { radius: number; alpha: number }[];\n  debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[];\n}\n\ninterface ApocalypticSkull {\n  x: number;\n  y: number;\n  size: number;\n  alpha: number;\n  rotation: number;\n  pulsePhase: number;\n}\n\nconst NUM_FISSURES = 6;\nconst MAX_FIRE_RAIN = 30;\nconst MAX_CHAOS_EXPLOSIONS = 3;\nconst NUM_SKULLS = 4;\n\n// High score entry for scoreboard\ninterface HighScoreEntry {\n  score: number;\n  date: number;\n  rank: number;\n}\n\nconst MAX_HIGH_SCORES = 5;\n\n// Color palette - HALLOWEEN theme: spooky purple/orange, ghostly greens, pumpkin glow\nconst COLORS = {\n  bgDark: 0x0a0012,\n  bgMid: 0x150825,\n  gridLine: 0x2a1540,\n  gridAccent: 0x401860,\n  snakeHead: 0x00ff66,\n  snakeBody: 0x00cc55,\n  snakeTail: 0x009944,\n  snakeHighlight: 0x66ffaa,\n  snakeScale: 0x00aa44,\n  snakeEye: 0xff0000,\n  snakePupil: 0x000000,\n  snakeGlow: 0x00ff80,\n  food: 0xff6600,\n  foodCore: 0xffcc00,\n  foodGlow: 0xff8800,\n  foodParticle: 0xffaa00,\n  star: 0x8844ff,\n  gameOverOverlay: 0x0a0015,\n  gameOverText: 0xff6600,\n  plasma1: 0x9933ff,\n  plasma2: 0xbb55ff,\n  plasma3: 0x7722cc,\n  screenFlash: 0xff6600,\n  // Halloween specific colors\n  noirWhite: 0xeeddff,\n  noirGray: 0x8866aa,\n  noirDark: 0x2a1540,\n  spotlight: 0xff8800,\n  // Halloween additions\n  chaosRed: 0x9933ff,\n  chaosOrange: 0xff6600,\n  chaosYellow: 0xffcc00,\n  lavaGlow: 0x9944ff,\n  ashGray: 0x554466,\n  bloodRed: 0x660088,\n  hellfire: 0xff6600,\n  // New Halloween colors\n  pumpkinOrange: 0xff6600,\n  ghostWhite: 0xeeffee,\n  witchPurple: 0x9933ff,\n  spiderBlack: 0x111122,\n  candyCorn1: 0xffcc00,\n  candyCorn2: 0xff8800,\n  candyCorn3: 0xffffff,\n};\n\nexport class SnakeScene extends Phaser.Scene {\n  private graphics!: Phaser.GameObjects.Graphics;\n  private currentState: GameState | null = null;\n  private needsRedraw = false;\n  private frameCount = 0;\n  private stars: Star[] = [];\n  private foodParticles: FoodParticle[] = [];\n  private trailParticles: SnakeTrailParticle[] = [];\n  private shockWaves: ShockWave[] = [];\n  private lightningBolts: LightningBolt[] = [];\n  private plasmaWaves: PlasmaWave[] = [];\n  private snakeAfterimages: SnakeAfterimage[] = [];\n  private auroraWaves: AuroraWave[] = [];\n  private nebulaClouds: NebulaCloud[] = [];\n  private vortexRings: VortexRing[] = [];\n  private vortexParticles: VortexParticle[] = [];\n  private vortexPulse = 0;\n  private meteors: Meteor[] = [];\n  private deathDebris: DeathDebris[] = [];\n  private deathExplosionPhase = 0;\n  private gameOverAlpha = 0;\n  private lastHeadPos: Position | null = null;\n  private lastSnakeLength = 0;\n  private hueOffset = 0;\n  private screenFlashAlpha = 0;\n  private gameOverGlitchOffset = 0;\n  private screenShakeX = 0;\n  private screenShakeY = 0;\n  private screenShakeIntensity = 0;\n  private energyFieldPulse = 0;\n  private foodBurstParticles: { x: number; y: number; vx: number; vy: number; life: number; size: number; hue: number; trail: { x: number; y: number }[] }[] = [];\n  private chromaticIntensity = 0;\n  // Film noir effects\n  private venetianPhase = 0;\n  private spotlightX = 0;\n  private spotlightY = 0;\n  private smokeParticles: { x: number; y: number; vx: number; vy: number; size: number; alpha: number; life: number }[] = [];\n  private guardianSpirits: GuardianSpirit[] = [];\n  // Burning flame particles trailing behind snake\n  private flameParticles: FlameParticle[] = [];\n  // Comet trail system - historical positions for smooth ribbon trail\n  private cometTrail: CometTrailSegment[] = [];\n  // Ethereal particles that drift away from the trail\n  private etherealParticles: EtherealParticle[] = [];\n  // Track last few head positions for smooth interpolation\n  private headHistory: { x: number; y: number; time: number }[] = [];\n  // Thrown food animation system\n  private thrownFood: ThrownFood | null = null;\n  private lastFoodPos: Position | null = null;\n  // Mystical bees swarming around\n  private bees: MysticalBee[] = [];\n  // Rival snake - spectral AI nemesis\n  private rivalSnake: RivalSnake | null = null;\n  // Scoreboard system\n  private highScores: HighScoreEntry[] = [];\n  private highScoresLoaded = false;\n  private newHighScoreRank = -1;\n  private scoreboardAnimPhase = 0;\n  private scoreboardRevealProgress = 0;\n  private lastGameOverState = false;\n  private hudPulsePhase = 0;\n  private lastHudScore = 0;\n  private scoreFlashIntensity = 0;\n  // Armageddon Chaos effects\n  private groundFissures: GroundFissure[] = [];\n  private fireRainParticles: FireRainParticle[] = [];\n  private chaosExplosions: ChaosExplosion[] = [];\n  private apocalypticSkulls: ApocalypticSkull[] = [];\n  private armageddonPulse = 0;\n  private chaosIntensity = 0;\n  private cleanEffects: CleanEffectsState = createCleanEffectsState();\n\n  constructor() {\n    super({ key: 'SnakeScene' });\n  }\n\n  create(): void {\n    this.graphics = this.add.graphics();\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    initMotes(this.cleanEffects, width, height);\n\n    if (this.currentState) {\n      this.needsRedraw = true;\n    }\n  }\n\n  private initArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Initialize ground fissures - cracks in the earth with lava\n    this.groundFissures = [];\n    for (let i = 0; i < NUM_FISSURES; i++) {\n      const startX = Math.random() * width;\n      const startY = Math.random() * height;\n      const angle = Math.random() * Math.PI;\n      const length = 40 + Math.random() * 80;\n      this.groundFissures.push({\n        x1: startX,\n        y1: startY,\n        x2: startX + Math.cos(angle) * length,\n        y2: startY + Math.sin(angle) * length,\n        width: 2 + Math.random() * 4,\n        glowIntensity: 0.5 + Math.random() * 0.5,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n\n    // Initialize fire rain\n    this.fireRainParticles = [];\n\n    // Initialize chaos explosions\n    this.chaosExplosions = [];\n\n    // Initialize apocalyptic skulls floating in background\n    this.apocalypticSkulls = [];\n    for (let i = 0; i < NUM_SKULLS; i++) {\n      this.apocalypticSkulls.push({\n        x: 30 + Math.random() * (width - 60),\n        y: 30 + Math.random() * (height - 60),\n        size: 15 + Math.random() * 10,\n        alpha: 0.03 + Math.random() * 0.04,\n        rotation: Math.random() * Math.PI * 2,\n        pulsePhase: Math.random() * Math.PI * 2,\n      });\n    }\n  }\n\n  private initSmokeParticles(): void {\n    this.smokeParticles = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < 12; i++) {\n      this.smokeParticles.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        vx: (Math.random() - 0.5) * 0.3,\n        vy: -0.1 - Math.random() * 0.2,\n        size: 30 + Math.random() * 50,\n        alpha: 0.02 + Math.random() * 0.03,\n        life: Math.random(),\n      });\n    }\n  }\n\n  private updateArmageddonEffects(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    this.armageddonPulse += 0.04;\n\n    // Update ground fissures - pulsing lava glow\n    for (const fissure of this.groundFissures) {\n      fissure.pulsePhase += 0.06;\n      fissure.glowIntensity = 0.5 + Math.sin(fissure.pulsePhase) * 0.3;\n    }\n\n    // Spawn fire rain particles\n    if (this.fireRainParticles.length < MAX_FIRE_RAIN && Math.random() < 0.3) {\n      const hueVariation = Math.random();\n      this.fireRainParticles.push({\n        x: Math.random() * width,\n        y: -20,\n        vy: 2 + Math.random() * 3,\n        size: 2 + Math.random() * 4,\n        alpha: 0.6 + Math.random() * 0.4,\n        hue: hueVariation < 0.6 ? 0 : (hueVariation < 0.85 ? 20 : 40), // Red, orange, yellow\n        trail: [],\n      });\n    }\n\n    // Update fire rain\n    for (let i = this.fireRainParticles.length - 1; i >= 0; i--) {\n      const p = this.fireRainParticles[i];\n      p.trail.unshift({ x: p.x, y: p.y, alpha: p.alpha });\n      if (p.trail.length > 6) p.trail.pop();\n      for (const t of p.trail) { t.alpha *= 0.7; }\n\n      p.y += p.vy;\n      p.x += Math.sin(this.armageddonPulse + p.y * 0.05) * 0.3;\n      p.alpha *= 0.995;\n\n      if (p.y > height + 20 || p.alpha < 0.05) {\n        this.fireRainParticles.splice(i, 1);\n      }\n    }\n\n    // Update chaos explosions\n    for (let i = this.chaosExplosions.length - 1; i >= 0; i--) {\n      const exp = this.chaosExplosions[i];\n      exp.radius += 4;\n      exp.life -= 0.03;\n\n      for (const ring of exp.rings) {\n        ring.radius += 3;\n        ring.alpha *= 0.92;\n      }\n      exp.rings = exp.rings.filter(r => r.alpha > 0.02);\n\n      for (const d of exp.debris) {\n        d.x += d.vx;\n        d.y += d.vy;\n        d.vy += 0.1;\n        d.alpha *= 0.96;\n      }\n      exp.debris = exp.debris.filter(d => d.alpha > 0.02);\n\n      if (exp.life <= 0 && exp.rings.length === 0 && exp.debris.length === 0) {\n        this.chaosExplosions.splice(i, 1);\n      }\n    }\n\n    // Update apocalyptic skulls - slow drift and pulse\n    for (const skull of this.apocalypticSkulls) {\n      skull.pulsePhase += 0.02;\n      skull.rotation += 0.002;\n      skull.x += Math.sin(skull.pulsePhase * 0.5) * 0.1;\n      skull.y += Math.cos(skull.pulsePhase * 0.3) * 0.1;\n\n      // Keep in bounds\n      if (skull.x < 20) skull.x = 20;\n      if (skull.x > width - 20) skull.x = width - 20;\n      if (skull.y < 20) skull.y = 20;\n      if (skull.y > height - 20) skull.y = height - 20;\n    }\n\n    // Chaos intensity increases when snake eats or dies\n    this.chaosIntensity *= 0.97;\n  }\n\n  private spawnChaosExplosion(x: number, y: number): void {\n    if (this.chaosExplosions.length >= MAX_CHAOS_EXPLOSIONS) {\n      this.chaosExplosions.shift();\n    }\n\n    const debris: { x: number; y: number; vx: number; vy: number; size: number; alpha: number }[] = [];\n    for (let i = 0; i < 12; i++) {\n      const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 5;\n      debris.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 2,\n        size: 2 + Math.random() * 4,\n        alpha: 1,\n      });\n    }\n\n    this.chaosExplosions.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: 80,\n      life: 1,\n      rings: [\n        { radius: 10, alpha: 1 },\n        { radius: 5, alpha: 0.8 },\n        { radius: 15, alpha: 0.6 },\n      ],\n      debris,\n    });\n\n    this.chaosIntensity = Math.min(1, this.chaosIntensity + 0.5);\n    this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 12);\n  }\n\n  private drawArmageddonBackground(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Spooky Halloween night sky\n    const skyPulse = 0.8 + Math.sin(this.armageddonPulse * 0.5) * 0.2;\n\n    // Layer 1: Deep purple-black night base\n    g.fillStyle(0x0a0018, 1);\n    g.fillRect(0, 0, width, height);\n\n    // Layer 2: Eerie purple glow from below (like fog)\n    g.fillStyle(0x200840, 0.3 * skyPulse);\n    g.fillRect(0, height * 0.7, width, height * 0.3);\n\n    // Layer 3: Misty purple clouds\n    for (let i = 0; i < 4; i++) {\n      const cloudY = i * 30 + Math.sin(this.armageddonPulse + i) * 10;\n      const cloudAlpha = 0.1 - i * 0.02;\n      g.fillStyle(0x301040, cloudAlpha * skyPulse);\n      g.fillRect(0, cloudY, width, 40);\n    }\n\n    // Draw haunted moon\n    this.drawHauntedMoon(g, width);\n\n    // Draw flying bats in background\n    this.drawFlyingBats(g, width, height);\n\n    // Draw apocalyptic skulls (very faint, background layer)\n    this.drawApocalypticSkulls(g);\n  }\n\n  private drawHauntedMoon(g: Phaser.GameObjects.Graphics, width: number): void {\n    const moonX = width * 0.8;\n    const moonY = 60;\n    const moonRadius = 35;\n    const moonPulse = 0.9 + Math.sin(this.frameCount * 0.02) * 0.1;\n\n    // Moon glow\n    g.fillStyle(0xff8800, 0.1 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 2);\n    g.fillStyle(0xffaa00, 0.15 * moonPulse);\n    g.fillCircle(moonX, moonY, moonRadius * 1.5);\n\n    // Main moon (orange harvest moon)\n    g.fillStyle(0xffaa33, 0.9);\n    g.fillCircle(moonX, moonY, moonRadius);\n\n    // Moon craters\n    g.fillStyle(0xcc8822, 0.4);\n    g.fillCircle(moonX - 10, moonY - 5, 8);\n    g.fillCircle(moonX + 12, moonY + 8, 6);\n    g.fillCircle(moonX - 5, moonY + 12, 5);\n  }\n\n  private drawFlyingBats(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const batCount = 6;\n    for (let i = 0; i < batCount; i++) {\n      const phase = this.frameCount * 0.03 + i * 1.5;\n      const batX = ((i * 127 + this.frameCount * 0.5) % (width + 100)) - 50;\n      const batY = 40 + i * 20 + Math.sin(phase) * 15;\n      const wingPhase = Math.sin(this.frameCount * 0.15 + i * 2);\n\n      // Bat body\n      g.fillStyle(0x111122, 0.8);\n      g.fillCircle(batX, batY, 4);\n\n      // Bat wings (flapping)\n      const wingSpread = 8 + wingPhase * 4;\n      g.fillStyle(0x111122, 0.7);\n\n      // Left wing\n      g.beginPath();\n      g.moveTo(batX - 2, batY);\n      g.lineTo(batX - wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX - wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n\n      // Right wing\n      g.beginPath();\n      g.moveTo(batX + 2, batY);\n      g.lineTo(batX + wingSpread, batY - wingPhase * 3);\n      g.lineTo(batX + wingSpread * 0.6, batY + 2);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawGroundFissures(g: Phaser.GameObjects.Graphics): void {\n    for (const fissure of this.groundFissures) {\n      const pulse = fissure.glowIntensity;\n\n      // Ghostly purple glow underneath\n      g.lineStyle(fissure.width * 3, COLORS.lavaGlow, 0.12 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Crack edges (dark purple)\n      g.lineStyle(fissure.width + 2, 0x200030, 0.4);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ethereal core (bright purple)\n      g.lineStyle(fissure.width, COLORS.witchPurple, 0.3 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n\n      // Ghostly white center\n      g.lineStyle(fissure.width * 0.3, COLORS.ghostWhite, 0.2 * pulse);\n      g.lineBetween(fissure.x1, fissure.y1, fissure.x2, fissure.y2);\n    }\n  }\n\n  private drawFireRain(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.fireRainParticles) {\n      // Draw ghostly trail\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailSize = p.size * (1 - i / p.trail.length) * 0.6;\n        // Ghostly purple/green trail\n        const ghostHue = 0.75 + (p.hue % 60) / 360;\n        const trailColor = this.hslToRgb(ghostHue, 0.6, 0.6);\n        g.fillStyle(trailColor, t.alpha * 0.3);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Main spirit particle (ghostly appearance)\n      const outerColor = this.hslToRgb(0.8, 0.5, 0.5);\n      const coreColor = this.hslToRgb(0.85, 0.3, 0.8);\n\n      g.fillStyle(outerColor, p.alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      g.fillStyle(coreColor, p.alpha * 0.6);\n      g.fillCircle(p.x, p.y, p.size);\n\n      g.fillStyle(COLORS.ghostWhite, p.alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawChaosExplosions(g: Phaser.GameObjects.Graphics): void {\n    for (const exp of this.chaosExplosions) {\n      // Central flash\n      if (exp.life > 0.7) {\n        const flashAlpha = (exp.life - 0.7) * 3;\n        g.fillStyle(0xffffff, flashAlpha * 0.5);\n        g.fillCircle(exp.x, exp.y, exp.radius * 0.5);\n        g.fillStyle(COLORS.chaosYellow, flashAlpha * 0.4);\n        g.fillCircle(exp.x, exp.y, exp.radius);\n      }\n\n      // Expanding rings\n      for (const ring of exp.rings) {\n        g.lineStyle(4, COLORS.chaosRed, ring.alpha * 0.5);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(2, COLORS.chaosOrange, ring.alpha * 0.7);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n        g.lineStyle(1, 0xffffff, ring.alpha * 0.4);\n        g.strokeCircle(exp.x, exp.y, ring.radius);\n      }\n\n      // Flying debris\n      for (const d of exp.debris) {\n        g.fillStyle(COLORS.chaosOrange, d.alpha * 0.6);\n        g.fillCircle(d.x, d.y, d.size * 1.3);\n        g.fillStyle(COLORS.chaosYellow, d.alpha * 0.9);\n        g.fillCircle(d.x, d.y, d.size);\n      }\n    }\n  }\n\n  private drawApocalypticSkulls(g: Phaser.GameObjects.Graphics): void {\n    for (const skull of this.apocalypticSkulls) {\n      const pulse = 0.7 + Math.sin(skull.pulsePhase) * 0.3;\n      const alpha = skull.alpha * pulse;\n      const s = skull.size;\n\n      // Ghostly purple glow\n      g.fillStyle(COLORS.witchPurple, alpha * 0.2);\n      g.fillCircle(skull.x, skull.y, s * 1.5);\n\n      // Skull outline (bone white)\n      g.fillStyle(0xcccccc, alpha * 0.8);\n      // Cranium\n      g.fillCircle(skull.x, skull.y - s * 0.1, s * 0.8);\n      // Jaw\n      g.fillRect(skull.x - s * 0.4, skull.y + s * 0.3, s * 0.8, s * 0.4);\n\n      // Eye sockets (glowing green - spooky!)\n      g.fillStyle(COLORS.snakeHead, alpha * 1.2);\n      g.fillCircle(skull.x - s * 0.25, skull.y - s * 0.1, s * 0.2);\n      g.fillCircle(skull.x + s * 0.25, skull.y - s * 0.1, s * 0.2);\n\n      // Nose hole\n      g.fillStyle(0x000000, alpha);\n      g.fillTriangle(\n        skull.x, skull.y + s * 0.1,\n        skull.x - s * 0.1, skull.y + s * 0.25,\n        skull.x + s * 0.1, skull.y + s * 0.25\n      );\n    }\n  }\n\n  private drawChaosOverlay(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (this.chaosIntensity <= 0) return;\n\n    // Purple tint overlay when chaos is active\n    g.fillStyle(COLORS.witchPurple, this.chaosIntensity * 0.1);\n    g.fillRect(0, 0, width, height);\n\n    // Pulsing purple vignette edges\n    const vignetteAlpha = this.chaosIntensity * 0.25;\n    g.lineStyle(80, COLORS.bloodRed, vignetteAlpha);\n    g.strokeRect(-40, -40, width + 80, height + 80);\n  }\n\n  private initGuardianSpirits(): void {\n    this.guardianSpirits = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const spiritHues = [180, 220, 280, 320];\n\n    const edges: ('top' | 'bottom' | 'left' | 'right')[] = ['top', 'bottom', 'left', 'right'];\n    for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      const edge = edges[edgeIndex];\n      for (let i = 0; i < NUM_SPIRITS_PER_EDGE; i++) {\n        let x = 0, y = 0;\n        const offset = (i + 0.5) / NUM_SPIRITS_PER_EDGE;\n\n        switch (edge) {\n          case 'top':\n            x = width * offset;\n            y = -15;\n            break;\n          case 'bottom':\n            x = width * offset;\n            y = height + 15;\n            break;\n          case 'left':\n            x = -15;\n            y = height * offset;\n            break;\n          case 'right':\n            x = width + 15;\n            y = height * offset;\n            break;\n        }\n\n        const orbs: { angle: number; distance: number; size: number; speed: number }[] = [];\n        const numOrbs = 3;\n        for (let o = 0; o < numOrbs; o++) {\n          orbs.push({\n            angle: (o / numOrbs) * Math.PI * 2,\n            distance: 15 + Math.random() * 10,\n            size: 3 + Math.random() * 2,\n            speed: 0.03 + Math.random() * 0.02,\n          });\n        }\n\n        this.guardianSpirits.push({\n          x,\n          y,\n          baseX: x,\n          baseY: y,\n          size: 20 + Math.random() * 10,\n          phase: Math.random() * Math.PI * 2,\n          speed: 0.015 + Math.random() * 0.01,\n          haloPhase: Math.random() * Math.PI * 2,\n          orbPhase: Math.random() * Math.PI * 2,\n          edge,\n          targetAlpha: 0.4 + Math.random() * 0.2,\n          currentAlpha: 0,\n          hue: spiritHues[edgeIndex % spiritHues.length] + Math.random() * 30 - 15,\n          orbs,\n        });\n      }\n    }\n  }\n\n  private initBees(): void {\n    this.bees = [];\n  }\n\n  private initRivalSnake(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    const startX = width - 50 - Math.random() * 50;\n    const startY = height - 50 - Math.random() * 50;\n\n    const segments: { x: number; y: number }[] = [];\n    for (let i = 0; i < RIVAL_SNAKE_LENGTH; i++) {\n      segments.push({\n        x: startX + i * CELL_SIZE * 0.6,\n        y: startY,\n      });\n    }\n\n    this.rivalSnake = {\n      segments,\n      direction: { dx: -1, dy: 0 },\n      targetX: width / 2,\n      targetY: height / 2,\n      moveTimer: 0,\n      moveInterval: RIVAL_MOVE_INTERVAL,\n      pulsePhase: 0,\n      glowIntensity: 0.8,\n      hue: 200,\n      trail: [],\n      energyTrail: [],\n      state: 'hunting',\n      aggression: 0.5,\n      nearMissTimer: 0,\n      electricArcs: [],\n    };\n  }\n\n  private updateRivalSnake(): void {\n    if (!this.rivalSnake || !this.currentState) return;\n\n    const rs = this.rivalSnake;\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    rs.pulsePhase += 0.1;\n    rs.glowIntensity = 0.6 + Math.sin(rs.pulsePhase) * 0.3;\n\n    if (rs.segments.length > 0) {\n      rs.trail.unshift({ x: rs.segments[0].x, y: rs.segments[0].y, alpha: 0.7 });\n      if (rs.trail.length > 20) rs.trail.pop();\n\n      rs.energyTrail.unshift({\n        x: rs.segments[0].x + (Math.random() - 0.5) * 8,\n        y: rs.segments[0].y + (Math.random() - 0.5) * 8,\n        alpha: 0.8,\n        size: 3 + Math.random() * 4\n      });\n      if (rs.energyTrail.length > 30) rs.energyTrail.pop();\n    }\n\n    for (const t of rs.trail) {\n      t.alpha *= 0.92;\n    }\n    rs.trail = rs.trail.filter(t => t.alpha > 0.02);\n\n    for (const e of rs.energyTrail) {\n      e.alpha *= 0.88;\n      e.size *= 0.95;\n    }\n    rs.energyTrail = rs.energyTrail.filter(e => e.alpha > 0.02);\n\n    rs.electricArcs = rs.electricArcs.filter(arc => {\n      arc.life -= 0.15;\n      return arc.life > 0;\n    });\n\n    if (rs.nearMissTimer > 0) rs.nearMissTimer--;\n\n    const playerHead = this.currentState.snake[0];\n    const playerX = playerHead.x * CELL_SIZE + CELL_SIZE / 2;\n    const playerY = playerHead.y * CELL_SIZE + CELL_SIZE / 2;\n    const rivalHead = rs.segments[0];\n    const distToPlayer = Math.sqrt(\n      Math.pow(playerX - rivalHead.x, 2) + Math.pow(playerY - rivalHead.y, 2)\n    );\n\n    if (distToPlayer < 60 && rs.nearMissTimer === 0) {\n      rs.nearMissTimer = 30;\n      rs.electricArcs.push({\n        x1: rivalHead.x,\n        y1: rivalHead.y,\n        x2: playerX,\n        y2: playerY,\n        life: 1.0\n      });\n      rs.aggression = Math.min(1.0, rs.aggression + 0.1);\n    }\n\n    rs.moveTimer++;\n    if (rs.moveTimer >= rs.moveInterval) {\n      rs.moveTimer = 0;\n\n      const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n      const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n      const distToFood = Math.sqrt(\n        Math.pow(foodX - rivalHead.x, 2) + Math.pow(foodY - rivalHead.y, 2)\n      );\n\n      if (distToPlayer < 80) {\n        rs.state = 'fleeing';\n        const fleeAngle = Math.atan2(rivalHead.y - playerY, rivalHead.x - playerX);\n        rs.targetX = rivalHead.x + Math.cos(fleeAngle) * 100;\n        rs.targetY = rivalHead.y + Math.sin(fleeAngle) * 100;\n      } else if (distToFood < 150 || rs.aggression > 0.7) {\n        rs.state = 'hunting';\n        rs.targetX = foodX;\n        rs.targetY = foodY;\n      } else {\n        rs.state = 'circling';\n        const circleAngle = rs.pulsePhase * 0.3;\n        rs.targetX = width / 2 + Math.cos(circleAngle) * 120;\n        rs.targetY = height / 2 + Math.sin(circleAngle) * 120;\n      }\n\n      rs.targetX = Math.max(30, Math.min(width - 30, rs.targetX));\n      rs.targetY = Math.max(30, Math.min(height - 30, rs.targetY));\n\n      const dx = rs.targetX - rivalHead.x;\n      const dy = rs.targetY - rivalHead.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 5) {\n        const targetDx = dx / dist;\n        const targetDy = dy / dist;\n        const turnSpeed = rs.state === 'fleeing' ? 0.5 : 0.35;\n\n        rs.direction.dx = rs.direction.dx * (1 - turnSpeed) + targetDx * turnSpeed;\n        rs.direction.dy = rs.direction.dy * (1 - turnSpeed) + targetDy * turnSpeed;\n\n        const len = Math.sqrt(rs.direction.dx * rs.direction.dx + rs.direction.dy * rs.direction.dy);\n        if (len > 0) {\n          rs.direction.dx /= len;\n          rs.direction.dy /= len;\n        }\n      }\n\n      const moveSpeed = rs.state === 'fleeing' ? CELL_SIZE * 0.7 : CELL_SIZE * 0.55;\n      const newHead = {\n        x: rivalHead.x + rs.direction.dx * moveSpeed,\n        y: rivalHead.y + rs.direction.dy * moveSpeed,\n      };\n\n      if (newHead.x < 10) newHead.x = width - 10;\n      if (newHead.x > width - 10) newHead.x = 10;\n      if (newHead.y < 10) newHead.y = height - 10;\n      if (newHead.y > height - 10) newHead.y = 10;\n\n      rs.segments.unshift(newHead);\n      rs.segments.pop();\n    } else {\n      const head = rs.segments[0];\n      const moveSpeed = CELL_SIZE * 0.5;\n\n      head.x += rs.direction.dx * moveSpeed * 0.06;\n      head.y += rs.direction.dy * moveSpeed * 0.06;\n\n      for (let i = 1; i < rs.segments.length; i++) {\n        const seg = rs.segments[i];\n        const prev = rs.segments[i - 1];\n        const pullStrength = 0.18;\n        seg.x += (prev.x - seg.x) * pullStrength;\n        seg.y += (prev.y - seg.y) * pullStrength;\n      }\n    }\n\n    if (this.currentState.gameOver) {\n      rs.hue = 180;\n      rs.glowIntensity *= 0.95;\n      rs.state = 'circling';\n    } else {\n      rs.hue = rs.state === 'hunting' ? 190 : (rs.state === 'fleeing' ? 220 : 200);\n      rs.hue += Math.sin(rs.pulsePhase * 0.5) * 10;\n    }\n\n    rs.aggression *= 0.998;\n  }\n\n  private drawRivalSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.rivalSnake || this.rivalSnake.segments.length === 0) return;\n\n    const rs = this.rivalSnake;\n    const pulse = rs.glowIntensity;\n\n    for (const arc of rs.electricArcs) {\n      this.drawElectricArc(g, arc.x1, arc.y1, arc.x2, arc.y2, arc.life);\n    }\n\n    for (const e of rs.energyTrail) {\n      g.fillStyle(this.hslToHex(rs.hue + 20, 80, 70), e.alpha * 0.6);\n      g.fillCircle(e.x, e.y, e.size);\n      g.fillStyle(this.hslToHex(rs.hue, 90, 85), e.alpha * 0.3);\n      g.fillCircle(e.x, e.y, e.size * 0.5);\n    }\n\n    for (let i = 0; i < rs.trail.length; i++) {\n      const t = rs.trail[i];\n      const trailSize = 5 * (1 - i / rs.trail.length);\n      g.fillStyle(this.hslToHex(rs.hue, 80, 55), t.alpha * 0.4);\n      g.fillCircle(t.x, t.y, trailSize * 2);\n      g.fillStyle(this.hslToHex(rs.hue + 30, 70, 70), t.alpha * 0.2);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    g.lineStyle(14, this.hslToHex(rs.hue, 70, 40), 0.2 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    g.lineStyle(8, this.hslToHex(rs.hue, 80, 55), 0.35 * pulse);\n    g.beginPath();\n    g.moveTo(rs.segments[0].x, rs.segments[0].y);\n    for (let i = 1; i < rs.segments.length; i++) {\n      g.lineTo(rs.segments[i].x, rs.segments[i].y);\n    }\n    g.strokePath();\n\n    for (let i = rs.segments.length - 1; i >= 0; i--) {\n      const seg = rs.segments[i];\n      const t = rs.segments.length > 1 ? i / (rs.segments.length - 1) : 1;\n      const segmentPulse = pulse * (0.8 + Math.sin(rs.pulsePhase + i * 0.4) * 0.2);\n\n      const baseSize = 7 + t * 5;\n      const size = baseSize * (0.9 + segmentPulse * 0.15);\n\n      g.fillStyle(this.hslToHex(rs.hue - 10, 60, 35), 0.15 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 2.8);\n\n      g.fillStyle(this.hslToHex(rs.hue, 75, 50), 0.3 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 1.6);\n\n      g.fillStyle(this.hslToHex(rs.hue + 10, 85, 65), 0.6 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size);\n\n      g.fillStyle(this.hslToHex(rs.hue + 40, 60, 90), 0.5 * segmentPulse);\n      g.fillCircle(seg.x, seg.y, size * 0.35);\n\n      if (i === 0) {\n        const dx = rs.direction.dx;\n        const dy = rs.direction.dy;\n        const perpX = -dy;\n        const perpY = dx;\n\n        g.fillStyle(this.hslToHex(rs.hue, 90, 70), 0.3);\n        g.fillCircle(seg.x - dx * 3, seg.y - dy * 3, size * 1.8);\n\n        const eyeOffset = 4;\n        const eyeForward = 5;\n        const leftEyeX = seg.x + perpX * eyeOffset + dx * eyeForward;\n        const leftEyeY = seg.y + perpY * eyeOffset + dy * eyeForward;\n        const rightEyeX = seg.x - perpX * eyeOffset + dx * eyeForward;\n        const rightEyeY = seg.y - perpY * eyeOffset + dy * eyeForward;\n\n        const eyeColor = rs.state === 'hunting' ? 0xff4444 :\n                         rs.state === 'fleeing' ? 0xffff44 : 0x44ffff;\n\n        g.fillStyle(0x000000, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 4);\n        g.fillCircle(rightEyeX, rightEyeY, 4);\n\n        g.fillStyle(eyeColor, 0.9 * segmentPulse);\n        g.fillCircle(leftEyeX, leftEyeY, 3);\n        g.fillCircle(rightEyeX, rightEyeY, 3);\n\n        g.fillStyle(0xffffff, 0.95 * segmentPulse);\n        g.fillCircle(leftEyeX + dx, leftEyeY + dy, 1.2);\n        g.fillCircle(rightEyeX + dx, rightEyeY + dy, 1.2);\n\n        const hornLength = 8;\n        const hornAngle = 0.4;\n        g.lineStyle(3, this.hslToHex(rs.hue - 20, 70, 45), 0.8 * segmentPulse);\n        g.beginPath();\n        g.moveTo(seg.x + perpX * 5, seg.y + perpY * 5);\n        g.lineTo(\n          seg.x + perpX * 5 + Math.cos(Math.atan2(dy, dx) - hornAngle) * hornLength,\n          seg.y + perpY * 5 + Math.sin(Math.atan2(dy, dx) - hornAngle) * hornLength\n        );\n        g.strokePath();\n        g.beginPath();\n        g.moveTo(seg.x - perpX * 5, seg.y - perpY * 5);\n        g.lineTo(\n          seg.x - perpX * 5 + Math.cos(Math.atan2(dy, dx) + hornAngle) * hornLength,\n          seg.y - perpY * 5 + Math.sin(Math.atan2(dy, dx) + hornAngle) * hornLength\n        );\n        g.strokePath();\n      }\n    }\n  }\n\n  private drawElectricArc(g: Phaser.GameObjects.Graphics, x1: number, y1: number, x2: number, y2: number, life: number): void {\n    const segments = 6;\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n    const jitter = 15 * life;\n\n    g.lineStyle(4, 0x00ffff, 0.2 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter;\n      const jy = (Math.random() - 0.5) * jitter;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(2, 0x88ffff, 0.5 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    for (let i = 1; i < segments; i++) {\n      const jx = (Math.random() - 0.5) * jitter * 0.5;\n      const jy = (Math.random() - 0.5) * jitter * 0.5;\n      g.lineTo(x1 + dx * i + jx, y1 + dy * i + jy);\n    }\n    g.lineTo(x2, y2);\n    g.strokePath();\n\n    g.lineStyle(1, 0xffffff, 0.8 * life);\n    g.beginPath();\n    g.moveTo(x1, y1);\n    g.lineTo(x2, y2);\n    g.strokePath();\n  }\n\n  private spawnBee(): void {\n    if (this.bees.length >= NUM_BEES) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n\n    // Spawn from random edge\n    const edge = Math.floor(Math.random() * 4);\n    let x: number, y: number;\n\n    switch (edge) {\n      case 0: // top\n        x = Math.random() * width;\n        y = -20;\n        break;\n      case 1: // right\n        x = width + 20;\n        y = Math.random() * height;\n        break;\n      case 2: // bottom\n        x = Math.random() * width;\n        y = height + 20;\n        break;\n      default: // left\n        x = -20;\n        y = Math.random() * height;\n        break;\n    }\n\n    // Random target inside the play area\n    const targetX = 50 + Math.random() * (width - 100);\n    const targetY = 50 + Math.random() * (height - 100);\n\n    this.bees.push({\n      x,\n      y,\n      vx: 0,\n      vy: 0,\n      targetX,\n      targetY,\n      wingPhase: Math.random() * Math.PI * 2,\n      wingSpeed: 0.4 + Math.random() * 0.2,\n      size: 6 + Math.random() * 3,\n      hue: 0 + Math.random() * 20, // Crimson/red volcanic color\n      glowIntensity: 0.5 + Math.random() * 0.5,\n      bobPhase: Math.random() * Math.PI * 2,\n      bobSpeed: 0.08 + Math.random() * 0.04,\n      trail: [],\n      state: 'flying',\n      sparkleTimer: 0,\n    });\n  }\n\n  private updateBees(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const foodX = this.currentState.food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = this.currentState.food.y * CELL_SIZE + CELL_SIZE / 2;\n    const gameOver = this.currentState.gameOver;\n\n    // Randomly spawn new bees\n    if (!gameOver && Math.random() < BEE_SPAWN_CHANCE && this.bees.length < NUM_BEES) {\n      this.spawnBee();\n    }\n\n    for (let i = this.bees.length - 1; i >= 0; i--) {\n      const bee = this.bees[i];\n\n      // Update wing animation\n      bee.wingPhase += bee.wingSpeed;\n      bee.bobPhase += bee.bobSpeed;\n      bee.sparkleTimer += 0.1;\n\n      // Store trail position\n      if (this.frameCount % 2 === 0) {\n        bee.trail.unshift({ x: bee.x, y: bee.y, alpha: 0.6 });\n        if (bee.trail.length > 8) bee.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of bee.trail) {\n        t.alpha *= 0.85;\n      }\n      bee.trail = bee.trail.filter(t => t.alpha > 0.05);\n\n      // Bees are attracted to food\n      const dxFood = foodX - bee.x;\n      const dyFood = foodY - bee.y;\n      const distFood = Math.sqrt(dxFood * dxFood + dyFood * dyFood);\n\n      // Determine behavior based on distance to food\n      if (distFood < 80) {\n        bee.state = 'attracted';\n        bee.targetX = foodX + Math.cos(bee.bobPhase * 3) * 30;\n        bee.targetY = foodY + Math.sin(bee.bobPhase * 3) * 30;\n      } else if (distFood < 150) {\n        bee.state = 'hovering';\n        // Circle around food loosely\n        const angle = Math.atan2(dyFood, dxFood) + Math.sin(bee.bobPhase) * 0.5;\n        bee.targetX = foodX - Math.cos(angle) * 60;\n        bee.targetY = foodY - Math.sin(angle) * 60;\n      } else {\n        bee.state = 'flying';\n        // Wander towards food with some randomness\n        if (Math.random() < 0.02) {\n          bee.targetX = foodX + (Math.random() - 0.5) * 200;\n          bee.targetY = foodY + (Math.random() - 0.5) * 200;\n        }\n      }\n\n      // Move towards target with smooth steering\n      const dx = bee.targetX - bee.x;\n      const dy = bee.targetY - bee.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 1) {\n        const speed = bee.state === 'attracted' ? 2.5 : (bee.state === 'hovering' ? 1.5 : 2);\n        const ax = (dx / dist) * speed * 0.1;\n        const ay = (dy / dist) * speed * 0.1;\n\n        bee.vx += ax;\n        bee.vy += ay;\n\n        // Add bobbing motion\n        bee.vy += Math.sin(bee.bobPhase) * 0.05;\n      }\n\n      // Limit velocity\n      const maxSpeed = bee.state === 'attracted' ? 3 : 2;\n      const currentSpeed = Math.sqrt(bee.vx * bee.vx + bee.vy * bee.vy);\n      if (currentSpeed > maxSpeed) {\n        bee.vx = (bee.vx / currentSpeed) * maxSpeed;\n        bee.vy = (bee.vy / currentSpeed) * maxSpeed;\n      }\n\n      // Apply velocity with damping\n      bee.x += bee.vx;\n      bee.y += bee.vy;\n      bee.vx *= 0.95;\n      bee.vy *= 0.95;\n\n      // Pulsing glow when near food\n      if (bee.state === 'attracted') {\n        bee.glowIntensity = 0.7 + Math.sin(bee.bobPhase * 4) * 0.3;\n      } else {\n        bee.glowIntensity = 0.5 + Math.sin(bee.bobPhase * 2) * 0.2;\n      }\n\n      // Remove bees that fly too far off screen\n      if (bee.x < -100 || bee.x > width + 100 || bee.y < -100 || bee.y > height + 100) {\n        this.bees.splice(i, 1);\n      }\n\n      // Scatter bees on game over\n      if (gameOver) {\n        bee.targetX = bee.x + (Math.random() - 0.5) * 400;\n        bee.targetY = bee.y - 200 - Math.random() * 200;\n        bee.vx += (Math.random() - 0.5) * 2;\n        bee.vy -= 1 + Math.random();\n      }\n    }\n  }\n\n  private drawBees(g: Phaser.GameObjects.Graphics): void {\n    for (const bee of this.bees) {\n      const { x, y, size, wingPhase, hue, glowIntensity, trail, state, sparkleTimer } = bee;\n\n      // Draw trail\n      for (let i = 0; i < trail.length; i++) {\n        const t = trail[i];\n        const trailSize = size * 0.4 * (1 - i / trail.length);\n        g.fillStyle(this.hslToHex(hue, 80, 60), t.alpha * 0.4);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      const glowSize = size * 2 * glowIntensity;\n      g.fillStyle(this.hslToHex(hue, 90, 50), 0.2 * glowIntensity);\n      g.fillCircle(x, y, glowSize);\n\n      // Mid glow\n      g.fillStyle(this.hslToHex(hue, 85, 60), 0.3 * glowIntensity);\n      g.fillCircle(x, y, glowSize * 0.6);\n\n      // Bee body - striped pattern\n      const bodyLength = size * 1.2;\n      const bodyWidth = size * 0.7;\n\n      // Body shadow/glow\n      g.fillStyle(this.hslToHex(hue, 70, 30), 0.5);\n      g.fillEllipse(x, y, bodyLength + 2, bodyWidth + 2);\n\n      // Main body (amber/golden)\n      g.fillStyle(this.hslToHex(hue, 90, 55), 1);\n      g.fillEllipse(x, y, bodyLength, bodyWidth);\n\n      // Dark stripes\n      g.fillStyle(0x1a1a1a, 0.8);\n      g.fillRect(x - bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n      g.fillRect(x + bodyLength * 0.15, y - bodyWidth / 2, bodyLength * 0.15, bodyWidth);\n\n      // Head\n      g.fillStyle(this.hslToHex(hue - 10, 80, 40), 1);\n      g.fillCircle(x - bodyLength * 0.4, y, size * 0.4);\n\n      // Wings - animated flutter\n      const wingAngle = Math.sin(wingPhase) * 0.8;\n      const wingSize = size * 0.9;\n\n      // Wing glow (ethereal effect)\n      g.fillStyle(0xffffff, 0.2 + Math.abs(Math.sin(wingPhase)) * 0.2);\n      g.fillEllipse(x + Math.cos(wingAngle + 0.5) * wingSize * 0.3, y - wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n      g.fillEllipse(x + Math.cos(-wingAngle + 0.5) * wingSize * 0.3, y + wingSize * 0.5, wingSize * 0.8, wingSize * 0.4);\n\n      // Wing bodies\n      g.fillStyle(0xffffff, 0.5 + Math.abs(Math.sin(wingPhase)) * 0.3);\n      g.fillEllipse(x + Math.cos(wingAngle) * wingSize * 0.2, y - wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n      g.fillEllipse(x + Math.cos(-wingAngle) * wingSize * 0.2, y + wingSize * 0.4, wingSize * 0.6, wingSize * 0.3);\n\n      // Eyes\n      g.fillStyle(0x000000, 1);\n      g.fillCircle(x - bodyLength * 0.45, y - size * 0.12, size * 0.12);\n      g.fillCircle(x - bodyLength * 0.45, y + size * 0.12, size * 0.12);\n\n      // Sparkles when attracted to food\n      if (state === 'attracted' && Math.sin(sparkleTimer * 3) > 0.7) {\n        const sparkleAngle = sparkleTimer * 2;\n        const sparkleDist = size * 1.5;\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n\n        g.fillStyle(0xffffff, 0.8);\n        g.fillCircle(sparkleX, sparkleY, 2);\n        g.fillStyle(this.hslToHex(hue, 100, 80), 0.6);\n        g.fillCircle(sparkleX, sparkleY, 3);\n      }\n    }\n  }\n\n  // Helper to convert HSL to hex for Phaser\n  private hslToHex(h: number, s: number, l: number): number {\n    h = h / 360;\n    s = s / 100;\n    l = l / 100;\n\n    let r: number, g: number, b: number;\n\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    return (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255);\n  }\n\n  private updateGuardianSpirits(): void {\n    if (!this.currentState) return;\n\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const gameOver = this.currentState.gameOver;\n    const snakeHead = this.currentState.snake.length > 0 ? this.currentState.snake[0] : null;\n\n    for (const spirit of this.guardianSpirits) {\n      spirit.phase += spirit.speed;\n      spirit.haloPhase += 0.04;\n      spirit.orbPhase += 0.02;\n\n      for (const orb of spirit.orbs) {\n        orb.angle += orb.speed;\n      }\n\n      const floatAmount = gameOver ? 20 : 12;\n      const waveAmount = 5;\n      const wave = Math.sin(spirit.phase) * waveAmount;\n\n      let targetX = spirit.baseX;\n      let targetY = spirit.baseY;\n\n      switch (spirit.edge) {\n        case 'top':\n          targetY = spirit.baseY + floatAmount + wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'bottom':\n          targetY = spirit.baseY - floatAmount - wave;\n          targetX = spirit.baseX + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'left':\n          targetX = spirit.baseX + floatAmount + wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n        case 'right':\n          targetX = spirit.baseX - floatAmount - wave;\n          targetY = spirit.baseY + Math.sin(spirit.phase * 0.7) * 8;\n          break;\n      }\n\n      if (snakeHead && !gameOver) {\n        const headX = snakeHead.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = snakeHead.y * CELL_SIZE + CELL_SIZE / 2;\n        const dx = spirit.x - headX;\n        const dy = spirit.y - headY;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        if (dist < 120) {\n          const attraction = (120 - dist) / 120 * 15;\n          targetX += (dx / dist) * attraction;\n          targetY += (dy / dist) * attraction;\n        }\n      }\n\n      spirit.x += (targetX - spirit.x) * 0.04;\n      spirit.y += (targetY - spirit.y) * 0.04;\n      spirit.x = Math.max(-50, Math.min(width + 50, spirit.x));\n      spirit.y = Math.max(-50, Math.min(height + 50, spirit.y));\n\n      const baseAlpha = gameOver ? 0.8 : spirit.targetAlpha;\n      spirit.currentAlpha += (baseAlpha - spirit.currentAlpha) * 0.05;\n    }\n  }\n\n  private drawGuardianSpirits(g: Phaser.GameObjects.Graphics): void {\n    for (const spirit of this.guardianSpirits) {\n      if (spirit.currentAlpha < 0.01) continue;\n\n      const { x, y, size, phase, haloPhase, currentAlpha, hue, orbs } = spirit;\n      const breathPulse = 1 + Math.sin(phase * 2) * 0.15;\n      const coreSize = size * breathPulse;\n\n      const spiritColor = this.hslToHex(hue, 0.7, 0.6);\n      const glowColor = this.hslToHex(hue, 0.5, 0.8);\n      const haloColor = this.hslToHex(hue, 0.3, 0.9);\n\n      g.fillStyle(glowColor, currentAlpha * 0.1);\n      g.fillCircle(x, y, coreSize * 2.5);\n\n      g.fillStyle(glowColor, currentAlpha * 0.15);\n      g.fillCircle(x, y, coreSize * 1.8);\n\n      const haloRadius = coreSize * 1.4 + Math.sin(haloPhase) * 3;\n      g.lineStyle(2, haloColor, currentAlpha * 0.4);\n      g.strokeCircle(x, y, haloRadius);\n\n      const innerHaloRadius = coreSize * 1.1 + Math.sin(haloPhase + 1) * 2;\n      g.lineStyle(1.5, haloColor, currentAlpha * 0.3);\n      g.strokeCircle(x, y, innerHaloRadius);\n\n      for (const orb of orbs) {\n        const orbX = x + Math.cos(orb.angle) * orb.distance;\n        const orbY = y + Math.sin(orb.angle) * orb.distance;\n        const orbPulse = 1 + Math.sin(phase + orb.angle) * 0.3;\n\n        g.fillStyle(glowColor, currentAlpha * 0.3);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse * 1.5);\n\n        g.fillStyle(spiritColor, currentAlpha * 0.8);\n        g.fillCircle(orbX, orbY, orb.size * orbPulse);\n      }\n\n      g.fillStyle(spiritColor, currentAlpha * 0.9);\n      g.fillCircle(x, y, coreSize * 0.5);\n\n      g.fillStyle(0xffffff, currentAlpha * 0.7);\n      g.fillCircle(x, y, coreSize * 0.25);\n\n      const sparkleCount = 4;\n      for (let i = 0; i < sparkleCount; i++) {\n        const sparkleAngle = (i / sparkleCount) * Math.PI * 2 + phase * 0.5;\n        const sparkleDist = coreSize * (0.8 + Math.sin(phase * 2 + i) * 0.3);\n        const sparkleX = x + Math.cos(sparkleAngle) * sparkleDist;\n        const sparkleY = y + Math.sin(sparkleAngle) * sparkleDist;\n        const sparkleSize = 1.5 + Math.sin(phase * 3 + i * 2) * 0.5;\n\n        g.fillStyle(0xffffff, currentAlpha * (0.4 + Math.sin(phase * 2 + i) * 0.3));\n        g.fillCircle(sparkleX, sparkleY, sparkleSize);\n      }\n    }\n  }\n\n  private initStars(): void {\n    this.stars = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_STARS; i++) {\n      this.stars.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: 0.5 + Math.random() * 1.5,\n        speed: 0.02 + Math.random() * 0.03,\n        brightness: 0.3 + Math.random() * 0.7,\n      });\n    }\n  }\n\n  private initPlasmaWaves(): void {\n    this.plasmaWaves = [];\n    const hues = [0, 15, 30]; // Red/orange volcanic variations\n    for (let i = 0; i < NUM_PLASMA_WAVES; i++) {\n      this.plasmaWaves.push({\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.015 + Math.random() * 0.01,\n        amplitude: 30 + Math.random() * 20,\n        wavelength: 80 + Math.random() * 40,\n        hue: hues[i % hues.length],\n      });\n    }\n  }\n\n  private initAuroraWaves(): void {\n    this.auroraWaves = [];\n    const height = GRID_SIZE * CELL_SIZE;\n    // Aurora hues: volcanic reds, oranges, crimsons\n    const auroraHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_AURORA_WAVES; i++) {\n      this.auroraWaves.push({\n        y: height * 0.2 + (height * 0.6 * i) / NUM_AURORA_WAVES,\n        phase: Math.random() * Math.PI * 2,\n        speed: 0.008 + Math.random() * 0.006,\n        hue: auroraHues[i % auroraHues.length],\n        thickness: 25 + Math.random() * 20,\n        amplitude: 15 + Math.random() * 25,\n      });\n    }\n  }\n\n  private initNebulaClouds(): void {\n    this.nebulaClouds = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    // Volcanic smoke and lava glow colors: reds, oranges, crimsons\n    const nebulaHues = [0, 10, 20, 30, 350, 340];\n    for (let i = 0; i < NUM_NEBULA_CLOUDS; i++) {\n      this.nebulaClouds.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        radius: 40 + Math.random() * 60,\n        hue: nebulaHues[i % nebulaHues.length],\n        alpha: 0.04 + Math.random() * 0.04,\n        driftX: (Math.random() - 0.5) * 0.15,\n        driftY: (Math.random() - 0.5) * 0.15,\n        pulsePhase: Math.random() * Math.PI * 2,\n        pulseSpeed: 0.01 + Math.random() * 0.01,\n      });\n    }\n  }\n\n  private initVortex(): void {\n    this.vortexRings = [];\n    this.vortexParticles = [];\n\n    // Create concentric rings with different properties\n    const ringHues = [0, 10, 20, 30, 350];\n    for (let i = 0; i < NUM_VORTEX_RINGS; i++) {\n      const baseRadius = 25 + i * 18;\n      this.vortexRings.push({\n        radius: baseRadius,\n        baseRadius,\n        rotationOffset: (i * Math.PI * 2) / NUM_VORTEX_RINGS,\n        rotationSpeed: 0.02 - i * 0.003,\n        thickness: 2 + (NUM_VORTEX_RINGS - i) * 0.5,\n        hue: ringHues[i % ringHues.length],\n        pulsePhase: i * 0.5,\n      });\n    }\n\n    // Create orbiting particles\n    for (let i = 0; i < NUM_VORTEX_PARTICLES; i++) {\n      const baseRadius = 20 + Math.random() * 80;\n      this.vortexParticles.push({\n        angle: Math.random() * Math.PI * 2,\n        radius: baseRadius,\n        baseRadius,\n        speed: 0.02 + Math.random() * 0.03,\n        size: 1 + Math.random() * 2,\n        hue: Math.random() * 360,\n        alpha: 0.3 + Math.random() * 0.5,\n      });\n    }\n  }\n\n  private initMeteors(): void {\n    this.meteors = [];\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (let i = 0; i < NUM_METEORS; i++) {\n      this.spawnMeteor(width, height, true);\n    }\n  }\n\n  private spawnMeteor(width: number, height: number, initial = false): void {\n    if (this.meteors.length >= NUM_METEORS) return;\n\n    // Meteors come from top-right and travel to bottom-left\n    const startX = initial ? Math.random() * width * 1.5 : width + 20 + Math.random() * 40;\n    const startY = initial ? Math.random() * height * 0.5 - height * 0.25 : -20 - Math.random() * 40;\n\n    // Random angle variation (mostly diagonal)\n    const angle = Math.PI * 0.65 + (Math.random() - 0.5) * 0.4;\n    const speed = 1.5 + Math.random() * 2;\n\n    this.meteors.push({\n      x: startX,\n      y: startY,\n      vx: -Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed,\n      size: 2 + Math.random() * 3,\n      hue: Math.random() < 0.3 ? 0 + Math.random() * 30 : 20 + Math.random() * 40, // Red or orange volcanic\n      alpha: 0.6 + Math.random() * 0.4,\n      trail: [],\n      life: 1,\n    });\n  }\n\n  private updateMeteors(width: number, height: number): void {\n    for (let i = this.meteors.length - 1; i >= 0; i--) {\n      const m = this.meteors[i];\n\n      // Store trail position\n      m.trail.unshift({ x: m.x, y: m.y, alpha: m.alpha });\n      if (m.trail.length > 12) m.trail.pop();\n\n      // Update position\n      m.x += m.vx;\n      m.y += m.vy;\n\n      // Check if meteor is out of bounds\n      if (m.x < -50 || m.y > height + 50) {\n        this.meteors.splice(i, 1);\n        // Spawn a new one\n        this.spawnMeteor(width, height, false);\n      }\n    }\n  }\n\n  private spawnDeathExplosion(): void {\n    if (!this.currentState) return;\n\n    this.deathDebris = [];\n    this.deathExplosionPhase = 1;\n\n    // Spawn debris from each snake segment\n    for (let i = 0; i < this.currentState.snake.length; i++) {\n      const seg = this.currentState.snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const segHue = (this.hueOffset + i * 15) % 360;\n\n      // Create debris particles per segment (limit total)\n      const debrisPerSeg = Math.min(3, Math.floor(MAX_DEATH_DEBRIS / this.currentState.snake.length));\n      for (let j = 0; j < debrisPerSeg; j++) {\n        if (this.deathDebris.length >= MAX_DEATH_DEBRIS) break;\n\n        const angle = Math.random() * Math.PI * 2;\n        const speed = 2 + Math.random() * 4;\n        const types: ('shard' | 'spark' | 'ember')[] = ['shard', 'spark', 'ember'];\n\n        this.deathDebris.push({\n          x: cx + (Math.random() - 0.5) * 8,\n          y: cy + (Math.random() - 0.5) * 8,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed - 1,\n          size: 3 + Math.random() * 5,\n          hue: segHue + (Math.random() - 0.5) * 40,\n          rotation: Math.random() * Math.PI * 2,\n          rotationSpeed: (Math.random() - 0.5) * 0.4,\n          life: 1,\n          type: types[Math.floor(Math.random() * types.length)],\n        });\n      }\n    }\n  }\n\n  private updateDeathDebris(): void {\n    // Decay explosion phase\n    if (this.deathExplosionPhase > 0) {\n      this.deathExplosionPhase *= 0.95;\n      if (this.deathExplosionPhase < 0.01) this.deathExplosionPhase = 0;\n    }\n\n    for (let i = this.deathDebris.length - 1; i >= 0; i--) {\n      const d = this.deathDebris[i];\n\n      // Update position with gravity\n      d.x += d.vx;\n      d.y += d.vy;\n      d.vy += 0.08; // gravity\n      d.vx *= 0.99; // air resistance\n\n      // Update rotation\n      d.rotation += d.rotationSpeed;\n\n      // Decay life\n      d.life -= 0.015;\n\n      if (d.life <= 0) {\n        this.deathDebris.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnFoodParticles(foodX: number, foodY: number): void {\n    if (this.foodParticles.length < MAX_FOOD_PARTICLES && Math.random() < 0.15) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.3 + Math.random() * 0.5;\n      this.foodParticles.push({\n        x: foodX,\n        y: foodY,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 0.5,\n        life: 1,\n        maxLife: 40 + Math.random() * 20,\n        size: 1 + Math.random() * 2,\n      });\n    }\n  }\n\n  private updateParticles(): void {\n    for (let i = this.foodParticles.length - 1; i >= 0; i--) {\n      const p = this.foodParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy += 0.02;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.foodParticles.splice(i, 1);\n      }\n    }\n    // Update trail particles\n    for (let i = this.trailParticles.length - 1; i >= 0; i--) {\n      const p = this.trailParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.life -= 1 / p.maxLife;\n      if (p.life <= 0) {\n        this.trailParticles.splice(i, 1);\n      }\n    }\n    // Update shockwaves\n    for (let i = this.shockWaves.length - 1; i >= 0; i--) {\n      const sw = this.shockWaves[i];\n      sw.radius += 3;\n      sw.life -= 0.04;\n      if (sw.life <= 0 || sw.radius >= sw.maxRadius) {\n        this.shockWaves.splice(i, 1);\n      }\n    }\n    // Update lightning bolts\n    for (let i = this.lightningBolts.length - 1; i >= 0; i--) {\n      const bolt = this.lightningBolts[i];\n      bolt.life -= 1 / bolt.maxLife;\n      if (bolt.life <= 0) {\n        this.lightningBolts.splice(i, 1);\n      }\n    }\n    // Update afterimages\n    for (let i = this.snakeAfterimages.length - 1; i >= 0; i--) {\n      const ai = this.snakeAfterimages[i];\n      ai.life -= 1 / ai.maxLife;\n      if (ai.life <= 0) {\n        this.snakeAfterimages.splice(i, 1);\n      }\n    }\n    // Decay screen flash\n    if (this.screenFlashAlpha > 0) {\n      this.screenFlashAlpha -= 0.08;\n      if (this.screenFlashAlpha < 0) this.screenFlashAlpha = 0;\n    }\n\n    // Update screen shake\n    if (this.screenShakeIntensity > 0) {\n      this.screenShakeX = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeY = (Math.random() - 0.5) * this.screenShakeIntensity;\n      this.screenShakeIntensity *= 0.9;\n      if (this.screenShakeIntensity < 0.5) {\n        this.screenShakeIntensity = 0;\n        this.screenShakeX = 0;\n        this.screenShakeY = 0;\n      }\n    }\n\n    // Decay chromatic aberration\n    if (this.chromaticIntensity > 0) {\n      this.chromaticIntensity *= 0.92;\n      if (this.chromaticIntensity < 0.05) this.chromaticIntensity = 0;\n    }\n\n    // Decay energy field pulse\n    if (this.energyFieldPulse > 0) {\n      this.energyFieldPulse *= 0.95;\n      if (this.energyFieldPulse < 0.05) this.energyFieldPulse = 0;\n    }\n\n    // Update food burst particles\n    for (let i = this.foodBurstParticles.length - 1; i >= 0; i--) {\n      const p = this.foodBurstParticles[i];\n      // Store trail position\n      p.trail.unshift({ x: p.x, y: p.y });\n      if (p.trail.length > 6) p.trail.pop();\n      // Update position\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vx *= 0.96;\n      p.vy *= 0.96;\n      p.life -= 0.025;\n      if (p.life <= 0) {\n        this.foodBurstParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private spawnTrailParticles(x: number, y: number): void {\n    if (this.trailParticles.length >= MAX_TRAIL_PARTICLES) return;\n    // Spawn 2-3 particles per movement\n    const count = 2 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < count; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.2 + Math.random() * 0.4;\n      this.trailParticles.push({\n        x: x + (Math.random() - 0.5) * 8,\n        y: y + (Math.random() - 0.5) * 8,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        maxLife: 25 + Math.random() * 15,\n        size: 2 + Math.random() * 3,\n        hue: this.hueOffset + Math.random() * 30,\n      });\n    }\n  }\n\n  updateGameState(state: GameState): void {\n    // Detect food eaten - snake got longer\n    if (this.currentState && state.snake.length > this.lastSnakeLength) {\n      const head = state.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n      this.spawnShockWave(headX, headY);\n      this.spawnLightningBurst(headX, headY);\n      this.spawnFoodBurst(headX, headY);\n      this.spawnChaosExplosion(headX, headY); // Armageddon chaos explosion\n      this.screenFlashAlpha = 0.8; // More intense flash for armageddon\n      this.chromaticIntensity = 1.5; // Stronger chromatic aberration\n      this.energyFieldPulse = 1.0; // Trigger energy field expansion\n    }\n    this.lastSnakeLength = state.snake.length;\n\n    // Detect food position change - trigger thrown food animation\n    const newFood = state.food;\n    if (this.lastFoodPos && (newFood.x !== this.lastFoodPos.x || newFood.y !== this.lastFoodPos.y)) {\n      this.spawnThrownFood(newFood.x, newFood.y);\n    } else if (!this.lastFoodPos && !state.gameOver) {\n      // First food spawn\n      this.spawnThrownFood(newFood.x, newFood.y);\n    }\n    this.lastFoodPos = { x: newFood.x, y: newFood.y };\n\n    // Create afterimage when snake moves\n    if (this.currentState && state.snake.length > 0) {\n      const oldHead = this.currentState.snake[0];\n      const newHead = state.snake[0];\n      if (oldHead && newHead && (oldHead.x !== newHead.x || oldHead.y !== newHead.y)) {\n        this.spawnAfterimage(this.currentState.snake);\n      }\n    }\n\n    // Detect game over transition - ARMAGEDDON CHAOS death sequence\n    if (state.gameOver && this.currentState && !this.currentState.gameOver) {\n      this.screenShakeIntensity = 25; // Massive screen shake on death\n      this.chromaticIntensity = 3.0; // Maximum chromatic aberration on death\n      this.chaosIntensity = 1.0; // Full chaos overlay\n      this.spawnDeathExplosion(); // Dramatic death explosion\n      // Spawn chaos explosions across the snake body\n      for (let i = 0; i < Math.min(3, state.snake.length); i++) {\n        const seg = state.snake[Math.floor(i * state.snake.length / 3)];\n        setTimeout(() => {\n          this.spawnChaosExplosion(\n            seg.x * CELL_SIZE + CELL_SIZE / 2,\n            seg.y * CELL_SIZE + CELL_SIZE / 2\n          );\n        }, i * 50);\n      }\n    }\n\n    this.currentState = state;\n    this.needsRedraw = true;\n    if (!state.gameOver) {\n      this.gameOverAlpha = 0;\n      this.gameOverGlitchOffset = 0;\n      this.screenShakeIntensity = 0;\n    }\n  }\n\n  private spawnShockWave(x: number, y: number): void {\n    if (this.shockWaves.length >= MAX_SHOCKWAVES) {\n      this.shockWaves.shift();\n    }\n    this.shockWaves.push({\n      x,\n      y,\n      radius: 5,\n      maxRadius: CELL_SIZE * 3,\n      life: 1,\n    });\n  }\n\n  private spawnAfterimage(snake: Position[]): void {\n    if (this.snakeAfterimages.length >= MAX_AFTERIMAGES) {\n      this.snakeAfterimages.shift();\n    }\n    this.snakeAfterimages.push({\n      segments: snake.map(s => ({ x: s.x, y: s.y })),\n      life: 1,\n      maxLife: 12,\n      hueOffset: this.hueOffset,\n    });\n  }\n\n  private spawnLightningBurst(x: number, y: number): void {\n    const numBolts = 3 + Math.floor(Math.random() * 2);\n    for (let i = 0; i < numBolts; i++) {\n      if (this.lightningBolts.length >= MAX_LIGHTNING_BOLTS) {\n        this.lightningBolts.shift();\n      }\n      const angle = (Math.PI * 2 * i) / numBolts + Math.random() * 0.5;\n      const length = 30 + Math.random() * 40;\n      const endX = x + Math.cos(angle) * length;\n      const endY = y + Math.sin(angle) * length;\n      this.lightningBolts.push({\n        points: this.generateLightningPath(x, y, endX, endY),\n        life: 1,\n        maxLife: 15 + Math.random() * 10,\n        hue: this.hueOffset + Math.random() * 60,\n      });\n    }\n  }\n\n  private generateLightningPath(x1: number, y1: number, x2: number, y2: number): { x: number; y: number }[] {\n    const points: { x: number; y: number }[] = [{ x: x1, y: y1 }];\n    const segments = 4 + Math.floor(Math.random() * 3);\n    const dx = (x2 - x1) / segments;\n    const dy = (y2 - y1) / segments;\n\n    for (let i = 1; i < segments; i++) {\n      const jitter = 8;\n      points.push({\n        x: x1 + dx * i + (Math.random() - 0.5) * jitter,\n        y: y1 + dy * i + (Math.random() - 0.5) * jitter,\n      });\n    }\n    points.push({ x: x2, y: y2 });\n    return points;\n  }\n\n  private spawnFoodBurst(x: number, y: number): void {\n    // Clear old particles and spawn new dramatic burst\n    this.foodBurstParticles = [];\n    const numParticles = MAX_BURST_PARTICLES;\n    for (let i = 0; i < numParticles; i++) {\n      const angle = (i / numParticles) * Math.PI * 2 + Math.random() * 0.3;\n      const speed = 3 + Math.random() * 4;\n      this.foodBurstParticles.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 1,\n        size: 3 + Math.random() * 4,\n        hue: this.hueOffset + Math.random() * 60,\n        trail: [],\n      });\n    }\n  }\n\n  private spawnThrownFood(targetGridX: number, targetGridY: number): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    const targetX = targetGridX * CELL_SIZE + CELL_SIZE / 2;\n    const targetY = targetGridY * CELL_SIZE + CELL_SIZE / 2;\n\n    // Choose random edge to throw from\n    const edge = Math.floor(Math.random() * 4);\n    let startX: number, startY: number;\n\n    switch (edge) {\n      case 0: // top\n        startX = Math.random() * width;\n        startY = -40;\n        break;\n      case 1: // right\n        startX = width + 40;\n        startY = Math.random() * height;\n        break;\n      case 2: // bottom\n        startX = Math.random() * width;\n        startY = height + 40;\n        break;\n      default: // left\n        startX = -40;\n        startY = Math.random() * height;\n        break;\n    }\n\n    this.thrownFood = {\n      startX,\n      startY,\n      targetX,\n      targetY,\n      x: startX,\n      y: startY,\n      progress: 0,\n      rotation: 0,\n      rotationSpeed: (Math.random() - 0.5) * 0.6,\n      trail: [],\n      landed: false,\n      landingParticles: [],\n      impactRings: [],\n    };\n  }\n\n  private updateThrownFood(): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    if (!tf.landed) {\n      // Update progress\n      tf.progress += 0.04;\n\n      // Store trail\n      if (this.frameCount % 2 === 0) {\n        tf.trail.unshift({ x: tf.x, y: tf.y, alpha: 1, rotation: tf.rotation });\n        if (tf.trail.length > 12) tf.trail.pop();\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.85;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Calculate position with parabolic arc\n      const t = tf.progress;\n      const arcHeight = 80;\n      const arc = 4 * arcHeight * t * (1 - t);\n      tf.x = tf.startX + (tf.targetX - tf.startX) * t;\n      tf.y = tf.startY + (tf.targetY - tf.startY) * t - arc;\n\n      // Rotation\n      tf.rotation += tf.rotationSpeed;\n\n      // Check if landed\n      if (tf.progress >= 1) {\n        tf.landed = true;\n        tf.x = tf.targetX;\n        tf.y = tf.targetY;\n\n        // Spawn landing effects\n        this.screenShakeIntensity = Math.max(this.screenShakeIntensity, 6);\n\n        // Impact rings\n        tf.impactRings = [\n          { radius: 5, alpha: 1 },\n          { radius: 3, alpha: 0.8 },\n        ];\n\n        // Landing particles\n        for (let i = 0; i < 10; i++) {\n          const angle = (i / 10) * Math.PI * 2 + Math.random() * 0.3;\n          const speed = 2 + Math.random() * 3;\n          tf.landingParticles.push({\n            x: tf.targetX,\n            y: tf.targetY,\n            vx: Math.cos(angle) * speed,\n            vy: Math.sin(angle) * speed - 1,\n            life: 1,\n            size: 2 + Math.random() * 3,\n          });\n        }\n      }\n    } else {\n      // Update landing effects\n      for (const ring of tf.impactRings) {\n        ring.radius += 3;\n        ring.alpha *= 0.9;\n      }\n      tf.impactRings = tf.impactRings.filter(r => r.alpha > 0.05);\n\n      for (let i = tf.landingParticles.length - 1; i >= 0; i--) {\n        const p = tf.landingParticles[i];\n        p.x += p.vx;\n        p.y += p.vy;\n        p.vy += 0.15;\n        p.vx *= 0.98;\n        p.life -= 0.04;\n        if (p.life <= 0) {\n          tf.landingParticles.splice(i, 1);\n        }\n      }\n\n      // Fade trail\n      for (const t of tf.trail) {\n        t.alpha *= 0.8;\n      }\n      tf.trail = tf.trail.filter(t => t.alpha > 0.05);\n\n      // Clear thrown food when effects are done\n      if (tf.impactRings.length === 0 && tf.landingParticles.length === 0 && tf.trail.length === 0) {\n        this.thrownFood = null;\n      }\n    }\n  }\n\n  private drawThrownFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.thrownFood) return;\n\n    const tf = this.thrownFood;\n\n    // Draw trail\n    for (let i = 0; i < tf.trail.length; i++) {\n      const t = tf.trail[i];\n      const trailProgress = i / tf.trail.length;\n      const trailSize = (CELL_SIZE / 2) * (1 - trailProgress * 0.5) * t.alpha;\n\n      // Trail glow\n      g.fillStyle(COLORS.foodGlow, t.alpha * 0.3);\n      g.fillCircle(t.x, t.y, trailSize * 1.5);\n\n      // Trail core\n      g.fillStyle(COLORS.food, t.alpha * 0.6);\n      g.fillCircle(t.x, t.y, trailSize);\n    }\n\n    // Draw impact rings\n    for (const ring of tf.impactRings) {\n      g.lineStyle(3, COLORS.foodGlow, ring.alpha * 0.5);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n      g.lineStyle(1.5, COLORS.noirWhite, ring.alpha * 0.7);\n      g.strokeCircle(tf.targetX, tf.targetY, ring.radius);\n    }\n\n    // Draw landing particles\n    for (const p of tf.landingParticles) {\n      g.fillStyle(COLORS.foodGlow, p.life * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Draw the flying food if not landed\n    if (!tf.landed) {\n      const scale = 0.8 + tf.progress * 0.4;\n      const foodSize = (CELL_SIZE / 2) * scale;\n\n      // Motion blur glow\n      g.fillStyle(COLORS.foodGlow, 0.3);\n      g.fillCircle(tf.x, tf.y, foodSize * 2);\n\n      // Outer glow\n      g.fillStyle(COLORS.noirWhite, 0.4);\n      g.fillCircle(tf.x, tf.y, foodSize * 1.5);\n\n      // Main food body\n      g.fillStyle(COLORS.food, 0.95);\n      g.fillCircle(tf.x, tf.y, foodSize);\n\n      // Spinning highlight\n      const highlightAngle = tf.rotation;\n      const highlightX = tf.x + Math.cos(highlightAngle) * foodSize * 0.3;\n      const highlightY = tf.y + Math.sin(highlightAngle) * foodSize * 0.3;\n      g.fillStyle(0xffffff, 0.9);\n      g.fillCircle(highlightX, highlightY, foodSize * 0.25);\n\n      // Secondary sparkle\n      const sparkleAngle = tf.rotation + Math.PI * 0.7;\n      const sparkleX = tf.x + Math.cos(sparkleAngle) * foodSize * 0.4;\n      const sparkleY = tf.y + Math.sin(sparkleAngle) * foodSize * 0.4;\n      g.fillStyle(0xffffff, 0.6);\n      g.fillCircle(sparkleX, sparkleY, foodSize * 0.15);\n    }\n  }\n\n  update(): void {\n    this.frameCount++;\n    this.cleanEffects.frameCount = this.frameCount;\n\n    const width = this.scale.width;\n    const height = this.scale.height;\n\n    updateMotes(this.cleanEffects, width, height);\n    updateRipples(this.cleanEffects);\n    updateTears(this.cleanEffects, height);\n    updateBlood(this.cleanEffects, height);\n\n    if (this.currentState && this.currentState.snake.length > 0) {\n      const head = this.currentState.snake[0];\n      const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n      const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n      if (this.lastHeadPos && (this.lastHeadPos.x !== head.x || this.lastHeadPos.y !== head.y)) {\n        updateGlowTrail(this.cleanEffects, headX, headY);\n      }\n      this.lastHeadPos = { x: head.x, y: head.y };\n\n      if (this.lastSnakeLength > 0 && this.currentState.snake.length > this.lastSnakeLength) {\n        const food = this.currentState.food;\n        const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n        const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnRipple(this.cleanEffects, foodX, foodY);\n      }\n      this.lastSnakeLength = this.currentState.snake.length;\n    }\n\n    const g = this.graphics;\n    g.clear();\n    g.setPosition(0, 0);\n\n    drawCleanBackground(g, width, height, this.frameCount);\n    drawCleanGrid(g, width, height, CELL_SIZE, GRID_SIZE, this.frameCount);\n    drawMotes(g, this.cleanEffects);\n\n    if (!this.currentState) return;\n\n    drawGlowTrail(g, this.cleanEffects);\n    drawRipples(g, this.cleanEffects);\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    drawCleanFood(g, foodX, foodY, CELL_SIZE, this.frameCount);\n\n    drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);\n\n    drawCleanVignette(g, width, height);\n\n    const score = this.currentState.score || 0;\n    const snakeLength = this.currentState.snake.length;\n    drawCleanHUD(g, score, snakeLength, width, this.frameCount, this.drawDigit.bind(this));\n\n    if (this.currentState.gameOver) {\n      this.drawGameOver(g, width, height);\n      this.drawScoreboard(g, width, height);\n    }\n\n    this.checkAndSaveHighScore();\n    this.needsRedraw = false;\n  }\n\n  private drawStars(g: Phaser.GameObjects.Graphics): void {\n    // In film noir mode, stars are subtle distant lights\n    for (const star of this.stars) {\n      const twinkle = 0.5 + Math.sin(this.frameCount * star.speed + star.x) * 0.5;\n      const alpha = star.brightness * twinkle * 0.25;\n      g.fillStyle(COLORS.star, alpha);\n      g.fillCircle(star.x, star.y, star.size * 0.7);\n    }\n  }\n\n  private updateSmokeParticles(): void {\n    const width = GRID_SIZE * CELL_SIZE;\n    const height = GRID_SIZE * CELL_SIZE;\n    for (const smoke of this.smokeParticles) {\n      smoke.x += smoke.vx;\n      smoke.y += smoke.vy;\n      smoke.life -= 0.002;\n      if (smoke.life <= 0 || smoke.y < -smoke.size) {\n        smoke.x = Math.random() * width;\n        smoke.y = height + smoke.size;\n        smoke.life = 1;\n        smoke.size = 30 + Math.random() * 50;\n        smoke.alpha = 0.02 + Math.random() * 0.03;\n      }\n      if (smoke.x < -smoke.size) smoke.x = width + smoke.size;\n      if (smoke.x > width + smoke.size) smoke.x = -smoke.size;\n    }\n  }\n\n  private drawSpotlight(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Create dramatic spotlight effect centered on snake\n    const cx = this.spotlightX || width / 2;\n    const cy = this.spotlightY || height / 2;\n    const pulse = 0.9 + Math.sin(this.frameCount * 0.03) * 0.1;\n\n    // Outer darkness vignette\n    g.fillStyle(0x000000, 0.6);\n    g.fillRect(0, 0, width, height);\n\n    // Spotlight cone - multiple layers for smooth falloff\n    const layers = 4;\n    for (let i = layers; i > 0; i--) {\n      const layerRadius = (width * 0.4 + i * 30) * pulse;\n      const layerAlpha = 0.15 * (1 - i / (layers + 1));\n      g.fillStyle(COLORS.spotlight, layerAlpha);\n      g.fillCircle(cx, cy, layerRadius);\n    }\n\n    // Bright center\n    g.fillStyle(COLORS.noirWhite, 0.08 * pulse);\n    g.fillCircle(cx, cy, width * 0.25);\n  }\n\n  private drawVenetianBlinds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Horizontal light streaks simulating light through venetian blinds\n    const blindSpacing = 25;\n    const blindWidth = 8;\n    const waveOffset = Math.sin(this.venetianPhase) * 10;\n\n    for (let y = waveOffset; y < height; y += blindSpacing) {\n      const brightness = 0.03 + Math.sin(y * 0.02 + this.venetianPhase * 2) * 0.015;\n      g.fillStyle(COLORS.noirWhite, brightness);\n      g.fillRect(0, y, width, blindWidth);\n    }\n\n    // Diagonal shadow bars from window frame\n    const diagonalAlpha = 0.04 + Math.sin(this.frameCount * 0.02) * 0.01;\n    g.fillStyle(0x000000, diagonalAlpha);\n    for (let i = -2; i < 6; i++) {\n      const x1 = i * 100 + Math.sin(this.venetianPhase) * 20;\n      g.beginPath();\n      g.moveTo(x1, 0);\n      g.lineTo(x1 + 40, 0);\n      g.lineTo(x1 + 40 + height * 0.3, height);\n      g.lineTo(x1 + height * 0.3, height);\n      g.closePath();\n      g.fillPath();\n    }\n  }\n\n  private drawSmoke(g: Phaser.GameObjects.Graphics): void {\n    for (const smoke of this.smokeParticles) {\n      const alpha = smoke.alpha * smoke.life;\n      g.fillStyle(COLORS.noirGray, alpha);\n      g.fillCircle(smoke.x, smoke.y, smoke.size);\n      g.fillStyle(COLORS.noirWhite, alpha * 0.3);\n      g.fillCircle(smoke.x, smoke.y, smoke.size * 0.5);\n    }\n  }\n\n  private spawnFlameParticle(x: number, y: number, intensity: number): void {\n    if (this.flameParticles.length >= MAX_FLAME_PARTICLES) {\n      this.flameParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.6;\n    const life = 0.5 + Math.random() * 0.5;\n\n    this.flameParticles.push({\n      x: x + (Math.random() - 0.5) * 6,\n      y: y + (Math.random() - 0.5) * 6,\n      vx: Math.cos(angle) * speed * 0.3,\n      vy: -0.5 - Math.random() * 1.5 * intensity,\n      size: 3 + Math.random() * 4 * intensity,\n      life,\n      maxLife: life,\n      hue: 10 + Math.random() * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n    });\n  }\n\n  private updateFlameParticles(): void {\n    for (let i = this.flameParticles.length - 1; i >= 0; i--) {\n      const p = this.flameParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.02;\n      p.vx *= 0.98;\n      p.size *= 0.97;\n      p.life -= 0.025;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.flameParticles.splice(i, 1);\n      }\n    }\n  }\n\n  private drawFlameParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.flameParticles) {\n      const lifeRatio = p.life / p.maxLife;\n\n      // Hue shifts from yellow-orange (high life) to red (low life)\n      const hue = p.hue - (1 - lifeRatio) * 15;\n      const outerColor = this.hslToRgb(hue / 360, 1, 0.3 + lifeRatio * 0.2);\n      const midColor = this.hslToRgb(hue / 360, 1, 0.5 + lifeRatio * 0.2);\n      const coreColor = this.hslToRgb((hue + 20) / 360, 0.7, 0.7 + lifeRatio * 0.2);\n\n      // Outer glow\n      g.fillStyle(outerColor, lifeRatio * 0.3);\n      g.fillCircle(p.x, p.y, p.size * 2);\n\n      // Mid flame\n      g.fillStyle(midColor, lifeRatio * 0.6);\n      g.fillCircle(p.x, p.y, p.size * 1.3);\n\n      // Core (bright yellow/white)\n      g.fillStyle(coreColor, lifeRatio * 0.8);\n      g.fillCircle(p.x, p.y, p.size * 0.6);\n    }\n  }\n\n  private spawnFlamesAlongSnake(): void {\n    if (!this.currentState || this.currentState.gameOver) return;\n\n    const snake = this.currentState.snake;\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const segX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const segY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const intensity = 1 - (i / snake.length) * 0.6;\n      if (Math.random() < 0.4 * intensity) {\n        this.spawnFlameParticle(segX, segY, intensity);\n      }\n    }\n  }\n\n  private drawMeteors(g: Phaser.GameObjects.Graphics): void {\n    for (const m of this.meteors) {\n      const meteorColor = this.hslToRgb(m.hue / 360, 0.9, 0.6);\n      const coreColor = this.hslToRgb(m.hue / 360, 0.6, 0.9);\n\n      // Draw trail (oldest to newest for proper layering)\n      for (let i = m.trail.length - 1; i >= 0; i--) {\n        const t = m.trail[i];\n        const trailProgress = 1 - i / m.trail.length;\n        const trailAlpha = t.alpha * trailProgress * 0.4;\n        const trailSize = m.size * trailProgress * 0.6;\n\n        g.fillStyle(meteorColor, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      // Outer glow\n      g.fillStyle(meteorColor, m.alpha * 0.3);\n      g.fillCircle(m.x, m.y, m.size * 2);\n\n      // Main meteor body\n      g.fillStyle(meteorColor, m.alpha * 0.8);\n      g.fillCircle(m.x, m.y, m.size);\n\n      // Bright core\n      g.fillStyle(coreColor, m.alpha);\n      g.fillCircle(m.x, m.y, m.size * 0.5);\n    }\n  }\n\n  private drawDeathDebris(g: Phaser.GameObjects.Graphics): void {\n    // Draw explosion flash at the beginning\n    if (this.deathExplosionPhase > 0.7) {\n      const flashAlpha = (this.deathExplosionPhase - 0.7) * 2;\n      g.fillStyle(0xffffff, flashAlpha * 0.5);\n      g.fillRect(0, 0, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);\n    }\n\n    for (const d of this.deathDebris) {\n      // Film noir: grayscale debris\n      const brightness = 0.4 + (d.hue % 60) / 100;\n      const color = this.hslToRgb(0, 0, brightness);\n      const alpha = d.life * 0.9;\n\n      g.save();\n\n      if (d.type === 'shard') {\n        // Draw triangular shards\n        const cx = d.x;\n        const cy = d.y;\n        const size = d.size * d.life;\n\n        // Calculate rotated triangle points\n        const cos = Math.cos(d.rotation);\n        const sin = Math.sin(d.rotation);\n\n        const p1x = cx + cos * size;\n        const p1y = cy + sin * size;\n        const p2x = cx + cos * (-size * 0.5) - sin * (size * 0.7);\n        const p2y = cy + sin * (-size * 0.5) + cos * (size * 0.7);\n        const p3x = cx + cos * (-size * 0.5) - sin * (-size * 0.7);\n        const p3y = cy + sin * (-size * 0.5) + cos * (-size * 0.7);\n\n        // Glow\n        g.fillStyle(color, alpha * 0.4);\n        g.fillCircle(cx, cy, size * 1.5);\n\n        // Shard body\n        g.fillStyle(color, alpha);\n        g.fillTriangle(p1x, p1y, p2x, p2y, p3x, p3y);\n\n        // Highlight edge\n        g.lineStyle(1, 0xffffff, alpha * 0.6);\n        g.lineBetween(p1x, p1y, p2x, p2y);\n\n      } else if (d.type === 'spark') {\n        // Draw elongated spark\n        const sparkLength = d.size * 2 * d.life;\n        const sparkWidth = d.size * 0.3 * d.life;\n\n        // Direction based on velocity\n        const vLen = Math.sqrt(d.vx * d.vx + d.vy * d.vy);\n        const nx = vLen > 0 ? d.vx / vLen : 1;\n        const ny = vLen > 0 ? d.vy / vLen : 0;\n\n        // Glow\n        g.fillStyle(color, alpha * 0.3);\n        g.fillCircle(d.x, d.y, sparkLength * 0.8);\n\n        // Spark line\n        g.lineStyle(sparkWidth * 2, color, alpha * 0.6);\n        g.lineBetween(d.x - nx * sparkLength, d.y - ny * sparkLength, d.x, d.y);\n\n        // Bright tip\n        g.lineStyle(sparkWidth, 0xffffff, alpha);\n        g.lineBetween(d.x - nx * sparkLength * 0.3, d.y - ny * sparkLength * 0.3, d.x, d.y);\n\n      } else {\n        // Ember - glowing circle\n        const emberSize = d.size * d.life;\n\n        // Outer glow\n        g.fillStyle(color, alpha * 0.2);\n        g.fillCircle(d.x, d.y, emberSize * 2);\n\n        // Mid glow\n        g.fillStyle(color, alpha * 0.5);\n        g.fillCircle(d.x, d.y, emberSize * 1.3);\n\n        // Core\n        g.fillStyle(color, alpha);\n        g.fillCircle(d.x, d.y, emberSize);\n\n        // Hot center\n        g.fillStyle(0xffffff, alpha * 0.7);\n        g.fillCircle(d.x, d.y, emberSize * 0.4);\n      }\n\n      g.restore();\n    }\n  }\n\n  private drawNebulaClouds(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const cloud of this.nebulaClouds) {\n      // Update cloud position (slow drift)\n      cloud.x += cloud.driftX;\n      cloud.y += cloud.driftY;\n      cloud.pulsePhase += cloud.pulseSpeed;\n\n      // Wrap around edges\n      if (cloud.x < -cloud.radius) cloud.x = width + cloud.radius;\n      if (cloud.x > width + cloud.radius) cloud.x = -cloud.radius;\n      if (cloud.y < -cloud.radius) cloud.y = height + cloud.radius;\n      if (cloud.y > height + cloud.radius) cloud.y = -cloud.radius;\n\n      // Pulsing alpha\n      const pulseAlpha = cloud.alpha * (0.7 + Math.sin(cloud.pulsePhase) * 0.3);\n      const color = this.hslToRgb(cloud.hue / 360, 0.6, 0.3);\n\n      // Draw multiple concentric layers for soft cloud effect\n      const layers = 4;\n      for (let i = layers; i > 0; i--) {\n        const layerRadius = cloud.radius * (i / layers);\n        const layerAlpha = pulseAlpha * (1 - i / (layers + 1)) * 0.6;\n        g.fillStyle(color, layerAlpha);\n        g.fillCircle(cloud.x, cloud.y, layerRadius);\n      }\n\n      // Core glow\n      const coreColor = this.hslToRgb(cloud.hue / 360, 0.8, 0.5);\n      g.fillStyle(coreColor, pulseAlpha * 0.4);\n      g.fillCircle(cloud.x, cloud.y, cloud.radius * 0.3);\n    }\n  }\n\n  private drawVortex(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Update vortex pulse\n    this.vortexPulse += 0.03;\n    const globalPulse = 0.8 + Math.sin(this.vortexPulse) * 0.2;\n\n    // Draw outer glow/halo\n    const outerGlowColor = this.hslToRgb(280 / 360, 0.7, 0.3);\n    g.fillStyle(outerGlowColor, 0.08 * globalPulse);\n    g.fillCircle(centerX, centerY, 120);\n    g.fillStyle(outerGlowColor, 0.05 * globalPulse);\n    g.fillCircle(centerX, centerY, 140);\n\n    // Draw orbiting particles (behind rings)\n    for (const particle of this.vortexParticles) {\n      // Update particle position - spiral inward slightly then reset\n      particle.angle += particle.speed;\n      particle.radius = particle.baseRadius + Math.sin(particle.angle * 3) * 8;\n\n      const px = centerX + Math.cos(particle.angle) * particle.radius;\n      const py = centerY + Math.sin(particle.angle) * particle.radius;\n\n      // Particle hue shifts over time\n      particle.hue = (particle.hue + 0.5) % 360;\n      const particleColor = this.hslToRgb(particle.hue / 360, 0.8, 0.6);\n\n      // Draw particle with trail\n      const trailAngle = particle.angle - 0.3;\n      const trailX = centerX + Math.cos(trailAngle) * particle.radius;\n      const trailY = centerY + Math.sin(trailAngle) * particle.radius;\n\n      g.lineStyle(particle.size * 0.8, particleColor, particle.alpha * 0.3 * globalPulse);\n      g.lineBetween(trailX, trailY, px, py);\n\n      g.fillStyle(particleColor, particle.alpha * globalPulse);\n      g.fillCircle(px, py, particle.size);\n\n      // Bright core\n      g.fillStyle(0xffffff, particle.alpha * 0.5 * globalPulse);\n      g.fillCircle(px, py, particle.size * 0.4);\n    }\n\n    // Draw rotating rings\n    for (const ring of this.vortexRings) {\n      ring.rotationOffset += ring.rotationSpeed;\n      ring.pulsePhase += 0.02;\n\n      const ringPulse = 0.7 + Math.sin(ring.pulsePhase) * 0.3;\n      const adjustedRadius = ring.baseRadius * (0.95 + ringPulse * 0.1);\n\n      const ringColor = this.hslToRgb(ring.hue / 360, 0.8, 0.5);\n\n      // Draw ring as series of arc segments with gaps\n      const segments = 6;\n      const arcLength = (Math.PI * 2) / segments * 0.7;\n\n      for (let i = 0; i < segments; i++) {\n        const startAngle = ring.rotationOffset + (i * Math.PI * 2) / segments;\n        const endAngle = startAngle + arcLength;\n\n        // Calculate alpha based on segment position for 3D effect\n        const segmentAlpha = 0.15 + Math.sin(startAngle + this.frameCount * 0.02) * 0.1;\n\n        g.lineStyle(ring.thickness, ringColor, segmentAlpha * ringPulse * globalPulse);\n        g.beginPath();\n        g.arc(centerX, centerY, adjustedRadius, startAngle, endAngle, false);\n        g.strokePath();\n      }\n\n      // Inner glow line\n      g.lineStyle(ring.thickness * 0.5, 0xffffff, 0.1 * ringPulse * globalPulse);\n      g.beginPath();\n      g.arc(centerX, centerY, adjustedRadius - 1, ring.rotationOffset, ring.rotationOffset + Math.PI, false);\n      g.strokePath();\n    }\n\n    // Central dark core (event horizon)\n    g.fillStyle(0x000000, 0.9);\n    g.fillCircle(centerX, centerY, 12);\n    g.fillStyle(0x000000, 0.7);\n    g.fillCircle(centerX, centerY, 18);\n    g.fillStyle(0x000000, 0.4);\n    g.fillCircle(centerX, centerY, 25);\n\n    // Bright accretion ring at edge of event horizon\n    const accretionHue = (this.frameCount * 2) % 360;\n    const accretionColor = this.hslToRgb(accretionHue / 360, 1, 0.6);\n    g.lineStyle(2, accretionColor, 0.4 * globalPulse);\n    g.strokeCircle(centerX, centerY, 14);\n    g.lineStyle(1, 0xffffff, 0.3 * globalPulse);\n    g.strokeCircle(centerX, centerY, 13);\n\n    // Gravitational lensing effect - distorted light streaks\n    const numStreaks = 4;\n    for (let i = 0; i < numStreaks; i++) {\n      const streakAngle = (i * Math.PI * 2) / numStreaks + this.frameCount * 0.01;\n      const streakHue = (accretionHue + i * 60) % 360;\n      const streakColor = this.hslToRgb(streakHue / 360, 0.9, 0.7);\n\n      const innerRadius = 20;\n      const outerRadius = 35 + Math.sin(this.frameCount * 0.05 + i) * 10;\n\n      const x1 = centerX + Math.cos(streakAngle) * innerRadius;\n      const y1 = centerY + Math.sin(streakAngle) * innerRadius;\n      const x2 = centerX + Math.cos(streakAngle + 0.2) * outerRadius;\n      const y2 = centerY + Math.sin(streakAngle + 0.2) * outerRadius;\n\n      g.lineStyle(3, streakColor, 0.15 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n      g.lineStyle(1.5, 0xffffff, 0.2 * globalPulse);\n      g.lineBetween(x1, y1, x2, y2);\n    }\n  }\n\n  private drawAuroraWaves(g: Phaser.GameObjects.Graphics, width: number): void {\n    for (const aurora of this.auroraWaves) {\n      aurora.phase += aurora.speed;\n\n      // Draw multiple ribbon layers for each aurora\n      const ribbonLayers = 3;\n      for (let layer = 0; layer < ribbonLayers; layer++) {\n        const layerOffset = layer * 5;\n        const layerAlpha = 0.06 - layer * 0.015;\n\n        // Calculate shifting hue for color variation\n        const shiftedHue = (aurora.hue + Math.sin(aurora.phase * 0.5) * 20) % 360;\n        const color = this.hslToRgb(shiftedHue / 360, 0.7, 0.5);\n\n        // Draw aurora as a series of connected curves\n        g.fillStyle(color, layerAlpha);\n        const step = 4;\n        for (let x = 0; x < width; x += step) {\n          // Multiple sine waves combined for organic movement\n          const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n          const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n          const wave3 = Math.sin(x * 0.01 + aurora.phase * 0.7) * aurora.amplitude * 0.3;\n          const yOffset = wave1 + wave2 + wave3;\n\n          const segmentY = aurora.y + yOffset + layerOffset;\n          const thickness = aurora.thickness * (0.7 + Math.sin(x * 0.05 + aurora.phase) * 0.3);\n\n          g.fillRect(x, segmentY - thickness / 2, step + 1, thickness);\n        }\n      }\n\n      // Add bright core line\n      const coreHue = (aurora.hue + 40) % 360;\n      const coreColor = this.hslToRgb(coreHue / 360, 0.9, 0.7);\n      g.lineStyle(1.5, coreColor, 0.15);\n      g.beginPath();\n      for (let x = 0; x < width; x += 3) {\n        const wave1 = Math.sin(x * 0.02 + aurora.phase) * aurora.amplitude;\n        const wave2 = Math.sin(x * 0.035 + aurora.phase * 1.3) * aurora.amplitude * 0.5;\n        const y = aurora.y + wave1 + wave2;\n        if (x === 0) {\n          g.moveTo(x, y);\n        } else {\n          g.lineTo(x, y);\n        }\n      }\n      g.strokePath();\n    }\n  }\n\n  private drawPlasmaWaves(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    for (const wave of this.plasmaWaves) {\n      wave.phase += wave.speed;\n      const color = this.hslToRgb(wave.hue / 360, 0.7, 0.4);\n\n      // Draw flowing plasma lines\n      for (let y = 0; y < height; y += 8) {\n        const waveOffset = Math.sin(y / wave.wavelength + wave.phase) * wave.amplitude;\n        const intensity = 0.03 + Math.sin(wave.phase + y * 0.01) * 0.02;\n\n        g.fillStyle(color, intensity);\n        const x1 = width / 2 + waveOffset - 40;\n        const x2 = width / 2 + waveOffset + 40;\n        g.fillRect(x1, y, x2 - x1, 2);\n      }\n    }\n  }\n\n  private drawSnakeAfterimages(g: Phaser.GameObjects.Graphics): void {\n    for (const ai of this.snakeAfterimages) {\n      const alpha = ai.life * 0.25;\n      for (let i = 0; i < ai.segments.length; i++) {\n        const seg = ai.segments[i];\n        const centerX = seg.x * CELL_SIZE + CELL_SIZE / 2;\n        const centerY = seg.y * CELL_SIZE + CELL_SIZE / 2;\n        const t = ai.segments.length > 1 ? i / (ai.segments.length - 1) : 1;\n        const radius = (CELL_SIZE / 2 - 2) * (0.7 + t * 0.2);\n\n        const segmentHue = (ai.hueOffset + i * 15) % 360;\n        const color = this.hslToRgb(segmentHue / 360, 0.6, 0.4);\n\n        g.fillStyle(color, alpha * t);\n        g.fillCircle(centerX, centerY, radius);\n      }\n    }\n  }\n\n  private drawTrailParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.trailParticles) {\n      // Film noir: grayscale trail\n      g.fillStyle(COLORS.noirGray, p.life * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 1.5 * p.life);\n      g.fillStyle(COLORS.noirWhite, p.life * 0.5);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n  }\n\n  // Update comet trail - add new segments and fade old ones\n  private updateCometTrail(): void {\n    if (!this.currentState || this.currentState.gameOver) {\n      // Fade out trail on game over\n      for (const seg of this.cometTrail) {\n        seg.alpha *= 0.9;\n      }\n      this.cometTrail = this.cometTrail.filter(s => s.alpha > 0.01);\n      return;\n    }\n\n    const snake = this.currentState.snake;\n    if (snake.length === 0) return;\n\n    const head = snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Track head history for smooth interpolation\n    this.headHistory.unshift({ x: headX, y: headY, time: this.frameCount });\n    if (this.headHistory.length > 10) this.headHistory.pop();\n\n    // Add new trail segment at head position\n    if (this.frameCount % 2 === 0) {\n      const hue = 270 + Math.sin(this.frameCount * 0.05) * 20;\n      this.cometTrail.unshift({\n        x: headX,\n        y: headY,\n        alpha: 1,\n        size: CELL_SIZE / 2 + 2,\n        hue,\n      });\n\n      // Spawn ethereal particles from trail\n      if (Math.random() < 0.6) {\n        this.spawnEtherealParticle(headX, headY, hue);\n      }\n    }\n\n    // Limit trail length and fade segments\n    while (this.cometTrail.length > MAX_COMET_TRAIL_LENGTH) {\n      this.cometTrail.pop();\n    }\n\n    // Fade all segments\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const fadeRate = 0.06 + (i / this.cometTrail.length) * 0.04;\n      this.cometTrail[i].alpha -= fadeRate;\n      this.cometTrail[i].size *= 0.97;\n    }\n\n    // Remove fully faded segments\n    this.cometTrail = this.cometTrail.filter(s => s.alpha > 0);\n  }\n\n  // Spawn an ethereal particle that drifts away from the trail\n  private spawnEtherealParticle(x: number, y: number, hue: number): void {\n    if (this.etherealParticles.length >= MAX_ETHEREAL_PARTICLES) {\n      this.etherealParticles.shift();\n    }\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.5;\n    const life = 0.8 + Math.random() * 0.4;\n\n    this.etherealParticles.push({\n      x: x + (Math.random() - 0.5) * 10,\n      y: y + (Math.random() - 0.5) * 10,\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed - 0.3,\n      size: 3 + Math.random() * 4,\n      life,\n      maxLife: life,\n      hue: hue + (Math.random() - 0.5) * 30,\n      brightness: 0.5 + Math.random() * 0.3,\n      pulsePhase: Math.random() * Math.PI * 2,\n    });\n  }\n\n  // Update ethereal particles\n  private updateEtherealParticles(): void {\n    for (let i = this.etherealParticles.length - 1; i >= 0; i--) {\n      const p = this.etherealParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy -= 0.015; // Slight upward drift\n      p.vx *= 0.98;\n      p.size *= 0.985;\n      p.life -= 0.02;\n      p.pulsePhase += 0.15;\n\n      if (p.life <= 0 || p.size < 0.5) {\n        this.etherealParticles.splice(i, 1);\n      }\n    }\n  }\n\n  // Draw the comet trail - smooth glowing ribbon\n  private drawCometTrail(g: Phaser.GameObjects.Graphics): void {\n    if (this.cometTrail.length < 2) return;\n\n    // Draw outer glow layer\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.05) continue;\n\n      const progress = i / this.cometTrail.length;\n      const glowSize = seg.size * (1.5 + progress * 0.5);\n      const glowAlpha = seg.alpha * 0.15 * (1 - progress * 0.5);\n\n      // Outer ethereal glow\n      const outerColor = this.hslToRgb(seg.hue / 360, 0.6, 0.4);\n      g.fillStyle(outerColor, glowAlpha);\n      g.fillCircle(seg.x, seg.y, glowSize * 1.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(seg.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, glowAlpha * 1.5);\n      g.fillCircle(seg.x, seg.y, glowSize);\n    }\n\n    // Draw connecting ribbon between segments\n    if (this.cometTrail.length >= 2) {\n      for (let i = 0; i < this.cometTrail.length - 1; i++) {\n        const seg1 = this.cometTrail[i];\n        const seg2 = this.cometTrail[i + 1];\n        if (seg1.alpha < 0.1 || seg2.alpha < 0.1) continue;\n\n        const progress = i / this.cometTrail.length;\n        const ribbonAlpha = Math.min(seg1.alpha, seg2.alpha) * 0.4 * (1 - progress * 0.5);\n        const ribbonWidth = (seg1.size + seg2.size) / 2 * 0.6;\n\n        // Ribbon core\n        const ribbonColor = this.hslToRgb(seg1.hue / 360, 0.8, 0.6);\n        g.lineStyle(ribbonWidth, ribbonColor, ribbonAlpha);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n\n        // Bright inner ribbon\n        g.lineStyle(ribbonWidth * 0.4, 0xffffff, ribbonAlpha * 0.6);\n        g.lineBetween(seg1.x, seg1.y, seg2.x, seg2.y);\n      }\n    }\n\n    // Draw core particles at each segment\n    for (let i = 0; i < this.cometTrail.length; i++) {\n      const seg = this.cometTrail[i];\n      if (seg.alpha < 0.1) continue;\n\n      const progress = i / this.cometTrail.length;\n      const coreAlpha = seg.alpha * 0.6 * (1 - progress * 0.7);\n      const coreSize = seg.size * 0.5 * (1 - progress * 0.3);\n\n      // Core glow\n      const coreColor = this.hslToRgb(seg.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, coreAlpha);\n      g.fillCircle(seg.x, seg.y, coreSize);\n\n      // Bright white center\n      g.fillStyle(0xffffff, coreAlpha * 0.5);\n      g.fillCircle(seg.x, seg.y, coreSize * 0.4);\n    }\n  }\n\n  // Draw ethereal particles - luminous drifting particles\n  private drawEtherealParticles(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.etherealParticles) {\n      const lifeRatio = p.life / p.maxLife;\n      const pulse = 0.7 + Math.sin(p.pulsePhase) * 0.3;\n      const alpha = lifeRatio * pulse;\n\n      // Outer glow\n      const glowColor = this.hslToRgb(p.hue / 360, 0.5, 0.3);\n      g.fillStyle(glowColor, alpha * 0.2);\n      g.fillCircle(p.x, p.y, p.size * 2.5);\n\n      // Mid glow\n      const midColor = this.hslToRgb(p.hue / 360, 0.7, 0.5);\n      g.fillStyle(midColor, alpha * 0.4);\n      g.fillCircle(p.x, p.y, p.size * 1.5);\n\n      // Core\n      const coreColor = this.hslToRgb(p.hue / 360, 0.9, 0.7);\n      g.fillStyle(coreColor, alpha * 0.7);\n      g.fillCircle(p.x, p.y, p.size);\n\n      // Bright center\n      g.fillStyle(0xffffff, alpha * 0.5);\n      g.fillCircle(p.x, p.y, p.size * 0.3);\n    }\n  }\n\n  private drawShockWaves(g: Phaser.GameObjects.Graphics): void {\n    for (const sw of this.shockWaves) {\n      const alpha = sw.life * 0.6;\n      // Outer ring\n      g.lineStyle(3, 0xffffff, alpha * 0.3);\n      g.strokeCircle(sw.x, sw.y, sw.radius);\n      // Inner bright ring\n      g.lineStyle(2, 0x00ffff, alpha * 0.7);\n      g.strokeCircle(sw.x, sw.y, sw.radius * 0.8);\n      // Core flash\n      if (sw.life > 0.8) {\n        g.fillStyle(0xffffff, (sw.life - 0.8) * 3);\n        g.fillCircle(sw.x, sw.y, sw.radius * 0.3);\n      }\n    }\n  }\n\n  private drawLightningBolts(g: Phaser.GameObjects.Graphics): void {\n    for (const bolt of this.lightningBolts) {\n      const alpha = bolt.life;\n\n      // Film noir: white lightning\n      g.lineStyle(4, COLORS.noirGray, alpha * 0.3);\n      this.drawLightningPath(g, bolt.points);\n\n      g.lineStyle(2, 0xffffff, alpha * 0.8);\n      this.drawLightningPath(g, bolt.points);\n    }\n  }\n\n  private drawLightningPath(g: Phaser.GameObjects.Graphics, points: { x: number; y: number }[]): void {\n    if (points.length < 2) return;\n    g.beginPath();\n    g.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      g.lineTo(points[i].x, points[i].y);\n    }\n    g.strokePath();\n  }\n\n  private drawSnakeElectricity(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n    const snake = this.currentState.snake;\n    if (snake.length < 2) return;\n\n    // Draw electric arcs between segments every few frames\n    if (this.frameCount % 3 !== 0) return;\n\n    for (let i = 0; i < snake.length - 1; i++) {\n      if (Math.random() > 0.4) continue;\n\n      const seg1 = snake[i];\n      const seg2 = snake[i + 1];\n      const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n      const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n      const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n      const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const arcPoints = this.generateLightningPath(x1, y1, x2, y2);\n\n      // Film noir: grayscale arcs\n      g.lineStyle(3, COLORS.noirGray, 0.3);\n      this.drawLightningPath(g, arcPoints);\n      g.lineStyle(1, 0xffffff, 0.7);\n      this.drawLightningPath(g, arcPoints);\n    }\n  }\n\n  private hslToRgb(h: number, s: number, l: number): number {\n    let r: number, g: number, b: number;\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return (Math.round(r * 255) << 16) | (Math.round(g * 255) << 8) | Math.round(b * 255);\n  }\n\n  private loadHighScores(): HighScoreEntry[] {\n    if (this.highScoresLoaded && this.highScores.length > 0) {\n      return this.highScores;\n    }\n    try {\n      const stored = localStorage.getItem('snake_high_scores');\n      if (stored) {\n        const parsed = JSON.parse(stored) as HighScoreEntry[];\n        this.highScores = parsed.slice(0, MAX_HIGH_SCORES);\n        this.highScoresLoaded = true;\n        return this.highScores;\n      }\n    } catch {\n      // localStorage not available\n    }\n    this.highScores = [];\n    this.highScoresLoaded = true;\n    return this.highScores;\n  }\n\n  private saveHighScore(score: number): number {\n    const highScores = this.loadHighScores();\n    const newEntry: HighScoreEntry = { score, date: Date.now(), rank: 0 };\n\n    let insertIndex = highScores.findIndex(entry => score > entry.score);\n    if (insertIndex === -1) insertIndex = highScores.length;\n\n    if (insertIndex < MAX_HIGH_SCORES && score > 0) {\n      highScores.splice(insertIndex, 0, newEntry);\n      highScores.forEach((entry, i) => { entry.rank = i + 1; });\n      this.highScores = highScores.slice(0, MAX_HIGH_SCORES);\n\n      try {\n        localStorage.setItem('snake_high_scores', JSON.stringify(this.highScores));\n      } catch {\n        // localStorage not available\n      }\n      return insertIndex + 1;\n    }\n    return -1;\n  }\n\n  private checkAndSaveHighScore(): void {\n    if (!this.currentState) return;\n\n    if (this.currentState.gameOver && !this.lastGameOverState) {\n      const score = this.currentState.score || 0;\n      const rank = this.saveHighScore(score);\n      this.newHighScoreRank = rank > 0 ? rank : -1;\n      this.scoreboardRevealProgress = 0;\n\n      const head = this.currentState.snake[0];\n      if (head) {\n        const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n        const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n        spawnBlood(this.cleanEffects, headX, headY, 15);\n        spawnTears(this.cleanEffects, headX, headY - 10, 6);\n      }\n    }\n    this.lastGameOverState = this.currentState.gameOver;\n\n    if (this.currentState.gameStarted && !this.currentState.gameOver) {\n      this.newHighScoreRank = -1;\n    }\n  }\n\n  private drawHUD(g: Phaser.GameObjects.Graphics, width: number): void {\n    if (!this.currentState || !this.currentState.gameStarted) return;\n\n    this.hudPulsePhase += 0.08;\n    const score = this.currentState.score || 0;\n\n    if (score > this.lastHudScore) {\n      this.scoreFlashIntensity = 1;\n    }\n    this.lastHudScore = score;\n    this.scoreFlashIntensity *= 0.92;\n\n    const padding = 12;\n    const scorePanelWidth = 120;\n    const scorePanelHeight = 50;\n\n    // Score panel background - volcanic lava theme\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Glowing border\n    const borderGlow = 0.6 + this.scoreFlashIntensity * 0.4;\n    g.lineStyle(2, COLORS.snakeGlow, borderGlow);\n    g.strokeRoundedRect(padding, padding, scorePanelWidth, scorePanelHeight, 8);\n\n    // Score label\n    this.drawText(g, 'SCORE', padding + 10, padding + 12, 10, COLORS.snakeBody, 0.9);\n\n    // Score value with flash effect\n    const scoreColor = this.scoreFlashIntensity > 0.5 ? 0xffffff : COLORS.snakeHead;\n    this.drawText(g, String(score).padStart(5, '0'), padding + 10, padding + 32, 18, scoreColor, 1);\n\n    // Outer glow on score when flashing\n    if (this.scoreFlashIntensity > 0.1) {\n      g.fillStyle(COLORS.snakeGlow, this.scoreFlashIntensity * 0.3);\n      g.fillRoundedRect(padding + 5, padding + 20, 100, 28, 4);\n    }\n\n    // Length panel on the right\n    const lengthPanelWidth = 80;\n    const lengthPanelHeight = 50;\n    const lengthX = width - padding - lengthPanelWidth;\n\n    g.fillStyle(0x150508, 0.9);\n    g.fillRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    g.lineStyle(2, COLORS.foodGlow, 0.6);\n    g.strokeRoundedRect(lengthX, padding, lengthPanelWidth, lengthPanelHeight, 8);\n\n    this.drawText(g, 'LENGTH', lengthX + 10, padding + 12, 10, COLORS.food, 0.9);\n    this.drawText(g, String(this.currentState.snake.length), lengthX + 10, padding + 32, 18, COLORS.foodCore, 1);\n  }\n\n  private drawText(\n    g: Phaser.GameObjects.Graphics,\n    text: string,\n    x: number,\n    y: number,\n    size: number,\n    color: number,\n    alpha: number\n  ): void {\n    // Use simple block characters for text rendering\n    const charWidth = size * 0.6;\n    const charHeight = size;\n\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const cx = x + i * charWidth;\n\n      g.fillStyle(color, alpha);\n\n      // Simple pixel-style character rendering\n      if (char >= '0' && char <= '9') {\n        this.drawDigit(g, char, cx, y, size);\n      } else {\n        this.drawLetter(g, char, cx, y, size);\n      }\n    }\n  }\n\n  private drawDigit(g: Phaser.GameObjects.Graphics, digit: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15; // thickness\n\n    // 7-segment style digits\n    const segments: Record<string, number[]> = {\n      '0': [1, 1, 1, 0, 1, 1, 1],\n      '1': [0, 0, 1, 0, 0, 1, 0],\n      '2': [1, 0, 1, 1, 1, 0, 1],\n      '3': [1, 0, 1, 1, 0, 1, 1],\n      '4': [0, 1, 1, 1, 0, 1, 0],\n      '5': [1, 1, 0, 1, 0, 1, 1],\n      '6': [1, 1, 0, 1, 1, 1, 1],\n      '7': [1, 0, 1, 0, 0, 1, 0],\n      '8': [1, 1, 1, 1, 1, 1, 1],\n      '9': [1, 1, 1, 1, 0, 1, 1],\n    };\n\n    const seg = segments[digit] || segments['0'];\n\n    // Top horizontal\n    if (seg[0]) g.fillRect(x, y - h / 2, w, t);\n    // Top-left vertical\n    if (seg[1]) g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n    // Top-right vertical\n    if (seg[2]) g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n    // Middle horizontal\n    if (seg[3]) g.fillRect(x, y - t / 2, w, t);\n    // Bottom-left vertical\n    if (seg[4]) g.fillRect(x - t / 2, y, t, h / 2);\n    // Bottom-right vertical\n    if (seg[5]) g.fillRect(x + w - t / 2, y, t, h / 2);\n    // Bottom horizontal\n    if (seg[6]) g.fillRect(x, y + h / 2 - t, w, t);\n  }\n\n  private drawLetter(g: Phaser.GameObjects.Graphics, letter: string, x: number, y: number, size: number): void {\n    const w = size * 0.5;\n    const h = size;\n    const t = size * 0.15;\n\n    // Simple block letters\n    switch (letter.toUpperCase()) {\n      case 'S':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'C':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'O':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'R':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x, y - t / 2, w, t);\n        g.fillRect(x + w / 2, y, t, h / 2);\n        break;\n      case 'E':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w * 0.7, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'L':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'N':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - h / 2 + t, w, t);\n        break;\n      case 'G':\n        g.fillRect(x, y - h / 2, w, t);\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y, t, h / 2);\n        g.fillRect(x + w / 2, y - t / 2, w / 2, t);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'T':\n        g.fillRect(x - t, y - h / 2, w + t * 2, t);\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'H':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n      case 'I':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h);\n        break;\n      case 'Y':\n        g.fillRect(x - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h / 2);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        break;\n      case 'U':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case 'W':\n        g.fillRect(x - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w - t / 2, y - h / 2, t, h);\n        g.fillRect(x + w / 2 - t / 2, y, t, h / 2);\n        g.fillRect(x, y + h / 2 - t, w, t);\n        break;\n      case '!':\n        g.fillRect(x + w / 2 - t / 2, y - h / 2, t, h * 0.6);\n        g.fillRect(x + w / 2 - t / 2, y + h / 2 - t * 2, t, t);\n        break;\n      case ' ':\n        break;\n      default:\n        g.fillRect(x, y - t / 2, w, t);\n        break;\n    }\n  }\n\n  private drawScoreboard(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    if (!this.currentState || !this.currentState.gameOver) return;\n\n    this.scoreboardAnimPhase += 0.06;\n    this.scoreboardRevealProgress = Math.min(1, this.scoreboardRevealProgress + 0.02);\n\n    const highScores = this.loadHighScores();\n    const centerX = width / 2;\n    const baseY = height * 0.18;\n    const panelWidth = 180;\n    const panelHeight = 170;\n    const panelX = centerX - panelWidth / 2;\n    const panelY = baseY;\n    const slideOffset = (1 - this.scoreboardRevealProgress) * 50;\n    const alphaMultiplier = this.scoreboardRevealProgress;\n\n    // Panel background - volcanic lava glow\n    g.fillStyle(0x150510, 0.95 * alphaMultiplier);\n    g.fillRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Glowing border - animated\n    const borderHue = this.newHighScoreRank > 0 ? 45 : 0;\n    const borderPulse = 0.6 + Math.sin(this.scoreboardAnimPhase) * 0.2;\n    const borderColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    g.lineStyle(3, borderColor, borderPulse * alphaMultiplier);\n    g.strokeRoundedRect(panelX, panelY - slideOffset, panelWidth, panelHeight, 12);\n\n    // Title\n    const titleY = panelY - slideOffset + 22;\n    this.drawText(g, 'HIGH SCORES', centerX - 55, titleY, 10, COLORS.foodCore, alphaMultiplier);\n\n    // Divider line\n    g.lineStyle(1, COLORS.snakeGlow, 0.5 * alphaMultiplier);\n    g.lineBetween(panelX + 20, titleY + 8, panelX + panelWidth - 20, titleY + 8);\n\n    const entryStartY = titleY + 25;\n    const entryHeight = 22;\n\n    if (highScores.length === 0) {\n      this.drawText(g, 'NO SCORES YET', centerX - 50, entryStartY + 30, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n    } else {\n      for (let i = 0; i < Math.min(highScores.length, 5); i++) {\n        const entry = highScores[i];\n        const entryY = entryStartY + i * entryHeight;\n        const isNewScore = this.newHighScoreRank === i + 1;\n        const entryDelay = i * 0.15;\n        const entryProgress = Math.max(0, Math.min(1, (this.scoreboardRevealProgress - entryDelay) * 2));\n        if (entryProgress <= 0) continue;\n\n        const entryAlpha = alphaMultiplier * entryProgress;\n\n        // Highlight new high score row\n        if (isNewScore) {\n          const flashIntensity = 0.3 + Math.sin(this.scoreboardAnimPhase * 3) * 0.2;\n          g.fillStyle(0xffcc00, flashIntensity * entryAlpha);\n          g.fillRoundedRect(panelX + 8, entryY - slideOffset - 8, panelWidth - 16, entryHeight - 2, 4);\n        }\n\n        // Rank colors: gold, silver, bronze, then volcanic colors\n        const rankColors = [0xffd700, 0xc0c0c0, 0xcd7f32, COLORS.snakeGlow, COLORS.foodGlow];\n        const rankColor = rankColors[i] || 0x888888;\n\n        // Rank number\n        this.drawText(g, `${i + 1}`, panelX + 18, entryY - slideOffset, 10, rankColor, entryAlpha);\n\n        // Score value\n        const scoreColor = isNewScore ? 0xffffff : COLORS.foodCore;\n        this.drawText(g, String(entry.score).padStart(5, '0'), panelX + panelWidth - 70, entryY - slideOffset, 10, scoreColor, entryAlpha);\n\n        // NEW! label\n        if (isNewScore) {\n          const newAlpha = 0.8 + Math.sin(this.scoreboardAnimPhase * 4) * 0.2;\n          this.drawText(g, 'NEW', panelX + 50, entryY - slideOffset, 7, 0xffcc00, newAlpha * entryAlpha);\n        }\n      }\n    }\n\n    // Current score at bottom\n    const currentScoreY = panelY - slideOffset + panelHeight - 30;\n    this.drawText(g, 'YOUR SCORE', centerX - 40, currentScoreY - 10, 8, COLORS.noirGray, 0.8 * alphaMultiplier);\n\n    const currentScore = this.currentState.score || 0;\n    const scoreColor = this.newHighScoreRank > 0 ? 0xffcc00 : COLORS.snakeGlow;\n    this.drawText(g, String(currentScore).padStart(5, '0'), centerX - 25, currentScoreY + 8, 14, scoreColor, alphaMultiplier);\n  }\n\n  private drawGrid(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir grid: subtle, dark lines suggesting tile floor or city grid\n    g.lineStyle(1, COLORS.gridLine, 0.08);\n    for (let i = 0; i <= GRID_SIZE; i++) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Accent lines every 5 cells - subtle gray\n    const accentPulse = 0.12 + Math.sin(this.frameCount * 0.03) * 0.04;\n    g.lineStyle(1, COLORS.gridAccent, accentPulse);\n    for (let i = 0; i <= GRID_SIZE; i += 5) {\n      g.lineBetween(i * CELL_SIZE, 0, i * CELL_SIZE, height);\n      g.lineBetween(0, i * CELL_SIZE, width, i * CELL_SIZE);\n    }\n\n    // Heavy vignette for dramatic noir look\n    this.drawVignette(g, width, height);\n  }\n\n  private drawVignette(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Multiple layers of vignette for smooth falloff\n    const layers = 5;\n    for (let i = 0; i < layers; i++) {\n      const inset = i * 30;\n      const alpha = 0.15 * (1 - i / layers);\n      g.lineStyle(60, 0x000000, alpha);\n      g.strokeRect(inset - 30, inset - 30, width - inset * 2 + 60, height - inset * 2 + 60);\n    }\n  }\n\n  private drawFood(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    // Don't draw food if it's still being thrown\n    if (this.thrownFood && !this.thrownFood.landed) return;\n\n    const food = this.currentState.food;\n    const foodX = food.x * CELL_SIZE + CELL_SIZE / 2;\n    const foodY = food.y * CELL_SIZE + CELL_SIZE / 2;\n    const pulseScale = 1 + Math.sin(this.frameCount * 0.15) * 0.08;\n    const glowPulse = 0.4 + Math.sin(this.frameCount * 0.1) * 0.2;\n\n    // Spawn particles (orange/yellow for Halloween)\n    this.spawnFoodParticles(foodX, foodY);\n\n    // Draw particles\n    for (const p of this.foodParticles) {\n      g.fillStyle(COLORS.pumpkinOrange, p.life * 0.4);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n    }\n\n    // Halloween pumpkin!\n    const pumpkinSize = (CELL_SIZE / 2) * pulseScale;\n\n    // Shadow underneath\n    g.fillStyle(0x000000, 0.5);\n    g.fillEllipse(foodX + 2, foodY + pumpkinSize * 0.8, pumpkinSize * 1.2, pumpkinSize * 0.4);\n\n    // Outer orange glow (candlelight effect)\n    g.fillStyle(COLORS.pumpkinOrange, glowPulse * 0.15);\n    g.fillCircle(foodX, foodY, pumpkinSize + 12);\n    g.fillStyle(COLORS.candyCorn1, glowPulse * 0.2);\n    g.fillCircle(foodX, foodY, pumpkinSize + 6);\n\n    // Pumpkin body (slightly squashed circle)\n    g.fillStyle(COLORS.pumpkinOrange, 0.95);\n    g.fillEllipse(foodX, foodY, pumpkinSize * 1.1, pumpkinSize * 0.9);\n\n    // Pumpkin segments (darker lines)\n    g.lineStyle(2, 0xcc4400, 0.5);\n    g.lineBetween(foodX, foodY - pumpkinSize * 0.8, foodX, foodY + pumpkinSize * 0.7);\n    g.lineStyle(1.5, 0xcc4400, 0.3);\n    g.lineBetween(foodX - pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX - pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n    g.lineBetween(foodX + pumpkinSize * 0.5, foodY - pumpkinSize * 0.5, foodX + pumpkinSize * 0.4, foodY + pumpkinSize * 0.6);\n\n    // Pumpkin stem\n    g.fillStyle(0x228822, 0.9);\n    g.fillRect(foodX - 2, foodY - pumpkinSize * 0.9 - 4, 4, 6);\n\n    // Jack-o-lantern face - glowing eyes and mouth\n    const faceGlow = 0.8 + Math.sin(this.frameCount * 0.12) * 0.2;\n    g.fillStyle(COLORS.candyCorn1, faceGlow);\n\n    // Eyes (triangles)\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX - pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.4, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.15, foodY - pumpkinSize * 0.1,\n      foodX + pumpkinSize * 0.27, foodY - pumpkinSize * 0.35\n    );\n\n    // Mouth (jagged smile)\n    g.fillStyle(COLORS.candyCorn1, faceGlow * 0.9);\n    g.fillRect(foodX - pumpkinSize * 0.35, foodY + pumpkinSize * 0.15, pumpkinSize * 0.7, pumpkinSize * 0.25);\n\n    // Teeth (dark gaps in mouth)\n    g.fillStyle(COLORS.pumpkinOrange, 1);\n    g.fillTriangle(\n      foodX - pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX, foodY + pumpkinSize * 0.15,\n      foodX - pumpkinSize * 0.075, foodY + pumpkinSize * 0.3\n    );\n    g.fillTriangle(\n      foodX + pumpkinSize * 0.15, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.3, foodY + pumpkinSize * 0.15,\n      foodX + pumpkinSize * 0.225, foodY + pumpkinSize * 0.3\n    );\n  }\n\n  private drawEnergyTendrils(g: Phaser.GameObjects.Graphics, foodX: number, foodY: number): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const head = this.currentState.snake[0];\n    const headX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const headY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Calculate distance to snake head\n    const dx = headX - foodX;\n    const dy = headY - foodY;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    // Only draw tendrils when snake is somewhat close\n    if (dist > CELL_SIZE * 6) return;\n\n    // Intensity increases as snake gets closer\n    const intensity = 1 - dist / (CELL_SIZE * 6);\n    const numTendrils = 2 + Math.floor(intensity * 2);\n\n    for (let i = 0; i < numTendrils; i++) {\n      // Tendril reaches partway toward the snake\n      const reach = 0.3 + intensity * 0.4;\n      const targetX = foodX + dx * reach;\n      const targetY = foodY + dy * reach;\n\n      // Add some wave offset for each tendril\n      const waveOffset = Math.sin(this.frameCount * 0.15 + i * 2) * 10;\n      const perpX = -dy / dist;\n      const perpY = dx / dist;\n      const wavyTargetX = targetX + perpX * waveOffset * (1 - reach);\n      const wavyTargetY = targetY + perpY * waveOffset * (1 - reach);\n\n      // Generate tendril path\n      const points = this.generateLightningPath(foodX, foodY, wavyTargetX, wavyTargetY);\n\n      // Draw tendril with glow\n      g.lineStyle(3, COLORS.foodGlow, intensity * 0.3);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1.5, COLORS.food, intensity * 0.7);\n      this.drawLightningPath(g, points);\n      g.lineStyle(1, 0xffffff, intensity * 0.5);\n      this.drawLightningPath(g, points);\n    }\n  }\n\n  private drawSnake(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const snakeLen = snake.length;\n\n    // Spooky shadow under snake\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2 + 3;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const shadowRadius = (CELL_SIZE / 2) * (0.9 + t * 0.1);\n      g.fillStyle(0x000000, 0.5 * t);\n      g.fillCircle(centerX, centerY, shadowRadius);\n    }\n\n    // Draw trailing glow (ghostly green)\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const glowAlpha = 0.2 * t;\n      const glowSize = (CELL_SIZE / 2 + 4) * (0.5 + t * 0.5);\n\n      g.fillStyle(COLORS.snakeGlow, glowAlpha);\n      g.fillCircle(centerX, centerY, glowSize);\n    }\n\n    // Draw snake segments from tail to head with green gradient\n    for (let i = snakeLen - 1; i >= 0; i--) {\n      const segment = snake[i];\n      const centerX = segment.x * CELL_SIZE + CELL_SIZE / 2;\n      const centerY = segment.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const t = snakeLen > 1 ? i / (snakeLen - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n\n      // Green gradient from tail (dark) to head (bright)\n      const brightness = 0.3 + t * 0.4;\n      const segmentColor = this.hslToRgb(0.4, 0.9, brightness);\n\n      if (i === 0) {\n        // Head: brightest green with eerie glow\n        g.fillStyle(COLORS.snakeGlow, 0.4);\n        g.fillCircle(centerX, centerY, radius + 8);\n\n        g.fillStyle(COLORS.snakeHead, 1);\n        g.fillCircle(centerX, centerY, radius + 1);\n\n        // Slimy highlight\n        g.fillStyle(0xaaffcc, 0.6);\n        g.fillCircle(centerX - 2, centerY - 2, radius * 0.35);\n\n        this.drawSnakeHead(g, segment, snake[1]);\n      } else {\n        // Body segment with green tones\n        g.fillStyle(COLORS.snakeGlow, 0.15);\n        g.fillCircle(centerX, centerY, radius + 2);\n\n        g.fillStyle(segmentColor, 1);\n        g.fillCircle(centerX, centerY, radius);\n\n        // Slimy specular highlight\n        g.fillStyle(0xaaffcc, 0.15 * t);\n        g.fillCircle(centerX - 1, centerY - 1, radius * 0.25);\n      }\n    }\n  }\n\n  private drawFoodBurst(g: Phaser.GameObjects.Graphics): void {\n    for (const p of this.foodBurstParticles) {\n      // Halloween: orange pumpkin burst\n      for (let i = 0; i < p.trail.length; i++) {\n        const t = p.trail[i];\n        const trailAlpha = p.life * 0.4 * (1 - i / p.trail.length);\n        const trailSize = p.size * p.life * (1 - i / p.trail.length);\n        g.fillStyle(COLORS.pumpkinOrange, trailAlpha);\n        g.fillCircle(t.x, t.y, trailSize);\n      }\n\n      g.fillStyle(COLORS.candyCorn1, p.life * 0.7);\n      g.fillCircle(p.x, p.y, p.size * p.life);\n      g.fillStyle(COLORS.candyCorn3, p.life * 0.9);\n      g.fillCircle(p.x, p.y, p.size * p.life * 0.4);\n    }\n  }\n\n  private drawEnergyField(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState || this.currentState.snake.length === 0) return;\n\n    const snake = this.currentState.snake;\n    const baseIntensity = 0.06 + this.energyFieldPulse * 0.2;\n    const pulseOffset = Math.sin(this.frameCount * 0.1) * 0.02;\n    const alpha = Math.min(0.3, baseIntensity + pulseOffset);\n\n    // Halloween: ghostly green energy field\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n\n      const fieldRadius = CELL_SIZE * (0.8 + this.energyFieldPulse * 0.5) + Math.sin(this.frameCount * 0.15 + i * 0.5) * 2;\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.2);\n      g.fillCircle(cx, cy, fieldRadius + 4);\n\n      g.fillStyle(COLORS.snakeGlow, alpha * 0.35);\n      g.fillCircle(cx, cy, fieldRadius);\n    }\n\n    // Connecting lines when pulse is active\n    if (this.energyFieldPulse > 0.3 && snake.length > 1) {\n      for (let i = 0; i < snake.length - 1; i++) {\n        const seg1 = snake[i];\n        const seg2 = snake[i + 1];\n        const x1 = seg1.x * CELL_SIZE + CELL_SIZE / 2;\n        const y1 = seg1.y * CELL_SIZE + CELL_SIZE / 2;\n        const x2 = seg2.x * CELL_SIZE + CELL_SIZE / 2;\n        const y2 = seg2.y * CELL_SIZE + CELL_SIZE / 2;\n\n        g.lineStyle(3, COLORS.noirGray, this.energyFieldPulse * 0.3);\n        g.lineBetween(x1, y1, x2, y2);\n        g.lineStyle(1.5, 0xffffff, this.energyFieldPulse * 0.5);\n        g.lineBetween(x1, y1, x2, y2);\n      }\n    }\n  }\n\n  private drawChromaticAberration(g: Phaser.GameObjects.Graphics): void {\n    if (!this.currentState) return;\n\n    const snake = this.currentState.snake;\n    const offset = this.chromaticIntensity * 3;\n\n    // Film noir: grayscale ghosting effect instead of color split\n    for (let i = 0; i < snake.length; i++) {\n      const seg = snake[i];\n      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;\n      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;\n      const t = snake.length > 1 ? i / (snake.length - 1) : 1;\n      const radius = (CELL_SIZE / 2 - 1) * (0.85 + t * 0.15);\n      const alpha = this.chromaticIntensity * 0.3 * (i === 0 ? 1 : 0.5);\n\n      // Light ghost - offset left\n      g.fillStyle(0xffffff, alpha);\n      g.fillCircle(cx - offset, cy, radius);\n\n      // Dark ghost - offset right\n      g.fillStyle(0x404040, alpha);\n      g.fillCircle(cx + offset, cy, radius);\n    }\n  }\n\n  private drawGameOver(g: Phaser.GameObjects.Graphics, width: number, height: number): void {\n    // Film noir game over: dramatic fade to black with spotlight\n    if (this.gameOverAlpha < 0.85) {\n      this.gameOverAlpha += 0.03;\n    }\n\n    // Heavy dark overlay\n    g.fillStyle(COLORS.gameOverOverlay, this.gameOverAlpha);\n    g.fillRect(0, 0, width, height);\n\n    // Film grain effect (subtle noise lines)\n    for (let y = 0; y < height; y += 3) {\n      const grainAlpha = 0.05 + Math.random() * 0.05;\n      g.fillStyle(Math.random() > 0.5 ? 0xffffff : 0x000000, grainAlpha);\n      g.fillRect(0, y, width, 1);\n    }\n\n    // Dramatic spotlight in center\n    const spotPulse = 0.15 + Math.sin(this.frameCount * 0.05) * 0.05;\n    g.fillStyle(COLORS.noirWhite, spotPulse);\n    g.fillCircle(width / 2, height / 2, 80);\n    g.fillStyle(COLORS.noirWhite, spotPulse * 0.5);\n    g.fillCircle(width / 2, height / 2, 120);\n\n    // Noir border: thick black frame\n    const borderSize = 8;\n    g.fillStyle(0x000000, 0.8);\n    g.fillRect(0, 0, width, borderSize);\n    g.fillRect(0, height - borderSize, width, borderSize);\n    g.fillRect(0, 0, borderSize, height);\n    g.fillRect(width - borderSize, 0, borderSize, height);\n\n    // White inner border\n    const innerBorder = 2;\n    const innerOffset = borderSize;\n    g.fillStyle(COLORS.noirWhite, 0.3);\n    g.fillRect(innerOffset, innerOffset, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, height - innerOffset - innerBorder, width - innerOffset * 2, innerBorder);\n    g.fillRect(innerOffset, innerOffset, innerBorder, height - innerOffset * 2);\n    g.fillRect(width - innerOffset - innerBorder, innerOffset, innerBorder, height - innerOffset * 2);\n  }\n\n  private drawSnakeHead(\n    g: Phaser.GameObjects.Graphics,\n    head: Position,\n    nextSegment: Position | undefined\n  ): void {\n    const centerX = head.x * CELL_SIZE + CELL_SIZE / 2;\n    const centerY = head.y * CELL_SIZE + CELL_SIZE / 2;\n\n    // Determine direction for eye placement\n    let dx = 1, dy = 0;\n    if (nextSegment) {\n      dx = head.x - nextSegment.x;\n      dy = head.y - nextSegment.y;\n      // Normalize\n      const len = Math.sqrt(dx * dx + dy * dy);\n      if (len > 0) {\n        dx /= len;\n        dy /= len;\n      }\n    }\n\n    // Perpendicular for eye offset\n    const perpX = -dy;\n    const perpY = dx;\n\n    const eyeOffset = 4;\n    const eyeForward = 3;\n    const eyeRadius = 3;\n    const pupilRadius = 1.5;\n\n    // Left eye\n    const leftEyeX = centerX + perpX * eyeOffset + dx * eyeForward;\n    const leftEyeY = centerY + perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(leftEyeX, leftEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(leftEyeX + dx * 1, leftEyeY + dy * 1, pupilRadius);\n\n    // Right eye\n    const rightEyeX = centerX - perpX * eyeOffset + dx * eyeForward;\n    const rightEyeY = centerY - perpY * eyeOffset + dy * eyeForward;\n    g.fillStyle(COLORS.snakeEye, 1);\n    g.fillCircle(rightEyeX, rightEyeY, eyeRadius);\n    g.fillStyle(COLORS.snakePupil, 1);\n    g.fillCircle(rightEyeX + dx * 1, rightEyeY + dy * 1, pupilRadius);\n\n    // Draw the royal crown\n    this.drawCrown(g, centerX, centerY, dx, dy, perpX, perpY);\n  }\n\n  private drawCrown(\n    g: Phaser.GameObjects.Graphics,\n    headX: number,\n    headY: number,\n    dx: number,\n    dy: number,\n    perpX: number,\n    perpY: number\n  ): void {\n    // Volcanic crown: molten gold with ruby gems\n    const crownOffset = -8;\n    const crownBaseX = headX - dx * crownOffset;\n    const crownBaseY = headY - dy * crownOffset;\n\n    const crownWidth = 14;\n    const crownHeight = 10;\n    const halfWidth = crownWidth / 2;\n\n    const sparkle = 0.7 + Math.sin(this.frameCount * 0.15) * 0.3;\n\n    const baseLeft = {\n      x: crownBaseX + perpX * halfWidth,\n      y: crownBaseY + perpY * halfWidth\n    };\n    const baseRight = {\n      x: crownBaseX - perpX * halfWidth,\n      y: crownBaseY - perpY * halfWidth\n    };\n\n    const pointOffset = -dx * crownHeight;\n    const pointOffsetY = -dy * crownHeight;\n\n    const crownPoints = [\n      baseLeft,\n      { x: baseLeft.x + pointOffset * 0.4, y: baseLeft.y + pointOffsetY * 0.4 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: crownBaseX + perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY + perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY },\n      { x: crownBaseX - perpX * (halfWidth * 0.25) + pointOffset * 0.5, y: crownBaseY - perpY * (halfWidth * 0.25) + pointOffsetY * 0.5 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9 },\n      { x: baseRight.x + pointOffset * 0.4, y: baseRight.y + pointOffsetY * 0.4 },\n      baseRight\n    ];\n\n    // Crown glow (molten orange/red aura)\n    g.fillStyle(COLORS.noirWhite, 0.25 * sparkle);\n    g.fillCircle(crownBaseX + pointOffset * 0.5, crownBaseY + pointOffsetY * 0.5, crownHeight + 4);\n\n    // Crown base (molten gold)\n    g.fillStyle(0xffa500, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.fillPath();\n\n    // Crown outline (dark crimson)\n    g.lineStyle(1.5, 0x801010, 1);\n    g.beginPath();\n    g.moveTo(crownPoints[0].x, crownPoints[0].y);\n    for (let i = 1; i < crownPoints.length; i++) {\n      g.lineTo(crownPoints[i].x, crownPoints[i].y);\n    }\n    g.closePath();\n    g.strokePath();\n\n    // Crown band\n    const bandY1 = {\n      x: baseLeft.x + pointOffset * 0.15,\n      y: baseLeft.y + pointOffsetY * 0.15\n    };\n    const bandY2 = {\n      x: baseRight.x + pointOffset * 0.15,\n      y: baseRight.y + pointOffsetY * 0.15\n    };\n    g.lineStyle(3, 0xcc6600, 1);\n    g.lineBetween(bandY1.x, bandY1.y, bandY2.x, bandY2.y);\n\n    // Ruby jewels: glowing red gems\n    const jewelPositions = [\n      { x: crownBaseX + pointOffset, y: crownBaseY + pointOffsetY, size: 2.5 },\n      { x: crownBaseX + perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY + perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n      { x: crownBaseX - perpX * (halfWidth * 0.5) + pointOffset * 0.9, y: crownBaseY - perpY * (halfWidth * 0.5) + pointOffsetY * 0.9, size: 2 },\n    ];\n\n    for (const jewel of jewelPositions) {\n      g.fillStyle(0xff4020, 0.5 * sparkle);\n      g.fillCircle(jewel.x, jewel.y, jewel.size + 2);\n\n      g.fillStyle(0xff2000, 1);\n      g.fillCircle(jewel.x, jewel.y, jewel.size);\n\n      g.fillStyle(0xffff80, 0.9 * sparkle);\n      g.fillCircle(jewel.x - 0.5, jewel.y - 0.5, jewel.size * 0.4);\n    }\n\n    // Crown highlight (golden gleam)\n    g.fillStyle(0xffff80, 0.6 * sparkle);\n    g.fillCircle(crownBaseX + perpX * 3 + pointOffset * 0.3, crownBaseY + perpY * 3 + pointOffsetY * 0.3, 2);\n  }\n}\n","structuredPatch":[{"oldStart":2433,"oldLines":6,"newStart":2433,"newLines":9,"lines":[" ","     drawCleanSnake(g, this.currentState.snake, CELL_SIZE, this.frameCount);"," ","+    drawTears(g, this.cleanEffects);","+    drawBlood(g, this.cleanEffects);","+","     drawCleanVignette(g, width, height);"," ","     const score = this.currentState.score || 0;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Lhw5QCURNNtJLCibBeanum","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XAcUEcBHP6cHTH61P3Njh4","name":"TodoWrite","input":{"todos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"completed","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"completed","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"completed","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"in_progress","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":45692,"cache_creation":{"ephemeral_5m_input_tokens":353,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"5858bee2-af80-4bd7-b114-816dec2a8b46"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XAcUEcBHP6cHTH61P3Njh4","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"f28b7f67-a0d1-49b2-a12d-8e509d4bc8dc","tool_use_result":{"oldTodos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"completed","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"completed","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"in_progress","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"pending","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}],"newTodos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"completed","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"completed","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"completed","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"in_progress","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017EmMeqdnVGLMxiPva3pypd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XXb5KPmNpR9a626mVQyvyZ","name":"Bash","input":{"command":"npm test 2>&1","description":"Run tests to verify the code doesn't break existing functionality","timeout":120000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":354,"cache_read_input_tokens":46045,"cache_creation":{"ephemeral_5m_input_tokens":354,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"3b8da72c-ce84-4eb9-9975-d5a80aee8be6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XXb5KPmNpR9a626mVQyvyZ","type":"tool_result","content":"> the-perfect-snake@0.0.0 test\n> vitest run\n\n\n\u001b[7m\u001b[1m\u001b[36m RUN \u001b[39m\u001b[22m\u001b[27m \u001b[36mv1.6.1\u001b[39m \u001b[90m/__w/perfect-snake-platform/perfect-snake-platform/game\u001b[39m\n\n \u001b[32mâœ“\u001b[39m src/__tests__/visual-safety.test.tsx \u001b[2m (\u001b[22m\u001b[2m15 tests\u001b[22m\u001b[2m)\u001b[22m\u001b[33m 478\u001b[2mms\u001b[22m\u001b[39m\n\u001b[90mstderr\u001b[2m | VirtualConsole.<anonymous> (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/virtual-console.js:29:45)\u001b[22m\u001b[39m\nError: Not implemented: HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\n    at module.exports (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/browser/not-implemented.js:9:17)\n    at HTMLCanvasElementImpl.getContext (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/living/nodes/HTMLCanvasElement-impl.js:42:5)\n    at HTMLCanvasElement.getContext (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/living/generated/HTMLCanvasElement.js:131:58)\n    at checkInverseAlpha (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:72:26)\n    at init (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:106:46)\n    at Object.<anonymous> (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:112:18)\n    at Module._compile (node:internal/modules/cjs/loader:1521:14)\n    at Object..js (node:internal/modules/cjs/loader:1623:10)\n    at Module.load (node:internal/modules/cjs/loader:1266:32)\n    at Function._load (node:internal/modules/cjs/loader:1091:12) undefined\n\n \u001b[32mâœ“\u001b[39m src/__tests__/postMessage.test.ts \u001b[2m (\u001b[22m\u001b[2m10 tests\u001b[22m\u001b[2m)\u001b[22m\u001b[90m 46\u001b[2mms\u001b[22m\u001b[39m\n \u001b[32mâœ“\u001b[39m src/components/GameBoard.test.tsx \u001b[2m (\u001b[22m\u001b[2m1 test\u001b[22m\u001b[2m)\u001b[22m\u001b[90m 27\u001b[2mms\u001b[22m\u001b[39m\n\n\u001b[2m Test Files \u001b[22m \u001b[1m\u001b[32m3 passed\u001b[39m\u001b[22m\u001b[90m (3)\u001b[39m\n\u001b[2m      Tests \u001b[22m \u001b[1m\u001b[32m26 passed\u001b[39m\u001b[22m\u001b[90m (26)\u001b[39m\n\u001b[2m   Start at \u001b[22m 21:52:57\n\u001b[2m   Duration \u001b[22m 4.24s\u001b[2m (transform 227ms, setup 608ms, collect 268ms, tests 551ms, environment 1.86s, prepare 378ms)\u001b[22m","is_error":false}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"5c7084e1-b72f-462a-bacf-e579e6a8a002","tool_use_result":{"stdout":"> the-perfect-snake@0.0.0 test\n> vitest run\n\n\n\u001b[7m\u001b[1m\u001b[36m RUN \u001b[39m\u001b[22m\u001b[27m \u001b[36mv1.6.1\u001b[39m \u001b[90m/__w/perfect-snake-platform/perfect-snake-platform/game\u001b[39m\n\n \u001b[32mâœ“\u001b[39m src/__tests__/visual-safety.test.tsx \u001b[2m (\u001b[22m\u001b[2m15 tests\u001b[22m\u001b[2m)\u001b[22m\u001b[33m 478\u001b[2mms\u001b[22m\u001b[39m\n\u001b[90mstderr\u001b[2m | VirtualConsole.<anonymous> (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/virtual-console.js:29:45)\u001b[22m\u001b[39m\nError: Not implemented: HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\n    at module.exports (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/browser/not-implemented.js:9:17)\n    at HTMLCanvasElementImpl.getContext (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/living/nodes/HTMLCanvasElement-impl.js:42:5)\n    at HTMLCanvasElement.getContext (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/jsdom/lib/jsdom/living/generated/HTMLCanvasElement.js:131:58)\n    at checkInverseAlpha (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:72:26)\n    at init (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:106:46)\n    at Object.<anonymous> (/__w/perfect-snake-platform/perfect-snake-platform/game/node_modules/phaser/src/device/CanvasFeatures.js:112:18)\n    at Module._compile (node:internal/modules/cjs/loader:1521:14)\n    at Object..js (node:internal/modules/cjs/loader:1623:10)\n    at Module.load (node:internal/modules/cjs/loader:1266:32)\n    at Function._load (node:internal/modules/cjs/loader:1091:12) undefined\n\n \u001b[32mâœ“\u001b[39m src/__tests__/postMessage.test.ts \u001b[2m (\u001b[22m\u001b[2m10 tests\u001b[22m\u001b[2m)\u001b[22m\u001b[90m 46\u001b[2mms\u001b[22m\u001b[39m\n \u001b[32mâœ“\u001b[39m src/components/GameBoard.test.tsx \u001b[2m (\u001b[22m\u001b[2m1 test\u001b[22m\u001b[2m)\u001b[22m\u001b[90m 27\u001b[2mms\u001b[22m\u001b[39m\n\n\u001b[2m Test Files \u001b[22m \u001b[1m\u001b[32m3 passed\u001b[39m\u001b[22m\u001b[90m (3)\u001b[39m\n\u001b[2m      Tests \u001b[22m \u001b[1m\u001b[32m26 passed\u001b[39m\u001b[22m\u001b[90m (26)\u001b[39m\n\u001b[2m   Start at \u001b[22m 21:52:57\n\u001b[2m   Duration \u001b[22m 4.24s\u001b[2m (transform 227ms, setup 608ms, collect 268ms, tests 551ms, environment 1.86s, prepare 378ms)\u001b[22m","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MzW3mD2LvMNkYkD3K39JgU","type":"message","role":"assistant","content":[{"type":"text","text":"All tests pass. Now let me run the build:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1005,"cache_read_input_tokens":46399,"cache_creation":{"ephemeral_5m_input_tokens":1005,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"03c5554b-7e09-4b37-b9de-5c9ac0e7847e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MzW3mD2LvMNkYkD3K39JgU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RCnBft2hxXN8QRaHJatmgT","name":"Bash","input":{"command":"npm run build 2>&1","description":"Build the project to verify TypeScript compilation","timeout":120000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1005,"cache_read_input_tokens":46399,"cache_creation":{"ephemeral_5m_input_tokens":1005,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"ac853d74-93dd-40ba-bc0b-6f4e376fa54d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RCnBft2hxXN8QRaHJatmgT","type":"tool_result","content":"> the-perfect-snake@0.0.0 build\n> tsc && vite build\n\n\u001b[36mvite v5.4.21 \u001b[32mbuilding for production...\u001b[36m\u001b[39m\ntransforming...\n\u001b[32mâœ“\u001b[39m 47 modules transformed.\nrendering chunks...\ncomputing gzip size...\n\u001b[2mdist/\u001b[22m\u001b[32mindex.html                     \u001b[39m\u001b[1m\u001b[2m    0.47 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m â”‚ gzip:   0.30 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[35mindex-lEa4aZZ6.css      \u001b[39m\u001b[1m\u001b[2m    3.29 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m â”‚ gzip:   0.97 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[36mSnakeScene-TVgITpqh.js  \u001b[39m\u001b[1m\u001b[2m   64.46 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m â”‚ gzip:  17.76 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[36mindex-BxO6zhJK.js       \u001b[39m\u001b[1m\u001b[2m  165.37 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m â”‚ gzip:  53.85 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[36mphaser-CSz1JFm1.js      \u001b[39m\u001b[1m\u001b[33m1,478.82 kB\u001b[39m\u001b[22m\u001b[2m â”‚ gzip: 339.81 kB\u001b[22m\n\u001b[33m\n(!) Some chunks are larger than 500 kB after minification. Consider:\n- Using dynamic import() to code-split the application\n- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks\n- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.\u001b[39m\n\u001b[32mâœ“ built in 7.79s\u001b[39m","is_error":false}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"71eeeacd-f430-4ddb-8a2e-926cdb8bbb1d","tool_use_result":{"stdout":"> the-perfect-snake@0.0.0 build\n> tsc && vite build\n\n\u001b[36mvite v5.4.21 \u001b[32mbuilding for production...\u001b[36m\u001b[39m\ntransforming...\n\u001b[32mâœ“\u001b[39m 47 modules transformed.\nrendering chunks...\ncomputing gzip size...\n\u001b[2mdist/\u001b[22m\u001b[32mindex.html                     \u001b[39m\u001b[1m\u001b[2m    0.47 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m â”‚ gzip:   0.30 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[35mindex-lEa4aZZ6.css      \u001b[39m\u001b[1m\u001b[2m    3.29 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m â”‚ gzip:   0.97 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[36mSnakeScene-TVgITpqh.js  \u001b[39m\u001b[1m\u001b[2m   64.46 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m â”‚ gzip:  17.76 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[36mindex-BxO6zhJK.js       \u001b[39m\u001b[1m\u001b[2m  165.37 kB\u001b[22m\u001b[1m\u001b[22m\u001b[2m â”‚ gzip:  53.85 kB\u001b[22m\n\u001b[2mdist/\u001b[22m\u001b[2massets/\u001b[22m\u001b[36mphaser-CSz1JFm1.js      \u001b[39m\u001b[1m\u001b[33m1,478.82 kB\u001b[39m\u001b[22m\u001b[2m â”‚ gzip: 339.81 kB\u001b[22m\n\u001b[33m\n(!) Some chunks are larger than 500 kB after minification. Consider:\n- Using dynamic import() to code-split the application\n- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks\n- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.\u001b[39m\n\u001b[32mâœ“ built in 7.79s\u001b[39m","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01C1oDbQxYCFYbq4VX5uhywS","type":"message","role":"assistant","content":[{"type":"text","text":"Build passes. Now let me take a screenshot to verify visual changes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":707,"cache_read_input_tokens":47404,"cache_creation":{"ephemeral_5m_input_tokens":707,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"c542e21c-ae31-40a1-a3ac-eb006838f444"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01C1oDbQxYCFYbq4VX5uhywS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AXYrutKif9i1DnTQDMXBeX","name":"TodoWrite","input":{"todos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"completed","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"completed","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"completed","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"completed","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"in_progress","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":707,"cache_read_input_tokens":47404,"cache_creation":{"ephemeral_5m_input_tokens":707,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"3af376c5-4e9d-4a3d-a39a-8db4cef2ea01"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AXYrutKif9i1DnTQDMXBeX","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"15efcfad-c52a-4e4e-8b6e-7c2f101522ec","tool_use_result":{"oldTodos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"completed","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"completed","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"completed","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"in_progress","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"pending","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}],"newTodos":[{"content":"Add tear and blood particle types to cleanEffects.ts","status":"completed","activeForm":"Adding tear and blood particle types"},{"content":"Create spawn and update functions for tears and blood","status":"completed","activeForm":"Creating spawn and update functions"},{"content":"Create draw functions for tears and blood effects","status":"completed","activeForm":"Creating draw functions"},{"content":"Integrate effects into SnakeScene.ts update loop","status":"completed","activeForm":"Integrating effects into SnakeScene"},{"content":"Run npm test and npm run build","status":"completed","activeForm":"Running tests and build"},{"content":"Take screenshot and verify visual changes","status":"in_progress","activeForm":"Verifying visual changes"},{"content":"Run npm run test:perf for FPS check","status":"pending","activeForm":"Running performance test"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CC8ypERKDzhDZodzHnx73L","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Kw2motJjk24nRdVbLD5THs","name":"Bash","input":{"command":"npm run test:screenshot 2>&1 || true","description":"Take screenshot of the game","timeout":120000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":372,"cache_read_input_tokens":48111,"cache_creation":{"ephemeral_5m_input_tokens":372,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"a8f1da6e-e71d-48d3-beea-2f3af7eeee23"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"This Bash command contains multiple operations. The following part requires approval: npm run test:screenshot","is_error":true,"tool_use_id":"toolu_01Kw2motJjk24nRdVbLD5THs"}]},"parent_tool_use_id":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","uuid":"f704d46d-b322-4e32-986b-1f73e83f3bad","tool_use_result":"Error: This Bash command contains multiple operations. The following part requires approval: npm run test:screenshot"}
{"type":"result","subtype":"error_max_turns","duration_ms":198336,"duration_api_ms":187797,"is_error":false,"num_turns":26,"stop_reason":null,"session_id":"15259d3e-8e8c-4603-b270-61d43f59e83b","total_cost_usd":1.08851525,"usage":{"input_tokens":29,"cache_creation_input_tokens":34790,"cache_read_input_tokens":947021,"output_tokens":8555,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":34790},"inference_geo":"","iterations":[],"speed":"standard"},"modelUsage":{"claude-haiku-4-5-20251001":{"inputTokens":10523,"outputTokens":4389,"cacheReadInputTokens":713055,"cacheCreationInputTokens":63819,"webSearchRequests":0,"costUSD":0.18354725000000005,"contextWindow":200000,"maxOutputTokens":64000},"claude-opus-4-5-20251101":{"inputTokens":29,"outputTokens":8555,"cacheReadInputTokens":947021,"cacheCreationInputTokens":34790,"webSearchRequests":0,"costUSD":0.9049680000000001,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[{"tool_name":"Bash","tool_use_id":"toolu_01MqyxmxhAendbDWmMYaJSpZ","tool_input":{"command":"ls -la /__w/perfect-snake-platform/perfect-snake-platform/game/src/components/ && echo \"---\" && ls -la /__w/perfect-snake-platform/perfect-snake-platform/game/src/game/"}},{"tool_name":"Bash","tool_use_id":"toolu_019FGWcLCKg8iEAtfkChis7K","tool_input":{"command":"cd /__w/perfect-snake-platform/perfect-snake-platform && git log --oneline -20"}},{"tool_name":"Bash","tool_use_id":"toolu_01BFAhwrDvWHjEk6bn8qVVBC","tool_input":{"command":"git -C /__w/perfect-snake-platform/perfect-snake-platform log --oneline -20"}},{"tool_name":"Bash","tool_use_id":"toolu_01Kw2motJjk24nRdVbLD5THs","tool_input":{"command":"npm run test:screenshot 2>&1 || true","timeout":120000,"description":"Take screenshot of the game"}}],"uuid":"0583f98d-749b-477c-a957-8fda08cb24b8","errors":[]}
